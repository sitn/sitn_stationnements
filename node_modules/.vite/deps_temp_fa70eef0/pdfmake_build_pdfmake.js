import {
  __commonJS
} from "./chunk-DFKQJ226.js";

// node_modules/pdfmake/build/pdfmake.js
var require_pdfmake = __commonJS({
  "node_modules/pdfmake/build/pdfmake.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else {
        var a = factory();
        for (var i in a)
          (typeof exports === "object" ? exports : root)[i] = a[i];
      }
    })(typeof self !== "undefined" ? self : exports, function() {
      return (
        /******/
        function() {
          var __webpack_modules__ = {
            /***/
            9282: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var process = __webpack_require__2(4155);
                function _typeof(obj) {
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    _typeof = function _typeof2(obj2) {
                      return typeof obj2;
                    };
                  } else {
                    _typeof = function _typeof2(obj2) {
                      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    };
                  }
                  return _typeof(obj);
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                var _require = __webpack_require__2(2136), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
                var AssertionError = __webpack_require__2(5961);
                var _require2 = __webpack_require__2(9539), inspect = _require2.inspect;
                var _require$types = __webpack_require__2(9539).types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
                var objectAssign = Object.assign ? Object.assign : __webpack_require__2(8091).assign;
                var objectIs = Object.is ? Object.is : __webpack_require__2(609);
                var errorCache = /* @__PURE__ */ new Map();
                var isDeepEqual;
                var isDeepStrictEqual;
                var parseExpressionAt;
                var findNodeAround;
                var decoder;
                function lazyLoadComparison() {
                  var comparison = __webpack_require__2(9158);
                  isDeepEqual = comparison.isDeepEqual;
                  isDeepStrictEqual = comparison.isDeepStrictEqual;
                }
                var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
                var meta = (
                  /* unused pure expression or super */
                  null
                );
                var escapeFn = function escapeFn2(str) {
                  return meta[str.charCodeAt(0)];
                };
                var warned = false;
                var assert = module2.exports = ok;
                var NO_EXCEPTION_SENTINEL = {};
                function innerFail(obj) {
                  if (obj.message instanceof Error)
                    throw obj.message;
                  throw new AssertionError(obj);
                }
                function fail(actual, expected, message, operator, stackStartFn) {
                  var argsLen = arguments.length;
                  var internalMessage;
                  if (argsLen === 0) {
                    internalMessage = "Failed";
                  } else if (argsLen === 1) {
                    message = actual;
                    actual = void 0;
                  } else {
                    if (warned === false) {
                      warned = true;
                      var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
                      warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
                    }
                    if (argsLen === 2)
                      operator = "!=";
                  }
                  if (message instanceof Error)
                    throw message;
                  var errArgs = {
                    actual,
                    expected,
                    operator: operator === void 0 ? "fail" : operator,
                    stackStartFn: stackStartFn || fail
                  };
                  if (message !== void 0) {
                    errArgs.message = message;
                  }
                  var err = new AssertionError(errArgs);
                  if (internalMessage) {
                    err.message = internalMessage;
                    err.generatedMessage = true;
                  }
                  throw err;
                }
                assert.fail = fail;
                assert.AssertionError = AssertionError;
                function innerOk(fn, argLen, value, message) {
                  if (!value) {
                    var generatedMessage = false;
                    if (argLen === 0) {
                      generatedMessage = true;
                      message = "No value argument passed to `assert.ok()`";
                    } else if (message instanceof Error) {
                      throw message;
                    }
                    var err = new AssertionError({
                      actual: value,
                      expected: true,
                      message,
                      operator: "==",
                      stackStartFn: fn
                    });
                    err.generatedMessage = generatedMessage;
                    throw err;
                  }
                }
                function ok() {
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }
                  innerOk.apply(void 0, [ok, args.length].concat(args));
                }
                assert.ok = ok;
                assert.equal = function equal(actual, expected, message) {
                  if (arguments.length < 2) {
                    throw new ERR_MISSING_ARGS("actual", "expected");
                  }
                  if (actual != expected) {
                    innerFail({
                      actual,
                      expected,
                      message,
                      operator: "==",
                      stackStartFn: equal
                    });
                  }
                };
                assert.notEqual = function notEqual(actual, expected, message) {
                  if (arguments.length < 2) {
                    throw new ERR_MISSING_ARGS("actual", "expected");
                  }
                  if (actual == expected) {
                    innerFail({
                      actual,
                      expected,
                      message,
                      operator: "!=",
                      stackStartFn: notEqual
                    });
                  }
                };
                assert.deepEqual = function deepEqual(actual, expected, message) {
                  if (arguments.length < 2) {
                    throw new ERR_MISSING_ARGS("actual", "expected");
                  }
                  if (isDeepEqual === void 0)
                    lazyLoadComparison();
                  if (!isDeepEqual(actual, expected)) {
                    innerFail({
                      actual,
                      expected,
                      message,
                      operator: "deepEqual",
                      stackStartFn: deepEqual
                    });
                  }
                };
                assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
                  if (arguments.length < 2) {
                    throw new ERR_MISSING_ARGS("actual", "expected");
                  }
                  if (isDeepEqual === void 0)
                    lazyLoadComparison();
                  if (isDeepEqual(actual, expected)) {
                    innerFail({
                      actual,
                      expected,
                      message,
                      operator: "notDeepEqual",
                      stackStartFn: notDeepEqual
                    });
                  }
                };
                assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
                  if (arguments.length < 2) {
                    throw new ERR_MISSING_ARGS("actual", "expected");
                  }
                  if (isDeepEqual === void 0)
                    lazyLoadComparison();
                  if (!isDeepStrictEqual(actual, expected)) {
                    innerFail({
                      actual,
                      expected,
                      message,
                      operator: "deepStrictEqual",
                      stackStartFn: deepStrictEqual
                    });
                  }
                };
                assert.notDeepStrictEqual = notDeepStrictEqual;
                function notDeepStrictEqual(actual, expected, message) {
                  if (arguments.length < 2) {
                    throw new ERR_MISSING_ARGS("actual", "expected");
                  }
                  if (isDeepEqual === void 0)
                    lazyLoadComparison();
                  if (isDeepStrictEqual(actual, expected)) {
                    innerFail({
                      actual,
                      expected,
                      message,
                      operator: "notDeepStrictEqual",
                      stackStartFn: notDeepStrictEqual
                    });
                  }
                }
                assert.strictEqual = function strictEqual(actual, expected, message) {
                  if (arguments.length < 2) {
                    throw new ERR_MISSING_ARGS("actual", "expected");
                  }
                  if (!objectIs(actual, expected)) {
                    innerFail({
                      actual,
                      expected,
                      message,
                      operator: "strictEqual",
                      stackStartFn: strictEqual
                    });
                  }
                };
                assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
                  if (arguments.length < 2) {
                    throw new ERR_MISSING_ARGS("actual", "expected");
                  }
                  if (objectIs(actual, expected)) {
                    innerFail({
                      actual,
                      expected,
                      message,
                      operator: "notStrictEqual",
                      stackStartFn: notStrictEqual
                    });
                  }
                };
                var Comparison = function Comparison2(obj, keys, actual) {
                  var _this = this;
                  _classCallCheck(this, Comparison2);
                  keys.forEach(function(key) {
                    if (key in obj) {
                      if (actual !== void 0 && typeof actual[key] === "string" && isRegExp(obj[key]) && obj[key].test(actual[key])) {
                        _this[key] = actual[key];
                      } else {
                        _this[key] = obj[key];
                      }
                    }
                  });
                };
                function compareExceptionKey(actual, expected, key, message, keys, fn) {
                  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
                    if (!message) {
                      var a = new Comparison(actual, keys);
                      var b = new Comparison(expected, keys, actual);
                      var err = new AssertionError({
                        actual: a,
                        expected: b,
                        operator: "deepStrictEqual",
                        stackStartFn: fn
                      });
                      err.actual = actual;
                      err.expected = expected;
                      err.operator = fn.name;
                      throw err;
                    }
                    innerFail({
                      actual,
                      expected,
                      message,
                      operator: fn.name,
                      stackStartFn: fn
                    });
                  }
                }
                function expectedException(actual, expected, msg, fn) {
                  if (typeof expected !== "function") {
                    if (isRegExp(expected))
                      return expected.test(actual);
                    if (arguments.length === 2) {
                      throw new ERR_INVALID_ARG_TYPE("expected", ["Function", "RegExp"], expected);
                    }
                    if (_typeof(actual) !== "object" || actual === null) {
                      var err = new AssertionError({
                        actual,
                        expected,
                        message: msg,
                        operator: "deepStrictEqual",
                        stackStartFn: fn
                      });
                      err.operator = fn.name;
                      throw err;
                    }
                    var keys = Object.keys(expected);
                    if (expected instanceof Error) {
                      keys.push("name", "message");
                    } else if (keys.length === 0) {
                      throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
                    }
                    if (isDeepEqual === void 0)
                      lazyLoadComparison();
                    keys.forEach(function(key) {
                      if (typeof actual[key] === "string" && isRegExp(expected[key]) && expected[key].test(actual[key])) {
                        return;
                      }
                      compareExceptionKey(actual, expected, key, msg, keys, fn);
                    });
                    return true;
                  }
                  if (expected.prototype !== void 0 && actual instanceof expected) {
                    return true;
                  }
                  if (Error.isPrototypeOf(expected)) {
                    return false;
                  }
                  return expected.call({}, actual) === true;
                }
                function getActual(fn) {
                  if (typeof fn !== "function") {
                    throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn);
                  }
                  try {
                    fn();
                  } catch (e) {
                    return e;
                  }
                  return NO_EXCEPTION_SENTINEL;
                }
                function checkIsPromise(obj) {
                  return isPromise(obj) || obj !== null && _typeof(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
                }
                function waitForActual(promiseFn) {
                  return Promise.resolve().then(function() {
                    var resultPromise;
                    if (typeof promiseFn === "function") {
                      resultPromise = promiseFn();
                      if (!checkIsPromise(resultPromise)) {
                        throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
                      }
                    } else if (checkIsPromise(promiseFn)) {
                      resultPromise = promiseFn;
                    } else {
                      throw new ERR_INVALID_ARG_TYPE("promiseFn", ["Function", "Promise"], promiseFn);
                    }
                    return Promise.resolve().then(function() {
                      return resultPromise;
                    }).then(function() {
                      return NO_EXCEPTION_SENTINEL;
                    }).catch(function(e) {
                      return e;
                    });
                  });
                }
                function expectsError(stackStartFn, actual, error, message) {
                  if (typeof error === "string") {
                    if (arguments.length === 4) {
                      throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
                    }
                    if (_typeof(actual) === "object" && actual !== null) {
                      if (actual.message === error) {
                        throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
                      }
                    } else if (actual === error) {
                      throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
                    }
                    message = error;
                    error = void 0;
                  } else if (error != null && _typeof(error) !== "object" && typeof error !== "function") {
                    throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
                  }
                  if (actual === NO_EXCEPTION_SENTINEL) {
                    var details = "";
                    if (error && error.name) {
                      details += " (".concat(error.name, ")");
                    }
                    details += message ? ": ".concat(message) : ".";
                    var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
                    innerFail({
                      actual: void 0,
                      expected: error,
                      operator: stackStartFn.name,
                      message: "Missing expected ".concat(fnType).concat(details),
                      stackStartFn
                    });
                  }
                  if (error && !expectedException(actual, error, message, stackStartFn)) {
                    throw actual;
                  }
                }
                function expectsNoError(stackStartFn, actual, error, message) {
                  if (actual === NO_EXCEPTION_SENTINEL)
                    return;
                  if (typeof error === "string") {
                    message = error;
                    error = void 0;
                  }
                  if (!error || expectedException(actual, error)) {
                    var details = message ? ": ".concat(message) : ".";
                    var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
                    innerFail({
                      actual,
                      expected: error,
                      operator: stackStartFn.name,
                      message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
                      stackStartFn
                    });
                  }
                  throw actual;
                }
                assert.throws = function throws(promiseFn) {
                  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                    args[_key2 - 1] = arguments[_key2];
                  }
                  expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
                };
                assert.rejects = function rejects(promiseFn) {
                  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
                    args[_key3 - 1] = arguments[_key3];
                  }
                  return waitForActual(promiseFn).then(function(result) {
                    return expectsError.apply(void 0, [rejects, result].concat(args));
                  });
                };
                assert.doesNotThrow = function doesNotThrow(fn) {
                  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
                    args[_key4 - 1] = arguments[_key4];
                  }
                  expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
                };
                assert.doesNotReject = function doesNotReject(fn) {
                  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
                    args[_key5 - 1] = arguments[_key5];
                  }
                  return waitForActual(fn).then(function(result) {
                    return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
                  });
                };
                assert.ifError = function ifError(err) {
                  if (err !== null && err !== void 0) {
                    var message = "ifError got unwanted exception: ";
                    if (_typeof(err) === "object" && typeof err.message === "string") {
                      if (err.message.length === 0 && err.constructor) {
                        message += err.constructor.name;
                      } else {
                        message += err.message;
                      }
                    } else {
                      message += inspect(err);
                    }
                    var newErr = new AssertionError({
                      actual: err,
                      expected: null,
                      operator: "ifError",
                      message,
                      stackStartFn: ifError
                    });
                    var origStack = err.stack;
                    if (typeof origStack === "string") {
                      var tmp2 = origStack.split("\n");
                      tmp2.shift();
                      var tmp1 = newErr.stack.split("\n");
                      for (var i = 0; i < tmp2.length; i++) {
                        var pos = tmp1.indexOf(tmp2[i]);
                        if (pos !== -1) {
                          tmp1 = tmp1.slice(0, pos);
                          break;
                        }
                      }
                      newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
                    }
                    throw newErr;
                  }
                };
                function strict() {
                  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
                    args[_key6] = arguments[_key6];
                  }
                  innerOk.apply(void 0, [strict, args.length].concat(args));
                }
                assert.strict = objectAssign(strict, assert, {
                  equal: assert.strictEqual,
                  deepEqual: assert.deepStrictEqual,
                  notEqual: assert.notStrictEqual,
                  notDeepEqual: assert.notDeepStrictEqual
                });
                assert.strict.strict = assert.strict;
              }
            ),
            /***/
            5961: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var process = __webpack_require__2(4155);
                function _objectSpread(target) {
                  for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i] != null ? arguments[i] : {};
                    var ownKeys = Object.keys(source);
                    if (typeof Object.getOwnPropertySymbols === "function") {
                      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                      }));
                    }
                    ownKeys.forEach(function(key) {
                      _defineProperty(target, key, source[key]);
                    });
                  }
                  return target;
                }
                function _defineProperty(obj, key, value) {
                  if (key in obj) {
                    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                  } else {
                    obj[key] = value;
                  }
                  return obj;
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  return Constructor;
                }
                function _possibleConstructorReturn(self2, call) {
                  if (call && (_typeof(call) === "object" || typeof call === "function")) {
                    return call;
                  }
                  return _assertThisInitialized(self2);
                }
                function _assertThisInitialized(self2) {
                  if (self2 === void 0) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return self2;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function");
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                  if (superClass)
                    _setPrototypeOf(subClass, superClass);
                }
                function _wrapNativeSuper(Class) {
                  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
                  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
                    if (Class2 === null || !_isNativeFunction(Class2))
                      return Class2;
                    if (typeof Class2 !== "function") {
                      throw new TypeError("Super expression must either be null or a function");
                    }
                    if (typeof _cache !== "undefined") {
                      if (_cache.has(Class2))
                        return _cache.get(Class2);
                      _cache.set(Class2, Wrapper);
                    }
                    function Wrapper() {
                      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
                    }
                    Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
                    return _setPrototypeOf(Wrapper, Class2);
                  };
                  return _wrapNativeSuper(Class);
                }
                function isNativeReflectConstruct() {
                  if (typeof Reflect === "undefined" || !Reflect.construct)
                    return false;
                  if (Reflect.construct.sham)
                    return false;
                  if (typeof Proxy === "function")
                    return true;
                  try {
                    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                    }));
                    return true;
                  } catch (e) {
                    return false;
                  }
                }
                function _construct(Parent, args, Class) {
                  if (isNativeReflectConstruct()) {
                    _construct = Reflect.construct;
                  } else {
                    _construct = function _construct2(Parent2, args2, Class2) {
                      var a = [null];
                      a.push.apply(a, args2);
                      var Constructor = Function.bind.apply(Parent2, a);
                      var instance = new Constructor();
                      if (Class2)
                        _setPrototypeOf(instance, Class2.prototype);
                      return instance;
                    };
                  }
                  return _construct.apply(null, arguments);
                }
                function _isNativeFunction(fn) {
                  return Function.toString.call(fn).indexOf("[native code]") !== -1;
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                function _getPrototypeOf(o) {
                  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                    return o2.__proto__ || Object.getPrototypeOf(o2);
                  };
                  return _getPrototypeOf(o);
                }
                function _typeof(obj) {
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    _typeof = function _typeof2(obj2) {
                      return typeof obj2;
                    };
                  } else {
                    _typeof = function _typeof2(obj2) {
                      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    };
                  }
                  return _typeof(obj);
                }
                var _require = __webpack_require__2(9539), inspect = _require.inspect;
                var _require2 = __webpack_require__2(2136), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;
                function endsWith(str, search, this_len) {
                  if (this_len === void 0 || this_len > str.length) {
                    this_len = str.length;
                  }
                  return str.substring(this_len - search.length, this_len) === search;
                }
                function repeat(str, count) {
                  count = Math.floor(count);
                  if (str.length == 0 || count == 0)
                    return "";
                  var maxCount = str.length * count;
                  count = Math.floor(Math.log(count) / Math.log(2));
                  while (count) {
                    str += str;
                    count--;
                  }
                  str += str.substring(0, maxCount - str.length);
                  return str;
                }
                var blue = "";
                var green = "";
                var red = "";
                var white = "";
                var kReadableOperator = {
                  deepStrictEqual: "Expected values to be strictly deep-equal:",
                  strictEqual: "Expected values to be strictly equal:",
                  strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
                  deepEqual: "Expected values to be loosely deep-equal:",
                  equal: "Expected values to be loosely equal:",
                  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
                  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
                  notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
                  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
                  notEqual: 'Expected "actual" to be loosely unequal to:',
                  notIdentical: "Values identical but not reference-equal:"
                };
                var kMaxShortLength = 10;
                function copyError(source) {
                  var keys = Object.keys(source);
                  var target = Object.create(Object.getPrototypeOf(source));
                  keys.forEach(function(key) {
                    target[key] = source[key];
                  });
                  Object.defineProperty(target, "message", {
                    value: source.message
                  });
                  return target;
                }
                function inspectValue(val) {
                  return inspect(val, {
                    compact: false,
                    customInspect: false,
                    depth: 1e3,
                    maxArrayLength: Infinity,
                    // Assert compares only enumerable properties (with a few exceptions).
                    showHidden: false,
                    // Having a long line as error is better than wrapping the line for
                    // comparison for now.
                    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
                    // have meta information about the inspected properties (i.e., know where
                    // in what line the property starts and ends).
                    breakLength: Infinity,
                    // Assert does not detect proxies currently.
                    showProxy: false,
                    sorted: true,
                    // Inspect getters as we also check them when comparing entries.
                    getters: true
                  });
                }
                function createErrDiff(actual, expected, operator) {
                  var other = "";
                  var res = "";
                  var lastPos = 0;
                  var end = "";
                  var skipped = false;
                  var actualInspected = inspectValue(actual);
                  var actualLines = actualInspected.split("\n");
                  var expectedLines = inspectValue(expected).split("\n");
                  var i = 0;
                  var indicator = "";
                  if (operator === "strictEqual" && _typeof(actual) === "object" && _typeof(expected) === "object" && actual !== null && expected !== null) {
                    operator = "strictEqualObject";
                  }
                  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
                    var inputLength = actualLines[0].length + expectedLines[0].length;
                    if (inputLength <= kMaxShortLength) {
                      if ((_typeof(actual) !== "object" || actual === null) && (_typeof(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
                        return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
                      }
                    } else if (operator !== "strictEqualObject") {
                      var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
                      if (inputLength < maxLength) {
                        while (actualLines[0][i] === expectedLines[0][i]) {
                          i++;
                        }
                        if (i > 2) {
                          indicator = "\n  ".concat(repeat(" ", i), "^");
                          i = 0;
                        }
                      }
                    }
                  }
                  var a = actualLines[actualLines.length - 1];
                  var b = expectedLines[expectedLines.length - 1];
                  while (a === b) {
                    if (i++ < 2) {
                      end = "\n  ".concat(a).concat(end);
                    } else {
                      other = a;
                    }
                    actualLines.pop();
                    expectedLines.pop();
                    if (actualLines.length === 0 || expectedLines.length === 0)
                      break;
                    a = actualLines[actualLines.length - 1];
                    b = expectedLines[expectedLines.length - 1];
                  }
                  var maxLines = Math.max(actualLines.length, expectedLines.length);
                  if (maxLines === 0) {
                    var _actualLines = actualInspected.split("\n");
                    if (_actualLines.length > 30) {
                      _actualLines[26] = "".concat(blue, "...").concat(white);
                      while (_actualLines.length > 27) {
                        _actualLines.pop();
                      }
                    }
                    return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
                  }
                  if (i > 3) {
                    end = "\n".concat(blue, "...").concat(white).concat(end);
                    skipped = true;
                  }
                  if (other !== "") {
                    end = "\n  ".concat(other).concat(end);
                    other = "";
                  }
                  var printedLines = 0;
                  var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
                  var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
                  for (i = 0; i < maxLines; i++) {
                    var cur = i - lastPos;
                    if (actualLines.length < i + 1) {
                      if (cur > 1 && i > 2) {
                        if (cur > 4) {
                          res += "\n".concat(blue, "...").concat(white);
                          skipped = true;
                        } else if (cur > 3) {
                          res += "\n  ".concat(expectedLines[i - 2]);
                          printedLines++;
                        }
                        res += "\n  ".concat(expectedLines[i - 1]);
                        printedLines++;
                      }
                      lastPos = i;
                      other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
                      printedLines++;
                    } else if (expectedLines.length < i + 1) {
                      if (cur > 1 && i > 2) {
                        if (cur > 4) {
                          res += "\n".concat(blue, "...").concat(white);
                          skipped = true;
                        } else if (cur > 3) {
                          res += "\n  ".concat(actualLines[i - 2]);
                          printedLines++;
                        }
                        res += "\n  ".concat(actualLines[i - 1]);
                        printedLines++;
                      }
                      lastPos = i;
                      res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
                      printedLines++;
                    } else {
                      var expectedLine = expectedLines[i];
                      var actualLine = actualLines[i];
                      var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
                      if (divergingLines && endsWith(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
                        divergingLines = false;
                        actualLine += ",";
                      }
                      if (divergingLines) {
                        if (cur > 1 && i > 2) {
                          if (cur > 4) {
                            res += "\n".concat(blue, "...").concat(white);
                            skipped = true;
                          } else if (cur > 3) {
                            res += "\n  ".concat(actualLines[i - 2]);
                            printedLines++;
                          }
                          res += "\n  ".concat(actualLines[i - 1]);
                          printedLines++;
                        }
                        lastPos = i;
                        res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
                        other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
                        printedLines += 2;
                      } else {
                        res += other;
                        other = "";
                        if (cur === 1 || i === 0) {
                          res += "\n  ".concat(actualLine);
                          printedLines++;
                        }
                      }
                    }
                    if (printedLines > 20 && i < maxLines - 2) {
                      return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
                    }
                  }
                  return "".concat(msg).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end).concat(indicator);
                }
                var AssertionError = function(_Error) {
                  _inherits(AssertionError2, _Error);
                  function AssertionError2(options) {
                    var _this;
                    _classCallCheck(this, AssertionError2);
                    if (_typeof(options) !== "object" || options === null) {
                      throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
                    }
                    var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
                    var actual = options.actual, expected = options.expected;
                    var limit = Error.stackTraceLimit;
                    Error.stackTraceLimit = 0;
                    if (message != null) {
                      _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, String(message)));
                    } else {
                      if (process.stderr && process.stderr.isTTY) {
                        if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
                          blue = "\x1B[34m";
                          green = "\x1B[32m";
                          white = "\x1B[39m";
                          red = "\x1B[31m";
                        } else {
                          blue = "";
                          green = "";
                          white = "";
                          red = "";
                        }
                      }
                      if (_typeof(actual) === "object" && actual !== null && _typeof(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
                        actual = copyError(actual);
                        expected = copyError(expected);
                      }
                      if (operator === "deepStrictEqual" || operator === "strictEqual") {
                        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, createErrDiff(actual, expected, operator)));
                      } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
                        var base = kReadableOperator[operator];
                        var res = inspectValue(actual).split("\n");
                        if (operator === "notStrictEqual" && _typeof(actual) === "object" && actual !== null) {
                          base = kReadableOperator.notStrictEqualObject;
                        }
                        if (res.length > 30) {
                          res[26] = "".concat(blue, "...").concat(white);
                          while (res.length > 27) {
                            res.pop();
                          }
                        }
                        if (res.length === 1) {
                          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, "".concat(base, " ").concat(res[0])));
                        } else {
                          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, "".concat(base, "\n\n").concat(res.join("\n"), "\n")));
                        }
                      } else {
                        var _res = inspectValue(actual);
                        var other = "";
                        var knownOperators = kReadableOperator[operator];
                        if (operator === "notDeepEqual" || operator === "notEqual") {
                          _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                          if (_res.length > 1024) {
                            _res = "".concat(_res.slice(0, 1021), "...");
                          }
                        } else {
                          other = "".concat(inspectValue(expected));
                          if (_res.length > 512) {
                            _res = "".concat(_res.slice(0, 509), "...");
                          }
                          if (other.length > 512) {
                            other = "".concat(other.slice(0, 509), "...");
                          }
                          if (operator === "deepEqual" || operator === "equal") {
                            _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                          } else {
                            other = " ".concat(operator, " ").concat(other);
                          }
                        }
                        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, "".concat(_res).concat(other)));
                      }
                    }
                    Error.stackTraceLimit = limit;
                    _this.generatedMessage = !message;
                    Object.defineProperty(_assertThisInitialized(_this), "name", {
                      value: "AssertionError [ERR_ASSERTION]",
                      enumerable: false,
                      writable: true,
                      configurable: true
                    });
                    _this.code = "ERR_ASSERTION";
                    _this.actual = actual;
                    _this.expected = expected;
                    _this.operator = operator;
                    if (Error.captureStackTrace) {
                      Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
                    }
                    _this.stack;
                    _this.name = "AssertionError";
                    return _possibleConstructorReturn(_this);
                  }
                  _createClass(AssertionError2, [{
                    key: "toString",
                    value: function toString() {
                      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
                    }
                  }, {
                    key: inspect.custom,
                    value: function value(recurseTimes, ctx) {
                      return inspect(this, _objectSpread({}, ctx, {
                        customInspect: false,
                        depth: 0
                      }));
                    }
                  }]);
                  return AssertionError2;
                }(_wrapNativeSuper(Error));
                module2.exports = AssertionError;
              }
            ),
            /***/
            2136: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                function _typeof(obj) {
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    _typeof = function _typeof2(obj2) {
                      return typeof obj2;
                    };
                  } else {
                    _typeof = function _typeof2(obj2) {
                      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    };
                  }
                  return _typeof(obj);
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _possibleConstructorReturn(self2, call) {
                  if (call && (_typeof(call) === "object" || typeof call === "function")) {
                    return call;
                  }
                  return _assertThisInitialized(self2);
                }
                function _assertThisInitialized(self2) {
                  if (self2 === void 0) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return self2;
                }
                function _getPrototypeOf(o) {
                  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                    return o2.__proto__ || Object.getPrototypeOf(o2);
                  };
                  return _getPrototypeOf(o);
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function");
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                  if (superClass)
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                var codes = {};
                var assert;
                var util;
                function createErrorType(code, message, Base) {
                  if (!Base) {
                    Base = Error;
                  }
                  function getMessage(arg1, arg2, arg3) {
                    if (typeof message === "string") {
                      return message;
                    } else {
                      return message(arg1, arg2, arg3);
                    }
                  }
                  var NodeError = function(_Base) {
                    _inherits(NodeError2, _Base);
                    function NodeError2(arg1, arg2, arg3) {
                      var _this;
                      _classCallCheck(this, NodeError2);
                      _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError2).call(this, getMessage(arg1, arg2, arg3)));
                      _this.code = code;
                      return _this;
                    }
                    return NodeError2;
                  }(Base);
                  codes[code] = NodeError;
                }
                function oneOf(expected, thing) {
                  if (Array.isArray(expected)) {
                    var len = expected.length;
                    expected = expected.map(function(i) {
                      return String(i);
                    });
                    if (len > 2) {
                      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
                    } else if (len === 2) {
                      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
                    } else {
                      return "of ".concat(thing, " ").concat(expected[0]);
                    }
                  } else {
                    return "of ".concat(thing, " ").concat(String(expected));
                  }
                }
                function startsWith(str, search, pos) {
                  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
                }
                function endsWith(str, search, this_len) {
                  if (this_len === void 0 || this_len > str.length) {
                    this_len = str.length;
                  }
                  return str.substring(this_len - search.length, this_len) === search;
                }
                function includes(str, search, start) {
                  if (typeof start !== "number") {
                    start = 0;
                  }
                  if (start + search.length > str.length) {
                    return false;
                  } else {
                    return str.indexOf(search, start) !== -1;
                  }
                }
                createErrorType("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
                createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
                  if (assert === void 0)
                    assert = __webpack_require__2(9282);
                  assert(typeof name === "string", "'name' must be a string");
                  var determiner;
                  if (typeof expected === "string" && startsWith(expected, "not ")) {
                    determiner = "must not be";
                    expected = expected.replace(/^not /, "");
                  } else {
                    determiner = "must be";
                  }
                  var msg;
                  if (endsWith(name, " argument")) {
                    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
                  } else {
                    var type = includes(name, ".") ? "property" : "argument";
                    msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
                  }
                  msg += ". Received type ".concat(_typeof(actual));
                  return msg;
                }, TypeError);
                createErrorType("ERR_INVALID_ARG_VALUE", function(name, value) {
                  var reason = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
                  if (util === void 0)
                    util = __webpack_require__2(9539);
                  var inspected = util.inspect(value);
                  if (inspected.length > 128) {
                    inspected = "".concat(inspected.slice(0, 128), "...");
                  }
                  return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
                }, TypeError, RangeError);
                createErrorType("ERR_INVALID_RETURN_VALUE", function(input, name, value) {
                  var type;
                  if (value && value.constructor && value.constructor.name) {
                    type = "instance of ".concat(value.constructor.name);
                  } else {
                    type = "type ".concat(_typeof(value));
                  }
                  return "Expected ".concat(input, ' to be returned from the "').concat(name, '"') + " function but got ".concat(type, ".");
                }, TypeError);
                createErrorType("ERR_MISSING_ARGS", function() {
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }
                  if (assert === void 0)
                    assert = __webpack_require__2(9282);
                  assert(args.length > 0, "At least one arg needs to be specified");
                  var msg = "The ";
                  var len = args.length;
                  args = args.map(function(a) {
                    return '"'.concat(a, '"');
                  });
                  switch (len) {
                    case 1:
                      msg += "".concat(args[0], " argument");
                      break;
                    case 2:
                      msg += "".concat(args[0], " and ").concat(args[1], " arguments");
                      break;
                    default:
                      msg += args.slice(0, len - 1).join(", ");
                      msg += ", and ".concat(args[len - 1], " arguments");
                      break;
                  }
                  return "".concat(msg, " must be specified");
                }, TypeError);
                module2.exports.codes = codes;
              }
            ),
            /***/
            9158: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                function _slicedToArray(arr, i) {
                  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
                }
                function _nonIterableRest() {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
                function _iterableToArrayLimit(arr, i) {
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = void 0;
                  try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i)
                        break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (!_n && _i["return"] != null)
                        _i["return"]();
                    } finally {
                      if (_d)
                        throw _e;
                    }
                  }
                  return _arr;
                }
                function _arrayWithHoles(arr) {
                  if (Array.isArray(arr))
                    return arr;
                }
                function _typeof(obj) {
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    _typeof = function _typeof2(obj2) {
                      return typeof obj2;
                    };
                  } else {
                    _typeof = function _typeof2(obj2) {
                      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    };
                  }
                  return _typeof(obj);
                }
                var regexFlagsSupported = /a/g.flags !== void 0;
                var arrayFromSet = function arrayFromSet2(set) {
                  var array = [];
                  set.forEach(function(value) {
                    return array.push(value);
                  });
                  return array;
                };
                var arrayFromMap = function arrayFromMap2(map) {
                  var array = [];
                  map.forEach(function(value, key) {
                    return array.push([key, value]);
                  });
                  return array;
                };
                var objectIs = Object.is ? Object.is : __webpack_require__2(609);
                var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
                  return [];
                };
                var numberIsNaN = Number.isNaN ? Number.isNaN : __webpack_require__2(360);
                function uncurryThis(f) {
                  return f.call.bind(f);
                }
                var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
                var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
                var objectToString = uncurryThis(Object.prototype.toString);
                var _require$types = __webpack_require__2(9539).types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView = _require$types.isArrayBufferView, isDate = _require$types.isDate, isMap = _require$types.isMap, isRegExp = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
                function isNonIndex(key) {
                  if (key.length === 0 || key.length > 10)
                    return true;
                  for (var i = 0; i < key.length; i++) {
                    var code = key.charCodeAt(i);
                    if (code < 48 || code > 57)
                      return true;
                  }
                  return key.length === 10 && key >= Math.pow(2, 32);
                }
                function getOwnNonIndexProperties(value) {
                  return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
                }
                function compare(a, b) {
                  if (a === b) {
                    return 0;
                  }
                  var x = a.length;
                  var y = b.length;
                  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                    if (a[i] !== b[i]) {
                      x = a[i];
                      y = b[i];
                      break;
                    }
                  }
                  if (x < y) {
                    return -1;
                  }
                  if (y < x) {
                    return 1;
                  }
                  return 0;
                }
                var ONLY_ENUMERABLE = void 0;
                var kStrict = true;
                var kLoose = false;
                var kNoIterator = 0;
                var kIsArray = 1;
                var kIsSet = 2;
                var kIsMap = 3;
                function areSimilarRegExps(a, b) {
                  return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
                }
                function areSimilarFloatArrays(a, b) {
                  if (a.byteLength !== b.byteLength) {
                    return false;
                  }
                  for (var offset = 0; offset < a.byteLength; offset++) {
                    if (a[offset] !== b[offset]) {
                      return false;
                    }
                  }
                  return true;
                }
                function areSimilarTypedArrays(a, b) {
                  if (a.byteLength !== b.byteLength) {
                    return false;
                  }
                  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
                }
                function areEqualArrayBuffers(buf1, buf2) {
                  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
                }
                function isEqualBoxedPrimitive(val1, val2) {
                  if (isNumberObject(val1)) {
                    return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
                  }
                  if (isStringObject(val1)) {
                    return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
                  }
                  if (isBooleanObject(val1)) {
                    return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
                  }
                  if (isBigIntObject(val1)) {
                    return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
                  }
                  return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
                }
                function innerDeepEqual(val1, val2, strict, memos) {
                  if (val1 === val2) {
                    if (val1 !== 0)
                      return true;
                    return strict ? objectIs(val1, val2) : true;
                  }
                  if (strict) {
                    if (_typeof(val1) !== "object") {
                      return typeof val1 === "number" && numberIsNaN(val1) && numberIsNaN(val2);
                    }
                    if (_typeof(val2) !== "object" || val1 === null || val2 === null) {
                      return false;
                    }
                    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
                      return false;
                    }
                  } else {
                    if (val1 === null || _typeof(val1) !== "object") {
                      if (val2 === null || _typeof(val2) !== "object") {
                        return val1 == val2;
                      }
                      return false;
                    }
                    if (val2 === null || _typeof(val2) !== "object") {
                      return false;
                    }
                  }
                  var val1Tag = objectToString(val1);
                  var val2Tag = objectToString(val2);
                  if (val1Tag !== val2Tag) {
                    return false;
                  }
                  if (Array.isArray(val1)) {
                    if (val1.length !== val2.length) {
                      return false;
                    }
                    var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                    var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                    if (keys1.length !== keys2.length) {
                      return false;
                    }
                    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
                  }
                  if (val1Tag === "[object Object]") {
                    if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
                      return false;
                    }
                  }
                  if (isDate(val1)) {
                    if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
                      return false;
                    }
                  } else if (isRegExp(val1)) {
                    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
                      return false;
                    }
                  } else if (isNativeError(val1) || val1 instanceof Error) {
                    if (val1.message !== val2.message || val1.name !== val2.name) {
                      return false;
                    }
                  } else if (isArrayBufferView(val1)) {
                    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
                      if (!areSimilarFloatArrays(val1, val2)) {
                        return false;
                      }
                    } else if (!areSimilarTypedArrays(val1, val2)) {
                      return false;
                    }
                    var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                    var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                    if (_keys.length !== _keys2.length) {
                      return false;
                    }
                    return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
                  } else if (isSet(val1)) {
                    if (!isSet(val2) || val1.size !== val2.size) {
                      return false;
                    }
                    return keyCheck(val1, val2, strict, memos, kIsSet);
                  } else if (isMap(val1)) {
                    if (!isMap(val2) || val1.size !== val2.size) {
                      return false;
                    }
                    return keyCheck(val1, val2, strict, memos, kIsMap);
                  } else if (isAnyArrayBuffer(val1)) {
                    if (!areEqualArrayBuffers(val1, val2)) {
                      return false;
                    }
                  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
                    return false;
                  }
                  return keyCheck(val1, val2, strict, memos, kNoIterator);
                }
                function getEnumerables(val, keys) {
                  return keys.filter(function(k) {
                    return propertyIsEnumerable(val, k);
                  });
                }
                function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
                  if (arguments.length === 5) {
                    aKeys = Object.keys(val1);
                    var bKeys = Object.keys(val2);
                    if (aKeys.length !== bKeys.length) {
                      return false;
                    }
                  }
                  var i = 0;
                  for (; i < aKeys.length; i++) {
                    if (!hasOwnProperty(val2, aKeys[i])) {
                      return false;
                    }
                  }
                  if (strict && arguments.length === 5) {
                    var symbolKeysA = objectGetOwnPropertySymbols(val1);
                    if (symbolKeysA.length !== 0) {
                      var count = 0;
                      for (i = 0; i < symbolKeysA.length; i++) {
                        var key = symbolKeysA[i];
                        if (propertyIsEnumerable(val1, key)) {
                          if (!propertyIsEnumerable(val2, key)) {
                            return false;
                          }
                          aKeys.push(key);
                          count++;
                        } else if (propertyIsEnumerable(val2, key)) {
                          return false;
                        }
                      }
                      var symbolKeysB = objectGetOwnPropertySymbols(val2);
                      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
                        return false;
                      }
                    } else {
                      var _symbolKeysB = objectGetOwnPropertySymbols(val2);
                      if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
                        return false;
                      }
                    }
                  }
                  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
                    return true;
                  }
                  if (memos === void 0) {
                    memos = {
                      val1: /* @__PURE__ */ new Map(),
                      val2: /* @__PURE__ */ new Map(),
                      position: 0
                    };
                  } else {
                    var val2MemoA = memos.val1.get(val1);
                    if (val2MemoA !== void 0) {
                      var val2MemoB = memos.val2.get(val2);
                      if (val2MemoB !== void 0) {
                        return val2MemoA === val2MemoB;
                      }
                    }
                    memos.position++;
                  }
                  memos.val1.set(val1, memos.position);
                  memos.val2.set(val2, memos.position);
                  var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
                  memos.val1.delete(val1);
                  memos.val2.delete(val2);
                  return areEq;
                }
                function setHasEqualElement(set, val1, strict, memo) {
                  var setValues = arrayFromSet(set);
                  for (var i = 0; i < setValues.length; i++) {
                    var val2 = setValues[i];
                    if (innerDeepEqual(val1, val2, strict, memo)) {
                      set.delete(val2);
                      return true;
                    }
                  }
                  return false;
                }
                function findLooseMatchingPrimitives(prim) {
                  switch (_typeof(prim)) {
                    case "undefined":
                      return null;
                    case "object":
                      return void 0;
                    case "symbol":
                      return false;
                    case "string":
                      prim = +prim;
                    case "number":
                      if (numberIsNaN(prim)) {
                        return false;
                      }
                  }
                  return true;
                }
                function setMightHaveLoosePrim(a, b, prim) {
                  var altValue = findLooseMatchingPrimitives(prim);
                  if (altValue != null)
                    return altValue;
                  return b.has(altValue) && !a.has(altValue);
                }
                function mapMightHaveLoosePrim(a, b, prim, item, memo) {
                  var altValue = findLooseMatchingPrimitives(prim);
                  if (altValue != null) {
                    return altValue;
                  }
                  var curB = b.get(altValue);
                  if (curB === void 0 && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
                    return false;
                  }
                  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
                }
                function setEquiv(a, b, strict, memo) {
                  var set = null;
                  var aValues = arrayFromSet(a);
                  for (var i = 0; i < aValues.length; i++) {
                    var val = aValues[i];
                    if (_typeof(val) === "object" && val !== null) {
                      if (set === null) {
                        set = /* @__PURE__ */ new Set();
                      }
                      set.add(val);
                    } else if (!b.has(val)) {
                      if (strict)
                        return false;
                      if (!setMightHaveLoosePrim(a, b, val)) {
                        return false;
                      }
                      if (set === null) {
                        set = /* @__PURE__ */ new Set();
                      }
                      set.add(val);
                    }
                  }
                  if (set !== null) {
                    var bValues = arrayFromSet(b);
                    for (var _i = 0; _i < bValues.length; _i++) {
                      var _val = bValues[_i];
                      if (_typeof(_val) === "object" && _val !== null) {
                        if (!setHasEqualElement(set, _val, strict, memo))
                          return false;
                      } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
                        return false;
                      }
                    }
                    return set.size === 0;
                  }
                  return true;
                }
                function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
                  var setValues = arrayFromSet(set);
                  for (var i = 0; i < setValues.length; i++) {
                    var key2 = setValues[i];
                    if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
                      set.delete(key2);
                      return true;
                    }
                  }
                  return false;
                }
                function mapEquiv(a, b, strict, memo) {
                  var set = null;
                  var aEntries = arrayFromMap(a);
                  for (var i = 0; i < aEntries.length; i++) {
                    var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
                    if (_typeof(key) === "object" && key !== null) {
                      if (set === null) {
                        set = /* @__PURE__ */ new Set();
                      }
                      set.add(key);
                    } else {
                      var item2 = b.get(key);
                      if (item2 === void 0 && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
                        if (strict)
                          return false;
                        if (!mapMightHaveLoosePrim(a, b, key, item1, memo))
                          return false;
                        if (set === null) {
                          set = /* @__PURE__ */ new Set();
                        }
                        set.add(key);
                      }
                    }
                  }
                  if (set !== null) {
                    var bEntries = arrayFromMap(b);
                    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
                      var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
                      if (_typeof(key) === "object" && key !== null) {
                        if (!mapHasEqualEntry(set, a, key, item, strict, memo))
                          return false;
                      } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
                        return false;
                      }
                    }
                    return set.size === 0;
                  }
                  return true;
                }
                function objEquiv(a, b, strict, keys, memos, iterationType) {
                  var i = 0;
                  if (iterationType === kIsSet) {
                    if (!setEquiv(a, b, strict, memos)) {
                      return false;
                    }
                  } else if (iterationType === kIsMap) {
                    if (!mapEquiv(a, b, strict, memos)) {
                      return false;
                    }
                  } else if (iterationType === kIsArray) {
                    for (; i < a.length; i++) {
                      if (hasOwnProperty(a, i)) {
                        if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
                          return false;
                        }
                      } else if (hasOwnProperty(b, i)) {
                        return false;
                      } else {
                        var keysA = Object.keys(a);
                        for (; i < keysA.length; i++) {
                          var key = keysA[i];
                          if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                            return false;
                          }
                        }
                        if (keysA.length !== Object.keys(b).length) {
                          return false;
                        }
                        return true;
                      }
                    }
                  }
                  for (i = 0; i < keys.length; i++) {
                    var _key = keys[i];
                    if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
                      return false;
                    }
                  }
                  return true;
                }
                function isDeepEqual(val1, val2) {
                  return innerDeepEqual(val1, val2, kLoose);
                }
                function isDeepStrictEqual(val1, val2) {
                  return innerDeepEqual(val1, val2, kStrict);
                }
                module2.exports = {
                  isDeepEqual,
                  isDeepStrictEqual
                };
              }
            ),
            /***/
            2055: (
              /***/
              function(__unused_webpack_module, exports2) {
                "use strict";
                exports2.OP = 0;
                exports2.CL = 1;
                exports2.CP = 2;
                exports2.QU = 3;
                exports2.GL = 4;
                exports2.NS = 5;
                exports2.EX = 6;
                exports2.SY = 7;
                exports2.IS = 8;
                exports2.PR = 9;
                exports2.PO = 10;
                exports2.NU = 11;
                exports2.AL = 12;
                exports2.HL = 13;
                exports2.ID = 14;
                exports2.IN = 15;
                exports2.HY = 16;
                exports2.BA = 17;
                exports2.BB = 18;
                exports2.B2 = 19;
                exports2.ZW = 20;
                exports2.CM = 21;
                exports2.WJ = 22;
                exports2.H2 = 23;
                exports2.H3 = 24;
                exports2.JL = 25;
                exports2.JV = 26;
                exports2.JT = 27;
                exports2.RI = 28;
                exports2.EB = 29;
                exports2.EM = 30;
                exports2.ZWJ = 31;
                exports2.CB = 32;
                exports2.AI = 33;
                exports2.BK = 34;
                exports2.CJ = 35;
                exports2.CR = 36;
                exports2.LF = 37;
                exports2.NL = 38;
                exports2.SA = 39;
                exports2.SG = 40;
                exports2.SP = 41;
                exports2.XX = 42;
              }
            ),
            /***/
            8383: (
              /***/
              function(__unused_webpack_module, exports2) {
                "use strict";
                var CI_BRK, CP_BRK, DI_BRK, IN_BRK, PR_BRK;
                exports2.DI_BRK = DI_BRK = 0;
                exports2.IN_BRK = IN_BRK = 1;
                exports2.CI_BRK = CI_BRK = 2;
                exports2.CP_BRK = CP_BRK = 3;
                exports2.PR_BRK = PR_BRK = 4;
                exports2.pairTable = [
                  //OP   , CL    , CP    , QU    , GL    , NS    , EX    , SY    , IS    , PR    , PO    , NU    , AL    , HL    , ID    , IN    , HY    , BA    , BB    , B2    , ZW    , CM    , WJ    , H2    , H3    , JL    , JV    , JT    , RI    , EB    , EM    , ZWJ   , CB
                  [PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, CP_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK],
                  // OP
                  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // CL
                  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // CP
                  [PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK],
                  // QU
                  [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK],
                  // GL
                  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // NS
                  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // EX
                  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // SY
                  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // IS
                  [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK],
                  // PR
                  [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // PO
                  [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // NU
                  [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // AL
                  [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // HL
                  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // ID
                  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // IN
                  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, DI_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // HY
                  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, DI_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // BA
                  [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK],
                  // BB
                  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, PR_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // B2
                  [DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK],
                  // ZW
                  [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // CM
                  [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK],
                  // WJ
                  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // H2
                  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // H3
                  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // JL
                  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // JV
                  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // JT
                  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // RI
                  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK],
                  // EB
                  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // EM
                  [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK],
                  // ZWJ
                  [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, DI_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK]
                  // CB
                ];
              }
            ),
            /***/
            5106: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(9601);
                exports2.EncodeStream = __webpack_require__2(9126);
                exports2.DecodeStream = __webpack_require__2(3030);
                exports2.Array = __webpack_require__2(1988);
                exports2.LazyArray = __webpack_require__2(6768);
                exports2.Bitfield = __webpack_require__2(3425);
                exports2.Boolean = __webpack_require__2(9024);
                exports2.Buffer = __webpack_require__2(5250);
                exports2.Enum = __webpack_require__2(3100);
                exports2.Optional = __webpack_require__2(9541);
                exports2.Reserved = __webpack_require__2(7468);
                exports2.String = __webpack_require__2(1466);
                exports2.Struct = __webpack_require__2(1219);
                exports2.VersionedStruct = __webpack_require__2(3585);
                var utils = __webpack_require__2(6610);
                var NumberT = __webpack_require__2(6462);
                var Pointer = __webpack_require__2(8011);
                Object.assign(exports2, utils, NumberT, Pointer);
              }
            ),
            /***/
            1988: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                __webpack_require__2(7042);
                __webpack_require__2(1539);
                __webpack_require__2(8309);
                __webpack_require__2(1038);
                __webpack_require__2(8783);
                __webpack_require__2(4916);
                __webpack_require__2(2526);
                __webpack_require__2(1817);
                __webpack_require__2(2165);
                __webpack_require__2(6992);
                __webpack_require__2(3948);
                function _createForOfIteratorHelperLoose(o, allowArrayLike) {
                  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                  if (it)
                    return (it = it.call(o)).next.bind(it);
                  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                      o = it;
                    var i = 0;
                    return function() {
                      if (i >= o.length)
                        return { done: true };
                      return { done: false, value: o[i++] };
                    };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                function _unsupportedIterableToArray(o, minLen) {
                  if (!o)
                    return;
                  if (typeof o === "string")
                    return _arrayLikeToArray(o, minLen);
                  var n = Object.prototype.toString.call(o).slice(8, -1);
                  if (n === "Object" && o.constructor)
                    n = o.constructor.name;
                  if (n === "Map" || n === "Set")
                    return Array.from(o);
                  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                    return _arrayLikeToArray(o, minLen);
                }
                function _arrayLikeToArray(arr, len) {
                  if (len == null || len > arr.length)
                    len = arr.length;
                  for (var i = 0, arr2 = new Array(len); i < len; i++) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                }
                var _require = __webpack_require__2(6462), NumberT = _require.Number;
                var utils = __webpack_require__2(6610);
                var ArrayT = function() {
                  function ArrayT2(type, length, lengthType) {
                    if (lengthType === void 0) {
                      lengthType = "count";
                    }
                    this.type = type;
                    this.length = length;
                    this.lengthType = lengthType;
                  }
                  var _proto = ArrayT2.prototype;
                  _proto.decode = function decode(stream, parent) {
                    var length;
                    var pos = stream.pos;
                    var res = [];
                    var ctx = parent;
                    if (this.length != null) {
                      length = utils.resolveLength(this.length, stream, parent);
                    }
                    if (this.length instanceof NumberT) {
                      Object.defineProperties(res, {
                        parent: {
                          value: parent
                        },
                        _startOffset: {
                          value: pos
                        },
                        _currentOffset: {
                          value: 0,
                          writable: true
                        },
                        _length: {
                          value: length
                        }
                      });
                      ctx = res;
                    }
                    if (length == null || this.lengthType === "bytes") {
                      var target = length != null ? stream.pos + length : (parent != null ? parent._length : void 0) ? parent._startOffset + parent._length : stream.length;
                      while (stream.pos < target) {
                        res.push(this.type.decode(stream, ctx));
                      }
                    } else {
                      for (var i = 0, end = length; i < end; i++) {
                        res.push(this.type.decode(stream, ctx));
                      }
                    }
                    return res;
                  };
                  _proto.size = function size(array, ctx) {
                    if (!array) {
                      return this.type.size(null, ctx) * utils.resolveLength(this.length, null, ctx);
                    }
                    var size2 = 0;
                    if (this.length instanceof NumberT) {
                      size2 += this.length.size();
                      ctx = {
                        parent: ctx
                      };
                    }
                    for (var _iterator = _createForOfIteratorHelperLoose(array), _step; !(_step = _iterator()).done; ) {
                      var item = _step.value;
                      size2 += this.type.size(item, ctx);
                    }
                    return size2;
                  };
                  _proto.encode = function encode(stream, array, parent) {
                    var ctx = parent;
                    if (this.length instanceof NumberT) {
                      ctx = {
                        pointers: [],
                        startOffset: stream.pos,
                        parent
                      };
                      ctx.pointerOffset = stream.pos + this.size(array, ctx);
                      this.length.encode(stream, array.length);
                    }
                    for (var _iterator2 = _createForOfIteratorHelperLoose(array), _step2; !(_step2 = _iterator2()).done; ) {
                      var item = _step2.value;
                      this.type.encode(stream, item, ctx);
                    }
                    if (this.length instanceof NumberT) {
                      var i = 0;
                      while (i < ctx.pointers.length) {
                        var ptr = ctx.pointers[i++];
                        ptr.type.encode(stream, ptr.val);
                      }
                    }
                  };
                  return ArrayT2;
                }();
                module2.exports = ArrayT;
              }
            ),
            /***/
            3425: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                __webpack_require__2(2087);
                var Bitfield = function() {
                  function Bitfield2(type, flags) {
                    if (flags === void 0) {
                      flags = [];
                    }
                    this.type = type;
                    this.flags = flags;
                  }
                  var _proto = Bitfield2.prototype;
                  _proto.decode = function decode(stream) {
                    var val = this.type.decode(stream);
                    var res = {};
                    for (var i = 0; i < this.flags.length; i++) {
                      var flag = this.flags[i];
                      if (flag != null) {
                        res[flag] = !!(val & 1 << i);
                      }
                    }
                    return res;
                  };
                  _proto.size = function size() {
                    return this.type.size();
                  };
                  _proto.encode = function encode(stream, keys) {
                    var val = 0;
                    for (var i = 0; i < this.flags.length; i++) {
                      var flag = this.flags[i];
                      if (flag != null) {
                        if (keys[flag]) {
                          val |= 1 << i;
                        }
                      }
                    }
                    return this.type.encode(stream, val);
                  };
                  return Bitfield2;
                }();
                module2.exports = Bitfield;
              }
            ),
            /***/
            9024: (
              /***/
              function(module2) {
                "use strict";
                var BooleanT = function() {
                  function BooleanT2(type) {
                    this.type = type;
                  }
                  var _proto = BooleanT2.prototype;
                  _proto.decode = function decode(stream, parent) {
                    return !!this.type.decode(stream, parent);
                  };
                  _proto.size = function size(val, parent) {
                    return this.type.size(val, parent);
                  };
                  _proto.encode = function encode(stream, val, parent) {
                    return this.type.encode(stream, +val, parent);
                  };
                  return BooleanT2;
                }();
                module2.exports = BooleanT;
              }
            ),
            /***/
            5250: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var utils = __webpack_require__2(6610);
                var _require = __webpack_require__2(6462), NumberT = _require.Number;
                var BufferT = function() {
                  function BufferT2(length) {
                    this.length = length;
                  }
                  var _proto = BufferT2.prototype;
                  _proto.decode = function decode(stream, parent) {
                    var length = utils.resolveLength(this.length, stream, parent);
                    return stream.readBuffer(length);
                  };
                  _proto.size = function size(val, parent) {
                    if (!val) {
                      return utils.resolveLength(this.length, null, parent);
                    }
                    return val.length;
                  };
                  _proto.encode = function encode(stream, buf, parent) {
                    if (this.length instanceof NumberT) {
                      this.length.encode(stream, buf.length);
                    }
                    return stream.writeBuffer(buf);
                  };
                  return BufferT2;
                }();
                module2.exports = BufferT;
              }
            ),
            /***/
            3030: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var Buffer = __webpack_require__2(8823)["Buffer"];
                __webpack_require__2(1539);
                __webpack_require__2(9714);
                __webpack_require__2(7042);
                __webpack_require__2(4916);
                __webpack_require__2(5306);
                var iconv;
                try {
                  iconv = __webpack_require__2(4914);
                } catch (error) {
                }
                var DecodeStream = function() {
                  function DecodeStream2(buffer) {
                    this.buffer = buffer;
                    this.pos = 0;
                    this.length = this.buffer.length;
                  }
                  var _proto = DecodeStream2.prototype;
                  _proto.readString = function readString(length, encoding) {
                    if (encoding === void 0) {
                      encoding = "ascii";
                    }
                    switch (encoding) {
                      case "utf16le":
                      case "ucs2":
                      case "utf8":
                      case "ascii":
                        return this.buffer.toString(encoding, this.pos, this.pos += length);
                      case "utf16be":
                        var buf = Buffer.from(this.readBuffer(length));
                        for (var i = 0, end = buf.length - 1; i < end; i += 2) {
                          var byte = buf[i];
                          buf[i] = buf[i + 1];
                          buf[i + 1] = byte;
                        }
                        return buf.toString("utf16le");
                      default:
                        buf = this.readBuffer(length);
                        if (iconv) {
                          try {
                            return iconv.decode(buf, encoding);
                          } catch (error1) {
                          }
                        }
                        return buf;
                    }
                  };
                  _proto.readBuffer = function readBuffer(length) {
                    return this.buffer.slice(this.pos, this.pos += length);
                  };
                  _proto.readUInt24BE = function readUInt24BE() {
                    return (this.readUInt16BE() << 8) + this.readUInt8();
                  };
                  _proto.readUInt24LE = function readUInt24LE() {
                    return this.readUInt16LE() + (this.readUInt8() << 16);
                  };
                  _proto.readInt24BE = function readInt24BE() {
                    return (this.readInt16BE() << 8) + this.readUInt8();
                  };
                  _proto.readInt24LE = function readInt24LE() {
                    return this.readUInt16LE() + (this.readInt8() << 16);
                  };
                  return DecodeStream2;
                }();
                DecodeStream.TYPES = {
                  UInt8: 1,
                  UInt16: 2,
                  UInt24: 3,
                  UInt32: 4,
                  Int8: 1,
                  Int16: 2,
                  Int24: 3,
                  Int32: 4,
                  Float: 4,
                  Double: 8
                };
                var _loop = function _loop2(key2) {
                  if (key2.slice(0, 4) === "read") {
                    var bytes = DecodeStream.TYPES[key2.replace(/read|[BL]E/g, "")];
                    DecodeStream.prototype[key2] = function() {
                      var ret = this.buffer[key2](this.pos);
                      this.pos += bytes;
                      return ret;
                    };
                  }
                };
                for (var key in Buffer.prototype) {
                  _loop(key);
                }
                module2.exports = DecodeStream;
              }
            ),
            /***/
            9126: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var Buffer = __webpack_require__2(8823)["Buffer"];
                __webpack_require__2(7042);
                __webpack_require__2(3290);
                __webpack_require__2(4916);
                __webpack_require__2(5306);
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                var iconv;
                var stream = __webpack_require__2(2830);
                var DecodeStream = __webpack_require__2(3030);
                try {
                  iconv = __webpack_require__2(4914);
                } catch (error) {
                }
                var EncodeStream = function(_stream$Readable) {
                  _inheritsLoose(EncodeStream2, _stream$Readable);
                  function EncodeStream2(bufferSize) {
                    var _this;
                    if (bufferSize === void 0) {
                      bufferSize = 65536;
                    }
                    _this = _stream$Readable.apply(this, arguments) || this;
                    _this.buffer = Buffer.alloc(bufferSize);
                    _this.bufferOffset = 0;
                    _this.pos = 0;
                    return _this;
                  }
                  var _proto = EncodeStream2.prototype;
                  _proto._read = function _read() {
                  };
                  _proto.ensure = function ensure(bytes) {
                    if (this.bufferOffset + bytes > this.buffer.length) {
                      return this.flush();
                    }
                  };
                  _proto.flush = function flush() {
                    if (this.bufferOffset > 0) {
                      this.push(Buffer.from(this.buffer.slice(0, this.bufferOffset)));
                      return this.bufferOffset = 0;
                    }
                  };
                  _proto.writeBuffer = function writeBuffer(buffer) {
                    this.flush();
                    this.push(buffer);
                    return this.pos += buffer.length;
                  };
                  _proto.writeString = function writeString(string, encoding) {
                    if (encoding === void 0) {
                      encoding = "ascii";
                    }
                    switch (encoding) {
                      case "utf16le":
                      case "ucs2":
                      case "utf8":
                      case "ascii":
                        return this.writeBuffer(Buffer.from(string, encoding));
                      case "utf16be":
                        var buf = Buffer.from(string, "utf16le");
                        for (var i = 0, end = buf.length - 1; i < end; i += 2) {
                          var byte = buf[i];
                          buf[i] = buf[i + 1];
                          buf[i + 1] = byte;
                        }
                        return this.writeBuffer(buf);
                      default:
                        if (iconv) {
                          return this.writeBuffer(iconv.encode(string, encoding));
                        } else {
                          throw new Error("Install iconv-lite to enable additional string encodings.");
                        }
                    }
                  };
                  _proto.writeUInt24BE = function writeUInt24BE(val) {
                    this.ensure(3);
                    this.buffer[this.bufferOffset++] = val >>> 16 & 255;
                    this.buffer[this.bufferOffset++] = val >>> 8 & 255;
                    this.buffer[this.bufferOffset++] = val & 255;
                    return this.pos += 3;
                  };
                  _proto.writeUInt24LE = function writeUInt24LE(val) {
                    this.ensure(3);
                    this.buffer[this.bufferOffset++] = val & 255;
                    this.buffer[this.bufferOffset++] = val >>> 8 & 255;
                    this.buffer[this.bufferOffset++] = val >>> 16 & 255;
                    return this.pos += 3;
                  };
                  _proto.writeInt24BE = function writeInt24BE(val) {
                    if (val >= 0) {
                      return this.writeUInt24BE(val);
                    } else {
                      return this.writeUInt24BE(val + 16777215 + 1);
                    }
                  };
                  _proto.writeInt24LE = function writeInt24LE(val) {
                    if (val >= 0) {
                      return this.writeUInt24LE(val);
                    } else {
                      return this.writeUInt24LE(val + 16777215 + 1);
                    }
                  };
                  _proto.fill = function fill(val, length) {
                    if (length < this.buffer.length) {
                      this.ensure(length);
                      this.buffer.fill(val, this.bufferOffset, this.bufferOffset + length);
                      this.bufferOffset += length;
                      return this.pos += length;
                    } else {
                      var buf = Buffer.alloc(length);
                      buf.fill(val);
                      return this.writeBuffer(buf);
                    }
                  };
                  _proto.end = function end() {
                    this.flush();
                    return this.push(null);
                  };
                  return EncodeStream2;
                }(stream.Readable);
                var _loop = function _loop2(key2) {
                  if (key2.slice(0, 5) === "write") {
                    var bytes = +DecodeStream.TYPES[key2.replace(/write|[BL]E/g, "")];
                    EncodeStream.prototype[key2] = function(value) {
                      this.ensure(bytes);
                      this.buffer[key2](value, this.bufferOffset);
                      this.bufferOffset += bytes;
                      return this.pos += bytes;
                    };
                  }
                };
                for (var key in Buffer.prototype) {
                  _loop(key);
                }
                module2.exports = EncodeStream;
              }
            ),
            /***/
            3100: (
              /***/
              function(module2) {
                "use strict";
                var Enum = function() {
                  function Enum2(type, options) {
                    if (options === void 0) {
                      options = [];
                    }
                    this.type = type;
                    this.options = options;
                  }
                  var _proto = Enum2.prototype;
                  _proto.decode = function decode(stream) {
                    var index = this.type.decode(stream);
                    return this.options[index] || index;
                  };
                  _proto.size = function size() {
                    return this.type.size();
                  };
                  _proto.encode = function encode(stream, val) {
                    var index = this.options.indexOf(val);
                    if (index === -1) {
                      throw new Error("Unknown option in enum: " + val);
                    }
                    return this.type.encode(stream, index);
                  };
                  return Enum2;
                }();
                module2.exports = Enum;
              }
            ),
            /***/
            6768: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                __webpack_require__2(1539);
                __webpack_require__2(8674);
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                var ArrayT = __webpack_require__2(1988);
                var _require = __webpack_require__2(6462), NumberT = _require.Number;
                var utils = __webpack_require__2(6610);
                var _require2 = __webpack_require__2(9539), _inspect = _require2.inspect;
                var LazyArrayT = function(_ArrayT) {
                  _inheritsLoose(LazyArrayT2, _ArrayT);
                  function LazyArrayT2() {
                    return _ArrayT.apply(this, arguments) || this;
                  }
                  var _proto = LazyArrayT2.prototype;
                  _proto.decode = function decode(stream, parent) {
                    var pos = stream.pos;
                    var length = utils.resolveLength(this.length, stream, parent);
                    if (this.length instanceof NumberT) {
                      parent = {
                        parent,
                        _startOffset: pos,
                        _currentOffset: 0,
                        _length: length
                      };
                    }
                    var res = new LazyArray(this.type, length, stream, parent);
                    stream.pos += length * this.type.size(null, parent);
                    return res;
                  };
                  _proto.size = function size(val, ctx) {
                    if (val instanceof LazyArray) {
                      val = val.toArray();
                    }
                    return _ArrayT.prototype.size.call(this, val, ctx);
                  };
                  _proto.encode = function encode(stream, val, ctx) {
                    if (val instanceof LazyArray) {
                      val = val.toArray();
                    }
                    return _ArrayT.prototype.encode.call(this, stream, val, ctx);
                  };
                  return LazyArrayT2;
                }(ArrayT);
                var LazyArray = function() {
                  function LazyArray2(type, length, stream, ctx) {
                    this.type = type;
                    this.length = length;
                    this.stream = stream;
                    this.ctx = ctx;
                    this.base = this.stream.pos;
                    this.items = [];
                  }
                  var _proto2 = LazyArray2.prototype;
                  _proto2.get = function get(index) {
                    if (index < 0 || index >= this.length) {
                      return void 0;
                    }
                    if (this.items[index] == null) {
                      var pos = this.stream.pos;
                      this.stream.pos = this.base + this.type.size(null, this.ctx) * index;
                      this.items[index] = this.type.decode(this.stream, this.ctx);
                      this.stream.pos = pos;
                    }
                    return this.items[index];
                  };
                  _proto2.toArray = function toArray() {
                    var result = [];
                    for (var i = 0, end = this.length; i < end; i++) {
                      result.push(this.get(i));
                    }
                    return result;
                  };
                  _proto2.inspect = function inspect() {
                    return _inspect(this.toArray());
                  };
                  return LazyArray2;
                }();
                module2.exports = LazyArrayT;
              }
            ),
            /***/
            6462: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                var DecodeStream = __webpack_require__2(3030);
                var NumberT = function() {
                  function NumberT2(type, endian) {
                    if (endian === void 0) {
                      endian = "BE";
                    }
                    this.type = type;
                    this.endian = endian;
                    this.fn = this.type;
                    if (this.type[this.type.length - 1] !== "8") {
                      this.fn += this.endian;
                    }
                  }
                  var _proto = NumberT2.prototype;
                  _proto.size = function size() {
                    return DecodeStream.TYPES[this.type];
                  };
                  _proto.decode = function decode(stream) {
                    return stream["read" + this.fn]();
                  };
                  _proto.encode = function encode(stream, val) {
                    return stream["write" + this.fn](val);
                  };
                  return NumberT2;
                }();
                exports2.Number = NumberT;
                exports2.uint8 = new NumberT("UInt8");
                exports2.uint16be = exports2.uint16 = new NumberT("UInt16", "BE");
                exports2.uint16le = new NumberT("UInt16", "LE");
                exports2.uint24be = exports2.uint24 = new NumberT("UInt24", "BE");
                exports2.uint24le = new NumberT("UInt24", "LE");
                exports2.uint32be = exports2.uint32 = new NumberT("UInt32", "BE");
                exports2.uint32le = new NumberT("UInt32", "LE");
                exports2.int8 = new NumberT("Int8");
                exports2.int16be = exports2.int16 = new NumberT("Int16", "BE");
                exports2.int16le = new NumberT("Int16", "LE");
                exports2.int24be = exports2.int24 = new NumberT("Int24", "BE");
                exports2.int24le = new NumberT("Int24", "LE");
                exports2.int32be = exports2.int32 = new NumberT("Int32", "BE");
                exports2.int32le = new NumberT("Int32", "LE");
                exports2.floatbe = exports2.float = new NumberT("Float", "BE");
                exports2.floatle = new NumberT("Float", "LE");
                exports2.doublebe = exports2.double = new NumberT("Double", "BE");
                exports2.doublele = new NumberT("Double", "LE");
                var Fixed = function(_NumberT) {
                  _inheritsLoose(Fixed2, _NumberT);
                  function Fixed2(size, endian, fracBits) {
                    var _this;
                    if (fracBits === void 0) {
                      fracBits = size >> 1;
                    }
                    _this = _NumberT.call(this, "Int" + size, endian) || this;
                    _this._point = 1 << fracBits;
                    return _this;
                  }
                  var _proto2 = Fixed2.prototype;
                  _proto2.decode = function decode(stream) {
                    return _NumberT.prototype.decode.call(this, stream) / this._point;
                  };
                  _proto2.encode = function encode(stream, val) {
                    return _NumberT.prototype.encode.call(this, stream, val * this._point | 0);
                  };
                  return Fixed2;
                }(NumberT);
                exports2.Fixed = Fixed;
                exports2.fixed16be = exports2.fixed16 = new Fixed(16, "BE");
                exports2.fixed16le = new Fixed(16, "LE");
                exports2.fixed32be = exports2.fixed32 = new Fixed(32, "BE");
                exports2.fixed32le = new Fixed(32, "LE");
              }
            ),
            /***/
            9541: (
              /***/
              function(module2) {
                "use strict";
                var Optional = function() {
                  function Optional2(type, condition) {
                    if (condition === void 0) {
                      condition = true;
                    }
                    this.type = type;
                    this.condition = condition;
                  }
                  var _proto = Optional2.prototype;
                  _proto.decode = function decode(stream, parent) {
                    var condition = this.condition;
                    if (typeof condition === "function") {
                      condition = condition.call(parent, parent);
                    }
                    if (condition) {
                      return this.type.decode(stream, parent);
                    }
                  };
                  _proto.size = function size(val, parent) {
                    var condition = this.condition;
                    if (typeof condition === "function") {
                      condition = condition.call(parent, parent);
                    }
                    if (condition) {
                      return this.type.size(val, parent);
                    } else {
                      return 0;
                    }
                  };
                  _proto.encode = function encode(stream, val, parent) {
                    var condition = this.condition;
                    if (typeof condition === "function") {
                      condition = condition.call(parent, parent);
                    }
                    if (condition) {
                      return this.type.encode(stream, val, parent);
                    }
                  };
                  return Optional2;
                }();
                module2.exports = Optional;
              }
            ),
            /***/
            8011: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var utils = __webpack_require__2(6610);
                var Pointer = function() {
                  function Pointer2(offsetType, type, options) {
                    if (options === void 0) {
                      options = {};
                    }
                    this.offsetType = offsetType;
                    this.type = type;
                    this.options = options;
                    if (this.type === "void") {
                      this.type = null;
                    }
                    if (this.options.type == null) {
                      this.options.type = "local";
                    }
                    if (this.options.allowNull == null) {
                      this.options.allowNull = true;
                    }
                    if (this.options.nullValue == null) {
                      this.options.nullValue = 0;
                    }
                    if (this.options.lazy == null) {
                      this.options.lazy = false;
                    }
                    if (this.options.relativeTo) {
                      if (typeof this.options.relativeTo !== "function") {
                        throw new Error("relativeTo option must be a function");
                      }
                      this.relativeToGetter = options.relativeTo;
                    }
                  }
                  var _proto = Pointer2.prototype;
                  _proto.decode = function decode(stream, ctx) {
                    var _this = this;
                    var offset = this.offsetType.decode(stream, ctx);
                    if (offset === this.options.nullValue && this.options.allowNull) {
                      return null;
                    }
                    var relative;
                    switch (this.options.type) {
                      case "local":
                        relative = ctx._startOffset;
                        break;
                      case "immediate":
                        relative = stream.pos - this.offsetType.size();
                        break;
                      case "parent":
                        relative = ctx.parent._startOffset;
                        break;
                      default:
                        var c = ctx;
                        while (c.parent) {
                          c = c.parent;
                        }
                        relative = c._startOffset || 0;
                    }
                    if (this.options.relativeTo) {
                      relative += this.relativeToGetter(ctx);
                    }
                    var ptr = offset + relative;
                    if (this.type != null) {
                      var val = null;
                      var decodeValue = function decodeValue2() {
                        if (val != null) {
                          return val;
                        }
                        var pos = stream.pos;
                        stream.pos = ptr;
                        val = _this.type.decode(stream, ctx);
                        stream.pos = pos;
                        return val;
                      };
                      if (this.options.lazy) {
                        return new utils.PropertyDescriptor({
                          get: decodeValue
                        });
                      }
                      return decodeValue();
                    } else {
                      return ptr;
                    }
                  };
                  _proto.size = function size(val, ctx) {
                    var parent = ctx;
                    switch (this.options.type) {
                      case "local":
                      case "immediate":
                        break;
                      case "parent":
                        ctx = ctx.parent;
                        break;
                      default:
                        while (ctx.parent) {
                          ctx = ctx.parent;
                        }
                    }
                    var type = this.type;
                    if (type == null) {
                      if (!(val instanceof VoidPointer)) {
                        throw new Error("Must be a VoidPointer");
                      }
                      var _val = val;
                      type = _val.type;
                      val = val.value;
                    }
                    if (val && ctx) {
                      ctx.pointerSize += type.size(val, parent);
                    }
                    return this.offsetType.size();
                  };
                  _proto.encode = function encode(stream, val, ctx) {
                    var relative;
                    var parent = ctx;
                    if (val == null) {
                      this.offsetType.encode(stream, this.options.nullValue);
                      return;
                    }
                    switch (this.options.type) {
                      case "local":
                        relative = ctx.startOffset;
                        break;
                      case "immediate":
                        relative = stream.pos + this.offsetType.size(val, parent);
                        break;
                      case "parent":
                        ctx = ctx.parent;
                        relative = ctx.startOffset;
                        break;
                      default:
                        relative = 0;
                        while (ctx.parent) {
                          ctx = ctx.parent;
                        }
                    }
                    if (this.options.relativeTo) {
                      relative += this.relativeToGetter(parent.val);
                    }
                    this.offsetType.encode(stream, ctx.pointerOffset - relative);
                    var type = this.type;
                    if (type == null) {
                      if (!(val instanceof VoidPointer)) {
                        throw new Error("Must be a VoidPointer");
                      }
                      var _val2 = val;
                      type = _val2.type;
                      val = val.value;
                    }
                    ctx.pointers.push({
                      type,
                      val,
                      parent
                    });
                    return ctx.pointerOffset += type.size(val, parent);
                  };
                  return Pointer2;
                }();
                var VoidPointer = function VoidPointer2(type, value) {
                  this.type = type;
                  this.value = value;
                };
                exports2.Pointer = Pointer;
                exports2.VoidPointer = VoidPointer;
              }
            ),
            /***/
            7468: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                __webpack_require__2(3290);
                var utils = __webpack_require__2(6610);
                var Reserved = function() {
                  function Reserved2(type, count) {
                    if (count === void 0) {
                      count = 1;
                    }
                    this.type = type;
                    this.count = count;
                  }
                  var _proto = Reserved2.prototype;
                  _proto.decode = function decode(stream, parent) {
                    stream.pos += this.size(null, parent);
                    return void 0;
                  };
                  _proto.size = function size(data, parent) {
                    var count = utils.resolveLength(this.count, null, parent);
                    return this.type.size() * count;
                  };
                  _proto.encode = function encode(stream, val, parent) {
                    return stream.fill(0, this.size(val, parent));
                  };
                  return Reserved2;
                }();
                module2.exports = Reserved;
              }
            ),
            /***/
            1466: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var Buffer = __webpack_require__2(8823)["Buffer"];
                var _require = __webpack_require__2(6462), NumberT = _require.Number;
                var utils = __webpack_require__2(6610);
                var StringT = function() {
                  function StringT2(length, encoding) {
                    if (encoding === void 0) {
                      encoding = "ascii";
                    }
                    this.length = length;
                    this.encoding = encoding;
                  }
                  var _proto = StringT2.prototype;
                  _proto.decode = function decode(stream, parent) {
                    var length, pos;
                    if (this.length != null) {
                      length = utils.resolveLength(this.length, stream, parent);
                    } else {
                      var buffer;
                      buffer = stream.buffer;
                      length = stream.length;
                      pos = stream.pos;
                      while (pos < length && buffer[pos] !== 0) {
                        ++pos;
                      }
                      length = pos - stream.pos;
                    }
                    var encoding = this.encoding;
                    if (typeof encoding === "function") {
                      encoding = encoding.call(parent, parent) || "ascii";
                    }
                    var string = stream.readString(length, encoding);
                    if (this.length == null && stream.pos < stream.length) {
                      stream.pos++;
                    }
                    return string;
                  };
                  _proto.size = function size(val, parent) {
                    if (!val) {
                      return utils.resolveLength(this.length, null, parent);
                    }
                    var encoding = this.encoding;
                    if (typeof encoding === "function") {
                      encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
                    }
                    if (encoding === "utf16be") {
                      encoding = "utf16le";
                    }
                    var size2 = Buffer.byteLength(val, encoding);
                    if (this.length instanceof NumberT) {
                      size2 += this.length.size();
                    }
                    if (this.length == null) {
                      size2++;
                    }
                    return size2;
                  };
                  _proto.encode = function encode(stream, val, parent) {
                    var encoding = this.encoding;
                    if (typeof encoding === "function") {
                      encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
                    }
                    if (this.length instanceof NumberT) {
                      this.length.encode(stream, Buffer.byteLength(val, encoding));
                    }
                    stream.writeString(val, encoding);
                    if (this.length == null) {
                      return stream.writeUInt8(0);
                    }
                  };
                  return StringT2;
                }();
                module2.exports = StringT;
              }
            ),
            /***/
            1219: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var utils = __webpack_require__2(6610);
                var Struct = function() {
                  function Struct2(fields) {
                    if (fields === void 0) {
                      fields = {};
                    }
                    this.fields = fields;
                  }
                  var _proto = Struct2.prototype;
                  _proto.decode = function decode(stream, parent, length) {
                    if (length === void 0) {
                      length = 0;
                    }
                    var res = this._setup(stream, parent, length);
                    this._parseFields(stream, res, this.fields);
                    if (this.process != null) {
                      this.process.call(res, stream);
                    }
                    return res;
                  };
                  _proto._setup = function _setup(stream, parent, length) {
                    var res = {};
                    Object.defineProperties(res, {
                      parent: {
                        value: parent
                      },
                      _startOffset: {
                        value: stream.pos
                      },
                      _currentOffset: {
                        value: 0,
                        writable: true
                      },
                      _length: {
                        value: length
                      }
                    });
                    return res;
                  };
                  _proto._parseFields = function _parseFields(stream, res, fields) {
                    for (var key in fields) {
                      var val;
                      var type = fields[key];
                      if (typeof type === "function") {
                        val = type.call(res, res);
                      } else {
                        val = type.decode(stream, res);
                      }
                      if (val !== void 0) {
                        if (val instanceof utils.PropertyDescriptor) {
                          Object.defineProperty(res, key, val);
                        } else {
                          res[key] = val;
                        }
                      }
                      res._currentOffset = stream.pos - res._startOffset;
                    }
                  };
                  _proto.size = function size(val, parent, includePointers) {
                    if (val == null) {
                      val = {};
                    }
                    if (includePointers == null) {
                      includePointers = true;
                    }
                    var ctx = {
                      parent,
                      val,
                      pointerSize: 0
                    };
                    var size2 = 0;
                    for (var key in this.fields) {
                      var type = this.fields[key];
                      if (type.size != null) {
                        size2 += type.size(val[key], ctx);
                      }
                    }
                    if (includePointers) {
                      size2 += ctx.pointerSize;
                    }
                    return size2;
                  };
                  _proto.encode = function encode(stream, val, parent) {
                    var type;
                    if (this.preEncode != null) {
                      this.preEncode.call(val, stream);
                    }
                    var ctx = {
                      pointers: [],
                      startOffset: stream.pos,
                      parent,
                      val,
                      pointerSize: 0
                    };
                    ctx.pointerOffset = stream.pos + this.size(val, ctx, false);
                    for (var key in this.fields) {
                      type = this.fields[key];
                      if (type.encode != null) {
                        type.encode(stream, val[key], ctx);
                      }
                    }
                    var i = 0;
                    while (i < ctx.pointers.length) {
                      var ptr = ctx.pointers[i++];
                      ptr.type.encode(stream, ptr.val, ptr.parent);
                    }
                  };
                  return Struct2;
                }();
                module2.exports = Struct;
              }
            ),
            /***/
            3585: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                __webpack_require__2(1539);
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                var Struct = __webpack_require__2(1219);
                var getPath = function getPath2(object, pathArray) {
                  return pathArray.reduce(function(prevObj, key) {
                    return prevObj && prevObj[key];
                  }, object);
                };
                var VersionedStruct = function(_Struct) {
                  _inheritsLoose(VersionedStruct2, _Struct);
                  function VersionedStruct2(type, versions) {
                    var _this;
                    if (versions === void 0) {
                      versions = {};
                    }
                    _this = _Struct.call(this) || this;
                    _this.type = type;
                    _this.versions = versions;
                    if (typeof type === "string") {
                      _this.versionPath = type.split(".");
                    }
                    return _this;
                  }
                  var _proto = VersionedStruct2.prototype;
                  _proto.decode = function decode(stream, parent, length) {
                    if (length === void 0) {
                      length = 0;
                    }
                    var res = this._setup(stream, parent, length);
                    if (typeof this.type === "string") {
                      res.version = getPath(parent, this.versionPath);
                    } else {
                      res.version = this.type.decode(stream);
                    }
                    if (this.versions.header) {
                      this._parseFields(stream, res, this.versions.header);
                    }
                    var fields = this.versions[res.version];
                    if (fields == null) {
                      throw new Error("Unknown version " + res.version);
                    }
                    if (fields instanceof VersionedStruct2) {
                      return fields.decode(stream, parent);
                    }
                    this._parseFields(stream, res, fields);
                    if (this.process != null) {
                      this.process.call(res, stream);
                    }
                    return res;
                  };
                  _proto.size = function size(val, parent, includePointers) {
                    if (includePointers === void 0) {
                      includePointers = true;
                    }
                    var key, type;
                    if (!val) {
                      throw new Error("Not a fixed size");
                    }
                    var ctx = {
                      parent,
                      val,
                      pointerSize: 0
                    };
                    var size2 = 0;
                    if (typeof this.type !== "string") {
                      size2 += this.type.size(val.version, ctx);
                    }
                    if (this.versions.header) {
                      for (key in this.versions.header) {
                        type = this.versions.header[key];
                        if (type.size != null) {
                          size2 += type.size(val[key], ctx);
                        }
                      }
                    }
                    var fields = this.versions[val.version];
                    if (fields == null) {
                      throw new Error("Unknown version " + val.version);
                    }
                    for (key in fields) {
                      type = fields[key];
                      if (type.size != null) {
                        size2 += type.size(val[key], ctx);
                      }
                    }
                    if (includePointers) {
                      size2 += ctx.pointerSize;
                    }
                    return size2;
                  };
                  _proto.encode = function encode(stream, val, parent) {
                    var key, type;
                    if (this.preEncode != null) {
                      this.preEncode.call(val, stream);
                    }
                    var ctx = {
                      pointers: [],
                      startOffset: stream.pos,
                      parent,
                      val,
                      pointerSize: 0
                    };
                    ctx.pointerOffset = stream.pos + this.size(val, ctx, false);
                    if (typeof this.type !== "string") {
                      this.type.encode(stream, val.version);
                    }
                    if (this.versions.header) {
                      for (key in this.versions.header) {
                        type = this.versions.header[key];
                        if (type.encode != null) {
                          type.encode(stream, val[key], ctx);
                        }
                      }
                    }
                    var fields = this.versions[val.version];
                    for (key in fields) {
                      type = fields[key];
                      if (type.encode != null) {
                        type.encode(stream, val[key], ctx);
                      }
                    }
                    var i = 0;
                    while (i < ctx.pointers.length) {
                      var ptr = ctx.pointers[i++];
                      ptr.type.encode(stream, ptr.val, ptr.parent);
                    }
                  };
                  return VersionedStruct2;
                }(Struct);
                module2.exports = VersionedStruct;
              }
            ),
            /***/
            6610: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var _require = __webpack_require__2(6462), NumberT = _require.Number;
                exports2.resolveLength = function(length, stream, parent) {
                  var res;
                  if (typeof length === "number") {
                    res = length;
                  } else if (typeof length === "function") {
                    res = length.call(parent, parent);
                  } else if (parent && typeof length === "string") {
                    res = parent[length];
                  } else if (stream && length instanceof NumberT) {
                    res = length.decode(stream);
                  }
                  if (isNaN(res)) {
                    throw new Error("Not a fixed size");
                  }
                  return res;
                };
                var PropertyDescriptor = function PropertyDescriptor2(opts) {
                  if (opts === void 0) {
                    opts = {};
                  }
                  this.enumerable = true;
                  this.configurable = true;
                  for (var key in opts) {
                    var val = opts[key];
                    this[key] = val;
                  }
                };
                exports2.PropertyDescriptor = PropertyDescriptor;
              }
            ),
            /***/
            8823: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(2526);
                __webpack_require__2(1817);
                __webpack_require__2(1539);
                __webpack_require__2(6992);
                __webpack_require__2(2472);
                __webpack_require__2(2990);
                __webpack_require__2(8927);
                __webpack_require__2(3105);
                __webpack_require__2(5035);
                __webpack_require__2(4345);
                __webpack_require__2(7174);
                __webpack_require__2(2846);
                __webpack_require__2(4731);
                __webpack_require__2(7209);
                __webpack_require__2(6319);
                __webpack_require__2(8867);
                __webpack_require__2(7789);
                __webpack_require__2(3739);
                __webpack_require__2(9368);
                __webpack_require__2(4483);
                __webpack_require__2(2056);
                __webpack_require__2(3462);
                __webpack_require__2(678);
                __webpack_require__2(7462);
                __webpack_require__2(3824);
                __webpack_require__2(5021);
                __webpack_require__2(2974);
                __webpack_require__2(5016);
                __webpack_require__2(7803);
                __webpack_require__2(6649);
                __webpack_require__2(6078);
                __webpack_require__2(3290);
                __webpack_require__2(7042);
                __webpack_require__2(2222);
                __webpack_require__2(9714);
                __webpack_require__2(3210);
                __webpack_require__2(4916);
                __webpack_require__2(5306);
                __webpack_require__2(6699);
                __webpack_require__2(2023);
                __webpack_require__2(9653);
                __webpack_require__2(3753);
                __webpack_require__2(545);
                __webpack_require__2(8309);
                __webpack_require__2(3161);
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  Object.defineProperty(Constructor, "prototype", { writable: false });
                  return Constructor;
                }
                function _toPropertyKey(arg) {
                  var key = _toPrimitive(arg, "string");
                  return typeof key === "symbol" ? key : String(key);
                }
                function _toPrimitive(input, hint) {
                  if (typeof input !== "object" || input === null)
                    return input;
                  var prim = input[Symbol.toPrimitive];
                  if (prim !== void 0) {
                    var res = prim.call(input, hint || "default");
                    if (typeof res !== "object")
                      return res;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return (hint === "string" ? String : Number)(input);
                }
                function _assertThisInitialized(self2) {
                  if (self2 === void 0) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return self2;
                }
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                var base64 = __webpack_require__2(9742);
                var ieee754 = __webpack_require__2(645);
                var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
                exports2.Buffer = Buffer;
                exports2.SlowBuffer = SlowBuffer;
                exports2.INSPECT_MAX_BYTES = 50;
                var K_MAX_LENGTH = 2147483647;
                exports2.kMaxLength = K_MAX_LENGTH;
                Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
                if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
                  console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
                }
                function typedArraySupport() {
                  try {
                    var arr = new Uint8Array(1);
                    var proto = {
                      foo: function foo() {
                        return 42;
                      }
                    };
                    Object.setPrototypeOf(proto, Uint8Array.prototype);
                    Object.setPrototypeOf(arr, proto);
                    return arr.foo() === 42;
                  } catch (e) {
                    return false;
                  }
                }
                Object.defineProperty(Buffer.prototype, "parent", {
                  enumerable: true,
                  get: function get() {
                    if (!Buffer.isBuffer(this))
                      return void 0;
                    return this.buffer;
                  }
                });
                Object.defineProperty(Buffer.prototype, "offset", {
                  enumerable: true,
                  get: function get() {
                    if (!Buffer.isBuffer(this))
                      return void 0;
                    return this.byteOffset;
                  }
                });
                function createBuffer(length) {
                  if (length > K_MAX_LENGTH) {
                    throw new RangeError('The value "' + length + '" is invalid for option "size"');
                  }
                  var buf = new Uint8Array(length);
                  Object.setPrototypeOf(buf, Buffer.prototype);
                  return buf;
                }
                function Buffer(arg, encodingOrOffset, length) {
                  if (typeof arg === "number") {
                    if (typeof encodingOrOffset === "string") {
                      throw new TypeError('The "string" argument must be of type string. Received type number');
                    }
                    return allocUnsafe(arg);
                  }
                  return from(arg, encodingOrOffset, length);
                }
                Buffer.poolSize = 8192;
                function from(value, encodingOrOffset, length) {
                  if (typeof value === "string") {
                    return fromString(value, encodingOrOffset);
                  }
                  if (ArrayBuffer.isView(value)) {
                    return fromArrayView(value);
                  }
                  if (value == null) {
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
                  }
                  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
                    return fromArrayBuffer(value, encodingOrOffset, length);
                  }
                  if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
                    return fromArrayBuffer(value, encodingOrOffset, length);
                  }
                  if (typeof value === "number") {
                    throw new TypeError('The "value" argument must not be of type number. Received type number');
                  }
                  var valueOf = value.valueOf && value.valueOf();
                  if (valueOf != null && valueOf !== value) {
                    return Buffer.from(valueOf, encodingOrOffset, length);
                  }
                  var b = fromObject(value);
                  if (b)
                    return b;
                  if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
                    return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
                  }
                  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
                }
                Buffer.from = function(value, encodingOrOffset, length) {
                  return from(value, encodingOrOffset, length);
                };
                Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
                Object.setPrototypeOf(Buffer, Uint8Array);
                function assertSize(size) {
                  if (typeof size !== "number") {
                    throw new TypeError('"size" argument must be of type number');
                  } else if (size < 0) {
                    throw new RangeError('The value "' + size + '" is invalid for option "size"');
                  }
                }
                function alloc(size, fill, encoding) {
                  assertSize(size);
                  if (size <= 0) {
                    return createBuffer(size);
                  }
                  if (fill !== void 0) {
                    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
                  }
                  return createBuffer(size);
                }
                Buffer.alloc = function(size, fill, encoding) {
                  return alloc(size, fill, encoding);
                };
                function allocUnsafe(size) {
                  assertSize(size);
                  return createBuffer(size < 0 ? 0 : checked(size) | 0);
                }
                Buffer.allocUnsafe = function(size) {
                  return allocUnsafe(size);
                };
                Buffer.allocUnsafeSlow = function(size) {
                  return allocUnsafe(size);
                };
                function fromString(string, encoding) {
                  if (typeof encoding !== "string" || encoding === "") {
                    encoding = "utf8";
                  }
                  if (!Buffer.isEncoding(encoding)) {
                    throw new TypeError("Unknown encoding: " + encoding);
                  }
                  var length = byteLength(string, encoding) | 0;
                  var buf = createBuffer(length);
                  var actual = buf.write(string, encoding);
                  if (actual !== length) {
                    buf = buf.slice(0, actual);
                  }
                  return buf;
                }
                function fromArrayLike(array) {
                  var length = array.length < 0 ? 0 : checked(array.length) | 0;
                  var buf = createBuffer(length);
                  for (var i = 0; i < length; i += 1) {
                    buf[i] = array[i] & 255;
                  }
                  return buf;
                }
                function fromArrayView(arrayView) {
                  if (isInstance(arrayView, Uint8Array)) {
                    var copy = new Uint8Array(arrayView);
                    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
                  }
                  return fromArrayLike(arrayView);
                }
                function fromArrayBuffer(array, byteOffset, length) {
                  if (byteOffset < 0 || array.byteLength < byteOffset) {
                    throw new RangeError('"offset" is outside of buffer bounds');
                  }
                  if (array.byteLength < byteOffset + (length || 0)) {
                    throw new RangeError('"length" is outside of buffer bounds');
                  }
                  var buf;
                  if (byteOffset === void 0 && length === void 0) {
                    buf = new Uint8Array(array);
                  } else if (length === void 0) {
                    buf = new Uint8Array(array, byteOffset);
                  } else {
                    buf = new Uint8Array(array, byteOffset, length);
                  }
                  Object.setPrototypeOf(buf, Buffer.prototype);
                  return buf;
                }
                function fromObject(obj) {
                  if (Buffer.isBuffer(obj)) {
                    var len = checked(obj.length) | 0;
                    var buf = createBuffer(len);
                    if (buf.length === 0) {
                      return buf;
                    }
                    obj.copy(buf, 0, 0, len);
                    return buf;
                  }
                  if (obj.length !== void 0) {
                    if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                      return createBuffer(0);
                    }
                    return fromArrayLike(obj);
                  }
                  if (obj.type === "Buffer" && Array.isArray(obj.data)) {
                    return fromArrayLike(obj.data);
                  }
                }
                function checked(length) {
                  if (length >= K_MAX_LENGTH) {
                    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
                  }
                  return length | 0;
                }
                function SlowBuffer(length) {
                  if (+length != length) {
                    length = 0;
                  }
                  return Buffer.alloc(+length);
                }
                Buffer.isBuffer = function isBuffer(b) {
                  return b != null && b._isBuffer === true && b !== Buffer.prototype;
                };
                Buffer.compare = function compare(a, b) {
                  if (isInstance(a, Uint8Array))
                    a = Buffer.from(a, a.offset, a.byteLength);
                  if (isInstance(b, Uint8Array))
                    b = Buffer.from(b, b.offset, b.byteLength);
                  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                  }
                  if (a === b)
                    return 0;
                  var x = a.length;
                  var y = b.length;
                  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                    if (a[i] !== b[i]) {
                      x = a[i];
                      y = b[i];
                      break;
                    }
                  }
                  if (x < y)
                    return -1;
                  if (y < x)
                    return 1;
                  return 0;
                };
                Buffer.isEncoding = function isEncoding(encoding) {
                  switch (String(encoding).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return true;
                    default:
                      return false;
                  }
                };
                Buffer.concat = function concat(list, length) {
                  if (!Array.isArray(list)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                  }
                  if (list.length === 0) {
                    return Buffer.alloc(0);
                  }
                  var i;
                  if (length === void 0) {
                    length = 0;
                    for (i = 0; i < list.length; ++i) {
                      length += list[i].length;
                    }
                  }
                  var buffer = Buffer.allocUnsafe(length);
                  var pos = 0;
                  for (i = 0; i < list.length; ++i) {
                    var buf = list[i];
                    if (isInstance(buf, Uint8Array)) {
                      if (pos + buf.length > buffer.length) {
                        if (!Buffer.isBuffer(buf))
                          buf = Buffer.from(buf);
                        buf.copy(buffer, pos);
                      } else {
                        Uint8Array.prototype.set.call(buffer, buf, pos);
                      }
                    } else if (!Buffer.isBuffer(buf)) {
                      throw new TypeError('"list" argument must be an Array of Buffers');
                    } else {
                      buf.copy(buffer, pos);
                    }
                    pos += buf.length;
                  }
                  return buffer;
                };
                function byteLength(string, encoding) {
                  if (Buffer.isBuffer(string)) {
                    return string.length;
                  }
                  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
                    return string.byteLength;
                  }
                  if (typeof string !== "string") {
                    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
                  }
                  var len = string.length;
                  var mustMatch = arguments.length > 2 && arguments[2] === true;
                  if (!mustMatch && len === 0)
                    return 0;
                  var loweredCase = false;
                  for (; ; ) {
                    switch (encoding) {
                      case "ascii":
                      case "latin1":
                      case "binary":
                        return len;
                      case "utf8":
                      case "utf-8":
                        return utf8ToBytes(string).length;
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return len * 2;
                      case "hex":
                        return len >>> 1;
                      case "base64":
                        return base64ToBytes(string).length;
                      default:
                        if (loweredCase) {
                          return mustMatch ? -1 : utf8ToBytes(string).length;
                        }
                        encoding = ("" + encoding).toLowerCase();
                        loweredCase = true;
                    }
                  }
                }
                Buffer.byteLength = byteLength;
                function slowToString(encoding, start, end) {
                  var loweredCase = false;
                  if (start === void 0 || start < 0) {
                    start = 0;
                  }
                  if (start > this.length) {
                    return "";
                  }
                  if (end === void 0 || end > this.length) {
                    end = this.length;
                  }
                  if (end <= 0) {
                    return "";
                  }
                  end >>>= 0;
                  start >>>= 0;
                  if (end <= start) {
                    return "";
                  }
                  if (!encoding)
                    encoding = "utf8";
                  while (true) {
                    switch (encoding) {
                      case "hex":
                        return hexSlice(this, start, end);
                      case "utf8":
                      case "utf-8":
                        return utf8Slice(this, start, end);
                      case "ascii":
                        return asciiSlice(this, start, end);
                      case "latin1":
                      case "binary":
                        return latin1Slice(this, start, end);
                      case "base64":
                        return base64Slice(this, start, end);
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return utf16leSlice(this, start, end);
                      default:
                        if (loweredCase)
                          throw new TypeError("Unknown encoding: " + encoding);
                        encoding = (encoding + "").toLowerCase();
                        loweredCase = true;
                    }
                  }
                }
                Buffer.prototype._isBuffer = true;
                function swap(b, n, m) {
                  var i = b[n];
                  b[n] = b[m];
                  b[m] = i;
                }
                Buffer.prototype.swap16 = function swap16() {
                  var len = this.length;
                  if (len % 2 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                  }
                  for (var i = 0; i < len; i += 2) {
                    swap(this, i, i + 1);
                  }
                  return this;
                };
                Buffer.prototype.swap32 = function swap32() {
                  var len = this.length;
                  if (len % 4 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                  }
                  for (var i = 0; i < len; i += 4) {
                    swap(this, i, i + 3);
                    swap(this, i + 1, i + 2);
                  }
                  return this;
                };
                Buffer.prototype.swap64 = function swap64() {
                  var len = this.length;
                  if (len % 8 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                  }
                  for (var i = 0; i < len; i += 8) {
                    swap(this, i, i + 7);
                    swap(this, i + 1, i + 6);
                    swap(this, i + 2, i + 5);
                    swap(this, i + 3, i + 4);
                  }
                  return this;
                };
                Buffer.prototype.toString = function toString() {
                  var length = this.length;
                  if (length === 0)
                    return "";
                  if (arguments.length === 0)
                    return utf8Slice(this, 0, length);
                  return slowToString.apply(this, arguments);
                };
                Buffer.prototype.toLocaleString = Buffer.prototype.toString;
                Buffer.prototype.equals = function equals(b) {
                  if (!Buffer.isBuffer(b))
                    throw new TypeError("Argument must be a Buffer");
                  if (this === b)
                    return true;
                  return Buffer.compare(this, b) === 0;
                };
                Buffer.prototype.inspect = function inspect() {
                  var str = "";
                  var max = exports2.INSPECT_MAX_BYTES;
                  str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
                  if (this.length > max)
                    str += " ... ";
                  return "<Buffer " + str + ">";
                };
                if (customInspectSymbol) {
                  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
                }
                Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
                  if (isInstance(target, Uint8Array)) {
                    target = Buffer.from(target, target.offset, target.byteLength);
                  }
                  if (!Buffer.isBuffer(target)) {
                    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
                  }
                  if (start === void 0) {
                    start = 0;
                  }
                  if (end === void 0) {
                    end = target ? target.length : 0;
                  }
                  if (thisStart === void 0) {
                    thisStart = 0;
                  }
                  if (thisEnd === void 0) {
                    thisEnd = this.length;
                  }
                  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                    throw new RangeError("out of range index");
                  }
                  if (thisStart >= thisEnd && start >= end) {
                    return 0;
                  }
                  if (thisStart >= thisEnd) {
                    return -1;
                  }
                  if (start >= end) {
                    return 1;
                  }
                  start >>>= 0;
                  end >>>= 0;
                  thisStart >>>= 0;
                  thisEnd >>>= 0;
                  if (this === target)
                    return 0;
                  var x = thisEnd - thisStart;
                  var y = end - start;
                  var len = Math.min(x, y);
                  var thisCopy = this.slice(thisStart, thisEnd);
                  var targetCopy = target.slice(start, end);
                  for (var i = 0; i < len; ++i) {
                    if (thisCopy[i] !== targetCopy[i]) {
                      x = thisCopy[i];
                      y = targetCopy[i];
                      break;
                    }
                  }
                  if (x < y)
                    return -1;
                  if (y < x)
                    return 1;
                  return 0;
                };
                function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                  if (buffer.length === 0)
                    return -1;
                  if (typeof byteOffset === "string") {
                    encoding = byteOffset;
                    byteOffset = 0;
                  } else if (byteOffset > 2147483647) {
                    byteOffset = 2147483647;
                  } else if (byteOffset < -2147483648) {
                    byteOffset = -2147483648;
                  }
                  byteOffset = +byteOffset;
                  if (numberIsNaN(byteOffset)) {
                    byteOffset = dir ? 0 : buffer.length - 1;
                  }
                  if (byteOffset < 0)
                    byteOffset = buffer.length + byteOffset;
                  if (byteOffset >= buffer.length) {
                    if (dir)
                      return -1;
                    else
                      byteOffset = buffer.length - 1;
                  } else if (byteOffset < 0) {
                    if (dir)
                      byteOffset = 0;
                    else
                      return -1;
                  }
                  if (typeof val === "string") {
                    val = Buffer.from(val, encoding);
                  }
                  if (Buffer.isBuffer(val)) {
                    if (val.length === 0) {
                      return -1;
                    }
                    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                  } else if (typeof val === "number") {
                    val = val & 255;
                    if (typeof Uint8Array.prototype.indexOf === "function") {
                      if (dir) {
                        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                      } else {
                        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                      }
                    }
                    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
                  }
                  throw new TypeError("val must be string, number or Buffer");
                }
                function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                  var indexSize = 1;
                  var arrLength = arr.length;
                  var valLength = val.length;
                  if (encoding !== void 0) {
                    encoding = String(encoding).toLowerCase();
                    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                      if (arr.length < 2 || val.length < 2) {
                        return -1;
                      }
                      indexSize = 2;
                      arrLength /= 2;
                      valLength /= 2;
                      byteOffset /= 2;
                    }
                  }
                  function read(buf, i2) {
                    if (indexSize === 1) {
                      return buf[i2];
                    } else {
                      return buf.readUInt16BE(i2 * indexSize);
                    }
                  }
                  var i;
                  if (dir) {
                    var foundIndex = -1;
                    for (i = byteOffset; i < arrLength; i++) {
                      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                        if (foundIndex === -1)
                          foundIndex = i;
                        if (i - foundIndex + 1 === valLength)
                          return foundIndex * indexSize;
                      } else {
                        if (foundIndex !== -1)
                          i -= i - foundIndex;
                        foundIndex = -1;
                      }
                    }
                  } else {
                    if (byteOffset + valLength > arrLength)
                      byteOffset = arrLength - valLength;
                    for (i = byteOffset; i >= 0; i--) {
                      var found = true;
                      for (var j = 0; j < valLength; j++) {
                        if (read(arr, i + j) !== read(val, j)) {
                          found = false;
                          break;
                        }
                      }
                      if (found)
                        return i;
                    }
                  }
                  return -1;
                }
                Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
                  return this.indexOf(val, byteOffset, encoding) !== -1;
                };
                Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
                  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
                };
                Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
                  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
                };
                function hexWrite(buf, string, offset, length) {
                  offset = Number(offset) || 0;
                  var remaining = buf.length - offset;
                  if (!length) {
                    length = remaining;
                  } else {
                    length = Number(length);
                    if (length > remaining) {
                      length = remaining;
                    }
                  }
                  var strLen = string.length;
                  if (length > strLen / 2) {
                    length = strLen / 2;
                  }
                  var i;
                  for (i = 0; i < length; ++i) {
                    var parsed = parseInt(string.substr(i * 2, 2), 16);
                    if (numberIsNaN(parsed))
                      return i;
                    buf[offset + i] = parsed;
                  }
                  return i;
                }
                function utf8Write(buf, string, offset, length) {
                  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
                }
                function asciiWrite(buf, string, offset, length) {
                  return blitBuffer(asciiToBytes(string), buf, offset, length);
                }
                function base64Write(buf, string, offset, length) {
                  return blitBuffer(base64ToBytes(string), buf, offset, length);
                }
                function ucs2Write(buf, string, offset, length) {
                  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
                }
                Buffer.prototype.write = function write(string, offset, length, encoding) {
                  if (offset === void 0) {
                    encoding = "utf8";
                    length = this.length;
                    offset = 0;
                  } else if (length === void 0 && typeof offset === "string") {
                    encoding = offset;
                    length = this.length;
                    offset = 0;
                  } else if (isFinite(offset)) {
                    offset = offset >>> 0;
                    if (isFinite(length)) {
                      length = length >>> 0;
                      if (encoding === void 0)
                        encoding = "utf8";
                    } else {
                      encoding = length;
                      length = void 0;
                    }
                  } else {
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                  }
                  var remaining = this.length - offset;
                  if (length === void 0 || length > remaining)
                    length = remaining;
                  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
                    throw new RangeError("Attempt to write outside buffer bounds");
                  }
                  if (!encoding)
                    encoding = "utf8";
                  var loweredCase = false;
                  for (; ; ) {
                    switch (encoding) {
                      case "hex":
                        return hexWrite(this, string, offset, length);
                      case "utf8":
                      case "utf-8":
                        return utf8Write(this, string, offset, length);
                      case "ascii":
                      case "latin1":
                      case "binary":
                        return asciiWrite(this, string, offset, length);
                      case "base64":
                        return base64Write(this, string, offset, length);
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return ucs2Write(this, string, offset, length);
                      default:
                        if (loweredCase)
                          throw new TypeError("Unknown encoding: " + encoding);
                        encoding = ("" + encoding).toLowerCase();
                        loweredCase = true;
                    }
                  }
                };
                Buffer.prototype.toJSON = function toJSON() {
                  return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                  };
                };
                function base64Slice(buf, start, end) {
                  if (start === 0 && end === buf.length) {
                    return base64.fromByteArray(buf);
                  } else {
                    return base64.fromByteArray(buf.slice(start, end));
                  }
                }
                function utf8Slice(buf, start, end) {
                  end = Math.min(buf.length, end);
                  var res = [];
                  var i = start;
                  while (i < end) {
                    var firstByte = buf[i];
                    var codePoint = null;
                    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                    if (i + bytesPerSequence <= end) {
                      var secondByte = void 0, thirdByte = void 0, fourthByte = void 0, tempCodePoint = void 0;
                      switch (bytesPerSequence) {
                        case 1:
                          if (firstByte < 128) {
                            codePoint = firstByte;
                          }
                          break;
                        case 2:
                          secondByte = buf[i + 1];
                          if ((secondByte & 192) === 128) {
                            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                            if (tempCodePoint > 127) {
                              codePoint = tempCodePoint;
                            }
                          }
                          break;
                        case 3:
                          secondByte = buf[i + 1];
                          thirdByte = buf[i + 2];
                          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                              codePoint = tempCodePoint;
                            }
                          }
                          break;
                        case 4:
                          secondByte = buf[i + 1];
                          thirdByte = buf[i + 2];
                          fourthByte = buf[i + 3];
                          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                              codePoint = tempCodePoint;
                            }
                          }
                      }
                    }
                    if (codePoint === null) {
                      codePoint = 65533;
                      bytesPerSequence = 1;
                    } else if (codePoint > 65535) {
                      codePoint -= 65536;
                      res.push(codePoint >>> 10 & 1023 | 55296);
                      codePoint = 56320 | codePoint & 1023;
                    }
                    res.push(codePoint);
                    i += bytesPerSequence;
                  }
                  return decodeCodePointsArray(res);
                }
                var MAX_ARGUMENTS_LENGTH = 4096;
                function decodeCodePointsArray(codePoints) {
                  var len = codePoints.length;
                  if (len <= MAX_ARGUMENTS_LENGTH) {
                    return String.fromCharCode.apply(String, codePoints);
                  }
                  var res = "";
                  var i = 0;
                  while (i < len) {
                    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
                  }
                  return res;
                }
                function asciiSlice(buf, start, end) {
                  var ret = "";
                  end = Math.min(buf.length, end);
                  for (var i = start; i < end; ++i) {
                    ret += String.fromCharCode(buf[i] & 127);
                  }
                  return ret;
                }
                function latin1Slice(buf, start, end) {
                  var ret = "";
                  end = Math.min(buf.length, end);
                  for (var i = start; i < end; ++i) {
                    ret += String.fromCharCode(buf[i]);
                  }
                  return ret;
                }
                function hexSlice(buf, start, end) {
                  var len = buf.length;
                  if (!start || start < 0)
                    start = 0;
                  if (!end || end < 0 || end > len)
                    end = len;
                  var out = "";
                  for (var i = start; i < end; ++i) {
                    out += hexSliceLookupTable[buf[i]];
                  }
                  return out;
                }
                function utf16leSlice(buf, start, end) {
                  var bytes = buf.slice(start, end);
                  var res = "";
                  for (var i = 0; i < bytes.length - 1; i += 2) {
                    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
                  }
                  return res;
                }
                Buffer.prototype.slice = function slice(start, end) {
                  var len = this.length;
                  start = ~~start;
                  end = end === void 0 ? len : ~~end;
                  if (start < 0) {
                    start += len;
                    if (start < 0)
                      start = 0;
                  } else if (start > len) {
                    start = len;
                  }
                  if (end < 0) {
                    end += len;
                    if (end < 0)
                      end = 0;
                  } else if (end > len) {
                    end = len;
                  }
                  if (end < start)
                    end = start;
                  var newBuf = this.subarray(start, end);
                  Object.setPrototypeOf(newBuf, Buffer.prototype);
                  return newBuf;
                };
                function checkOffset(offset, ext, length) {
                  if (offset % 1 !== 0 || offset < 0)
                    throw new RangeError("offset is not uint");
                  if (offset + ext > length)
                    throw new RangeError("Trying to access beyond buffer length");
                }
                Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
                  offset = offset >>> 0;
                  byteLength2 = byteLength2 >>> 0;
                  if (!noAssert)
                    checkOffset(offset, byteLength2, this.length);
                  var val = this[offset];
                  var mul = 1;
                  var i = 0;
                  while (++i < byteLength2 && (mul *= 256)) {
                    val += this[offset + i] * mul;
                  }
                  return val;
                };
                Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
                  offset = offset >>> 0;
                  byteLength2 = byteLength2 >>> 0;
                  if (!noAssert) {
                    checkOffset(offset, byteLength2, this.length);
                  }
                  var val = this[offset + --byteLength2];
                  var mul = 1;
                  while (byteLength2 > 0 && (mul *= 256)) {
                    val += this[offset + --byteLength2] * mul;
                  }
                  return val;
                };
                Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 1, this.length);
                  return this[offset];
                };
                Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 2, this.length);
                  return this[offset] | this[offset + 1] << 8;
                };
                Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 2, this.length);
                  return this[offset] << 8 | this[offset + 1];
                };
                Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 4, this.length);
                  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
                };
                Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 4, this.length);
                  return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
                };
                Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
                  offset = offset >>> 0;
                  validateNumber(offset, "offset");
                  var first = this[offset];
                  var last = this[offset + 7];
                  if (first === void 0 || last === void 0) {
                    boundsError(offset, this.length - 8);
                  }
                  var lo = first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24);
                  var hi = this[++offset] + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + last * Math.pow(2, 24);
                  return BigInt(lo) + (BigInt(hi) << BigInt(32));
                });
                Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
                  offset = offset >>> 0;
                  validateNumber(offset, "offset");
                  var first = this[offset];
                  var last = this[offset + 7];
                  if (first === void 0 || last === void 0) {
                    boundsError(offset, this.length - 8);
                  }
                  var hi = first * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
                  var lo = this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last;
                  return (BigInt(hi) << BigInt(32)) + BigInt(lo);
                });
                Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
                  offset = offset >>> 0;
                  byteLength2 = byteLength2 >>> 0;
                  if (!noAssert)
                    checkOffset(offset, byteLength2, this.length);
                  var val = this[offset];
                  var mul = 1;
                  var i = 0;
                  while (++i < byteLength2 && (mul *= 256)) {
                    val += this[offset + i] * mul;
                  }
                  mul *= 128;
                  if (val >= mul)
                    val -= Math.pow(2, 8 * byteLength2);
                  return val;
                };
                Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
                  offset = offset >>> 0;
                  byteLength2 = byteLength2 >>> 0;
                  if (!noAssert)
                    checkOffset(offset, byteLength2, this.length);
                  var i = byteLength2;
                  var mul = 1;
                  var val = this[offset + --i];
                  while (i > 0 && (mul *= 256)) {
                    val += this[offset + --i] * mul;
                  }
                  mul *= 128;
                  if (val >= mul)
                    val -= Math.pow(2, 8 * byteLength2);
                  return val;
                };
                Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 1, this.length);
                  if (!(this[offset] & 128))
                    return this[offset];
                  return (255 - this[offset] + 1) * -1;
                };
                Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 2, this.length);
                  var val = this[offset] | this[offset + 1] << 8;
                  return val & 32768 ? val | 4294901760 : val;
                };
                Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 2, this.length);
                  var val = this[offset + 1] | this[offset] << 8;
                  return val & 32768 ? val | 4294901760 : val;
                };
                Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 4, this.length);
                  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
                };
                Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 4, this.length);
                  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
                };
                Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
                  offset = offset >>> 0;
                  validateNumber(offset, "offset");
                  var first = this[offset];
                  var last = this[offset + 7];
                  if (first === void 0 || last === void 0) {
                    boundsError(offset, this.length - 8);
                  }
                  var val = this[offset + 4] + this[offset + 5] * Math.pow(2, 8) + this[offset + 6] * Math.pow(2, 16) + (last << 24);
                  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24));
                });
                Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
                  offset = offset >>> 0;
                  validateNumber(offset, "offset");
                  var first = this[offset];
                  var last = this[offset + 7];
                  if (first === void 0 || last === void 0) {
                    boundsError(offset, this.length - 8);
                  }
                  var val = (first << 24) + // Overflow
                  this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
                  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last);
                });
                Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 4, this.length);
                  return ieee754.read(this, offset, true, 23, 4);
                };
                Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 4, this.length);
                  return ieee754.read(this, offset, false, 23, 4);
                };
                Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 8, this.length);
                  return ieee754.read(this, offset, true, 52, 8);
                };
                Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 8, this.length);
                  return ieee754.read(this, offset, false, 52, 8);
                };
                function checkInt(buf, value, offset, ext, max, min) {
                  if (!Buffer.isBuffer(buf))
                    throw new TypeError('"buffer" argument must be a Buffer instance');
                  if (value > max || value < min)
                    throw new RangeError('"value" argument is out of bounds');
                  if (offset + ext > buf.length)
                    throw new RangeError("Index out of range");
                }
                Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  byteLength2 = byteLength2 >>> 0;
                  if (!noAssert) {
                    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                    checkInt(this, value, offset, byteLength2, maxBytes, 0);
                  }
                  var mul = 1;
                  var i = 0;
                  this[offset] = value & 255;
                  while (++i < byteLength2 && (mul *= 256)) {
                    this[offset + i] = value / mul & 255;
                  }
                  return offset + byteLength2;
                };
                Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  byteLength2 = byteLength2 >>> 0;
                  if (!noAssert) {
                    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                    checkInt(this, value, offset, byteLength2, maxBytes, 0);
                  }
                  var i = byteLength2 - 1;
                  var mul = 1;
                  this[offset + i] = value & 255;
                  while (--i >= 0 && (mul *= 256)) {
                    this[offset + i] = value / mul & 255;
                  }
                  return offset + byteLength2;
                };
                Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 1, 255, 0);
                  this[offset] = value & 255;
                  return offset + 1;
                };
                Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 2, 65535, 0);
                  this[offset] = value & 255;
                  this[offset + 1] = value >>> 8;
                  return offset + 2;
                };
                Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 2, 65535, 0);
                  this[offset] = value >>> 8;
                  this[offset + 1] = value & 255;
                  return offset + 2;
                };
                Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 4, 4294967295, 0);
                  this[offset + 3] = value >>> 24;
                  this[offset + 2] = value >>> 16;
                  this[offset + 1] = value >>> 8;
                  this[offset] = value & 255;
                  return offset + 4;
                };
                Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 4, 4294967295, 0);
                  this[offset] = value >>> 24;
                  this[offset + 1] = value >>> 16;
                  this[offset + 2] = value >>> 8;
                  this[offset + 3] = value & 255;
                  return offset + 4;
                };
                function wrtBigUInt64LE(buf, value, offset, min, max) {
                  checkIntBI(value, min, max, buf, offset, 7);
                  var lo = Number(value & BigInt(4294967295));
                  buf[offset++] = lo;
                  lo = lo >> 8;
                  buf[offset++] = lo;
                  lo = lo >> 8;
                  buf[offset++] = lo;
                  lo = lo >> 8;
                  buf[offset++] = lo;
                  var hi = Number(value >> BigInt(32) & BigInt(4294967295));
                  buf[offset++] = hi;
                  hi = hi >> 8;
                  buf[offset++] = hi;
                  hi = hi >> 8;
                  buf[offset++] = hi;
                  hi = hi >> 8;
                  buf[offset++] = hi;
                  return offset;
                }
                function wrtBigUInt64BE(buf, value, offset, min, max) {
                  checkIntBI(value, min, max, buf, offset, 7);
                  var lo = Number(value & BigInt(4294967295));
                  buf[offset + 7] = lo;
                  lo = lo >> 8;
                  buf[offset + 6] = lo;
                  lo = lo >> 8;
                  buf[offset + 5] = lo;
                  lo = lo >> 8;
                  buf[offset + 4] = lo;
                  var hi = Number(value >> BigInt(32) & BigInt(4294967295));
                  buf[offset + 3] = hi;
                  hi = hi >> 8;
                  buf[offset + 2] = hi;
                  hi = hi >> 8;
                  buf[offset + 1] = hi;
                  hi = hi >> 8;
                  buf[offset] = hi;
                  return offset + 8;
                }
                Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset) {
                  if (offset === void 0) {
                    offset = 0;
                  }
                  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
                });
                Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset) {
                  if (offset === void 0) {
                    offset = 0;
                  }
                  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
                });
                Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert) {
                    var limit = Math.pow(2, 8 * byteLength2 - 1);
                    checkInt(this, value, offset, byteLength2, limit - 1, -limit);
                  }
                  var i = 0;
                  var mul = 1;
                  var sub = 0;
                  this[offset] = value & 255;
                  while (++i < byteLength2 && (mul *= 256)) {
                    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                      sub = 1;
                    }
                    this[offset + i] = (value / mul >> 0) - sub & 255;
                  }
                  return offset + byteLength2;
                };
                Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert) {
                    var limit = Math.pow(2, 8 * byteLength2 - 1);
                    checkInt(this, value, offset, byteLength2, limit - 1, -limit);
                  }
                  var i = byteLength2 - 1;
                  var mul = 1;
                  var sub = 0;
                  this[offset + i] = value & 255;
                  while (--i >= 0 && (mul *= 256)) {
                    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                      sub = 1;
                    }
                    this[offset + i] = (value / mul >> 0) - sub & 255;
                  }
                  return offset + byteLength2;
                };
                Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 1, 127, -128);
                  if (value < 0)
                    value = 255 + value + 1;
                  this[offset] = value & 255;
                  return offset + 1;
                };
                Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 2, 32767, -32768);
                  this[offset] = value & 255;
                  this[offset + 1] = value >>> 8;
                  return offset + 2;
                };
                Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 2, 32767, -32768);
                  this[offset] = value >>> 8;
                  this[offset + 1] = value & 255;
                  return offset + 2;
                };
                Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 4, 2147483647, -2147483648);
                  this[offset] = value & 255;
                  this[offset + 1] = value >>> 8;
                  this[offset + 2] = value >>> 16;
                  this[offset + 3] = value >>> 24;
                  return offset + 4;
                };
                Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 4, 2147483647, -2147483648);
                  if (value < 0)
                    value = 4294967295 + value + 1;
                  this[offset] = value >>> 24;
                  this[offset + 1] = value >>> 16;
                  this[offset + 2] = value >>> 8;
                  this[offset + 3] = value & 255;
                  return offset + 4;
                };
                Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset) {
                  if (offset === void 0) {
                    offset = 0;
                  }
                  return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
                });
                Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset) {
                  if (offset === void 0) {
                    offset = 0;
                  }
                  return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
                });
                function checkIEEE754(buf, value, offset, ext, max, min) {
                  if (offset + ext > buf.length)
                    throw new RangeError("Index out of range");
                  if (offset < 0)
                    throw new RangeError("Index out of range");
                }
                function writeFloat(buf, value, offset, littleEndian, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert) {
                    checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
                  }
                  ieee754.write(buf, value, offset, littleEndian, 23, 4);
                  return offset + 4;
                }
                Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                  return writeFloat(this, value, offset, true, noAssert);
                };
                Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                  return writeFloat(this, value, offset, false, noAssert);
                };
                function writeDouble(buf, value, offset, littleEndian, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert) {
                    checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
                  }
                  ieee754.write(buf, value, offset, littleEndian, 52, 8);
                  return offset + 8;
                }
                Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                  return writeDouble(this, value, offset, true, noAssert);
                };
                Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                  return writeDouble(this, value, offset, false, noAssert);
                };
                Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                  if (!Buffer.isBuffer(target))
                    throw new TypeError("argument should be a Buffer");
                  if (!start)
                    start = 0;
                  if (!end && end !== 0)
                    end = this.length;
                  if (targetStart >= target.length)
                    targetStart = target.length;
                  if (!targetStart)
                    targetStart = 0;
                  if (end > 0 && end < start)
                    end = start;
                  if (end === start)
                    return 0;
                  if (target.length === 0 || this.length === 0)
                    return 0;
                  if (targetStart < 0) {
                    throw new RangeError("targetStart out of bounds");
                  }
                  if (start < 0 || start >= this.length)
                    throw new RangeError("Index out of range");
                  if (end < 0)
                    throw new RangeError("sourceEnd out of bounds");
                  if (end > this.length)
                    end = this.length;
                  if (target.length - targetStart < end - start) {
                    end = target.length - targetStart + start;
                  }
                  var len = end - start;
                  if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
                    this.copyWithin(targetStart, start, end);
                  } else {
                    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
                  }
                  return len;
                };
                Buffer.prototype.fill = function fill(val, start, end, encoding) {
                  if (typeof val === "string") {
                    if (typeof start === "string") {
                      encoding = start;
                      start = 0;
                      end = this.length;
                    } else if (typeof end === "string") {
                      encoding = end;
                      end = this.length;
                    }
                    if (encoding !== void 0 && typeof encoding !== "string") {
                      throw new TypeError("encoding must be a string");
                    }
                    if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
                      throw new TypeError("Unknown encoding: " + encoding);
                    }
                    if (val.length === 1) {
                      var code = val.charCodeAt(0);
                      if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                        val = code;
                      }
                    }
                  } else if (typeof val === "number") {
                    val = val & 255;
                  } else if (typeof val === "boolean") {
                    val = Number(val);
                  }
                  if (start < 0 || this.length < start || this.length < end) {
                    throw new RangeError("Out of range index");
                  }
                  if (end <= start) {
                    return this;
                  }
                  start = start >>> 0;
                  end = end === void 0 ? this.length : end >>> 0;
                  if (!val)
                    val = 0;
                  var i;
                  if (typeof val === "number") {
                    for (i = start; i < end; ++i) {
                      this[i] = val;
                    }
                  } else {
                    var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
                    var len = bytes.length;
                    if (len === 0) {
                      throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                    }
                    for (i = 0; i < end - start; ++i) {
                      this[i + start] = bytes[i % len];
                    }
                  }
                  return this;
                };
                var errors = {};
                function E(sym, getMessage, Base) {
                  errors[sym] = function(_Base) {
                    _inheritsLoose(NodeError, _Base);
                    function NodeError() {
                      var _this;
                      _this = _Base.call(this) || this;
                      Object.defineProperty(_assertThisInitialized(_this), "message", {
                        value: getMessage.apply(_assertThisInitialized(_this), arguments),
                        writable: true,
                        configurable: true
                      });
                      _this.name = _this.name + " [" + sym + "]";
                      _this.stack;
                      delete _this.name;
                      return _this;
                    }
                    var _proto = NodeError.prototype;
                    _proto.toString = function toString() {
                      return this.name + " [" + sym + "]: " + this.message;
                    };
                    _createClass(NodeError, [{
                      key: "code",
                      get: function get() {
                        return sym;
                      },
                      set: function set(value) {
                        Object.defineProperty(this, "code", {
                          configurable: true,
                          enumerable: true,
                          value,
                          writable: true
                        });
                      }
                    }]);
                    return NodeError;
                  }(Base);
                }
                E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
                  if (name) {
                    return name + " is outside of buffer bounds";
                  }
                  return "Attempt to access memory outside buffer bounds";
                }, RangeError);
                E("ERR_INVALID_ARG_TYPE", function(name, actual) {
                  return 'The "' + name + '" argument must be of type number. Received type ' + typeof actual;
                }, TypeError);
                E("ERR_OUT_OF_RANGE", function(str, range, input) {
                  var msg = 'The value of "' + str + '" is out of range.';
                  var received = input;
                  if (Number.isInteger(input) && Math.abs(input) > Math.pow(2, 32)) {
                    received = addNumericalSeparator(String(input));
                  } else if (typeof input === "bigint") {
                    received = String(input);
                    if (input > Math.pow(BigInt(2), BigInt(32)) || input < -Math.pow(BigInt(2), BigInt(32))) {
                      received = addNumericalSeparator(received);
                    }
                    received += "n";
                  }
                  msg += " It must be " + range + ". Received " + received;
                  return msg;
                }, RangeError);
                function addNumericalSeparator(val) {
                  var res = "";
                  var i = val.length;
                  var start = val[0] === "-" ? 1 : 0;
                  for (; i >= start + 4; i -= 3) {
                    res = "_" + val.slice(i - 3, i) + res;
                  }
                  return "" + val.slice(0, i) + res;
                }
                function checkBounds(buf, offset, byteLength2) {
                  validateNumber(offset, "offset");
                  if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
                    boundsError(offset, buf.length - (byteLength2 + 1));
                  }
                }
                function checkIntBI(value, min, max, buf, offset, byteLength2) {
                  if (value > max || value < min) {
                    var n = typeof min === "bigint" ? "n" : "";
                    var range;
                    if (byteLength2 > 3) {
                      if (min === 0 || min === BigInt(0)) {
                        range = ">= 0" + n + " and < 2" + n + " ** " + (byteLength2 + 1) * 8 + n;
                      } else {
                        range = ">= -(2" + n + " ** " + ((byteLength2 + 1) * 8 - 1) + n + ") and < 2 ** " + ("" + ((byteLength2 + 1) * 8 - 1) + n);
                      }
                    } else {
                      range = ">= " + min + n + " and <= " + max + n;
                    }
                    throw new errors.ERR_OUT_OF_RANGE("value", range, value);
                  }
                  checkBounds(buf, offset, byteLength2);
                }
                function validateNumber(value, name) {
                  if (typeof value !== "number") {
                    throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
                  }
                }
                function boundsError(value, length, type) {
                  if (Math.floor(value) !== value) {
                    validateNumber(value, type);
                    throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
                  }
                  if (length < 0) {
                    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
                  }
                  throw new errors.ERR_OUT_OF_RANGE(type || "offset", ">= " + (type ? 1 : 0) + " and <= " + length, value);
                }
                var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
                function base64clean(str) {
                  str = str.split("=")[0];
                  str = str.trim().replace(INVALID_BASE64_RE, "");
                  if (str.length < 2)
                    return "";
                  while (str.length % 4 !== 0) {
                    str = str + "=";
                  }
                  return str;
                }
                function utf8ToBytes(string, units) {
                  units = units || Infinity;
                  var codePoint;
                  var length = string.length;
                  var leadSurrogate = null;
                  var bytes = [];
                  for (var i = 0; i < length; ++i) {
                    codePoint = string.charCodeAt(i);
                    if (codePoint > 55295 && codePoint < 57344) {
                      if (!leadSurrogate) {
                        if (codePoint > 56319) {
                          if ((units -= 3) > -1)
                            bytes.push(239, 191, 189);
                          continue;
                        } else if (i + 1 === length) {
                          if ((units -= 3) > -1)
                            bytes.push(239, 191, 189);
                          continue;
                        }
                        leadSurrogate = codePoint;
                        continue;
                      }
                      if (codePoint < 56320) {
                        if ((units -= 3) > -1)
                          bytes.push(239, 191, 189);
                        leadSurrogate = codePoint;
                        continue;
                      }
                      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                    } else if (leadSurrogate) {
                      if ((units -= 3) > -1)
                        bytes.push(239, 191, 189);
                    }
                    leadSurrogate = null;
                    if (codePoint < 128) {
                      if ((units -= 1) < 0)
                        break;
                      bytes.push(codePoint);
                    } else if (codePoint < 2048) {
                      if ((units -= 2) < 0)
                        break;
                      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
                    } else if (codePoint < 65536) {
                      if ((units -= 3) < 0)
                        break;
                      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                    } else if (codePoint < 1114112) {
                      if ((units -= 4) < 0)
                        break;
                      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                    } else {
                      throw new Error("Invalid code point");
                    }
                  }
                  return bytes;
                }
                function asciiToBytes(str) {
                  var byteArray = [];
                  for (var i = 0; i < str.length; ++i) {
                    byteArray.push(str.charCodeAt(i) & 255);
                  }
                  return byteArray;
                }
                function utf16leToBytes(str, units) {
                  var c, hi, lo;
                  var byteArray = [];
                  for (var i = 0; i < str.length; ++i) {
                    if ((units -= 2) < 0)
                      break;
                    c = str.charCodeAt(i);
                    hi = c >> 8;
                    lo = c % 256;
                    byteArray.push(lo);
                    byteArray.push(hi);
                  }
                  return byteArray;
                }
                function base64ToBytes(str) {
                  return base64.toByteArray(base64clean(str));
                }
                function blitBuffer(src, dst, offset, length) {
                  var i;
                  for (i = 0; i < length; ++i) {
                    if (i + offset >= dst.length || i >= src.length)
                      break;
                    dst[i + offset] = src[i];
                  }
                  return i;
                }
                function isInstance(obj, type) {
                  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
                }
                function numberIsNaN(obj) {
                  return obj !== obj;
                }
                var hexSliceLookupTable = function() {
                  var alphabet = "0123456789abcdef";
                  var table = new Array(256);
                  for (var i = 0; i < 16; ++i) {
                    var i16 = i * 16;
                    for (var j = 0; j < 16; ++j) {
                      table[i16 + j] = alphabet[i] + alphabet[j];
                    }
                  }
                  return table;
                }();
                function defineBigIntMethod(fn) {
                  return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
                }
                function BufferBigIntNotDefined() {
                  throw new Error("BigInt not supported");
                }
              }
            ),
            /***/
            477: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                __webpack_require__2(7803);
                __webpack_require__2(1539);
                module2.exports = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
              }
            ),
            /***/
            2094: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var NATIVE_ARRAY_BUFFER = __webpack_require__2(477);
                var DESCRIPTORS = __webpack_require__2(9781);
                var global = __webpack_require__2(7854);
                var isCallable = __webpack_require__2(614);
                var isObject = __webpack_require__2(111);
                var hasOwn = __webpack_require__2(2597);
                var classof = __webpack_require__2(648);
                var tryToString = __webpack_require__2(6330);
                var createNonEnumerableProperty = __webpack_require__2(8880);
                var redefine = __webpack_require__2(1320);
                var defineProperty = __webpack_require__2(3070).f;
                var isPrototypeOf = __webpack_require__2(7976);
                var getPrototypeOf = __webpack_require__2(9518);
                var setPrototypeOf = __webpack_require__2(7674);
                var wellKnownSymbol = __webpack_require__2(5112);
                var uid = __webpack_require__2(9711);
                var Int8Array2 = global.Int8Array;
                var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
                var Uint8ClampedArray2 = global.Uint8ClampedArray;
                var Uint8ClampedArrayPrototype = Uint8ClampedArray2 && Uint8ClampedArray2.prototype;
                var TypedArray = Int8Array2 && getPrototypeOf(Int8Array2);
                var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
                var ObjectPrototype = Object.prototype;
                var TypeError2 = global.TypeError;
                var TO_STRING_TAG = wellKnownSymbol("toStringTag");
                var TYPED_ARRAY_TAG = uid("TYPED_ARRAY_TAG");
                var TYPED_ARRAY_CONSTRUCTOR = uid("TYPED_ARRAY_CONSTRUCTOR");
                var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== "Opera";
                var TYPED_ARRAY_TAG_REQIRED = false;
                var NAME, Constructor, Prototype;
                var TypedArrayConstructorsList = {
                  Int8Array: 1,
                  Uint8Array: 1,
                  Uint8ClampedArray: 1,
                  Int16Array: 2,
                  Uint16Array: 2,
                  Int32Array: 4,
                  Uint32Array: 4,
                  Float32Array: 4,
                  Float64Array: 8
                };
                var BigIntArrayConstructorsList = {
                  BigInt64Array: 8,
                  BigUint64Array: 8
                };
                var isView = function isView2(it) {
                  if (!isObject(it))
                    return false;
                  var klass = classof(it);
                  return klass === "DataView" || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
                };
                var isTypedArray = function isTypedArray2(it) {
                  if (!isObject(it))
                    return false;
                  var klass = classof(it);
                  return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
                };
                var aTypedArray = function aTypedArray2(it) {
                  if (isTypedArray(it))
                    return it;
                  throw TypeError2("Target is not a typed array");
                };
                var aTypedArrayConstructor = function aTypedArrayConstructor2(C) {
                  if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C)))
                    return C;
                  throw TypeError2(tryToString(C) + " is not a typed array constructor");
                };
                var exportTypedArrayMethod = function exportTypedArrayMethod2(KEY, property, forced) {
                  if (!DESCRIPTORS)
                    return;
                  if (forced)
                    for (var ARRAY in TypedArrayConstructorsList) {
                      var TypedArrayConstructor = global[ARRAY];
                      if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY))
                        try {
                          delete TypedArrayConstructor.prototype[KEY];
                        } catch (error) {
                        }
                    }
                  if (!TypedArrayPrototype[KEY] || forced) {
                    redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
                  }
                };
                var exportTypedArrayStaticMethod = function exportTypedArrayStaticMethod2(KEY, property, forced) {
                  var ARRAY, TypedArrayConstructor;
                  if (!DESCRIPTORS)
                    return;
                  if (setPrototypeOf) {
                    if (forced)
                      for (ARRAY in TypedArrayConstructorsList) {
                        TypedArrayConstructor = global[ARRAY];
                        if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY))
                          try {
                            delete TypedArrayConstructor[KEY];
                          } catch (error) {
                          }
                      }
                    if (!TypedArray[KEY] || forced) {
                      try {
                        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
                      } catch (error) {
                      }
                    } else
                      return;
                  }
                  for (ARRAY in TypedArrayConstructorsList) {
                    TypedArrayConstructor = global[ARRAY];
                    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
                      redefine(TypedArrayConstructor, KEY, property);
                    }
                  }
                };
                for (NAME in TypedArrayConstructorsList) {
                  Constructor = global[NAME];
                  Prototype = Constructor && Constructor.prototype;
                  if (Prototype)
                    createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR, Constructor);
                  else
                    NATIVE_ARRAY_BUFFER_VIEWS = false;
                }
                for (NAME in BigIntArrayConstructorsList) {
                  Constructor = global[NAME];
                  Prototype = Constructor && Constructor.prototype;
                  if (Prototype)
                    createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR, Constructor);
                }
                if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
                  TypedArray = function TypedArray2() {
                    throw TypeError2("Incorrect invocation");
                  };
                  if (NATIVE_ARRAY_BUFFER_VIEWS)
                    for (NAME in TypedArrayConstructorsList) {
                      if (global[NAME])
                        setPrototypeOf(global[NAME], TypedArray);
                    }
                }
                if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
                  TypedArrayPrototype = TypedArray.prototype;
                  if (NATIVE_ARRAY_BUFFER_VIEWS)
                    for (NAME in TypedArrayConstructorsList) {
                      if (global[NAME])
                        setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
                    }
                }
                if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
                  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
                }
                if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
                  TYPED_ARRAY_TAG_REQIRED = true;
                  defineProperty(TypedArrayPrototype, TO_STRING_TAG, {
                    get: function get() {
                      return isObject(this) ? this[TYPED_ARRAY_TAG] : void 0;
                    }
                  });
                  for (NAME in TypedArrayConstructorsList) {
                    if (global[NAME]) {
                      createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
                    }
                  }
                }
                module2.exports = {
                  NATIVE_ARRAY_BUFFER_VIEWS,
                  TYPED_ARRAY_CONSTRUCTOR,
                  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
                  aTypedArray,
                  aTypedArrayConstructor,
                  exportTypedArrayMethod,
                  exportTypedArrayStaticMethod,
                  isView,
                  isTypedArray,
                  TypedArray,
                  TypedArrayPrototype
                };
              }
            ),
            /***/
            2091: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                __webpack_require__2(8309);
                var global = __webpack_require__2(7854);
                var uncurryThis = __webpack_require__2(1702);
                var DESCRIPTORS = __webpack_require__2(9781);
                var NATIVE_ARRAY_BUFFER = __webpack_require__2(477);
                var FunctionName = __webpack_require__2(6530);
                var createNonEnumerableProperty = __webpack_require__2(8880);
                var redefineAll = __webpack_require__2(2248);
                var fails = __webpack_require__2(7293);
                var anInstance = __webpack_require__2(5787);
                var toIntegerOrInfinity = __webpack_require__2(9303);
                var toLength = __webpack_require__2(7466);
                var toIndex = __webpack_require__2(7067);
                var IEEE754 = __webpack_require__2(1179);
                var getPrototypeOf = __webpack_require__2(9518);
                var setPrototypeOf = __webpack_require__2(7674);
                var getOwnPropertyNames = __webpack_require__2(8006).f;
                var defineProperty = __webpack_require__2(3070).f;
                var arrayFill = __webpack_require__2(1285);
                var arraySlice = __webpack_require__2(206);
                var setToStringTag = __webpack_require__2(8003);
                var InternalStateModule = __webpack_require__2(9909);
                var PROPER_FUNCTION_NAME = FunctionName.PROPER;
                var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
                var getInternalState = InternalStateModule.get;
                var setInternalState = InternalStateModule.set;
                var ARRAY_BUFFER = "ArrayBuffer";
                var DATA_VIEW = "DataView";
                var PROTOTYPE = "prototype";
                var WRONG_LENGTH = "Wrong length";
                var WRONG_INDEX = "Wrong index";
                var NativeArrayBuffer = global[ARRAY_BUFFER];
                var $ArrayBuffer = NativeArrayBuffer;
                var ArrayBufferPrototype = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];
                var $DataView = global[DATA_VIEW];
                var DataViewPrototype = $DataView && $DataView[PROTOTYPE];
                var ObjectPrototype = Object.prototype;
                var Array2 = global.Array;
                var RangeError2 = global.RangeError;
                var fill = uncurryThis(arrayFill);
                var reverse = uncurryThis([].reverse);
                var packIEEE754 = IEEE754.pack;
                var unpackIEEE754 = IEEE754.unpack;
                var packInt8 = function packInt82(number) {
                  return [number & 255];
                };
                var packInt16 = function packInt162(number) {
                  return [number & 255, number >> 8 & 255];
                };
                var packInt32 = function packInt322(number) {
                  return [number & 255, number >> 8 & 255, number >> 16 & 255, number >> 24 & 255];
                };
                var unpackInt32 = function unpackInt322(buffer) {
                  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
                };
                var packFloat32 = function packFloat322(number) {
                  return packIEEE754(number, 23, 4);
                };
                var packFloat64 = function packFloat642(number) {
                  return packIEEE754(number, 52, 8);
                };
                var addGetter = function addGetter2(Constructor, key2) {
                  defineProperty(Constructor[PROTOTYPE], key2, {
                    get: function get2() {
                      return getInternalState(this)[key2];
                    }
                  });
                };
                var get = function get2(view, count, index, isLittleEndian) {
                  var intIndex = toIndex(index);
                  var store = getInternalState(view);
                  if (intIndex + count > store.byteLength)
                    throw RangeError2(WRONG_INDEX);
                  var bytes = getInternalState(store.buffer).bytes;
                  var start = intIndex + store.byteOffset;
                  var pack = arraySlice(bytes, start, start + count);
                  return isLittleEndian ? pack : reverse(pack);
                };
                var set = function set2(view, count, index, conversion, value, isLittleEndian) {
                  var intIndex = toIndex(index);
                  var store = getInternalState(view);
                  if (intIndex + count > store.byteLength)
                    throw RangeError2(WRONG_INDEX);
                  var bytes = getInternalState(store.buffer).bytes;
                  var start = intIndex + store.byteOffset;
                  var pack = conversion(+value);
                  for (var i = 0; i < count; i++) {
                    bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
                  }
                };
                if (!NATIVE_ARRAY_BUFFER) {
                  $ArrayBuffer = function ArrayBuffer2(length) {
                    anInstance(this, ArrayBufferPrototype);
                    var byteLength = toIndex(length);
                    setInternalState(this, {
                      bytes: fill(Array2(byteLength), 0),
                      byteLength
                    });
                    if (!DESCRIPTORS)
                      this.byteLength = byteLength;
                  };
                  ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE];
                  $DataView = function DataView2(buffer, byteOffset, byteLength) {
                    anInstance(this, DataViewPrototype);
                    anInstance(buffer, ArrayBufferPrototype);
                    var bufferLength = getInternalState(buffer).byteLength;
                    var offset = toIntegerOrInfinity(byteOffset);
                    if (offset < 0 || offset > bufferLength)
                      throw RangeError2("Wrong offset");
                    byteLength = byteLength === void 0 ? bufferLength - offset : toLength(byteLength);
                    if (offset + byteLength > bufferLength)
                      throw RangeError2(WRONG_LENGTH);
                    setInternalState(this, {
                      buffer,
                      byteLength,
                      byteOffset: offset
                    });
                    if (!DESCRIPTORS) {
                      this.buffer = buffer;
                      this.byteLength = byteLength;
                      this.byteOffset = offset;
                    }
                  };
                  DataViewPrototype = $DataView[PROTOTYPE];
                  if (DESCRIPTORS) {
                    addGetter($ArrayBuffer, "byteLength");
                    addGetter($DataView, "buffer");
                    addGetter($DataView, "byteLength");
                    addGetter($DataView, "byteOffset");
                  }
                  redefineAll(DataViewPrototype, {
                    getInt8: function getInt8(byteOffset) {
                      return get(this, 1, byteOffset)[0] << 24 >> 24;
                    },
                    getUint8: function getUint8(byteOffset) {
                      return get(this, 1, byteOffset)[0];
                    },
                    getInt16: function getInt16(byteOffset) {
                      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : void 0);
                      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
                    },
                    getUint16: function getUint16(byteOffset) {
                      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : void 0);
                      return bytes[1] << 8 | bytes[0];
                    },
                    getInt32: function getInt32(byteOffset) {
                      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : void 0));
                    },
                    getUint32: function getUint32(byteOffset) {
                      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : void 0)) >>> 0;
                    },
                    getFloat32: function getFloat32(byteOffset) {
                      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : void 0), 23);
                    },
                    getFloat64: function getFloat64(byteOffset) {
                      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : void 0), 52);
                    },
                    setInt8: function setInt8(byteOffset, value) {
                      set(this, 1, byteOffset, packInt8, value);
                    },
                    setUint8: function setUint8(byteOffset, value) {
                      set(this, 1, byteOffset, packInt8, value);
                    },
                    setInt16: function setInt16(byteOffset, value) {
                      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : void 0);
                    },
                    setUint16: function setUint16(byteOffset, value) {
                      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : void 0);
                    },
                    setInt32: function setInt32(byteOffset, value) {
                      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : void 0);
                    },
                    setUint32: function setUint32(byteOffset, value) {
                      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : void 0);
                    },
                    setFloat32: function setFloat32(byteOffset, value) {
                      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : void 0);
                    },
                    setFloat64: function setFloat64(byteOffset, value) {
                      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : void 0);
                    }
                  });
                } else {
                  var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;
                  if (!fails(function() {
                    NativeArrayBuffer(1);
                  }) || !fails(function() {
                    new NativeArrayBuffer(-1);
                  }) || fails(function() {
                    new NativeArrayBuffer();
                    new NativeArrayBuffer(1.5);
                    new NativeArrayBuffer(NaN);
                    return INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
                  })) {
                    $ArrayBuffer = function ArrayBuffer2(length) {
                      anInstance(this, ArrayBufferPrototype);
                      return new NativeArrayBuffer(toIndex(length));
                    };
                    $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype;
                    for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j; ) {
                      if (!((key = keys[j++]) in $ArrayBuffer)) {
                        createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
                      }
                    }
                    ArrayBufferPrototype.constructor = $ArrayBuffer;
                  } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {
                    createNonEnumerableProperty(NativeArrayBuffer, "name", ARRAY_BUFFER);
                  }
                  if (setPrototypeOf && getPrototypeOf(DataViewPrototype) !== ObjectPrototype) {
                    setPrototypeOf(DataViewPrototype, ObjectPrototype);
                  }
                  var testView = new $DataView(new $ArrayBuffer(2));
                  var $setInt8 = uncurryThis(DataViewPrototype.setInt8);
                  testView.setInt8(0, 2147483648);
                  testView.setInt8(1, 2147483649);
                  if (testView.getInt8(0) || !testView.getInt8(1))
                    redefineAll(DataViewPrototype, {
                      setInt8: function setInt8(byteOffset, value) {
                        $setInt8(this, byteOffset, value << 24 >> 24);
                      },
                      setUint8: function setUint8(byteOffset, value) {
                        $setInt8(this, byteOffset, value << 24 >> 24);
                      }
                    }, {
                      unsafe: true
                    });
                }
                setToStringTag($ArrayBuffer, ARRAY_BUFFER);
                setToStringTag($DataView, DATA_VIEW);
                module2.exports = {
                  ArrayBuffer: $ArrayBuffer,
                  DataView: $DataView
                };
              }
            ),
            /***/
            7803: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var global = __webpack_require__2(7854);
                var arrayBufferModule = __webpack_require__2(2091);
                var setSpecies = __webpack_require__2(6340);
                var ARRAY_BUFFER = "ArrayBuffer";
                var ArrayBuffer2 = arrayBufferModule[ARRAY_BUFFER];
                var NativeArrayBuffer = global[ARRAY_BUFFER];
                $({
                  global: true,
                  forced: NativeArrayBuffer !== ArrayBuffer2
                }, {
                  ArrayBuffer: ArrayBuffer2
                });
                setSpecies(ARRAY_BUFFER);
              }
            ),
            /***/
            194: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(7508), __webpack_require__2(3440), __webpack_require__2(3839), __webpack_require__2(1582));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var BlockCipher = C_lib.BlockCipher;
                    var C_algo = C.algo;
                    var SBOX = [];
                    var INV_SBOX = [];
                    var SUB_MIX_0 = [];
                    var SUB_MIX_1 = [];
                    var SUB_MIX_2 = [];
                    var SUB_MIX_3 = [];
                    var INV_SUB_MIX_0 = [];
                    var INV_SUB_MIX_1 = [];
                    var INV_SUB_MIX_2 = [];
                    var INV_SUB_MIX_3 = [];
                    (function() {
                      var d = [];
                      for (var i = 0; i < 256; i++) {
                        if (i < 128) {
                          d[i] = i << 1;
                        } else {
                          d[i] = i << 1 ^ 283;
                        }
                      }
                      var x = 0;
                      var xi = 0;
                      for (var i = 0; i < 256; i++) {
                        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
                        sx = sx >>> 8 ^ sx & 255 ^ 99;
                        SBOX[x] = sx;
                        INV_SBOX[sx] = x;
                        var x2 = d[x];
                        var x4 = d[x2];
                        var x8 = d[x4];
                        var t = d[sx] * 257 ^ sx * 16843008;
                        SUB_MIX_0[x] = t << 24 | t >>> 8;
                        SUB_MIX_1[x] = t << 16 | t >>> 16;
                        SUB_MIX_2[x] = t << 8 | t >>> 24;
                        SUB_MIX_3[x] = t;
                        var t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
                        INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
                        INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
                        INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
                        INV_SUB_MIX_3[sx] = t;
                        if (!x) {
                          x = xi = 1;
                        } else {
                          x = x2 ^ d[d[d[x8 ^ x2]]];
                          xi ^= d[d[xi]];
                        }
                      }
                    })();
                    var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
                    var AES = C_algo.AES = BlockCipher.extend({
                      _doReset: function _doReset() {
                        var t;
                        if (this._nRounds && this._keyPriorReset === this._key) {
                          return;
                        }
                        var key = this._keyPriorReset = this._key;
                        var keyWords = key.words;
                        var keySize = key.sigBytes / 4;
                        var nRounds = this._nRounds = keySize + 6;
                        var ksRows = (nRounds + 1) * 4;
                        var keySchedule = this._keySchedule = [];
                        for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                          if (ksRow < keySize) {
                            keySchedule[ksRow] = keyWords[ksRow];
                          } else {
                            t = keySchedule[ksRow - 1];
                            if (!(ksRow % keySize)) {
                              t = t << 8 | t >>> 24;
                              t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                              t ^= RCON[ksRow / keySize | 0] << 24;
                            } else if (keySize > 6 && ksRow % keySize == 4) {
                              t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                            }
                            keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
                          }
                        }
                        var invKeySchedule = this._invKeySchedule = [];
                        for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                          var ksRow = ksRows - invKsRow;
                          if (invKsRow % 4) {
                            var t = keySchedule[ksRow];
                          } else {
                            var t = keySchedule[ksRow - 4];
                          }
                          if (invKsRow < 4 || ksRow <= 4) {
                            invKeySchedule[invKsRow] = t;
                          } else {
                            invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]];
                          }
                        }
                      },
                      encryptBlock: function encryptBlock(M, offset) {
                        this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
                      },
                      decryptBlock: function decryptBlock(M, offset) {
                        var t = M[offset + 1];
                        M[offset + 1] = M[offset + 3];
                        M[offset + 3] = t;
                        this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
                        var t = M[offset + 1];
                        M[offset + 1] = M[offset + 3];
                        M[offset + 3] = t;
                      },
                      _doCryptBlock: function _doCryptBlock(M, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
                        var nRounds = this._nRounds;
                        var s0 = M[offset] ^ keySchedule[0];
                        var s1 = M[offset + 1] ^ keySchedule[1];
                        var s2 = M[offset + 2] ^ keySchedule[2];
                        var s3 = M[offset + 3] ^ keySchedule[3];
                        var ksRow = 4;
                        for (var round = 1; round < nRounds; round++) {
                          var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
                          var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
                          var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
                          var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
                          s0 = t0;
                          s1 = t1;
                          s2 = t2;
                          s3 = t3;
                        }
                        var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
                        var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
                        var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
                        var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
                        M[offset] = t0;
                        M[offset + 1] = t1;
                        M[offset + 2] = t2;
                        M[offset + 3] = t3;
                      },
                      keySize: 256 / 32
                    });
                    C.AES = BlockCipher._createHelper(AES);
                  })();
                  return CryptoJS.AES;
                });
              }
            ),
            /***/
            1582: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(7042);
                __webpack_require__2(2222);
                __webpack_require__2(1539);
                __webpack_require__2(9714);
                __webpack_require__2(561);
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(3839));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  CryptoJS.lib.Cipher || function(undefined2) {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var Base = C_lib.Base;
                    var WordArray = C_lib.WordArray;
                    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
                    var C_enc = C.enc;
                    var Utf8 = C_enc.Utf8;
                    var Base64 = C_enc.Base64;
                    var C_algo = C.algo;
                    var EvpKDF = C_algo.EvpKDF;
                    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
                      /**
                       * Configuration options.
                       *
                       * @property {WordArray} iv The IV to use for this operation.
                       */
                      cfg: Base.extend(),
                      /**
                       * Creates this cipher in encryption mode.
                       *
                       * @param {WordArray} key The key.
                       * @param {Object} cfg (Optional) The configuration options to use for this operation.
                       *
                       * @return {Cipher} A cipher instance.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
                       */
                      createEncryptor: function createEncryptor(key, cfg) {
                        return this.create(this._ENC_XFORM_MODE, key, cfg);
                      },
                      /**
                       * Creates this cipher in decryption mode.
                       *
                       * @param {WordArray} key The key.
                       * @param {Object} cfg (Optional) The configuration options to use for this operation.
                       *
                       * @return {Cipher} A cipher instance.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
                       */
                      createDecryptor: function createDecryptor(key, cfg) {
                        return this.create(this._DEC_XFORM_MODE, key, cfg);
                      },
                      /**
                       * Initializes a newly created cipher.
                       *
                       * @param {number} xformMode Either the encryption or decryption transormation mode constant.
                       * @param {WordArray} key The key.
                       * @param {Object} cfg (Optional) The configuration options to use for this operation.
                       *
                       * @example
                       *
                       *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
                       */
                      init: function init(xformMode, key, cfg) {
                        this.cfg = this.cfg.extend(cfg);
                        this._xformMode = xformMode;
                        this._key = key;
                        this.reset();
                      },
                      /**
                       * Resets this cipher to its initial state.
                       *
                       * @example
                       *
                       *     cipher.reset();
                       */
                      reset: function reset() {
                        BufferedBlockAlgorithm.reset.call(this);
                        this._doReset();
                      },
                      /**
                       * Adds data to be encrypted or decrypted.
                       *
                       * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
                       *
                       * @return {WordArray} The data after processing.
                       *
                       * @example
                       *
                       *     var encrypted = cipher.process('data');
                       *     var encrypted = cipher.process(wordArray);
                       */
                      process: function process(dataUpdate) {
                        this._append(dataUpdate);
                        return this._process();
                      },
                      /**
                       * Finalizes the encryption or decryption process.
                       * Note that the finalize operation is effectively a destructive, read-once operation.
                       *
                       * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
                       *
                       * @return {WordArray} The data after final processing.
                       *
                       * @example
                       *
                       *     var encrypted = cipher.finalize();
                       *     var encrypted = cipher.finalize('data');
                       *     var encrypted = cipher.finalize(wordArray);
                       */
                      finalize: function finalize(dataUpdate) {
                        if (dataUpdate) {
                          this._append(dataUpdate);
                        }
                        var finalProcessedData = this._doFinalize();
                        return finalProcessedData;
                      },
                      keySize: 128 / 32,
                      ivSize: 128 / 32,
                      _ENC_XFORM_MODE: 1,
                      _DEC_XFORM_MODE: 2,
                      /**
                       * Creates shortcut functions to a cipher's object interface.
                       *
                       * @param {Cipher} cipher The cipher to create a helper for.
                       *
                       * @return {Object} An object with encrypt and decrypt shortcut functions.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
                       */
                      _createHelper: function() {
                        function selectCipherStrategy(key) {
                          if (typeof key == "string") {
                            return PasswordBasedCipher;
                          } else {
                            return SerializableCipher;
                          }
                        }
                        return function(cipher) {
                          return {
                            encrypt: function encrypt(message, key, cfg) {
                              return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                            },
                            decrypt: function decrypt(ciphertext, key, cfg) {
                              return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                            }
                          };
                        };
                      }()
                    });
                    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
                      _doFinalize: function _doFinalize() {
                        var finalProcessedBlocks = this._process(true);
                        return finalProcessedBlocks;
                      },
                      blockSize: 1
                    });
                    var C_mode = C.mode = {};
                    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
                      /**
                       * Creates this mode for encryption.
                       *
                       * @param {Cipher} cipher A block cipher instance.
                       * @param {Array} iv The IV words.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
                       */
                      createEncryptor: function createEncryptor(cipher, iv) {
                        return this.Encryptor.create(cipher, iv);
                      },
                      /**
                       * Creates this mode for decryption.
                       *
                       * @param {Cipher} cipher A block cipher instance.
                       * @param {Array} iv The IV words.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
                       */
                      createDecryptor: function createDecryptor(cipher, iv) {
                        return this.Decryptor.create(cipher, iv);
                      },
                      /**
                       * Initializes a newly created mode.
                       *
                       * @param {Cipher} cipher A block cipher instance.
                       * @param {Array} iv The IV words.
                       *
                       * @example
                       *
                       *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
                       */
                      init: function init(cipher, iv) {
                        this._cipher = cipher;
                        this._iv = iv;
                      }
                    });
                    var CBC = C_mode.CBC = function() {
                      var CBC2 = BlockCipherMode.extend();
                      CBC2.Encryptor = CBC2.extend({
                        /**
                         * Processes the data block at offset.
                         *
                         * @param {Array} words The data words to operate on.
                         * @param {number} offset The offset where the block starts.
                         *
                         * @example
                         *
                         *     mode.processBlock(data.words, offset);
                         */
                        processBlock: function processBlock(words, offset) {
                          var cipher = this._cipher;
                          var blockSize = cipher.blockSize;
                          xorBlock.call(this, words, offset, blockSize);
                          cipher.encryptBlock(words, offset);
                          this._prevBlock = words.slice(offset, offset + blockSize);
                        }
                      });
                      CBC2.Decryptor = CBC2.extend({
                        /**
                         * Processes the data block at offset.
                         *
                         * @param {Array} words The data words to operate on.
                         * @param {number} offset The offset where the block starts.
                         *
                         * @example
                         *
                         *     mode.processBlock(data.words, offset);
                         */
                        processBlock: function processBlock(words, offset) {
                          var cipher = this._cipher;
                          var blockSize = cipher.blockSize;
                          var thisBlock = words.slice(offset, offset + blockSize);
                          cipher.decryptBlock(words, offset);
                          xorBlock.call(this, words, offset, blockSize);
                          this._prevBlock = thisBlock;
                        }
                      });
                      function xorBlock(words, offset, blockSize) {
                        var block;
                        var iv = this._iv;
                        if (iv) {
                          block = iv;
                          this._iv = undefined2;
                        } else {
                          block = this._prevBlock;
                        }
                        for (var i = 0; i < blockSize; i++) {
                          words[offset + i] ^= block[i];
                        }
                      }
                      return CBC2;
                    }();
                    var C_pad = C.pad = {};
                    var Pkcs7 = C_pad.Pkcs7 = {
                      /**
                       * Pads data using the algorithm defined in PKCS #5/7.
                       *
                       * @param {WordArray} data The data to pad.
                       * @param {number} blockSize The multiple that the data should be padded to.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
                       */
                      pad: function pad(data, blockSize) {
                        var blockSizeBytes = blockSize * 4;
                        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
                        var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
                        var paddingWords = [];
                        for (var i = 0; i < nPaddingBytes; i += 4) {
                          paddingWords.push(paddingWord);
                        }
                        var padding = WordArray.create(paddingWords, nPaddingBytes);
                        data.concat(padding);
                      },
                      /**
                       * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
                       *
                       * @param {WordArray} data The data to unpad.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     CryptoJS.pad.Pkcs7.unpad(wordArray);
                       */
                      unpad: function unpad(data) {
                        var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
                        data.sigBytes -= nPaddingBytes;
                      }
                    };
                    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
                      /**
                       * Configuration options.
                       *
                       * @property {Mode} mode The block mode to use. Default: CBC
                       * @property {Padding} padding The padding strategy to use. Default: Pkcs7
                       */
                      cfg: Cipher.cfg.extend({
                        mode: CBC,
                        padding: Pkcs7
                      }),
                      reset: function reset() {
                        var modeCreator;
                        Cipher.reset.call(this);
                        var cfg = this.cfg;
                        var iv = cfg.iv;
                        var mode = cfg.mode;
                        if (this._xformMode == this._ENC_XFORM_MODE) {
                          modeCreator = mode.createEncryptor;
                        } else {
                          modeCreator = mode.createDecryptor;
                          this._minBufferSize = 1;
                        }
                        if (this._mode && this._mode.__creator == modeCreator) {
                          this._mode.init(this, iv && iv.words);
                        } else {
                          this._mode = modeCreator.call(mode, this, iv && iv.words);
                          this._mode.__creator = modeCreator;
                        }
                      },
                      _doProcessBlock: function _doProcessBlock(words, offset) {
                        this._mode.processBlock(words, offset);
                      },
                      _doFinalize: function _doFinalize() {
                        var finalProcessedBlocks;
                        var padding = this.cfg.padding;
                        if (this._xformMode == this._ENC_XFORM_MODE) {
                          padding.pad(this._data, this.blockSize);
                          finalProcessedBlocks = this._process(true);
                        } else {
                          finalProcessedBlocks = this._process(true);
                          padding.unpad(finalProcessedBlocks);
                        }
                        return finalProcessedBlocks;
                      },
                      blockSize: 128 / 32
                    });
                    var CipherParams = C_lib.CipherParams = Base.extend({
                      /**
                       * Initializes a newly created cipher params object.
                       *
                       * @param {Object} cipherParams An object with any of the possible cipher parameters.
                       *
                       * @example
                       *
                       *     var cipherParams = CryptoJS.lib.CipherParams.create({
                       *         ciphertext: ciphertextWordArray,
                       *         key: keyWordArray,
                       *         iv: ivWordArray,
                       *         salt: saltWordArray,
                       *         algorithm: CryptoJS.algo.AES,
                       *         mode: CryptoJS.mode.CBC,
                       *         padding: CryptoJS.pad.PKCS7,
                       *         blockSize: 4,
                       *         formatter: CryptoJS.format.OpenSSL
                       *     });
                       */
                      init: function init(cipherParams) {
                        this.mixIn(cipherParams);
                      },
                      /**
                       * Converts this cipher params object to a string.
                       *
                       * @param {Format} formatter (Optional) The formatting strategy to use.
                       *
                       * @return {string} The stringified cipher params.
                       *
                       * @throws Error If neither the formatter nor the default formatter is set.
                       *
                       * @example
                       *
                       *     var string = cipherParams + '';
                       *     var string = cipherParams.toString();
                       *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
                       */
                      toString: function toString(formatter) {
                        return (formatter || this.formatter).stringify(this);
                      }
                    });
                    var C_format = C.format = {};
                    var OpenSSLFormatter = C_format.OpenSSL = {
                      /**
                       * Converts a cipher params object to an OpenSSL-compatible string.
                       *
                       * @param {CipherParams} cipherParams The cipher params object.
                       *
                       * @return {string} The OpenSSL-compatible string.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
                       */
                      stringify: function stringify(cipherParams) {
                        var wordArray;
                        var ciphertext = cipherParams.ciphertext;
                        var salt = cipherParams.salt;
                        if (salt) {
                          wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
                        } else {
                          wordArray = ciphertext;
                        }
                        return wordArray.toString(Base64);
                      },
                      /**
                       * Converts an OpenSSL-compatible string to a cipher params object.
                       *
                       * @param {string} openSSLStr The OpenSSL-compatible string.
                       *
                       * @return {CipherParams} The cipher params object.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
                       */
                      parse: function parse(openSSLStr) {
                        var salt;
                        var ciphertext = Base64.parse(openSSLStr);
                        var ciphertextWords = ciphertext.words;
                        if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
                          salt = WordArray.create(ciphertextWords.slice(2, 4));
                          ciphertextWords.splice(0, 4);
                          ciphertext.sigBytes -= 16;
                        }
                        return CipherParams.create({
                          ciphertext,
                          salt
                        });
                      }
                    };
                    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
                      /**
                       * Configuration options.
                       *
                       * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
                       */
                      cfg: Base.extend({
                        format: OpenSSLFormatter
                      }),
                      /**
                       * Encrypts a message.
                       *
                       * @param {Cipher} cipher The cipher algorithm to use.
                       * @param {WordArray|string} message The message to encrypt.
                       * @param {WordArray} key The key.
                       * @param {Object} cfg (Optional) The configuration options to use for this operation.
                       *
                       * @return {CipherParams} A cipher params object.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
                       *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
                       *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                       */
                      encrypt: function encrypt(cipher, message, key, cfg) {
                        cfg = this.cfg.extend(cfg);
                        var encryptor = cipher.createEncryptor(key, cfg);
                        var ciphertext = encryptor.finalize(message);
                        var cipherCfg = encryptor.cfg;
                        return CipherParams.create({
                          ciphertext,
                          key,
                          iv: cipherCfg.iv,
                          algorithm: cipher,
                          mode: cipherCfg.mode,
                          padding: cipherCfg.padding,
                          blockSize: cipher.blockSize,
                          formatter: cfg.format
                        });
                      },
                      /**
                       * Decrypts serialized ciphertext.
                       *
                       * @param {Cipher} cipher The cipher algorithm to use.
                       * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
                       * @param {WordArray} key The key.
                       * @param {Object} cfg (Optional) The configuration options to use for this operation.
                       *
                       * @return {WordArray} The plaintext.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                       *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                       */
                      decrypt: function decrypt(cipher, ciphertext, key, cfg) {
                        cfg = this.cfg.extend(cfg);
                        ciphertext = this._parse(ciphertext, cfg.format);
                        var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
                        return plaintext;
                      },
                      /**
                       * Converts serialized ciphertext to CipherParams,
                       * else assumed CipherParams already and returns ciphertext unchanged.
                       *
                       * @param {CipherParams|string} ciphertext The ciphertext.
                       * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
                       *
                       * @return {CipherParams} The unserialized ciphertext.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
                       */
                      _parse: function _parse(ciphertext, format) {
                        if (typeof ciphertext == "string") {
                          return format.parse(ciphertext, this);
                        } else {
                          return ciphertext;
                        }
                      }
                    });
                    var C_kdf = C.kdf = {};
                    var OpenSSLKdf = C_kdf.OpenSSL = {
                      /**
                       * Derives a key and IV from a password.
                       *
                       * @param {string} password The password to derive from.
                       * @param {number} keySize The size in words of the key to generate.
                       * @param {number} ivSize The size in words of the IV to generate.
                       * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
                       *
                       * @return {CipherParams} A cipher params object with the key, IV, and salt.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
                       *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
                       */
                      execute: function execute(password, keySize, ivSize, salt) {
                        if (!salt) {
                          salt = WordArray.random(64 / 8);
                        }
                        var key = EvpKDF.create({
                          keySize: keySize + ivSize
                        }).compute(password, salt);
                        var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
                        key.sigBytes = keySize * 4;
                        return CipherParams.create({
                          key,
                          iv,
                          salt
                        });
                      }
                    };
                    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
                      /**
                       * Configuration options.
                       *
                       * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
                       */
                      cfg: SerializableCipher.cfg.extend({
                        kdf: OpenSSLKdf
                      }),
                      /**
                       * Encrypts a message using a password.
                       *
                       * @param {Cipher} cipher The cipher algorithm to use.
                       * @param {WordArray|string} message The message to encrypt.
                       * @param {string} password The password.
                       * @param {Object} cfg (Optional) The configuration options to use for this operation.
                       *
                       * @return {CipherParams} A cipher params object.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
                       *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
                       */
                      encrypt: function encrypt(cipher, message, password, cfg) {
                        cfg = this.cfg.extend(cfg);
                        var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
                        cfg.iv = derivedParams.iv;
                        var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
                        ciphertext.mixIn(derivedParams);
                        return ciphertext;
                      },
                      /**
                       * Decrypts serialized ciphertext using a password.
                       *
                       * @param {Cipher} cipher The cipher algorithm to use.
                       * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
                       * @param {string} password The password.
                       * @param {Object} cfg (Optional) The configuration options to use for this operation.
                       *
                       * @return {WordArray} The plaintext.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
                       *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
                       */
                      decrypt: function decrypt(cipher, ciphertext, password, cfg) {
                        cfg = this.cfg.extend(cfg);
                        ciphertext = this._parse(ciphertext, cfg.format);
                        var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
                        cfg.iv = derivedParams.iv;
                        var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
                        return plaintext;
                      }
                    });
                  }();
                });
              }
            ),
            /***/
            757: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(5743);
                __webpack_require__2(6992);
                __webpack_require__2(1539);
                __webpack_require__2(9135);
                __webpack_require__2(2990);
                __webpack_require__2(8927);
                __webpack_require__2(3105);
                __webpack_require__2(5035);
                __webpack_require__2(4345);
                __webpack_require__2(7174);
                __webpack_require__2(2846);
                __webpack_require__2(4731);
                __webpack_require__2(7209);
                __webpack_require__2(6319);
                __webpack_require__2(8867);
                __webpack_require__2(7789);
                __webpack_require__2(3739);
                __webpack_require__2(9368);
                __webpack_require__2(4483);
                __webpack_require__2(2056);
                __webpack_require__2(3462);
                __webpack_require__2(678);
                __webpack_require__2(7462);
                __webpack_require__2(3824);
                __webpack_require__2(5021);
                __webpack_require__2(2974);
                __webpack_require__2(5016);
                __webpack_require__2(9714);
                __webpack_require__2(7042);
                __webpack_require__2(9600);
                __webpack_require__2(2222);
                __webpack_require__2(561);
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory();
                  } else {
                  }
                })(void 0, function() {
                  var CryptoJS = CryptoJS || function(Math2, undefined2) {
                    var crypto;
                    if (typeof window !== "undefined" && window.crypto) {
                      crypto = window.crypto;
                    }
                    if (typeof self !== "undefined" && self.crypto) {
                      crypto = self.crypto;
                    }
                    if (typeof globalThis !== "undefined" && globalThis.crypto) {
                      crypto = globalThis.crypto;
                    }
                    if (!crypto && typeof window !== "undefined" && window.msCrypto) {
                      crypto = window.msCrypto;
                    }
                    if (!crypto && typeof __webpack_require__2.g !== "undefined" && __webpack_require__2.g.crypto) {
                      crypto = __webpack_require__2.g.crypto;
                    }
                    if (!crypto && true) {
                      try {
                        crypto = __webpack_require__2(2480);
                      } catch (err) {
                      }
                    }
                    var cryptoSecureRandomInt = function cryptoSecureRandomInt2() {
                      if (crypto) {
                        if (typeof crypto.getRandomValues === "function") {
                          try {
                            return crypto.getRandomValues(new Uint32Array(1))[0];
                          } catch (err) {
                          }
                        }
                        if (typeof crypto.randomBytes === "function") {
                          try {
                            return crypto.randomBytes(4).readInt32LE();
                          } catch (err) {
                          }
                        }
                      }
                      throw new Error("Native crypto module could not be used to get secure random number.");
                    };
                    var create = Object.create || function() {
                      function F() {
                      }
                      return function(obj) {
                        var subtype;
                        F.prototype = obj;
                        subtype = new F();
                        F.prototype = null;
                        return subtype;
                      };
                    }();
                    var C = {};
                    var C_lib = C.lib = {};
                    var Base = C_lib.Base = function() {
                      return {
                        /**
                         * Creates a new object that inherits from this object.
                         *
                         * @param {Object} overrides Properties to copy into the new object.
                         *
                         * @return {Object} The new object.
                         *
                         * @static
                         *
                         * @example
                         *
                         *     var MyType = CryptoJS.lib.Base.extend({
                         *         field: 'value',
                         *
                         *         method: function () {
                         *         }
                         *     });
                         */
                        extend: function extend(overrides) {
                          var subtype = create(this);
                          if (overrides) {
                            subtype.mixIn(overrides);
                          }
                          if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                            subtype.init = function() {
                              subtype.$super.init.apply(this, arguments);
                            };
                          }
                          subtype.init.prototype = subtype;
                          subtype.$super = this;
                          return subtype;
                        },
                        /**
                         * Extends this object and runs the init method.
                         * Arguments to create() will be passed to init().
                         *
                         * @return {Object} The new object.
                         *
                         * @static
                         *
                         * @example
                         *
                         *     var instance = MyType.create();
                         */
                        create: function create2() {
                          var instance = this.extend();
                          instance.init.apply(instance, arguments);
                          return instance;
                        },
                        /**
                         * Initializes a newly created object.
                         * Override this method to add some logic when your objects are created.
                         *
                         * @example
                         *
                         *     var MyType = CryptoJS.lib.Base.extend({
                         *         init: function () {
                         *             // ...
                         *         }
                         *     });
                         */
                        init: function init() {
                        },
                        /**
                         * Copies properties into this object.
                         *
                         * @param {Object} properties The properties to mix in.
                         *
                         * @example
                         *
                         *     MyType.mixIn({
                         *         field: 'value'
                         *     });
                         */
                        mixIn: function mixIn(properties) {
                          for (var propertyName in properties) {
                            if (properties.hasOwnProperty(propertyName)) {
                              this[propertyName] = properties[propertyName];
                            }
                          }
                          if (properties.hasOwnProperty("toString")) {
                            this.toString = properties.toString;
                          }
                        },
                        /**
                         * Creates a copy of this object.
                         *
                         * @return {Object} The clone.
                         *
                         * @example
                         *
                         *     var clone = instance.clone();
                         */
                        clone: function clone() {
                          return this.init.prototype.extend(this);
                        }
                      };
                    }();
                    var WordArray = C_lib.WordArray = Base.extend({
                      /**
                       * Initializes a newly created word array.
                       *
                       * @param {Array} words (Optional) An array of 32-bit words.
                       * @param {number} sigBytes (Optional) The number of significant bytes in the words.
                       *
                       * @example
                       *
                       *     var wordArray = CryptoJS.lib.WordArray.create();
                       *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
                       *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
                       */
                      init: function init(words, sigBytes) {
                        words = this.words = words || [];
                        if (sigBytes != undefined2) {
                          this.sigBytes = sigBytes;
                        } else {
                          this.sigBytes = words.length * 4;
                        }
                      },
                      /**
                       * Converts this word array to a string.
                       *
                       * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
                       *
                       * @return {string} The stringified word array.
                       *
                       * @example
                       *
                       *     var string = wordArray + '';
                       *     var string = wordArray.toString();
                       *     var string = wordArray.toString(CryptoJS.enc.Utf8);
                       */
                      toString: function toString(encoder) {
                        return (encoder || Hex).stringify(this);
                      },
                      /**
                       * Concatenates a word array to this word array.
                       *
                       * @param {WordArray} wordArray The word array to append.
                       *
                       * @return {WordArray} This word array.
                       *
                       * @example
                       *
                       *     wordArray1.concat(wordArray2);
                       */
                      concat: function concat(wordArray) {
                        var thisWords = this.words;
                        var thatWords = wordArray.words;
                        var thisSigBytes = this.sigBytes;
                        var thatSigBytes = wordArray.sigBytes;
                        this.clamp();
                        if (thisSigBytes % 4) {
                          for (var i = 0; i < thatSigBytes; i++) {
                            var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                            thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
                          }
                        } else {
                          for (var j = 0; j < thatSigBytes; j += 4) {
                            thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
                          }
                        }
                        this.sigBytes += thatSigBytes;
                        return this;
                      },
                      /**
                       * Removes insignificant bits.
                       *
                       * @example
                       *
                       *     wordArray.clamp();
                       */
                      clamp: function clamp() {
                        var words = this.words;
                        var sigBytes = this.sigBytes;
                        words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
                        words.length = Math2.ceil(sigBytes / 4);
                      },
                      /**
                       * Creates a copy of this word array.
                       *
                       * @return {WordArray} The clone.
                       *
                       * @example
                       *
                       *     var clone = wordArray.clone();
                       */
                      clone: function clone() {
                        var clone2 = Base.clone.call(this);
                        clone2.words = this.words.slice(0);
                        return clone2;
                      },
                      /**
                       * Creates a word array filled with random bytes.
                       *
                       * @param {number} nBytes The number of random bytes to generate.
                       *
                       * @return {WordArray} The random word array.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var wordArray = CryptoJS.lib.WordArray.random(16);
                       */
                      random: function random(nBytes) {
                        var words = [];
                        for (var i = 0; i < nBytes; i += 4) {
                          words.push(cryptoSecureRandomInt());
                        }
                        return new WordArray.init(words, nBytes);
                      }
                    });
                    var C_enc = C.enc = {};
                    var Hex = C_enc.Hex = {
                      /**
                       * Converts a word array to a hex string.
                       *
                       * @param {WordArray} wordArray The word array.
                       *
                       * @return {string} The hex string.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
                       */
                      stringify: function stringify(wordArray) {
                        var words = wordArray.words;
                        var sigBytes = wordArray.sigBytes;
                        var hexChars = [];
                        for (var i = 0; i < sigBytes; i++) {
                          var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                          hexChars.push((bite >>> 4).toString(16));
                          hexChars.push((bite & 15).toString(16));
                        }
                        return hexChars.join("");
                      },
                      /**
                       * Converts a hex string to a word array.
                       *
                       * @param {string} hexStr The hex string.
                       *
                       * @return {WordArray} The word array.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
                       */
                      parse: function parse(hexStr) {
                        var hexStrLength = hexStr.length;
                        var words = [];
                        for (var i = 0; i < hexStrLength; i += 2) {
                          words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
                        }
                        return new WordArray.init(words, hexStrLength / 2);
                      }
                    };
                    var Latin1 = C_enc.Latin1 = {
                      /**
                       * Converts a word array to a Latin1 string.
                       *
                       * @param {WordArray} wordArray The word array.
                       *
                       * @return {string} The Latin1 string.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
                       */
                      stringify: function stringify(wordArray) {
                        var words = wordArray.words;
                        var sigBytes = wordArray.sigBytes;
                        var latin1Chars = [];
                        for (var i = 0; i < sigBytes; i++) {
                          var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                          latin1Chars.push(String.fromCharCode(bite));
                        }
                        return latin1Chars.join("");
                      },
                      /**
                       * Converts a Latin1 string to a word array.
                       *
                       * @param {string} latin1Str The Latin1 string.
                       *
                       * @return {WordArray} The word array.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
                       */
                      parse: function parse(latin1Str) {
                        var latin1StrLength = latin1Str.length;
                        var words = [];
                        for (var i = 0; i < latin1StrLength; i++) {
                          words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
                        }
                        return new WordArray.init(words, latin1StrLength);
                      }
                    };
                    var Utf8 = C_enc.Utf8 = {
                      /**
                       * Converts a word array to a UTF-8 string.
                       *
                       * @param {WordArray} wordArray The word array.
                       *
                       * @return {string} The UTF-8 string.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
                       */
                      stringify: function stringify(wordArray) {
                        try {
                          return decodeURIComponent(escape(Latin1.stringify(wordArray)));
                        } catch (e) {
                          throw new Error("Malformed UTF-8 data");
                        }
                      },
                      /**
                       * Converts a UTF-8 string to a word array.
                       *
                       * @param {string} utf8Str The UTF-8 string.
                       *
                       * @return {WordArray} The word array.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
                       */
                      parse: function parse(utf8Str) {
                        return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
                      }
                    };
                    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
                      /**
                       * Resets this block algorithm's data buffer to its initial state.
                       *
                       * @example
                       *
                       *     bufferedBlockAlgorithm.reset();
                       */
                      reset: function reset() {
                        this._data = new WordArray.init();
                        this._nDataBytes = 0;
                      },
                      /**
                       * Adds new data to this block algorithm's buffer.
                       *
                       * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
                       *
                       * @example
                       *
                       *     bufferedBlockAlgorithm._append('data');
                       *     bufferedBlockAlgorithm._append(wordArray);
                       */
                      _append: function _append(data) {
                        if (typeof data == "string") {
                          data = Utf8.parse(data);
                        }
                        this._data.concat(data);
                        this._nDataBytes += data.sigBytes;
                      },
                      /**
                       * Processes available data blocks.
                       *
                       * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
                       *
                       * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
                       *
                       * @return {WordArray} The processed data.
                       *
                       * @example
                       *
                       *     var processedData = bufferedBlockAlgorithm._process();
                       *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
                       */
                      _process: function _process(doFlush) {
                        var processedWords;
                        var data = this._data;
                        var dataWords = data.words;
                        var dataSigBytes = data.sigBytes;
                        var blockSize = this.blockSize;
                        var blockSizeBytes = blockSize * 4;
                        var nBlocksReady = dataSigBytes / blockSizeBytes;
                        if (doFlush) {
                          nBlocksReady = Math2.ceil(nBlocksReady);
                        } else {
                          nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
                        }
                        var nWordsReady = nBlocksReady * blockSize;
                        var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
                        if (nWordsReady) {
                          for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                            this._doProcessBlock(dataWords, offset);
                          }
                          processedWords = dataWords.splice(0, nWordsReady);
                          data.sigBytes -= nBytesReady;
                        }
                        return new WordArray.init(processedWords, nBytesReady);
                      },
                      /**
                       * Creates a copy of this object.
                       *
                       * @return {Object} The clone.
                       *
                       * @example
                       *
                       *     var clone = bufferedBlockAlgorithm.clone();
                       */
                      clone: function clone() {
                        var clone2 = Base.clone.call(this);
                        clone2._data = this._data.clone();
                        return clone2;
                      },
                      _minBufferSize: 0
                    });
                    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
                      /**
                       * Configuration options.
                       */
                      cfg: Base.extend(),
                      /**
                       * Initializes a newly created hasher.
                       *
                       * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
                       *
                       * @example
                       *
                       *     var hasher = CryptoJS.algo.SHA256.create();
                       */
                      init: function init(cfg) {
                        this.cfg = this.cfg.extend(cfg);
                        this.reset();
                      },
                      /**
                       * Resets this hasher to its initial state.
                       *
                       * @example
                       *
                       *     hasher.reset();
                       */
                      reset: function reset() {
                        BufferedBlockAlgorithm.reset.call(this);
                        this._doReset();
                      },
                      /**
                       * Updates this hasher with a message.
                       *
                       * @param {WordArray|string} messageUpdate The message to append.
                       *
                       * @return {Hasher} This hasher.
                       *
                       * @example
                       *
                       *     hasher.update('message');
                       *     hasher.update(wordArray);
                       */
                      update: function update(messageUpdate) {
                        this._append(messageUpdate);
                        this._process();
                        return this;
                      },
                      /**
                       * Finalizes the hash computation.
                       * Note that the finalize operation is effectively a destructive, read-once operation.
                       *
                       * @param {WordArray|string} messageUpdate (Optional) A final message update.
                       *
                       * @return {WordArray} The hash.
                       *
                       * @example
                       *
                       *     var hash = hasher.finalize();
                       *     var hash = hasher.finalize('message');
                       *     var hash = hasher.finalize(wordArray);
                       */
                      finalize: function finalize(messageUpdate) {
                        if (messageUpdate) {
                          this._append(messageUpdate);
                        }
                        var hash = this._doFinalize();
                        return hash;
                      },
                      blockSize: 512 / 32,
                      /**
                       * Creates a shortcut function to a hasher's object interface.
                       *
                       * @param {Hasher} hasher The hasher to create a helper for.
                       *
                       * @return {Function} The shortcut function.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
                       */
                      _createHelper: function _createHelper(hasher) {
                        return function(message, cfg) {
                          return new hasher.init(cfg).finalize(message);
                        };
                      },
                      /**
                       * Creates a shortcut function to the HMAC's object interface.
                       *
                       * @param {Hasher} hasher The hasher to use in this HMAC helper.
                       *
                       * @return {Function} The shortcut function.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
                       */
                      _createHmacHelper: function _createHmacHelper(hasher) {
                        return function(message, key) {
                          return new C_algo.HMAC.init(hasher, key).finalize(message);
                        };
                      }
                    });
                    var C_algo = C.algo = {};
                    return C;
                  }(Math);
                  return CryptoJS;
                });
              }
            ),
            /***/
            7508: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(9600);
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var C_enc = C.enc;
                    var Base64 = C_enc.Base64 = {
                      /**
                       * Converts a word array to a Base64 string.
                       *
                       * @param {WordArray} wordArray The word array.
                       *
                       * @return {string} The Base64 string.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
                       */
                      stringify: function stringify(wordArray) {
                        var words = wordArray.words;
                        var sigBytes = wordArray.sigBytes;
                        var map = this._map;
                        wordArray.clamp();
                        var base64Chars = [];
                        for (var i = 0; i < sigBytes; i += 3) {
                          var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                          var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
                          var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
                          var triplet = byte1 << 16 | byte2 << 8 | byte3;
                          for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                            base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
                          }
                        }
                        var paddingChar = map.charAt(64);
                        if (paddingChar) {
                          while (base64Chars.length % 4) {
                            base64Chars.push(paddingChar);
                          }
                        }
                        return base64Chars.join("");
                      },
                      /**
                       * Converts a Base64 string to a word array.
                       *
                       * @param {string} base64Str The Base64 string.
                       *
                       * @return {WordArray} The word array.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
                       */
                      parse: function parse(base64Str) {
                        var base64StrLength = base64Str.length;
                        var map = this._map;
                        var reverseMap = this._reverseMap;
                        if (!reverseMap) {
                          reverseMap = this._reverseMap = [];
                          for (var j = 0; j < map.length; j++) {
                            reverseMap[map.charCodeAt(j)] = j;
                          }
                        }
                        var paddingChar = map.charAt(64);
                        if (paddingChar) {
                          var paddingIndex = base64Str.indexOf(paddingChar);
                          if (paddingIndex !== -1) {
                            base64StrLength = paddingIndex;
                          }
                        }
                        return parseLoop(base64Str, base64StrLength, reverseMap);
                      },
                      _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
                    };
                    function parseLoop(base64Str, base64StrLength, reverseMap) {
                      var words = [];
                      var nBytes = 0;
                      for (var i = 0; i < base64StrLength; i++) {
                        if (i % 4) {
                          var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
                          var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
                          var bitsCombined = bits1 | bits2;
                          words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                          nBytes++;
                        }
                      }
                      return WordArray.create(words, nBytes);
                    }
                  })();
                  return CryptoJS.enc.Base64;
                });
              }
            ),
            /***/
            7590: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(9600);
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var C_enc = C.enc;
                    var Base64url = C_enc.Base64url = {
                      /**
                       * Converts a word array to a Base64url string.
                       *
                       * @param {WordArray} wordArray The word array.
                       *
                       * @param {boolean} urlSafe Whether to use url safe
                       *
                       * @return {string} The Base64url string.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
                       */
                      stringify: function stringify(wordArray, urlSafe) {
                        if (urlSafe === void 0) {
                          urlSafe = true;
                        }
                        var words = wordArray.words;
                        var sigBytes = wordArray.sigBytes;
                        var map = urlSafe ? this._safe_map : this._map;
                        wordArray.clamp();
                        var base64Chars = [];
                        for (var i = 0; i < sigBytes; i += 3) {
                          var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                          var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
                          var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
                          var triplet = byte1 << 16 | byte2 << 8 | byte3;
                          for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                            base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
                          }
                        }
                        var paddingChar = map.charAt(64);
                        if (paddingChar) {
                          while (base64Chars.length % 4) {
                            base64Chars.push(paddingChar);
                          }
                        }
                        return base64Chars.join("");
                      },
                      /**
                       * Converts a Base64url string to a word array.
                       *
                       * @param {string} base64Str The Base64url string.
                       *
                       * @param {boolean} urlSafe Whether to use url safe
                       *
                       * @return {WordArray} The word array.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
                       */
                      parse: function parse(base64Str, urlSafe) {
                        if (urlSafe === void 0) {
                          urlSafe = true;
                        }
                        var base64StrLength = base64Str.length;
                        var map = urlSafe ? this._safe_map : this._map;
                        var reverseMap = this._reverseMap;
                        if (!reverseMap) {
                          reverseMap = this._reverseMap = [];
                          for (var j = 0; j < map.length; j++) {
                            reverseMap[map.charCodeAt(j)] = j;
                          }
                        }
                        var paddingChar = map.charAt(64);
                        if (paddingChar) {
                          var paddingIndex = base64Str.indexOf(paddingChar);
                          if (paddingIndex !== -1) {
                            base64StrLength = paddingIndex;
                          }
                        }
                        return parseLoop(base64Str, base64StrLength, reverseMap);
                      },
                      _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                      _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
                    };
                    function parseLoop(base64Str, base64StrLength, reverseMap) {
                      var words = [];
                      var nBytes = 0;
                      for (var i = 0; i < base64StrLength; i++) {
                        if (i % 4) {
                          var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
                          var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
                          var bitsCombined = bits1 | bits2;
                          words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                          nBytes++;
                        }
                      }
                      return WordArray.create(words, nBytes);
                    }
                  })();
                  return CryptoJS.enc.Base64url;
                });
              }
            ),
            /***/
            4978: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(9600);
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var C_enc = C.enc;
                    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
                      /**
                       * Converts a word array to a UTF-16 BE string.
                       *
                       * @param {WordArray} wordArray The word array.
                       *
                       * @return {string} The UTF-16 BE string.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
                       */
                      stringify: function stringify(wordArray) {
                        var words = wordArray.words;
                        var sigBytes = wordArray.sigBytes;
                        var utf16Chars = [];
                        for (var i = 0; i < sigBytes; i += 2) {
                          var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
                          utf16Chars.push(String.fromCharCode(codePoint));
                        }
                        return utf16Chars.join("");
                      },
                      /**
                       * Converts a UTF-16 BE string to a word array.
                       *
                       * @param {string} utf16Str The UTF-16 BE string.
                       *
                       * @return {WordArray} The word array.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
                       */
                      parse: function parse(utf16Str) {
                        var utf16StrLength = utf16Str.length;
                        var words = [];
                        for (var i = 0; i < utf16StrLength; i++) {
                          words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
                        }
                        return WordArray.create(words, utf16StrLength * 2);
                      }
                    };
                    C_enc.Utf16LE = {
                      /**
                       * Converts a word array to a UTF-16 LE string.
                       *
                       * @param {WordArray} wordArray The word array.
                       *
                       * @return {string} The UTF-16 LE string.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
                       */
                      stringify: function stringify(wordArray) {
                        var words = wordArray.words;
                        var sigBytes = wordArray.sigBytes;
                        var utf16Chars = [];
                        for (var i = 0; i < sigBytes; i += 2) {
                          var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
                          utf16Chars.push(String.fromCharCode(codePoint));
                        }
                        return utf16Chars.join("");
                      },
                      /**
                       * Converts a UTF-16 LE string to a word array.
                       *
                       * @param {string} utf16Str The UTF-16 LE string.
                       *
                       * @return {WordArray} The word array.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
                       */
                      parse: function parse(utf16Str) {
                        var utf16StrLength = utf16Str.length;
                        var words = [];
                        for (var i = 0; i < utf16StrLength; i++) {
                          words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
                        }
                        return WordArray.create(words, utf16StrLength * 2);
                      }
                    };
                    function swapEndian(word) {
                      return word << 8 & 4278255360 | word >>> 8 & 16711935;
                    }
                  })();
                  return CryptoJS.enc.Utf16;
                });
              }
            ),
            /***/
            3839: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(2222);
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(9865), __webpack_require__2(6727));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var Base = C_lib.Base;
                    var WordArray = C_lib.WordArray;
                    var C_algo = C.algo;
                    var MD5 = C_algo.MD5;
                    var EvpKDF = C_algo.EvpKDF = Base.extend({
                      /**
                       * Configuration options.
                       *
                       * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
                       * @property {Hasher} hasher The hash algorithm to use. Default: MD5
                       * @property {number} iterations The number of iterations to perform. Default: 1
                       */
                      cfg: Base.extend({
                        keySize: 128 / 32,
                        hasher: MD5,
                        iterations: 1
                      }),
                      /**
                       * Initializes a newly created key derivation function.
                       *
                       * @param {Object} cfg (Optional) The configuration options to use for the derivation.
                       *
                       * @example
                       *
                       *     var kdf = CryptoJS.algo.EvpKDF.create();
                       *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
                       *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
                       */
                      init: function init(cfg) {
                        this.cfg = this.cfg.extend(cfg);
                      },
                      /**
                       * Derives a key from a password.
                       *
                       * @param {WordArray|string} password The password.
                       * @param {WordArray|string} salt A salt.
                       *
                       * @return {WordArray} The derived key.
                       *
                       * @example
                       *
                       *     var key = kdf.compute(password, salt);
                       */
                      compute: function compute(password, salt) {
                        var block;
                        var cfg = this.cfg;
                        var hasher = cfg.hasher.create();
                        var derivedKey = WordArray.create();
                        var derivedKeyWords = derivedKey.words;
                        var keySize = cfg.keySize;
                        var iterations = cfg.iterations;
                        while (derivedKeyWords.length < keySize) {
                          if (block) {
                            hasher.update(block);
                          }
                          block = hasher.update(password).finalize(salt);
                          hasher.reset();
                          for (var i = 1; i < iterations; i++) {
                            block = hasher.finalize(block);
                            hasher.reset();
                          }
                          derivedKey.concat(block);
                        }
                        derivedKey.sigBytes = keySize * 4;
                        return derivedKey;
                      }
                    });
                    C.EvpKDF = function(password, salt, cfg) {
                      return EvpKDF.create(cfg).compute(password, salt);
                    };
                  })();
                  return CryptoJS.EvpKDF;
                });
              }
            ),
            /***/
            8942: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(1539);
                __webpack_require__2(9714);
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(1582));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function(undefined2) {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var CipherParams = C_lib.CipherParams;
                    var C_enc = C.enc;
                    var Hex = C_enc.Hex;
                    var C_format = C.format;
                    var HexFormatter = C_format.Hex = {
                      /**
                       * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
                       *
                       * @param {CipherParams} cipherParams The cipher params object.
                       *
                       * @return {string} The hexadecimally encoded string.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
                       */
                      stringify: function stringify(cipherParams) {
                        return cipherParams.ciphertext.toString(Hex);
                      },
                      /**
                       * Converts a hexadecimally encoded ciphertext string to a cipher params object.
                       *
                       * @param {string} input The hexadecimally encoded string.
                       *
                       * @return {CipherParams} The cipher params object.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
                       */
                      parse: function parse(input) {
                        var ciphertext = Hex.parse(input);
                        return CipherParams.create({
                          ciphertext
                        });
                      }
                    };
                  })();
                  return CryptoJS.format.Hex;
                });
              }
            ),
            /***/
            6727: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(2222);
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var Base = C_lib.Base;
                    var C_enc = C.enc;
                    var Utf8 = C_enc.Utf8;
                    var C_algo = C.algo;
                    var HMAC = C_algo.HMAC = Base.extend({
                      /**
                       * Initializes a newly created HMAC.
                       *
                       * @param {Hasher} hasher The hash algorithm to use.
                       * @param {WordArray|string} key The secret key.
                       *
                       * @example
                       *
                       *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
                       */
                      init: function init(hasher, key) {
                        hasher = this._hasher = new hasher.init();
                        if (typeof key == "string") {
                          key = Utf8.parse(key);
                        }
                        var hasherBlockSize = hasher.blockSize;
                        var hasherBlockSizeBytes = hasherBlockSize * 4;
                        if (key.sigBytes > hasherBlockSizeBytes) {
                          key = hasher.finalize(key);
                        }
                        key.clamp();
                        var oKey = this._oKey = key.clone();
                        var iKey = this._iKey = key.clone();
                        var oKeyWords = oKey.words;
                        var iKeyWords = iKey.words;
                        for (var i = 0; i < hasherBlockSize; i++) {
                          oKeyWords[i] ^= 1549556828;
                          iKeyWords[i] ^= 909522486;
                        }
                        oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
                        this.reset();
                      },
                      /**
                       * Resets this HMAC to its initial state.
                       *
                       * @example
                       *
                       *     hmacHasher.reset();
                       */
                      reset: function reset() {
                        var hasher = this._hasher;
                        hasher.reset();
                        hasher.update(this._iKey);
                      },
                      /**
                       * Updates this HMAC with a message.
                       *
                       * @param {WordArray|string} messageUpdate The message to append.
                       *
                       * @return {HMAC} This HMAC instance.
                       *
                       * @example
                       *
                       *     hmacHasher.update('message');
                       *     hmacHasher.update(wordArray);
                       */
                      update: function update(messageUpdate) {
                        this._hasher.update(messageUpdate);
                        return this;
                      },
                      /**
                       * Finalizes the HMAC computation.
                       * Note that the finalize operation is effectively a destructive, read-once operation.
                       *
                       * @param {WordArray|string} messageUpdate (Optional) A final message update.
                       *
                       * @return {WordArray} The HMAC.
                       *
                       * @example
                       *
                       *     var hmac = hmacHasher.finalize();
                       *     var hmac = hmacHasher.finalize('message');
                       *     var hmac = hmacHasher.finalize(wordArray);
                       */
                      finalize: function finalize(messageUpdate) {
                        var hasher = this._hasher;
                        var innerHash = hasher.finalize(messageUpdate);
                        hasher.reset();
                        var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
                        return hmac;
                      }
                    });
                  })();
                });
              }
            ),
            /***/
            5153: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(2601), __webpack_require__2(1947), __webpack_require__2(4978), __webpack_require__2(7508), __webpack_require__2(7590), __webpack_require__2(3440), __webpack_require__2(9865), __webpack_require__2(8921), __webpack_require__2(6876), __webpack_require__2(7991), __webpack_require__2(8122), __webpack_require__2(8342), __webpack_require__2(8714), __webpack_require__2(6727), __webpack_require__2(3486), __webpack_require__2(3839), __webpack_require__2(1582), __webpack_require__2(702), __webpack_require__2(2362), __webpack_require__2(4412), __webpack_require__2(5720), __webpack_require__2(3518), __webpack_require__2(6362), __webpack_require__2(4431), __webpack_require__2(8800), __webpack_require__2(3992), __webpack_require__2(649), __webpack_require__2(8942), __webpack_require__2(194), __webpack_require__2(8437), __webpack_require__2(4640), __webpack_require__2(5323), __webpack_require__2(4363));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  return CryptoJS;
                });
              }
            ),
            /***/
            1947: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(7803);
                __webpack_require__2(1539);
                __webpack_require__2(6992);
                __webpack_require__2(2472);
                __webpack_require__2(2990);
                __webpack_require__2(8927);
                __webpack_require__2(3105);
                __webpack_require__2(5035);
                __webpack_require__2(4345);
                __webpack_require__2(7174);
                __webpack_require__2(2846);
                __webpack_require__2(4731);
                __webpack_require__2(7209);
                __webpack_require__2(6319);
                __webpack_require__2(8867);
                __webpack_require__2(7789);
                __webpack_require__2(3739);
                __webpack_require__2(9368);
                __webpack_require__2(4483);
                __webpack_require__2(2056);
                __webpack_require__2(3462);
                __webpack_require__2(678);
                __webpack_require__2(7462);
                __webpack_require__2(3824);
                __webpack_require__2(5021);
                __webpack_require__2(2974);
                __webpack_require__2(5016);
                __webpack_require__2(7145);
                __webpack_require__2(9743);
                __webpack_require__2(5109);
                __webpack_require__2(8255);
                __webpack_require__2(5125);
                __webpack_require__2(9135);
                __webpack_require__2(4197);
                __webpack_require__2(6495);
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function() {
                    if (typeof ArrayBuffer != "function") {
                      return;
                    }
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var superInit = WordArray.init;
                    var subInit = WordArray.init = function(typedArray) {
                      if (typedArray instanceof ArrayBuffer) {
                        typedArray = new Uint8Array(typedArray);
                      }
                      if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
                        typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
                      }
                      if (typedArray instanceof Uint8Array) {
                        var typedArrayByteLength = typedArray.byteLength;
                        var words = [];
                        for (var i = 0; i < typedArrayByteLength; i++) {
                          words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
                        }
                        superInit.call(this, words, typedArrayByteLength);
                      } else {
                        superInit.apply(this, arguments);
                      }
                    };
                    subInit.prototype = WordArray;
                  })();
                  return CryptoJS.lib.WordArray;
                });
              }
            ),
            /***/
            3440: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function(Math2) {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var Hasher = C_lib.Hasher;
                    var C_algo = C.algo;
                    var T = [];
                    (function() {
                      for (var i = 0; i < 64; i++) {
                        T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
                      }
                    })();
                    var MD5 = C_algo.MD5 = Hasher.extend({
                      _doReset: function _doReset() {
                        this._hash = new WordArray.init([1732584193, 4023233417, 2562383102, 271733878]);
                      },
                      _doProcessBlock: function _doProcessBlock(M, offset) {
                        for (var i = 0; i < 16; i++) {
                          var offset_i = offset + i;
                          var M_offset_i = M[offset_i];
                          M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
                        }
                        var H = this._hash.words;
                        var M_offset_0 = M[offset + 0];
                        var M_offset_1 = M[offset + 1];
                        var M_offset_2 = M[offset + 2];
                        var M_offset_3 = M[offset + 3];
                        var M_offset_4 = M[offset + 4];
                        var M_offset_5 = M[offset + 5];
                        var M_offset_6 = M[offset + 6];
                        var M_offset_7 = M[offset + 7];
                        var M_offset_8 = M[offset + 8];
                        var M_offset_9 = M[offset + 9];
                        var M_offset_10 = M[offset + 10];
                        var M_offset_11 = M[offset + 11];
                        var M_offset_12 = M[offset + 12];
                        var M_offset_13 = M[offset + 13];
                        var M_offset_14 = M[offset + 14];
                        var M_offset_15 = M[offset + 15];
                        var a = H[0];
                        var b = H[1];
                        var c = H[2];
                        var d = H[3];
                        a = FF(a, b, c, d, M_offset_0, 7, T[0]);
                        d = FF(d, a, b, c, M_offset_1, 12, T[1]);
                        c = FF(c, d, a, b, M_offset_2, 17, T[2]);
                        b = FF(b, c, d, a, M_offset_3, 22, T[3]);
                        a = FF(a, b, c, d, M_offset_4, 7, T[4]);
                        d = FF(d, a, b, c, M_offset_5, 12, T[5]);
                        c = FF(c, d, a, b, M_offset_6, 17, T[6]);
                        b = FF(b, c, d, a, M_offset_7, 22, T[7]);
                        a = FF(a, b, c, d, M_offset_8, 7, T[8]);
                        d = FF(d, a, b, c, M_offset_9, 12, T[9]);
                        c = FF(c, d, a, b, M_offset_10, 17, T[10]);
                        b = FF(b, c, d, a, M_offset_11, 22, T[11]);
                        a = FF(a, b, c, d, M_offset_12, 7, T[12]);
                        d = FF(d, a, b, c, M_offset_13, 12, T[13]);
                        c = FF(c, d, a, b, M_offset_14, 17, T[14]);
                        b = FF(b, c, d, a, M_offset_15, 22, T[15]);
                        a = GG(a, b, c, d, M_offset_1, 5, T[16]);
                        d = GG(d, a, b, c, M_offset_6, 9, T[17]);
                        c = GG(c, d, a, b, M_offset_11, 14, T[18]);
                        b = GG(b, c, d, a, M_offset_0, 20, T[19]);
                        a = GG(a, b, c, d, M_offset_5, 5, T[20]);
                        d = GG(d, a, b, c, M_offset_10, 9, T[21]);
                        c = GG(c, d, a, b, M_offset_15, 14, T[22]);
                        b = GG(b, c, d, a, M_offset_4, 20, T[23]);
                        a = GG(a, b, c, d, M_offset_9, 5, T[24]);
                        d = GG(d, a, b, c, M_offset_14, 9, T[25]);
                        c = GG(c, d, a, b, M_offset_3, 14, T[26]);
                        b = GG(b, c, d, a, M_offset_8, 20, T[27]);
                        a = GG(a, b, c, d, M_offset_13, 5, T[28]);
                        d = GG(d, a, b, c, M_offset_2, 9, T[29]);
                        c = GG(c, d, a, b, M_offset_7, 14, T[30]);
                        b = GG(b, c, d, a, M_offset_12, 20, T[31]);
                        a = HH(a, b, c, d, M_offset_5, 4, T[32]);
                        d = HH(d, a, b, c, M_offset_8, 11, T[33]);
                        c = HH(c, d, a, b, M_offset_11, 16, T[34]);
                        b = HH(b, c, d, a, M_offset_14, 23, T[35]);
                        a = HH(a, b, c, d, M_offset_1, 4, T[36]);
                        d = HH(d, a, b, c, M_offset_4, 11, T[37]);
                        c = HH(c, d, a, b, M_offset_7, 16, T[38]);
                        b = HH(b, c, d, a, M_offset_10, 23, T[39]);
                        a = HH(a, b, c, d, M_offset_13, 4, T[40]);
                        d = HH(d, a, b, c, M_offset_0, 11, T[41]);
                        c = HH(c, d, a, b, M_offset_3, 16, T[42]);
                        b = HH(b, c, d, a, M_offset_6, 23, T[43]);
                        a = HH(a, b, c, d, M_offset_9, 4, T[44]);
                        d = HH(d, a, b, c, M_offset_12, 11, T[45]);
                        c = HH(c, d, a, b, M_offset_15, 16, T[46]);
                        b = HH(b, c, d, a, M_offset_2, 23, T[47]);
                        a = II(a, b, c, d, M_offset_0, 6, T[48]);
                        d = II(d, a, b, c, M_offset_7, 10, T[49]);
                        c = II(c, d, a, b, M_offset_14, 15, T[50]);
                        b = II(b, c, d, a, M_offset_5, 21, T[51]);
                        a = II(a, b, c, d, M_offset_12, 6, T[52]);
                        d = II(d, a, b, c, M_offset_3, 10, T[53]);
                        c = II(c, d, a, b, M_offset_10, 15, T[54]);
                        b = II(b, c, d, a, M_offset_1, 21, T[55]);
                        a = II(a, b, c, d, M_offset_8, 6, T[56]);
                        d = II(d, a, b, c, M_offset_15, 10, T[57]);
                        c = II(c, d, a, b, M_offset_6, 15, T[58]);
                        b = II(b, c, d, a, M_offset_13, 21, T[59]);
                        a = II(a, b, c, d, M_offset_4, 6, T[60]);
                        d = II(d, a, b, c, M_offset_11, 10, T[61]);
                        c = II(c, d, a, b, M_offset_2, 15, T[62]);
                        b = II(b, c, d, a, M_offset_9, 21, T[63]);
                        H[0] = H[0] + a | 0;
                        H[1] = H[1] + b | 0;
                        H[2] = H[2] + c | 0;
                        H[3] = H[3] + d | 0;
                      },
                      _doFinalize: function _doFinalize() {
                        var data = this._data;
                        var dataWords = data.words;
                        var nBitsTotal = this._nDataBytes * 8;
                        var nBitsLeft = data.sigBytes * 8;
                        dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                        var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
                        var nBitsTotalL = nBitsTotal;
                        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
                        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
                        data.sigBytes = (dataWords.length + 1) * 4;
                        this._process();
                        var hash = this._hash;
                        var H = hash.words;
                        for (var i = 0; i < 4; i++) {
                          var H_i = H[i];
                          H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
                        }
                        return hash;
                      },
                      clone: function clone() {
                        var clone2 = Hasher.clone.call(this);
                        clone2._hash = this._hash.clone();
                        return clone2;
                      }
                    });
                    function FF(a, b, c, d, x, s, t) {
                      var n = a + (b & c | ~b & d) + x + t;
                      return (n << s | n >>> 32 - s) + b;
                    }
                    function GG(a, b, c, d, x, s, t) {
                      var n = a + (b & d | c & ~d) + x + t;
                      return (n << s | n >>> 32 - s) + b;
                    }
                    function HH(a, b, c, d, x, s, t) {
                      var n = a + (b ^ c ^ d) + x + t;
                      return (n << s | n >>> 32 - s) + b;
                    }
                    function II(a, b, c, d, x, s, t) {
                      var n = a + (c ^ (b | ~d)) + x + t;
                      return (n << s | n >>> 32 - s) + b;
                    }
                    C.MD5 = Hasher._createHelper(MD5);
                    C.HmacMD5 = Hasher._createHmacHelper(MD5);
                  })(Math);
                  return CryptoJS.MD5;
                });
              }
            ),
            /***/
            702: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(7042);
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(1582));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  CryptoJS.mode.CFB = function() {
                    var CFB = CryptoJS.lib.BlockCipherMode.extend();
                    CFB.Encryptor = CFB.extend({
                      processBlock: function processBlock(words, offset) {
                        var cipher = this._cipher;
                        var blockSize = cipher.blockSize;
                        generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
                        this._prevBlock = words.slice(offset, offset + blockSize);
                      }
                    });
                    CFB.Decryptor = CFB.extend({
                      processBlock: function processBlock(words, offset) {
                        var cipher = this._cipher;
                        var blockSize = cipher.blockSize;
                        var thisBlock = words.slice(offset, offset + blockSize);
                        generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
                        this._prevBlock = thisBlock;
                      }
                    });
                    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
                      var keystream;
                      var iv = this._iv;
                      if (iv) {
                        keystream = iv.slice(0);
                        this._iv = void 0;
                      } else {
                        keystream = this._prevBlock;
                      }
                      cipher.encryptBlock(keystream, 0);
                      for (var i = 0; i < blockSize; i++) {
                        words[offset + i] ^= keystream[i];
                      }
                    }
                    return CFB;
                  }();
                  return CryptoJS.mode.CFB;
                });
              }
            ),
            /***/
            4412: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(7042);
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(1582));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  CryptoJS.mode.CTRGladman = function() {
                    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
                    function incWord(word) {
                      if ((word >> 24 & 255) === 255) {
                        var b1 = word >> 16 & 255;
                        var b2 = word >> 8 & 255;
                        var b3 = word & 255;
                        if (b1 === 255) {
                          b1 = 0;
                          if (b2 === 255) {
                            b2 = 0;
                            if (b3 === 255) {
                              b3 = 0;
                            } else {
                              ++b3;
                            }
                          } else {
                            ++b2;
                          }
                        } else {
                          ++b1;
                        }
                        word = 0;
                        word += b1 << 16;
                        word += b2 << 8;
                        word += b3;
                      } else {
                        word += 1 << 24;
                      }
                      return word;
                    }
                    function incCounter(counter) {
                      if ((counter[0] = incWord(counter[0])) === 0) {
                        counter[1] = incWord(counter[1]);
                      }
                      return counter;
                    }
                    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
                      processBlock: function processBlock(words, offset) {
                        var cipher = this._cipher;
                        var blockSize = cipher.blockSize;
                        var iv = this._iv;
                        var counter = this._counter;
                        if (iv) {
                          counter = this._counter = iv.slice(0);
                          this._iv = void 0;
                        }
                        incCounter(counter);
                        var keystream = counter.slice(0);
                        cipher.encryptBlock(keystream, 0);
                        for (var i = 0; i < blockSize; i++) {
                          words[offset + i] ^= keystream[i];
                        }
                      }
                    });
                    CTRGladman.Decryptor = Encryptor;
                    return CTRGladman;
                  }();
                  return CryptoJS.mode.CTRGladman;
                });
              }
            ),
            /***/
            2362: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(7042);
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(1582));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  CryptoJS.mode.CTR = function() {
                    var CTR = CryptoJS.lib.BlockCipherMode.extend();
                    var Encryptor = CTR.Encryptor = CTR.extend({
                      processBlock: function processBlock(words, offset) {
                        var cipher = this._cipher;
                        var blockSize = cipher.blockSize;
                        var iv = this._iv;
                        var counter = this._counter;
                        if (iv) {
                          counter = this._counter = iv.slice(0);
                          this._iv = void 0;
                        }
                        var keystream = counter.slice(0);
                        cipher.encryptBlock(keystream, 0);
                        counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
                        for (var i = 0; i < blockSize; i++) {
                          words[offset + i] ^= keystream[i];
                        }
                      }
                    });
                    CTR.Decryptor = Encryptor;
                    return CTR;
                  }();
                  return CryptoJS.mode.CTR;
                });
              }
            ),
            /***/
            3518: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(1582));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  CryptoJS.mode.ECB = function() {
                    var ECB = CryptoJS.lib.BlockCipherMode.extend();
                    ECB.Encryptor = ECB.extend({
                      processBlock: function processBlock(words, offset) {
                        this._cipher.encryptBlock(words, offset);
                      }
                    });
                    ECB.Decryptor = ECB.extend({
                      processBlock: function processBlock(words, offset) {
                        this._cipher.decryptBlock(words, offset);
                      }
                    });
                    return ECB;
                  }();
                  return CryptoJS.mode.ECB;
                });
              }
            ),
            /***/
            5720: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(7042);
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(1582));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  CryptoJS.mode.OFB = function() {
                    var OFB = CryptoJS.lib.BlockCipherMode.extend();
                    var Encryptor = OFB.Encryptor = OFB.extend({
                      processBlock: function processBlock(words, offset) {
                        var cipher = this._cipher;
                        var blockSize = cipher.blockSize;
                        var iv = this._iv;
                        var keystream = this._keystream;
                        if (iv) {
                          keystream = this._keystream = iv.slice(0);
                          this._iv = void 0;
                        }
                        cipher.encryptBlock(keystream, 0);
                        for (var i = 0; i < blockSize; i++) {
                          words[offset + i] ^= keystream[i];
                        }
                      }
                    });
                    OFB.Decryptor = Encryptor;
                    return OFB;
                  }();
                  return CryptoJS.mode.OFB;
                });
              }
            ),
            /***/
            6362: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(1582));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  CryptoJS.pad.AnsiX923 = {
                    pad: function pad(data, blockSize) {
                      var dataSigBytes = data.sigBytes;
                      var blockSizeBytes = blockSize * 4;
                      var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
                      var lastBytePos = dataSigBytes + nPaddingBytes - 1;
                      data.clamp();
                      data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
                      data.sigBytes += nPaddingBytes;
                    },
                    unpad: function unpad(data) {
                      var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
                      data.sigBytes -= nPaddingBytes;
                    }
                  };
                  return CryptoJS.pad.Ansix923;
                });
              }
            ),
            /***/
            4431: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(2222);
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(1582));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  CryptoJS.pad.Iso10126 = {
                    pad: function pad(data, blockSize) {
                      var blockSizeBytes = blockSize * 4;
                      var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
                      data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
                    },
                    unpad: function unpad(data) {
                      var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
                      data.sigBytes -= nPaddingBytes;
                    }
                  };
                  return CryptoJS.pad.Iso10126;
                });
              }
            ),
            /***/
            8800: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(2222);
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(1582));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  CryptoJS.pad.Iso97971 = {
                    pad: function pad(data, blockSize) {
                      data.concat(CryptoJS.lib.WordArray.create([2147483648], 1));
                      CryptoJS.pad.ZeroPadding.pad(data, blockSize);
                    },
                    unpad: function unpad(data) {
                      CryptoJS.pad.ZeroPadding.unpad(data);
                      data.sigBytes--;
                    }
                  };
                  return CryptoJS.pad.Iso97971;
                });
              }
            ),
            /***/
            649: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(1582));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  CryptoJS.pad.NoPadding = {
                    pad: function pad() {
                    },
                    unpad: function unpad() {
                    }
                  };
                  return CryptoJS.pad.NoPadding;
                });
              }
            ),
            /***/
            3992: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(1582));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  CryptoJS.pad.ZeroPadding = {
                    pad: function pad(data, blockSize) {
                      var blockSizeBytes = blockSize * 4;
                      data.clamp();
                      data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
                    },
                    unpad: function unpad(data) {
                      var dataWords = data.words;
                      var i = data.sigBytes - 1;
                      for (var i = data.sigBytes - 1; i >= 0; i--) {
                        if (dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 255) {
                          data.sigBytes = i + 1;
                          break;
                        }
                      }
                    }
                  };
                  return CryptoJS.pad.ZeroPadding;
                });
              }
            ),
            /***/
            3486: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(2222);
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(9865), __webpack_require__2(6727));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var Base = C_lib.Base;
                    var WordArray = C_lib.WordArray;
                    var C_algo = C.algo;
                    var SHA1 = C_algo.SHA1;
                    var HMAC = C_algo.HMAC;
                    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
                      /**
                       * Configuration options.
                       *
                       * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
                       * @property {Hasher} hasher The hasher to use. Default: SHA1
                       * @property {number} iterations The number of iterations to perform. Default: 1
                       */
                      cfg: Base.extend({
                        keySize: 128 / 32,
                        hasher: SHA1,
                        iterations: 1
                      }),
                      /**
                       * Initializes a newly created key derivation function.
                       *
                       * @param {Object} cfg (Optional) The configuration options to use for the derivation.
                       *
                       * @example
                       *
                       *     var kdf = CryptoJS.algo.PBKDF2.create();
                       *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
                       *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
                       */
                      init: function init(cfg) {
                        this.cfg = this.cfg.extend(cfg);
                      },
                      /**
                       * Computes the Password-Based Key Derivation Function 2.
                       *
                       * @param {WordArray|string} password The password.
                       * @param {WordArray|string} salt A salt.
                       *
                       * @return {WordArray} The derived key.
                       *
                       * @example
                       *
                       *     var key = kdf.compute(password, salt);
                       */
                      compute: function compute(password, salt) {
                        var cfg = this.cfg;
                        var hmac = HMAC.create(cfg.hasher, password);
                        var derivedKey = WordArray.create();
                        var blockIndex = WordArray.create([1]);
                        var derivedKeyWords = derivedKey.words;
                        var blockIndexWords = blockIndex.words;
                        var keySize = cfg.keySize;
                        var iterations = cfg.iterations;
                        while (derivedKeyWords.length < keySize) {
                          var block = hmac.update(salt).finalize(blockIndex);
                          hmac.reset();
                          var blockWords = block.words;
                          var blockWordsLength = blockWords.length;
                          var intermediate = block;
                          for (var i = 1; i < iterations; i++) {
                            intermediate = hmac.finalize(intermediate);
                            hmac.reset();
                            var intermediateWords = intermediate.words;
                            for (var j = 0; j < blockWordsLength; j++) {
                              blockWords[j] ^= intermediateWords[j];
                            }
                          }
                          derivedKey.concat(block);
                          blockIndexWords[0]++;
                        }
                        derivedKey.sigBytes = keySize * 4;
                        return derivedKey;
                      }
                    });
                    C.PBKDF2 = function(password, salt, cfg) {
                      return PBKDF2.create(cfg).compute(password, salt);
                    };
                  })();
                  return CryptoJS.PBKDF2;
                });
              }
            ),
            /***/
            4363: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(7508), __webpack_require__2(3440), __webpack_require__2(3839), __webpack_require__2(1582));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var StreamCipher = C_lib.StreamCipher;
                    var C_algo = C.algo;
                    var S = [];
                    var C_ = [];
                    var G = [];
                    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
                      _doReset: function _doReset() {
                        var K = this._key.words;
                        var iv = this.cfg.iv;
                        var X = this._X = [K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16];
                        var C2 = this._C = [K[2] << 16 | K[2] >>> 16, K[0] & 4294901760 | K[1] & 65535, K[3] << 16 | K[3] >>> 16, K[1] & 4294901760 | K[2] & 65535, K[0] << 16 | K[0] >>> 16, K[2] & 4294901760 | K[3] & 65535, K[1] << 16 | K[1] >>> 16, K[3] & 4294901760 | K[0] & 65535];
                        this._b = 0;
                        for (var i = 0; i < 4; i++) {
                          nextState.call(this);
                        }
                        for (var i = 0; i < 8; i++) {
                          C2[i] ^= X[i + 4 & 7];
                        }
                        if (iv) {
                          var IV = iv.words;
                          var IV_0 = IV[0];
                          var IV_1 = IV[1];
                          var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                          var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                          var i1 = i0 >>> 16 | i2 & 4294901760;
                          var i3 = i2 << 16 | i0 & 65535;
                          C2[0] ^= i0;
                          C2[1] ^= i1;
                          C2[2] ^= i2;
                          C2[3] ^= i3;
                          C2[4] ^= i0;
                          C2[5] ^= i1;
                          C2[6] ^= i2;
                          C2[7] ^= i3;
                          for (var i = 0; i < 4; i++) {
                            nextState.call(this);
                          }
                        }
                      },
                      _doProcessBlock: function _doProcessBlock(M, offset) {
                        var X = this._X;
                        nextState.call(this);
                        S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
                        S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
                        S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
                        S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
                        for (var i = 0; i < 4; i++) {
                          S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
                          M[offset + i] ^= S[i];
                        }
                      },
                      blockSize: 128 / 32,
                      ivSize: 64 / 32
                    });
                    function nextState() {
                      var X = this._X;
                      var C2 = this._C;
                      for (var i = 0; i < 8; i++) {
                        C_[i] = C2[i];
                      }
                      C2[0] = C2[0] + 1295307597 + this._b | 0;
                      C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
                      C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
                      C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
                      C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
                      C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
                      C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
                      C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
                      this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
                      for (var i = 0; i < 8; i++) {
                        var gx = X[i] + C2[i];
                        var ga = gx & 65535;
                        var gb = gx >>> 16;
                        var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
                        var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
                        G[i] = gh ^ gl;
                      }
                      X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
                      X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
                      X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
                      X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
                      X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
                      X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
                      X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
                      X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
                    }
                    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
                  })();
                  return CryptoJS.RabbitLegacy;
                });
              }
            ),
            /***/
            5323: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(7508), __webpack_require__2(3440), __webpack_require__2(3839), __webpack_require__2(1582));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var StreamCipher = C_lib.StreamCipher;
                    var C_algo = C.algo;
                    var S = [];
                    var C_ = [];
                    var G = [];
                    var Rabbit = C_algo.Rabbit = StreamCipher.extend({
                      _doReset: function _doReset() {
                        var K = this._key.words;
                        var iv = this.cfg.iv;
                        for (var i = 0; i < 4; i++) {
                          K[i] = (K[i] << 8 | K[i] >>> 24) & 16711935 | (K[i] << 24 | K[i] >>> 8) & 4278255360;
                        }
                        var X = this._X = [K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16];
                        var C2 = this._C = [K[2] << 16 | K[2] >>> 16, K[0] & 4294901760 | K[1] & 65535, K[3] << 16 | K[3] >>> 16, K[1] & 4294901760 | K[2] & 65535, K[0] << 16 | K[0] >>> 16, K[2] & 4294901760 | K[3] & 65535, K[1] << 16 | K[1] >>> 16, K[3] & 4294901760 | K[0] & 65535];
                        this._b = 0;
                        for (var i = 0; i < 4; i++) {
                          nextState.call(this);
                        }
                        for (var i = 0; i < 8; i++) {
                          C2[i] ^= X[i + 4 & 7];
                        }
                        if (iv) {
                          var IV = iv.words;
                          var IV_0 = IV[0];
                          var IV_1 = IV[1];
                          var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                          var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                          var i1 = i0 >>> 16 | i2 & 4294901760;
                          var i3 = i2 << 16 | i0 & 65535;
                          C2[0] ^= i0;
                          C2[1] ^= i1;
                          C2[2] ^= i2;
                          C2[3] ^= i3;
                          C2[4] ^= i0;
                          C2[5] ^= i1;
                          C2[6] ^= i2;
                          C2[7] ^= i3;
                          for (var i = 0; i < 4; i++) {
                            nextState.call(this);
                          }
                        }
                      },
                      _doProcessBlock: function _doProcessBlock(M, offset) {
                        var X = this._X;
                        nextState.call(this);
                        S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
                        S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
                        S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
                        S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
                        for (var i = 0; i < 4; i++) {
                          S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
                          M[offset + i] ^= S[i];
                        }
                      },
                      blockSize: 128 / 32,
                      ivSize: 64 / 32
                    });
                    function nextState() {
                      var X = this._X;
                      var C2 = this._C;
                      for (var i = 0; i < 8; i++) {
                        C_[i] = C2[i];
                      }
                      C2[0] = C2[0] + 1295307597 + this._b | 0;
                      C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
                      C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
                      C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
                      C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
                      C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
                      C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
                      C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
                      this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
                      for (var i = 0; i < 8; i++) {
                        var gx = X[i] + C2[i];
                        var ga = gx & 65535;
                        var gb = gx >>> 16;
                        var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
                        var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
                        G[i] = gh ^ gl;
                      }
                      X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
                      X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
                      X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
                      X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
                      X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
                      X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
                      X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
                      X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
                    }
                    C.Rabbit = StreamCipher._createHelper(Rabbit);
                  })();
                  return CryptoJS.Rabbit;
                });
              }
            ),
            /***/
            4640: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(1539);
                __webpack_require__2(8674);
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(7508), __webpack_require__2(3440), __webpack_require__2(3839), __webpack_require__2(1582));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var StreamCipher = C_lib.StreamCipher;
                    var C_algo = C.algo;
                    var RC4 = C_algo.RC4 = StreamCipher.extend({
                      _doReset: function _doReset() {
                        var key = this._key;
                        var keyWords = key.words;
                        var keySigBytes = key.sigBytes;
                        var S = this._S = [];
                        for (var i = 0; i < 256; i++) {
                          S[i] = i;
                        }
                        for (var i = 0, j = 0; i < 256; i++) {
                          var keyByteIndex = i % keySigBytes;
                          var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
                          j = (j + S[i] + keyByte) % 256;
                          var t = S[i];
                          S[i] = S[j];
                          S[j] = t;
                        }
                        this._i = this._j = 0;
                      },
                      _doProcessBlock: function _doProcessBlock(M, offset) {
                        M[offset] ^= generateKeystreamWord.call(this);
                      },
                      keySize: 256 / 32,
                      ivSize: 0
                    });
                    function generateKeystreamWord() {
                      var S = this._S;
                      var i = this._i;
                      var j = this._j;
                      var keystreamWord = 0;
                      for (var n = 0; n < 4; n++) {
                        i = (i + 1) % 256;
                        j = (j + S[i]) % 256;
                        var t = S[i];
                        S[i] = S[j];
                        S[j] = t;
                        keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - n * 8;
                      }
                      this._i = i;
                      this._j = j;
                      return keystreamWord;
                    }
                    C.RC4 = StreamCipher._createHelper(RC4);
                    var RC4Drop = C_algo.RC4Drop = RC4.extend({
                      /**
                       * Configuration options.
                       *
                       * @property {number} drop The number of keystream words to drop. Default 192
                       */
                      cfg: RC4.cfg.extend({
                        drop: 192
                      }),
                      _doReset: function _doReset() {
                        RC4._doReset.call(this);
                        for (var i = this.cfg.drop; i > 0; i--) {
                          generateKeystreamWord.call(this);
                        }
                      }
                    });
                    C.RC4Drop = StreamCipher._createHelper(RC4Drop);
                  })();
                  return CryptoJS.RC4;
                });
              }
            ),
            /***/
            8714: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function(Math2) {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var Hasher = C_lib.Hasher;
                    var C_algo = C.algo;
                    var _zl = WordArray.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]);
                    var _zr = WordArray.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]);
                    var _sl = WordArray.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]);
                    var _sr = WordArray.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]);
                    var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
                    var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
                    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
                      _doReset: function _doReset() {
                        this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
                      },
                      _doProcessBlock: function _doProcessBlock(M, offset) {
                        for (var i = 0; i < 16; i++) {
                          var offset_i = offset + i;
                          var M_offset_i = M[offset_i];
                          M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
                        }
                        var H = this._hash.words;
                        var hl = _hl.words;
                        var hr = _hr.words;
                        var zl = _zl.words;
                        var zr = _zr.words;
                        var sl = _sl.words;
                        var sr = _sr.words;
                        var al, bl, cl, dl, el;
                        var ar, br, cr, dr, er;
                        ar = al = H[0];
                        br = bl = H[1];
                        cr = cl = H[2];
                        dr = dl = H[3];
                        er = el = H[4];
                        var t;
                        for (var i = 0; i < 80; i += 1) {
                          t = al + M[offset + zl[i]] | 0;
                          if (i < 16) {
                            t += f1(bl, cl, dl) + hl[0];
                          } else if (i < 32) {
                            t += f2(bl, cl, dl) + hl[1];
                          } else if (i < 48) {
                            t += f3(bl, cl, dl) + hl[2];
                          } else if (i < 64) {
                            t += f4(bl, cl, dl) + hl[3];
                          } else {
                            t += f5(bl, cl, dl) + hl[4];
                          }
                          t = t | 0;
                          t = rotl(t, sl[i]);
                          t = t + el | 0;
                          al = el;
                          el = dl;
                          dl = rotl(cl, 10);
                          cl = bl;
                          bl = t;
                          t = ar + M[offset + zr[i]] | 0;
                          if (i < 16) {
                            t += f5(br, cr, dr) + hr[0];
                          } else if (i < 32) {
                            t += f4(br, cr, dr) + hr[1];
                          } else if (i < 48) {
                            t += f3(br, cr, dr) + hr[2];
                          } else if (i < 64) {
                            t += f2(br, cr, dr) + hr[3];
                          } else {
                            t += f1(br, cr, dr) + hr[4];
                          }
                          t = t | 0;
                          t = rotl(t, sr[i]);
                          t = t + er | 0;
                          ar = er;
                          er = dr;
                          dr = rotl(cr, 10);
                          cr = br;
                          br = t;
                        }
                        t = H[1] + cl + dr | 0;
                        H[1] = H[2] + dl + er | 0;
                        H[2] = H[3] + el + ar | 0;
                        H[3] = H[4] + al + br | 0;
                        H[4] = H[0] + bl + cr | 0;
                        H[0] = t;
                      },
                      _doFinalize: function _doFinalize() {
                        var data = this._data;
                        var dataWords = data.words;
                        var nBitsTotal = this._nDataBytes * 8;
                        var nBitsLeft = data.sigBytes * 8;
                        dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
                        data.sigBytes = (dataWords.length + 1) * 4;
                        this._process();
                        var hash = this._hash;
                        var H = hash.words;
                        for (var i = 0; i < 5; i++) {
                          var H_i = H[i];
                          H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
                        }
                        return hash;
                      },
                      clone: function clone() {
                        var clone2 = Hasher.clone.call(this);
                        clone2._hash = this._hash.clone();
                        return clone2;
                      }
                    });
                    function f1(x, y, z) {
                      return x ^ y ^ z;
                    }
                    function f2(x, y, z) {
                      return x & y | ~x & z;
                    }
                    function f3(x, y, z) {
                      return (x | ~y) ^ z;
                    }
                    function f4(x, y, z) {
                      return x & z | y & ~z;
                    }
                    function f5(x, y, z) {
                      return x ^ (y | ~z);
                    }
                    function rotl(x, n) {
                      return x << n | x >>> 32 - n;
                    }
                    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
                    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
                  })(Math);
                  return CryptoJS.RIPEMD160;
                });
              }
            ),
            /***/
            9865: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var Hasher = C_lib.Hasher;
                    var C_algo = C.algo;
                    var W = [];
                    var SHA1 = C_algo.SHA1 = Hasher.extend({
                      _doReset: function _doReset() {
                        this._hash = new WordArray.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
                      },
                      _doProcessBlock: function _doProcessBlock(M, offset) {
                        var H = this._hash.words;
                        var a = H[0];
                        var b = H[1];
                        var c = H[2];
                        var d = H[3];
                        var e = H[4];
                        for (var i = 0; i < 80; i++) {
                          if (i < 16) {
                            W[i] = M[offset + i] | 0;
                          } else {
                            var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                            W[i] = n << 1 | n >>> 31;
                          }
                          var t = (a << 5 | a >>> 27) + e + W[i];
                          if (i < 20) {
                            t += (b & c | ~b & d) + 1518500249;
                          } else if (i < 40) {
                            t += (b ^ c ^ d) + 1859775393;
                          } else if (i < 60) {
                            t += (b & c | b & d | c & d) - 1894007588;
                          } else {
                            t += (b ^ c ^ d) - 899497514;
                          }
                          e = d;
                          d = c;
                          c = b << 30 | b >>> 2;
                          b = a;
                          a = t;
                        }
                        H[0] = H[0] + a | 0;
                        H[1] = H[1] + b | 0;
                        H[2] = H[2] + c | 0;
                        H[3] = H[3] + d | 0;
                        H[4] = H[4] + e | 0;
                      },
                      _doFinalize: function _doFinalize() {
                        var data = this._data;
                        var dataWords = data.words;
                        var nBitsTotal = this._nDataBytes * 8;
                        var nBitsLeft = data.sigBytes * 8;
                        dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
                        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
                        data.sigBytes = dataWords.length * 4;
                        this._process();
                        return this._hash;
                      },
                      clone: function clone() {
                        var clone2 = Hasher.clone.call(this);
                        clone2._hash = this._hash.clone();
                        return clone2;
                      }
                    });
                    C.SHA1 = Hasher._createHelper(SHA1);
                    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
                  })();
                  return CryptoJS.SHA1;
                });
              }
            ),
            /***/
            6876: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(8921));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var C_algo = C.algo;
                    var SHA256 = C_algo.SHA256;
                    var SHA224 = C_algo.SHA224 = SHA256.extend({
                      _doReset: function _doReset() {
                        this._hash = new WordArray.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]);
                      },
                      _doFinalize: function _doFinalize() {
                        var hash = SHA256._doFinalize.call(this);
                        hash.sigBytes -= 4;
                        return hash;
                      }
                    });
                    C.SHA224 = SHA256._createHelper(SHA224);
                    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
                  })();
                  return CryptoJS.SHA224;
                });
              }
            ),
            /***/
            8921: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(7042);
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function(Math2) {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var Hasher = C_lib.Hasher;
                    var C_algo = C.algo;
                    var H = [];
                    var K = [];
                    (function() {
                      function isPrime(n2) {
                        var sqrtN = Math2.sqrt(n2);
                        for (var factor = 2; factor <= sqrtN; factor++) {
                          if (!(n2 % factor)) {
                            return false;
                          }
                        }
                        return true;
                      }
                      function getFractionalBits(n2) {
                        return (n2 - (n2 | 0)) * 4294967296 | 0;
                      }
                      var n = 2;
                      var nPrime = 0;
                      while (nPrime < 64) {
                        if (isPrime(n)) {
                          if (nPrime < 8) {
                            H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
                          }
                          K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
                          nPrime++;
                        }
                        n++;
                      }
                    })();
                    var W = [];
                    var SHA256 = C_algo.SHA256 = Hasher.extend({
                      _doReset: function _doReset() {
                        this._hash = new WordArray.init(H.slice(0));
                      },
                      _doProcessBlock: function _doProcessBlock(M, offset) {
                        var H2 = this._hash.words;
                        var a = H2[0];
                        var b = H2[1];
                        var c = H2[2];
                        var d = H2[3];
                        var e = H2[4];
                        var f = H2[5];
                        var g = H2[6];
                        var h = H2[7];
                        for (var i = 0; i < 64; i++) {
                          if (i < 16) {
                            W[i] = M[offset + i] | 0;
                          } else {
                            var gamma0x = W[i - 15];
                            var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                            var gamma1x = W[i - 2];
                            var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                            W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                          }
                          var ch = e & f ^ ~e & g;
                          var maj = a & b ^ a & c ^ b & c;
                          var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
                          var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
                          var t1 = h + sigma1 + ch + K[i] + W[i];
                          var t2 = sigma0 + maj;
                          h = g;
                          g = f;
                          f = e;
                          e = d + t1 | 0;
                          d = c;
                          c = b;
                          b = a;
                          a = t1 + t2 | 0;
                        }
                        H2[0] = H2[0] + a | 0;
                        H2[1] = H2[1] + b | 0;
                        H2[2] = H2[2] + c | 0;
                        H2[3] = H2[3] + d | 0;
                        H2[4] = H2[4] + e | 0;
                        H2[5] = H2[5] + f | 0;
                        H2[6] = H2[6] + g | 0;
                        H2[7] = H2[7] + h | 0;
                      },
                      _doFinalize: function _doFinalize() {
                        var data = this._data;
                        var dataWords = data.words;
                        var nBitsTotal = this._nDataBytes * 8;
                        var nBitsLeft = data.sigBytes * 8;
                        dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
                        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
                        data.sigBytes = dataWords.length * 4;
                        this._process();
                        return this._hash;
                      },
                      clone: function clone() {
                        var clone2 = Hasher.clone.call(this);
                        clone2._hash = this._hash.clone();
                        return clone2;
                      }
                    });
                    C.SHA256 = Hasher._createHelper(SHA256);
                    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
                  })(Math);
                  return CryptoJS.SHA256;
                });
              }
            ),
            /***/
            8342: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(7042);
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(2601));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function(Math2) {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var Hasher = C_lib.Hasher;
                    var C_x64 = C.x64;
                    var X64Word = C_x64.Word;
                    var C_algo = C.algo;
                    var RHO_OFFSETS = [];
                    var PI_INDEXES = [];
                    var ROUND_CONSTANTS = [];
                    (function() {
                      var x = 1, y = 0;
                      for (var t = 0; t < 24; t++) {
                        RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
                        var newX = y % 5;
                        var newY = (2 * x + 3 * y) % 5;
                        x = newX;
                        y = newY;
                      }
                      for (var x = 0; x < 5; x++) {
                        for (var y = 0; y < 5; y++) {
                          PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
                        }
                      }
                      var LFSR = 1;
                      for (var i = 0; i < 24; i++) {
                        var roundConstantMsw = 0;
                        var roundConstantLsw = 0;
                        for (var j = 0; j < 7; j++) {
                          if (LFSR & 1) {
                            var bitPosition = (1 << j) - 1;
                            if (bitPosition < 32) {
                              roundConstantLsw ^= 1 << bitPosition;
                            } else {
                              roundConstantMsw ^= 1 << bitPosition - 32;
                            }
                          }
                          if (LFSR & 128) {
                            LFSR = LFSR << 1 ^ 113;
                          } else {
                            LFSR <<= 1;
                          }
                        }
                        ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
                      }
                    })();
                    var T = [];
                    (function() {
                      for (var i = 0; i < 25; i++) {
                        T[i] = X64Word.create();
                      }
                    })();
                    var SHA3 = C_algo.SHA3 = Hasher.extend({
                      /**
                       * Configuration options.
                       *
                       * @property {number} outputLength
                       *   The desired number of bits in the output hash.
                       *   Only values permitted are: 224, 256, 384, 512.
                       *   Default: 512
                       */
                      cfg: Hasher.cfg.extend({
                        outputLength: 512
                      }),
                      _doReset: function _doReset() {
                        var state = this._state = [];
                        for (var i = 0; i < 25; i++) {
                          state[i] = new X64Word.init();
                        }
                        this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
                      },
                      _doProcessBlock: function _doProcessBlock(M, offset) {
                        var state = this._state;
                        var nBlockSizeLanes = this.blockSize / 2;
                        for (var i = 0; i < nBlockSizeLanes; i++) {
                          var M2i = M[offset + 2 * i];
                          var M2i1 = M[offset + 2 * i + 1];
                          M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
                          M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
                          var lane = state[i];
                          lane.high ^= M2i1;
                          lane.low ^= M2i;
                        }
                        for (var round = 0; round < 24; round++) {
                          for (var x = 0; x < 5; x++) {
                            var tMsw = 0, tLsw = 0;
                            for (var y = 0; y < 5; y++) {
                              var lane = state[x + 5 * y];
                              tMsw ^= lane.high;
                              tLsw ^= lane.low;
                            }
                            var Tx = T[x];
                            Tx.high = tMsw;
                            Tx.low = tLsw;
                          }
                          for (var x = 0; x < 5; x++) {
                            var Tx4 = T[(x + 4) % 5];
                            var Tx1 = T[(x + 1) % 5];
                            var Tx1Msw = Tx1.high;
                            var Tx1Lsw = Tx1.low;
                            var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                            var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                            for (var y = 0; y < 5; y++) {
                              var lane = state[x + 5 * y];
                              lane.high ^= tMsw;
                              lane.low ^= tLsw;
                            }
                          }
                          for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                            var tMsw;
                            var tLsw;
                            var lane = state[laneIndex];
                            var laneMsw = lane.high;
                            var laneLsw = lane.low;
                            var rhoOffset = RHO_OFFSETS[laneIndex];
                            if (rhoOffset < 32) {
                              tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                              tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                            } else {
                              tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                              tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                            }
                            var TPiLane = T[PI_INDEXES[laneIndex]];
                            TPiLane.high = tMsw;
                            TPiLane.low = tLsw;
                          }
                          var T0 = T[0];
                          var state0 = state[0];
                          T0.high = state0.high;
                          T0.low = state0.low;
                          for (var x = 0; x < 5; x++) {
                            for (var y = 0; y < 5; y++) {
                              var laneIndex = x + 5 * y;
                              var lane = state[laneIndex];
                              var TLane = T[laneIndex];
                              var Tx1Lane = T[(x + 1) % 5 + 5 * y];
                              var Tx2Lane = T[(x + 2) % 5 + 5 * y];
                              lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                              lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                            }
                          }
                          var lane = state[0];
                          var roundConstant = ROUND_CONSTANTS[round];
                          lane.high ^= roundConstant.high;
                          lane.low ^= roundConstant.low;
                        }
                      },
                      _doFinalize: function _doFinalize() {
                        var data = this._data;
                        var dataWords = data.words;
                        var nBitsTotal = this._nDataBytes * 8;
                        var nBitsLeft = data.sigBytes * 8;
                        var blockSizeBits = this.blockSize * 32;
                        dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
                        dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
                        data.sigBytes = dataWords.length * 4;
                        this._process();
                        var state = this._state;
                        var outputLengthBytes = this.cfg.outputLength / 8;
                        var outputLengthLanes = outputLengthBytes / 8;
                        var hashWords = [];
                        for (var i = 0; i < outputLengthLanes; i++) {
                          var lane = state[i];
                          var laneMsw = lane.high;
                          var laneLsw = lane.low;
                          laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
                          laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
                          hashWords.push(laneLsw);
                          hashWords.push(laneMsw);
                        }
                        return new WordArray.init(hashWords, outputLengthBytes);
                      },
                      clone: function clone() {
                        var clone2 = Hasher.clone.call(this);
                        var state = clone2._state = this._state.slice(0);
                        for (var i = 0; i < 25; i++) {
                          state[i] = state[i].clone();
                        }
                        return clone2;
                      }
                    });
                    C.SHA3 = Hasher._createHelper(SHA3);
                    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
                  })(Math);
                  return CryptoJS.SHA3;
                });
              }
            ),
            /***/
            8122: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(2601), __webpack_require__2(7991));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_x64 = C.x64;
                    var X64Word = C_x64.Word;
                    var X64WordArray = C_x64.WordArray;
                    var C_algo = C.algo;
                    var SHA512 = C_algo.SHA512;
                    var SHA384 = C_algo.SHA384 = SHA512.extend({
                      _doReset: function _doReset() {
                        this._hash = new X64WordArray.init([new X64Word.init(3418070365, 3238371032), new X64Word.init(1654270250, 914150663), new X64Word.init(2438529370, 812702999), new X64Word.init(355462360, 4144912697), new X64Word.init(1731405415, 4290775857), new X64Word.init(2394180231, 1750603025), new X64Word.init(3675008525, 1694076839), new X64Word.init(1203062813, 3204075428)]);
                      },
                      _doFinalize: function _doFinalize() {
                        var hash = SHA512._doFinalize.call(this);
                        hash.sigBytes -= 16;
                        return hash;
                      }
                    });
                    C.SHA384 = SHA512._createHelper(SHA384);
                    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
                  })();
                  return CryptoJS.SHA384;
                });
              }
            ),
            /***/
            7991: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(2601));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var Hasher = C_lib.Hasher;
                    var C_x64 = C.x64;
                    var X64Word = C_x64.Word;
                    var X64WordArray = C_x64.WordArray;
                    var C_algo = C.algo;
                    function X64Word_create() {
                      return X64Word.create.apply(X64Word, arguments);
                    }
                    var K = [X64Word_create(1116352408, 3609767458), X64Word_create(1899447441, 602891725), X64Word_create(3049323471, 3964484399), X64Word_create(3921009573, 2173295548), X64Word_create(961987163, 4081628472), X64Word_create(1508970993, 3053834265), X64Word_create(2453635748, 2937671579), X64Word_create(2870763221, 3664609560), X64Word_create(3624381080, 2734883394), X64Word_create(310598401, 1164996542), X64Word_create(607225278, 1323610764), X64Word_create(1426881987, 3590304994), X64Word_create(1925078388, 4068182383), X64Word_create(2162078206, 991336113), X64Word_create(2614888103, 633803317), X64Word_create(3248222580, 3479774868), X64Word_create(3835390401, 2666613458), X64Word_create(4022224774, 944711139), X64Word_create(264347078, 2341262773), X64Word_create(604807628, 2007800933), X64Word_create(770255983, 1495990901), X64Word_create(1249150122, 1856431235), X64Word_create(1555081692, 3175218132), X64Word_create(1996064986, 2198950837), X64Word_create(2554220882, 3999719339), X64Word_create(2821834349, 766784016), X64Word_create(2952996808, 2566594879), X64Word_create(3210313671, 3203337956), X64Word_create(3336571891, 1034457026), X64Word_create(3584528711, 2466948901), X64Word_create(113926993, 3758326383), X64Word_create(338241895, 168717936), X64Word_create(666307205, 1188179964), X64Word_create(773529912, 1546045734), X64Word_create(1294757372, 1522805485), X64Word_create(1396182291, 2643833823), X64Word_create(1695183700, 2343527390), X64Word_create(1986661051, 1014477480), X64Word_create(2177026350, 1206759142), X64Word_create(2456956037, 344077627), X64Word_create(2730485921, 1290863460), X64Word_create(2820302411, 3158454273), X64Word_create(3259730800, 3505952657), X64Word_create(3345764771, 106217008), X64Word_create(3516065817, 3606008344), X64Word_create(3600352804, 1432725776), X64Word_create(4094571909, 1467031594), X64Word_create(275423344, 851169720), X64Word_create(430227734, 3100823752), X64Word_create(506948616, 1363258195), X64Word_create(659060556, 3750685593), X64Word_create(883997877, 3785050280), X64Word_create(958139571, 3318307427), X64Word_create(1322822218, 3812723403), X64Word_create(1537002063, 2003034995), X64Word_create(1747873779, 3602036899), X64Word_create(1955562222, 1575990012), X64Word_create(2024104815, 1125592928), X64Word_create(2227730452, 2716904306), X64Word_create(2361852424, 442776044), X64Word_create(2428436474, 593698344), X64Word_create(2756734187, 3733110249), X64Word_create(3204031479, 2999351573), X64Word_create(3329325298, 3815920427), X64Word_create(3391569614, 3928383900), X64Word_create(3515267271, 566280711), X64Word_create(3940187606, 3454069534), X64Word_create(4118630271, 4000239992), X64Word_create(116418474, 1914138554), X64Word_create(174292421, 2731055270), X64Word_create(289380356, 3203993006), X64Word_create(460393269, 320620315), X64Word_create(685471733, 587496836), X64Word_create(852142971, 1086792851), X64Word_create(1017036298, 365543100), X64Word_create(1126000580, 2618297676), X64Word_create(1288033470, 3409855158), X64Word_create(1501505948, 4234509866), X64Word_create(1607167915, 987167468), X64Word_create(1816402316, 1246189591)];
                    var W = [];
                    (function() {
                      for (var i = 0; i < 80; i++) {
                        W[i] = X64Word_create();
                      }
                    })();
                    var SHA512 = C_algo.SHA512 = Hasher.extend({
                      _doReset: function _doReset() {
                        this._hash = new X64WordArray.init([new X64Word.init(1779033703, 4089235720), new X64Word.init(3144134277, 2227873595), new X64Word.init(1013904242, 4271175723), new X64Word.init(2773480762, 1595750129), new X64Word.init(1359893119, 2917565137), new X64Word.init(2600822924, 725511199), new X64Word.init(528734635, 4215389547), new X64Word.init(1541459225, 327033209)]);
                      },
                      _doProcessBlock: function _doProcessBlock(M, offset) {
                        var H = this._hash.words;
                        var H0 = H[0];
                        var H1 = H[1];
                        var H2 = H[2];
                        var H3 = H[3];
                        var H4 = H[4];
                        var H5 = H[5];
                        var H6 = H[6];
                        var H7 = H[7];
                        var H0h = H0.high;
                        var H0l = H0.low;
                        var H1h = H1.high;
                        var H1l = H1.low;
                        var H2h = H2.high;
                        var H2l = H2.low;
                        var H3h = H3.high;
                        var H3l = H3.low;
                        var H4h = H4.high;
                        var H4l = H4.low;
                        var H5h = H5.high;
                        var H5l = H5.low;
                        var H6h = H6.high;
                        var H6l = H6.low;
                        var H7h = H7.high;
                        var H7l = H7.low;
                        var ah = H0h;
                        var al = H0l;
                        var bh = H1h;
                        var bl = H1l;
                        var ch = H2h;
                        var cl = H2l;
                        var dh = H3h;
                        var dl = H3l;
                        var eh = H4h;
                        var el = H4l;
                        var fh = H5h;
                        var fl = H5l;
                        var gh = H6h;
                        var gl = H6l;
                        var hh = H7h;
                        var hl = H7l;
                        for (var i = 0; i < 80; i++) {
                          var Wil;
                          var Wih;
                          var Wi = W[i];
                          if (i < 16) {
                            Wih = Wi.high = M[offset + i * 2] | 0;
                            Wil = Wi.low = M[offset + i * 2 + 1] | 0;
                          } else {
                            var gamma0x = W[i - 15];
                            var gamma0xh = gamma0x.high;
                            var gamma0xl = gamma0x.low;
                            var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                            var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                            var gamma1x = W[i - 2];
                            var gamma1xh = gamma1x.high;
                            var gamma1xl = gamma1x.low;
                            var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                            var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                            var Wi7 = W[i - 7];
                            var Wi7h = Wi7.high;
                            var Wi7l = Wi7.low;
                            var Wi16 = W[i - 16];
                            var Wi16h = Wi16.high;
                            var Wi16l = Wi16.low;
                            Wil = gamma0l + Wi7l;
                            Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                            Wil = Wil + gamma1l;
                            Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                            Wil = Wil + Wi16l;
                            Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                            Wi.high = Wih;
                            Wi.low = Wil;
                          }
                          var chh = eh & fh ^ ~eh & gh;
                          var chl = el & fl ^ ~el & gl;
                          var majh = ah & bh ^ ah & ch ^ bh & ch;
                          var majl = al & bl ^ al & cl ^ bl & cl;
                          var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
                          var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
                          var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
                          var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
                          var Ki = K[i];
                          var Kih = Ki.high;
                          var Kil = Ki.low;
                          var t1l = hl + sigma1l;
                          var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
                          var t1l = t1l + chl;
                          var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
                          var t1l = t1l + Kil;
                          var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
                          var t1l = t1l + Wil;
                          var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
                          var t2l = sigma0l + majl;
                          var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
                          hh = gh;
                          hl = gl;
                          gh = fh;
                          gl = fl;
                          fh = eh;
                          fl = el;
                          el = dl + t1l | 0;
                          eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
                          dh = ch;
                          dl = cl;
                          ch = bh;
                          cl = bl;
                          bh = ah;
                          bl = al;
                          al = t1l + t2l | 0;
                          ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
                        }
                        H0l = H0.low = H0l + al;
                        H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
                        H1l = H1.low = H1l + bl;
                        H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
                        H2l = H2.low = H2l + cl;
                        H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
                        H3l = H3.low = H3l + dl;
                        H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
                        H4l = H4.low = H4l + el;
                        H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
                        H5l = H5.low = H5l + fl;
                        H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
                        H6l = H6.low = H6l + gl;
                        H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
                        H7l = H7.low = H7l + hl;
                        H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
                      },
                      _doFinalize: function _doFinalize() {
                        var data = this._data;
                        var dataWords = data.words;
                        var nBitsTotal = this._nDataBytes * 8;
                        var nBitsLeft = data.sigBytes * 8;
                        dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                        dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
                        dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
                        data.sigBytes = dataWords.length * 4;
                        this._process();
                        var hash = this._hash.toX32();
                        return hash;
                      },
                      clone: function clone() {
                        var clone2 = Hasher.clone.call(this);
                        clone2._hash = this._hash.clone();
                        return clone2;
                      },
                      blockSize: 1024 / 32
                    });
                    C.SHA512 = Hasher._createHelper(SHA512);
                    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
                  })();
                  return CryptoJS.SHA512;
                });
              }
            ),
            /***/
            8437: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(7042);
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757), __webpack_require__2(7508), __webpack_require__2(3440), __webpack_require__2(3839), __webpack_require__2(1582));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var BlockCipher = C_lib.BlockCipher;
                    var C_algo = C.algo;
                    var PC1 = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4];
                    var PC2 = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32];
                    var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
                    var SBOX_P = [{
                      0: 8421888,
                      268435456: 32768,
                      536870912: 8421378,
                      805306368: 2,
                      1073741824: 512,
                      1342177280: 8421890,
                      1610612736: 8389122,
                      1879048192: 8388608,
                      2147483648: 514,
                      2415919104: 8389120,
                      2684354560: 33280,
                      2952790016: 8421376,
                      3221225472: 32770,
                      3489660928: 8388610,
                      3758096384: 0,
                      4026531840: 33282,
                      134217728: 0,
                      402653184: 8421890,
                      671088640: 33282,
                      939524096: 32768,
                      1207959552: 8421888,
                      1476395008: 512,
                      1744830464: 8421378,
                      2013265920: 2,
                      2281701376: 8389120,
                      2550136832: 33280,
                      2818572288: 8421376,
                      3087007744: 8389122,
                      3355443200: 8388610,
                      3623878656: 32770,
                      3892314112: 514,
                      4160749568: 8388608,
                      1: 32768,
                      268435457: 2,
                      536870913: 8421888,
                      805306369: 8388608,
                      1073741825: 8421378,
                      1342177281: 33280,
                      1610612737: 512,
                      1879048193: 8389122,
                      2147483649: 8421890,
                      2415919105: 8421376,
                      2684354561: 8388610,
                      2952790017: 33282,
                      3221225473: 514,
                      3489660929: 8389120,
                      3758096385: 32770,
                      4026531841: 0,
                      134217729: 8421890,
                      402653185: 8421376,
                      671088641: 8388608,
                      939524097: 512,
                      1207959553: 32768,
                      1476395009: 8388610,
                      1744830465: 2,
                      2013265921: 33282,
                      2281701377: 32770,
                      2550136833: 8389122,
                      2818572289: 514,
                      3087007745: 8421888,
                      3355443201: 8389120,
                      3623878657: 0,
                      3892314113: 33280,
                      4160749569: 8421378
                    }, {
                      0: 1074282512,
                      16777216: 16384,
                      33554432: 524288,
                      50331648: 1074266128,
                      67108864: 1073741840,
                      83886080: 1074282496,
                      100663296: 1073758208,
                      117440512: 16,
                      134217728: 540672,
                      150994944: 1073758224,
                      167772160: 1073741824,
                      184549376: 540688,
                      201326592: 524304,
                      218103808: 0,
                      234881024: 16400,
                      251658240: 1074266112,
                      8388608: 1073758208,
                      25165824: 540688,
                      41943040: 16,
                      58720256: 1073758224,
                      75497472: 1074282512,
                      92274688: 1073741824,
                      109051904: 524288,
                      125829120: 1074266128,
                      142606336: 524304,
                      159383552: 0,
                      176160768: 16384,
                      192937984: 1074266112,
                      209715200: 1073741840,
                      226492416: 540672,
                      243269632: 1074282496,
                      260046848: 16400,
                      268435456: 0,
                      285212672: 1074266128,
                      301989888: 1073758224,
                      318767104: 1074282496,
                      335544320: 1074266112,
                      352321536: 16,
                      369098752: 540688,
                      385875968: 16384,
                      402653184: 16400,
                      419430400: 524288,
                      436207616: 524304,
                      452984832: 1073741840,
                      469762048: 540672,
                      486539264: 1073758208,
                      503316480: 1073741824,
                      520093696: 1074282512,
                      276824064: 540688,
                      293601280: 524288,
                      310378496: 1074266112,
                      327155712: 16384,
                      343932928: 1073758208,
                      360710144: 1074282512,
                      377487360: 16,
                      394264576: 1073741824,
                      411041792: 1074282496,
                      427819008: 1073741840,
                      444596224: 1073758224,
                      461373440: 524304,
                      478150656: 0,
                      494927872: 16400,
                      511705088: 1074266128,
                      528482304: 540672
                    }, {
                      0: 260,
                      1048576: 0,
                      2097152: 67109120,
                      3145728: 65796,
                      4194304: 65540,
                      5242880: 67108868,
                      6291456: 67174660,
                      7340032: 67174400,
                      8388608: 67108864,
                      9437184: 67174656,
                      10485760: 65792,
                      11534336: 67174404,
                      12582912: 67109124,
                      13631488: 65536,
                      14680064: 4,
                      15728640: 256,
                      524288: 67174656,
                      1572864: 67174404,
                      2621440: 0,
                      3670016: 67109120,
                      4718592: 67108868,
                      5767168: 65536,
                      6815744: 65540,
                      7864320: 260,
                      8912896: 4,
                      9961472: 256,
                      11010048: 67174400,
                      12058624: 65796,
                      13107200: 65792,
                      14155776: 67109124,
                      15204352: 67174660,
                      16252928: 67108864,
                      16777216: 67174656,
                      17825792: 65540,
                      18874368: 65536,
                      19922944: 67109120,
                      20971520: 256,
                      22020096: 67174660,
                      23068672: 67108868,
                      24117248: 0,
                      25165824: 67109124,
                      26214400: 67108864,
                      27262976: 4,
                      28311552: 65792,
                      29360128: 67174400,
                      30408704: 260,
                      31457280: 65796,
                      32505856: 67174404,
                      17301504: 67108864,
                      18350080: 260,
                      19398656: 67174656,
                      20447232: 0,
                      21495808: 65540,
                      22544384: 67109120,
                      23592960: 256,
                      24641536: 67174404,
                      25690112: 65536,
                      26738688: 67174660,
                      27787264: 65796,
                      28835840: 67108868,
                      29884416: 67109124,
                      30932992: 67174400,
                      31981568: 4,
                      33030144: 65792
                    }, {
                      0: 2151682048,
                      65536: 2147487808,
                      131072: 4198464,
                      196608: 2151677952,
                      262144: 0,
                      327680: 4198400,
                      393216: 2147483712,
                      458752: 4194368,
                      524288: 2147483648,
                      589824: 4194304,
                      655360: 64,
                      720896: 2147487744,
                      786432: 2151678016,
                      851968: 4160,
                      917504: 4096,
                      983040: 2151682112,
                      32768: 2147487808,
                      98304: 64,
                      163840: 2151678016,
                      229376: 2147487744,
                      294912: 4198400,
                      360448: 2151682112,
                      425984: 0,
                      491520: 2151677952,
                      557056: 4096,
                      622592: 2151682048,
                      688128: 4194304,
                      753664: 4160,
                      819200: 2147483648,
                      884736: 4194368,
                      950272: 4198464,
                      1015808: 2147483712,
                      1048576: 4194368,
                      1114112: 4198400,
                      1179648: 2147483712,
                      1245184: 0,
                      1310720: 4160,
                      1376256: 2151678016,
                      1441792: 2151682048,
                      1507328: 2147487808,
                      1572864: 2151682112,
                      1638400: 2147483648,
                      1703936: 2151677952,
                      1769472: 4198464,
                      1835008: 2147487744,
                      1900544: 4194304,
                      1966080: 64,
                      2031616: 4096,
                      1081344: 2151677952,
                      1146880: 2151682112,
                      1212416: 0,
                      1277952: 4198400,
                      1343488: 4194368,
                      1409024: 2147483648,
                      1474560: 2147487808,
                      1540096: 64,
                      1605632: 2147483712,
                      1671168: 4096,
                      1736704: 2147487744,
                      1802240: 2151678016,
                      1867776: 4160,
                      1933312: 2151682048,
                      1998848: 4194304,
                      2064384: 4198464
                    }, {
                      0: 128,
                      4096: 17039360,
                      8192: 262144,
                      12288: 536870912,
                      16384: 537133184,
                      20480: 16777344,
                      24576: 553648256,
                      28672: 262272,
                      32768: 16777216,
                      36864: 537133056,
                      40960: 536871040,
                      45056: 553910400,
                      49152: 553910272,
                      53248: 0,
                      57344: 17039488,
                      61440: 553648128,
                      2048: 17039488,
                      6144: 553648256,
                      10240: 128,
                      14336: 17039360,
                      18432: 262144,
                      22528: 537133184,
                      26624: 553910272,
                      30720: 536870912,
                      34816: 537133056,
                      38912: 0,
                      43008: 553910400,
                      47104: 16777344,
                      51200: 536871040,
                      55296: 553648128,
                      59392: 16777216,
                      63488: 262272,
                      65536: 262144,
                      69632: 128,
                      73728: 536870912,
                      77824: 553648256,
                      81920: 16777344,
                      86016: 553910272,
                      90112: 537133184,
                      94208: 16777216,
                      98304: 553910400,
                      102400: 553648128,
                      106496: 17039360,
                      110592: 537133056,
                      114688: 262272,
                      118784: 536871040,
                      122880: 0,
                      126976: 17039488,
                      67584: 553648256,
                      71680: 16777216,
                      75776: 17039360,
                      79872: 537133184,
                      83968: 536870912,
                      88064: 17039488,
                      92160: 128,
                      96256: 553910272,
                      100352: 262272,
                      104448: 553910400,
                      108544: 0,
                      112640: 553648128,
                      116736: 16777344,
                      120832: 262144,
                      124928: 537133056,
                      129024: 536871040
                    }, {
                      0: 268435464,
                      256: 8192,
                      512: 270532608,
                      768: 270540808,
                      1024: 268443648,
                      1280: 2097152,
                      1536: 2097160,
                      1792: 268435456,
                      2048: 0,
                      2304: 268443656,
                      2560: 2105344,
                      2816: 8,
                      3072: 270532616,
                      3328: 2105352,
                      3584: 8200,
                      3840: 270540800,
                      128: 270532608,
                      384: 270540808,
                      640: 8,
                      896: 2097152,
                      1152: 2105352,
                      1408: 268435464,
                      1664: 268443648,
                      1920: 8200,
                      2176: 2097160,
                      2432: 8192,
                      2688: 268443656,
                      2944: 270532616,
                      3200: 0,
                      3456: 270540800,
                      3712: 2105344,
                      3968: 268435456,
                      4096: 268443648,
                      4352: 270532616,
                      4608: 270540808,
                      4864: 8200,
                      5120: 2097152,
                      5376: 268435456,
                      5632: 268435464,
                      5888: 2105344,
                      6144: 2105352,
                      6400: 0,
                      6656: 8,
                      6912: 270532608,
                      7168: 8192,
                      7424: 268443656,
                      7680: 270540800,
                      7936: 2097160,
                      4224: 8,
                      4480: 2105344,
                      4736: 2097152,
                      4992: 268435464,
                      5248: 268443648,
                      5504: 8200,
                      5760: 270540808,
                      6016: 270532608,
                      6272: 270540800,
                      6528: 270532616,
                      6784: 8192,
                      7040: 2105352,
                      7296: 2097160,
                      7552: 0,
                      7808: 268435456,
                      8064: 268443656
                    }, {
                      0: 1048576,
                      16: 33555457,
                      32: 1024,
                      48: 1049601,
                      64: 34604033,
                      80: 0,
                      96: 1,
                      112: 34603009,
                      128: 33555456,
                      144: 1048577,
                      160: 33554433,
                      176: 34604032,
                      192: 34603008,
                      208: 1025,
                      224: 1049600,
                      240: 33554432,
                      8: 34603009,
                      24: 0,
                      40: 33555457,
                      56: 34604032,
                      72: 1048576,
                      88: 33554433,
                      104: 33554432,
                      120: 1025,
                      136: 1049601,
                      152: 33555456,
                      168: 34603008,
                      184: 1048577,
                      200: 1024,
                      216: 34604033,
                      232: 1,
                      248: 1049600,
                      256: 33554432,
                      272: 1048576,
                      288: 33555457,
                      304: 34603009,
                      320: 1048577,
                      336: 33555456,
                      352: 34604032,
                      368: 1049601,
                      384: 1025,
                      400: 34604033,
                      416: 1049600,
                      432: 1,
                      448: 0,
                      464: 34603008,
                      480: 33554433,
                      496: 1024,
                      264: 1049600,
                      280: 33555457,
                      296: 34603009,
                      312: 1,
                      328: 33554432,
                      344: 1048576,
                      360: 1025,
                      376: 34604032,
                      392: 33554433,
                      408: 34603008,
                      424: 0,
                      440: 34604033,
                      456: 1049601,
                      472: 1024,
                      488: 33555456,
                      504: 1048577
                    }, {
                      0: 134219808,
                      1: 131072,
                      2: 134217728,
                      3: 32,
                      4: 131104,
                      5: 134350880,
                      6: 134350848,
                      7: 2048,
                      8: 134348800,
                      9: 134219776,
                      10: 133120,
                      11: 134348832,
                      12: 2080,
                      13: 0,
                      14: 134217760,
                      15: 133152,
                      2147483648: 2048,
                      2147483649: 134350880,
                      2147483650: 134219808,
                      2147483651: 134217728,
                      2147483652: 134348800,
                      2147483653: 133120,
                      2147483654: 133152,
                      2147483655: 32,
                      2147483656: 134217760,
                      2147483657: 2080,
                      2147483658: 131104,
                      2147483659: 134350848,
                      2147483660: 0,
                      2147483661: 134348832,
                      2147483662: 134219776,
                      2147483663: 131072,
                      16: 133152,
                      17: 134350848,
                      18: 32,
                      19: 2048,
                      20: 134219776,
                      21: 134217760,
                      22: 134348832,
                      23: 131072,
                      24: 0,
                      25: 131104,
                      26: 134348800,
                      27: 134219808,
                      28: 134350880,
                      29: 133120,
                      30: 2080,
                      31: 134217728,
                      2147483664: 131072,
                      2147483665: 2048,
                      2147483666: 134348832,
                      2147483667: 133152,
                      2147483668: 32,
                      2147483669: 134348800,
                      2147483670: 134217728,
                      2147483671: 134219808,
                      2147483672: 134350880,
                      2147483673: 134217760,
                      2147483674: 134219776,
                      2147483675: 0,
                      2147483676: 133120,
                      2147483677: 2080,
                      2147483678: 131104,
                      2147483679: 134350848
                    }];
                    var SBOX_MASK = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679];
                    var DES = C_algo.DES = BlockCipher.extend({
                      _doReset: function _doReset() {
                        var key = this._key;
                        var keyWords = key.words;
                        var keyBits = [];
                        for (var i = 0; i < 56; i++) {
                          var keyBitPos = PC1[i] - 1;
                          keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
                        }
                        var subKeys = this._subKeys = [];
                        for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
                          var subKey = subKeys[nSubKey] = [];
                          var bitShift = BIT_SHIFTS[nSubKey];
                          for (var i = 0; i < 24; i++) {
                            subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;
                            subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
                          }
                          subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
                          for (var i = 1; i < 7; i++) {
                            subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
                          }
                          subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
                        }
                        var invSubKeys = this._invSubKeys = [];
                        for (var i = 0; i < 16; i++) {
                          invSubKeys[i] = subKeys[15 - i];
                        }
                      },
                      encryptBlock: function encryptBlock(M, offset) {
                        this._doCryptBlock(M, offset, this._subKeys);
                      },
                      decryptBlock: function decryptBlock(M, offset) {
                        this._doCryptBlock(M, offset, this._invSubKeys);
                      },
                      _doCryptBlock: function _doCryptBlock(M, offset, subKeys) {
                        this._lBlock = M[offset];
                        this._rBlock = M[offset + 1];
                        exchangeLR.call(this, 4, 252645135);
                        exchangeLR.call(this, 16, 65535);
                        exchangeRL.call(this, 2, 858993459);
                        exchangeRL.call(this, 8, 16711935);
                        exchangeLR.call(this, 1, 1431655765);
                        for (var round = 0; round < 16; round++) {
                          var subKey = subKeys[round];
                          var lBlock = this._lBlock;
                          var rBlock = this._rBlock;
                          var f = 0;
                          for (var i = 0; i < 8; i++) {
                            f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
                          }
                          this._lBlock = rBlock;
                          this._rBlock = lBlock ^ f;
                        }
                        var t = this._lBlock;
                        this._lBlock = this._rBlock;
                        this._rBlock = t;
                        exchangeLR.call(this, 1, 1431655765);
                        exchangeRL.call(this, 8, 16711935);
                        exchangeRL.call(this, 2, 858993459);
                        exchangeLR.call(this, 16, 65535);
                        exchangeLR.call(this, 4, 252645135);
                        M[offset] = this._lBlock;
                        M[offset + 1] = this._rBlock;
                      },
                      keySize: 64 / 32,
                      ivSize: 64 / 32,
                      blockSize: 64 / 32
                    });
                    function exchangeLR(offset, mask) {
                      var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
                      this._rBlock ^= t;
                      this._lBlock ^= t << offset;
                    }
                    function exchangeRL(offset, mask) {
                      var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
                      this._lBlock ^= t;
                      this._rBlock ^= t << offset;
                    }
                    C.DES = BlockCipher._createHelper(DES);
                    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
                      _doReset: function _doReset() {
                        var key = this._key;
                        var keyWords = key.words;
                        if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
                          throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
                        }
                        var key1 = keyWords.slice(0, 2);
                        var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
                        var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
                        this._des1 = DES.createEncryptor(WordArray.create(key1));
                        this._des2 = DES.createEncryptor(WordArray.create(key2));
                        this._des3 = DES.createEncryptor(WordArray.create(key3));
                      },
                      encryptBlock: function encryptBlock(M, offset) {
                        this._des1.encryptBlock(M, offset);
                        this._des2.decryptBlock(M, offset);
                        this._des3.encryptBlock(M, offset);
                      },
                      decryptBlock: function decryptBlock(M, offset) {
                        this._des3.decryptBlock(M, offset);
                        this._des2.encryptBlock(M, offset);
                        this._des1.decryptBlock(M, offset);
                      },
                      keySize: 192 / 32,
                      ivSize: 64 / 32,
                      blockSize: 64 / 32
                    });
                    C.TripleDES = BlockCipher._createHelper(TripleDES);
                  })();
                  return CryptoJS.TripleDES;
                });
              }
            ),
            /***/
            2601: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(7042);
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(757));
                  } else {
                  }
                })(void 0, function(CryptoJS) {
                  (function(undefined2) {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var Base = C_lib.Base;
                    var X32WordArray = C_lib.WordArray;
                    var C_x64 = C.x64 = {};
                    var X64Word = C_x64.Word = Base.extend({
                      /**
                       * Initializes a newly created 64-bit word.
                       *
                       * @param {number} high The high 32 bits.
                       * @param {number} low The low 32 bits.
                       *
                       * @example
                       *
                       *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
                       */
                      init: function init(high, low) {
                        this.high = high;
                        this.low = low;
                      }
                      /**
                       * Bitwise NOTs this word.
                       *
                       * @return {X64Word} A new x64-Word object after negating.
                       *
                       * @example
                       *
                       *     var negated = x64Word.not();
                       */
                      // not: function () {
                      // var high = ~this.high;
                      // var low = ~this.low;
                      // return X64Word.create(high, low);
                      // },
                      /**
                       * Bitwise ANDs this word with the passed word.
                       *
                       * @param {X64Word} word The x64-Word to AND with this word.
                       *
                       * @return {X64Word} A new x64-Word object after ANDing.
                       *
                       * @example
                       *
                       *     var anded = x64Word.and(anotherX64Word);
                       */
                      // and: function (word) {
                      // var high = this.high & word.high;
                      // var low = this.low & word.low;
                      // return X64Word.create(high, low);
                      // },
                      /**
                       * Bitwise ORs this word with the passed word.
                       *
                       * @param {X64Word} word The x64-Word to OR with this word.
                       *
                       * @return {X64Word} A new x64-Word object after ORing.
                       *
                       * @example
                       *
                       *     var ored = x64Word.or(anotherX64Word);
                       */
                      // or: function (word) {
                      // var high = this.high | word.high;
                      // var low = this.low | word.low;
                      // return X64Word.create(high, low);
                      // },
                      /**
                       * Bitwise XORs this word with the passed word.
                       *
                       * @param {X64Word} word The x64-Word to XOR with this word.
                       *
                       * @return {X64Word} A new x64-Word object after XORing.
                       *
                       * @example
                       *
                       *     var xored = x64Word.xor(anotherX64Word);
                       */
                      // xor: function (word) {
                      // var high = this.high ^ word.high;
                      // var low = this.low ^ word.low;
                      // return X64Word.create(high, low);
                      // },
                      /**
                       * Shifts this word n bits to the left.
                       *
                       * @param {number} n The number of bits to shift.
                       *
                       * @return {X64Word} A new x64-Word object after shifting.
                       *
                       * @example
                       *
                       *     var shifted = x64Word.shiftL(25);
                       */
                      // shiftL: function (n) {
                      // if (n < 32) {
                      // var high = (this.high << n) | (this.low >>> (32 - n));
                      // var low = this.low << n;
                      // } else {
                      // var high = this.low << (n - 32);
                      // var low = 0;
                      // }
                      // return X64Word.create(high, low);
                      // },
                      /**
                       * Shifts this word n bits to the right.
                       *
                       * @param {number} n The number of bits to shift.
                       *
                       * @return {X64Word} A new x64-Word object after shifting.
                       *
                       * @example
                       *
                       *     var shifted = x64Word.shiftR(7);
                       */
                      // shiftR: function (n) {
                      // if (n < 32) {
                      // var low = (this.low >>> n) | (this.high << (32 - n));
                      // var high = this.high >>> n;
                      // } else {
                      // var low = this.high >>> (n - 32);
                      // var high = 0;
                      // }
                      // return X64Word.create(high, low);
                      // },
                      /**
                       * Rotates this word n bits to the left.
                       *
                       * @param {number} n The number of bits to rotate.
                       *
                       * @return {X64Word} A new x64-Word object after rotating.
                       *
                       * @example
                       *
                       *     var rotated = x64Word.rotL(25);
                       */
                      // rotL: function (n) {
                      // return this.shiftL(n).or(this.shiftR(64 - n));
                      // },
                      /**
                       * Rotates this word n bits to the right.
                       *
                       * @param {number} n The number of bits to rotate.
                       *
                       * @return {X64Word} A new x64-Word object after rotating.
                       *
                       * @example
                       *
                       *     var rotated = x64Word.rotR(7);
                       */
                      // rotR: function (n) {
                      // return this.shiftR(n).or(this.shiftL(64 - n));
                      // },
                      /**
                       * Adds this word with the passed word.
                       *
                       * @param {X64Word} word The x64-Word to add with this word.
                       *
                       * @return {X64Word} A new x64-Word object after adding.
                       *
                       * @example
                       *
                       *     var added = x64Word.add(anotherX64Word);
                       */
                      // add: function (word) {
                      // var low = (this.low + word.low) | 0;
                      // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
                      // var high = (this.high + word.high + carry) | 0;
                      // return X64Word.create(high, low);
                      // }
                    });
                    var X64WordArray = C_x64.WordArray = Base.extend({
                      /**
                       * Initializes a newly created word array.
                       *
                       * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
                       * @param {number} sigBytes (Optional) The number of significant bytes in the words.
                       *
                       * @example
                       *
                       *     var wordArray = CryptoJS.x64.WordArray.create();
                       *
                       *     var wordArray = CryptoJS.x64.WordArray.create([
                       *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
                       *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
                       *     ]);
                       *
                       *     var wordArray = CryptoJS.x64.WordArray.create([
                       *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
                       *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
                       *     ], 10);
                       */
                      init: function init(words, sigBytes) {
                        words = this.words = words || [];
                        if (sigBytes != undefined2) {
                          this.sigBytes = sigBytes;
                        } else {
                          this.sigBytes = words.length * 8;
                        }
                      },
                      /**
                       * Converts this 64-bit word array to a 32-bit word array.
                       *
                       * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
                       *
                       * @example
                       *
                       *     var x32WordArray = x64WordArray.toX32();
                       */
                      toX32: function toX32() {
                        var x64Words = this.words;
                        var x64WordsLength = x64Words.length;
                        var x32Words = [];
                        for (var i = 0; i < x64WordsLength; i++) {
                          var x64Word = x64Words[i];
                          x32Words.push(x64Word.high);
                          x32Words.push(x64Word.low);
                        }
                        return X32WordArray.create(x32Words, this.sigBytes);
                      },
                      /**
                       * Creates a copy of this word array.
                       *
                       * @return {X64WordArray} The clone.
                       *
                       * @example
                       *
                       *     var clone = x64WordArray.clone();
                       */
                      clone: function clone() {
                        var clone2 = Base.clone.call(this);
                        var words = clone2.words = this.words.slice(0);
                        var wordsLength = words.length;
                        for (var i = 0; i < wordsLength; i++) {
                          words[i] = words[i].clone();
                        }
                        return clone2;
                      }
                    });
                  })();
                  return CryptoJS;
                });
              }
            ),
            /***/
            9811: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                __webpack_require__2(2443);
                __webpack_require__2(3680);
                __webpack_require__2(3706);
                __webpack_require__2(2703);
                __webpack_require__2(489);
                __webpack_require__2(4747);
                __webpack_require__2(8309);
                __webpack_require__2(8674);
                __webpack_require__2(1038);
                __webpack_require__2(4916);
                __webpack_require__2(4723);
                __webpack_require__2(2165);
                __webpack_require__2(6992);
                __webpack_require__2(1539);
                __webpack_require__2(8783);
                __webpack_require__2(3948);
                __webpack_require__2(2526);
                __webpack_require__2(1817);
                __webpack_require__2(7042);
                function _createForOfIteratorHelperLoose(o, allowArrayLike) {
                  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                  if (it)
                    return (it = it.call(o)).next.bind(it);
                  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                      o = it;
                    var i = 0;
                    return function() {
                      if (i >= o.length)
                        return { done: true };
                      return { done: false, value: o[i++] };
                    };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                function _unsupportedIterableToArray(o, minLen) {
                  if (!o)
                    return;
                  if (typeof o === "string")
                    return _arrayLikeToArray(o, minLen);
                  var n = Object.prototype.toString.call(o).slice(8, -1);
                  if (n === "Object" && o.constructor)
                    n = o.constructor.name;
                  if (n === "Map" || n === "Set")
                    return Array.from(o);
                  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                    return _arrayLikeToArray(o, minLen);
                }
                function _arrayLikeToArray(arr, len) {
                  if (len == null || len > arr.length)
                    len = arr.length;
                  for (var i = 0, arr2 = new Array(len); i < len; i++) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                }
                function _regeneratorRuntime() {
                  "use strict";
                  _regeneratorRuntime = function _regeneratorRuntime2() {
                    return exports2;
                  };
                  var exports2 = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
                    obj[key] = desc.value;
                  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
                  function define2(obj, key, value) {
                    return Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true }), obj[key];
                  }
                  try {
                    define2({}, "");
                  } catch (err) {
                    define2 = function define3(obj, key, value) {
                      return obj[key] = value;
                    };
                  }
                  function wrap(innerFn, outerFn, self2, tryLocsList) {
                    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
                    return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self2, context) }), generator;
                  }
                  function tryCatch(fn, obj, arg) {
                    try {
                      return { type: "normal", arg: fn.call(obj, arg) };
                    } catch (err) {
                      return { type: "throw", arg: err };
                    }
                  }
                  exports2.wrap = wrap;
                  var ContinueSentinel = {};
                  function Generator() {
                  }
                  function GeneratorFunction() {
                  }
                  function GeneratorFunctionPrototype() {
                  }
                  var IteratorPrototype = {};
                  define2(IteratorPrototype, iteratorSymbol, function() {
                    return this;
                  });
                  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
                  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
                  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
                  function defineIteratorMethods(prototype) {
                    ["next", "throw", "return"].forEach(function(method) {
                      define2(prototype, method, function(arg) {
                        return this._invoke(method, arg);
                      });
                    });
                  }
                  function AsyncIterator(generator, PromiseImpl) {
                    function invoke(method, arg, resolve, reject) {
                      var record = tryCatch(generator[method], generator, arg);
                      if ("throw" !== record.type) {
                        var result = record.arg, value = result.value;
                        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
                          invoke("next", value2, resolve, reject);
                        }, function(err) {
                          invoke("throw", err, resolve, reject);
                        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
                          result.value = unwrapped, resolve(result);
                        }, function(error) {
                          return invoke("throw", error, resolve, reject);
                        });
                      }
                      reject(record.arg);
                    }
                    var previousPromise;
                    defineProperty(this, "_invoke", { value: function value(method, arg) {
                      function callInvokeWithMethodAndArg() {
                        return new PromiseImpl(function(resolve, reject) {
                          invoke(method, arg, resolve, reject);
                        });
                      }
                      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
                    } });
                  }
                  function makeInvokeMethod(innerFn, self2, context) {
                    var state = "suspendedStart";
                    return function(method, arg) {
                      if ("executing" === state)
                        throw new Error("Generator is already running");
                      if ("completed" === state) {
                        if ("throw" === method)
                          throw arg;
                        return doneResult();
                      }
                      for (context.method = method, context.arg = arg; ; ) {
                        var delegate = context.delegate;
                        if (delegate) {
                          var delegateResult = maybeInvokeDelegate(delegate, context);
                          if (delegateResult) {
                            if (delegateResult === ContinueSentinel)
                              continue;
                            return delegateResult;
                          }
                        }
                        if ("next" === context.method)
                          context.sent = context._sent = context.arg;
                        else if ("throw" === context.method) {
                          if ("suspendedStart" === state)
                            throw state = "completed", context.arg;
                          context.dispatchException(context.arg);
                        } else
                          "return" === context.method && context.abrupt("return", context.arg);
                        state = "executing";
                        var record = tryCatch(innerFn, self2, context);
                        if ("normal" === record.type) {
                          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
                            continue;
                          return { value: record.arg, done: context.done };
                        }
                        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
                      }
                    };
                  }
                  function maybeInvokeDelegate(delegate, context) {
                    var methodName = context.method, method = delegate.iterator[methodName];
                    if (void 0 === method)
                      return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
                    var record = tryCatch(method, delegate.iterator, context.arg);
                    if ("throw" === record.type)
                      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
                    var info = record.arg;
                    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
                  }
                  function pushTryEntry(locs) {
                    var entry = { tryLoc: locs[0] };
                    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
                  }
                  function resetTryEntry(entry) {
                    var record = entry.completion || {};
                    record.type = "normal", delete record.arg, entry.completion = record;
                  }
                  function Context(tryLocsList) {
                    this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
                  }
                  function values(iterable) {
                    if (iterable) {
                      var iteratorMethod = iterable[iteratorSymbol];
                      if (iteratorMethod)
                        return iteratorMethod.call(iterable);
                      if ("function" == typeof iterable.next)
                        return iterable;
                      if (!isNaN(iterable.length)) {
                        var i = -1, next = function next2() {
                          for (; ++i < iterable.length; ) {
                            if (hasOwn.call(iterable, i))
                              return next2.value = iterable[i], next2.done = false, next2;
                          }
                          return next2.value = void 0, next2.done = true, next2;
                        };
                        return next.next = next;
                      }
                    }
                    return { next: doneResult };
                  }
                  function doneResult() {
                    return { value: void 0, done: true };
                  }
                  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports2.isGeneratorFunction = function(genFun) {
                    var ctor = "function" == typeof genFun && genFun.constructor;
                    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
                  }, exports2.mark = function(genFun) {
                    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
                  }, exports2.awrap = function(arg) {
                    return { __await: arg };
                  }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
                    return this;
                  }), exports2.AsyncIterator = AsyncIterator, exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
                    void 0 === PromiseImpl && (PromiseImpl = Promise);
                    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
                    return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
                      return result.done ? result.value : iter.next();
                    });
                  }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
                    return this;
                  }), define2(Gp, "toString", function() {
                    return "[object Generator]";
                  }), exports2.keys = function(val) {
                    var object = Object(val), keys = [];
                    for (var key in object) {
                      keys.push(key);
                    }
                    return keys.reverse(), function next() {
                      for (; keys.length; ) {
                        var key2 = keys.pop();
                        if (key2 in object)
                          return next.value = key2, next.done = false, next;
                      }
                      return next.done = true, next;
                    };
                  }, exports2.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) {
                    if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
                      for (var name in this) {
                        "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
                      }
                  }, stop: function stop() {
                    this.done = true;
                    var rootRecord = this.tryEntries[0].completion;
                    if ("throw" === rootRecord.type)
                      throw rootRecord.arg;
                    return this.rval;
                  }, dispatchException: function dispatchException(exception) {
                    if (this.done)
                      throw exception;
                    var context = this;
                    function handle(loc, caught) {
                      return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
                    }
                    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                      var entry = this.tryEntries[i], record = entry.completion;
                      if ("root" === entry.tryLoc)
                        return handle("end");
                      if (entry.tryLoc <= this.prev) {
                        var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
                        if (hasCatch && hasFinally) {
                          if (this.prev < entry.catchLoc)
                            return handle(entry.catchLoc, true);
                          if (this.prev < entry.finallyLoc)
                            return handle(entry.finallyLoc);
                        } else if (hasCatch) {
                          if (this.prev < entry.catchLoc)
                            return handle(entry.catchLoc, true);
                        } else {
                          if (!hasFinally)
                            throw new Error("try statement without catch or finally");
                          if (this.prev < entry.finallyLoc)
                            return handle(entry.finallyLoc);
                        }
                      }
                    }
                  }, abrupt: function abrupt(type, arg) {
                    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                      var entry = this.tryEntries[i];
                      if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                        var finallyEntry = entry;
                        break;
                      }
                    }
                    finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
                    var record = finallyEntry ? finallyEntry.completion : {};
                    return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
                  }, complete: function complete(record, afterLoc) {
                    if ("throw" === record.type)
                      throw record.arg;
                    return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
                  }, finish: function finish(finallyLoc) {
                    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                      var entry = this.tryEntries[i];
                      if (entry.finallyLoc === finallyLoc)
                        return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
                    }
                  }, catch: function _catch(tryLoc) {
                    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                      var entry = this.tryEntries[i];
                      if (entry.tryLoc === tryLoc) {
                        var record = entry.completion;
                        if ("throw" === record.type) {
                          var thrown = record.arg;
                          resetTryEntry(entry);
                        }
                        return thrown;
                      }
                    }
                    throw new Error("illegal catch attempt");
                  }, delegateYield: function delegateYield(iterable, resultName, nextLoc) {
                    return this.delegate = { iterator: values(iterable), resultName, nextLoc }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
                  } }, exports2;
                }
                var INITIAL_STATE = 1;
                var FAIL_STATE = 0;
                var StateMachine = function() {
                  function StateMachine2(dfa) {
                    this.stateTable = dfa.stateTable;
                    this.accepting = dfa.accepting;
                    this.tags = dfa.tags;
                  }
                  var _proto = StateMachine2.prototype;
                  _proto.match = function match(str) {
                    var _ref;
                    var self2 = this;
                    return _ref = {}, _ref[Symbol.iterator] = _regeneratorRuntime().mark(function _callee() {
                      var state, startRun, lastAccepting, lastState, p, c;
                      return _regeneratorRuntime().wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              state = INITIAL_STATE;
                              startRun = null;
                              lastAccepting = null;
                              lastState = null;
                              p = 0;
                            case 5:
                              if (!(p < str.length)) {
                                _context.next = 21;
                                break;
                              }
                              c = str[p];
                              lastState = state;
                              state = self2.stateTable[state][c];
                              if (!(state === FAIL_STATE)) {
                                _context.next = 15;
                                break;
                              }
                              if (!(startRun != null && lastAccepting != null && lastAccepting >= startRun)) {
                                _context.next = 13;
                                break;
                              }
                              _context.next = 13;
                              return [startRun, lastAccepting, self2.tags[lastState]];
                            case 13:
                              state = self2.stateTable[INITIAL_STATE][c];
                              startRun = null;
                            case 15:
                              if (state !== FAIL_STATE && startRun == null) {
                                startRun = p;
                              }
                              if (self2.accepting[state]) {
                                lastAccepting = p;
                              }
                              if (state === FAIL_STATE) {
                                state = INITIAL_STATE;
                              }
                            case 18:
                              p++;
                              _context.next = 5;
                              break;
                            case 21:
                              if (!(startRun != null && lastAccepting != null && lastAccepting >= startRun)) {
                                _context.next = 24;
                                break;
                              }
                              _context.next = 24;
                              return [startRun, lastAccepting, self2.tags[state]];
                            case 24:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee);
                    }), _ref;
                  };
                  _proto.apply = function apply(str, actions) {
                    for (var _iterator = _createForOfIteratorHelperLoose(this.match(str)), _step; !(_step = _iterator()).done; ) {
                      var _step$value = _step.value, start = _step$value[0], end = _step$value[1], tags = _step$value[2];
                      for (var _iterator2 = _createForOfIteratorHelperLoose(tags), _step2; !(_step2 = _iterator2()).done; ) {
                        var tag = _step2.value;
                        if (typeof actions[tag] === "function") {
                          actions[tag](start, end, str.slice(start, end + 1));
                        }
                      }
                    }
                  };
                  return StateMachine2;
                }();
                module2.exports = StateMachine;
              }
            ),
            /***/
            8478: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var Buffer = __webpack_require__2(8823)["Buffer"];
                __webpack_require__2(1539);
                __webpack_require__2(8674);
                __webpack_require__2(7042);
                __webpack_require__2(6699);
                var fs = __webpack_require__2(3857);
                var zlib = __webpack_require__2(2635);
                module2.exports = function() {
                  PNG.decode = function decode(path, fn) {
                    return fs.readFile(path, function(err, file) {
                      var png = new PNG(file);
                      return png.decode(function(pixels) {
                        return fn(pixels);
                      });
                    });
                  };
                  PNG.load = function load(path) {
                    var file = fs.readFileSync(path);
                    return new PNG(file);
                  };
                  function PNG(data) {
                    var i;
                    this.data = data;
                    this.pos = 8;
                    this.palette = [];
                    this.imgData = [];
                    this.transparency = {};
                    this.text = {};
                    while (true) {
                      var chunkSize = this.readUInt32();
                      var section = "";
                      for (i = 0; i < 4; i++) {
                        section += String.fromCharCode(this.data[this.pos++]);
                      }
                      switch (section) {
                        case "IHDR":
                          this.width = this.readUInt32();
                          this.height = this.readUInt32();
                          this.bits = this.data[this.pos++];
                          this.colorType = this.data[this.pos++];
                          this.compressionMethod = this.data[this.pos++];
                          this.filterMethod = this.data[this.pos++];
                          this.interlaceMethod = this.data[this.pos++];
                          break;
                        case "PLTE":
                          this.palette = this.read(chunkSize);
                          break;
                        case "IDAT":
                          for (i = 0; i < chunkSize; i++) {
                            this.imgData.push(this.data[this.pos++]);
                          }
                          break;
                        case "tRNS":
                          this.transparency = {};
                          switch (this.colorType) {
                            case 3:
                              this.transparency.indexed = this.read(chunkSize);
                              var short = 255 - this.transparency.indexed.length;
                              if (short > 0) {
                                for (i = 0; i < short; i++) {
                                  this.transparency.indexed.push(255);
                                }
                              }
                              break;
                            case 0:
                              this.transparency.grayscale = this.read(chunkSize)[0];
                              break;
                            case 2:
                              this.transparency.rgb = this.read(chunkSize);
                              break;
                          }
                          break;
                        case "tEXt":
                          var text = this.read(chunkSize);
                          var index = text.indexOf(0);
                          var key = String.fromCharCode.apply(String, text.slice(0, index));
                          this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));
                          break;
                        case "IEND":
                          switch (this.colorType) {
                            case 0:
                            case 3:
                            case 4:
                              this.colors = 1;
                              break;
                            case 2:
                            case 6:
                              this.colors = 3;
                              break;
                          }
                          this.hasAlphaChannel = [4, 6].includes(this.colorType);
                          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
                          this.pixelBitlength = this.bits * colors;
                          switch (this.colors) {
                            case 1:
                              this.colorSpace = "DeviceGray";
                              break;
                            case 3:
                              this.colorSpace = "DeviceRGB";
                              break;
                          }
                          this.imgData = new Buffer(this.imgData);
                          return;
                          break;
                        default:
                          this.pos += chunkSize;
                      }
                      this.pos += 4;
                      if (this.pos > this.data.length) {
                        throw new Error("Incomplete or corrupt PNG file");
                      }
                    }
                  }
                  var _proto = PNG.prototype;
                  _proto.read = function read(bytes) {
                    var result = new Array(bytes);
                    for (var i = 0; i < bytes; i++) {
                      result[i] = this.data[this.pos++];
                    }
                    return result;
                  };
                  _proto.readUInt32 = function readUInt32() {
                    var b1 = this.data[this.pos++] << 24;
                    var b2 = this.data[this.pos++] << 16;
                    var b3 = this.data[this.pos++] << 8;
                    var b4 = this.data[this.pos++];
                    return b1 | b2 | b3 | b4;
                  };
                  _proto.readUInt16 = function readUInt16() {
                    var b1 = this.data[this.pos++] << 8;
                    var b2 = this.data[this.pos++];
                    return b1 | b2;
                  };
                  _proto.decodePixels = function decodePixels(fn) {
                    var _this = this;
                    return zlib.inflate(this.imgData, function(err, data) {
                      if (err) {
                        throw err;
                      }
                      var width = _this.width, height = _this.height;
                      var pixelBytes = _this.pixelBitlength / 8;
                      var pixels = new Buffer(width * height * pixelBytes);
                      var length = data.length;
                      var pos = 0;
                      function pass(x0, y0, dx, dy, singlePass) {
                        if (singlePass === void 0) {
                          singlePass = false;
                        }
                        var w = Math.ceil((width - x0) / dx);
                        var h = Math.ceil((height - y0) / dy);
                        var scanlineLength = pixelBytes * w;
                        var buffer = singlePass ? pixels : new Buffer(scanlineLength * h);
                        var row = 0;
                        var c = 0;
                        while (row < h && pos < length) {
                          var byte, col, i, left, upper;
                          switch (data[pos++]) {
                            case 0:
                              for (i = 0; i < scanlineLength; i++) {
                                buffer[c++] = data[pos++];
                              }
                              break;
                            case 1:
                              for (i = 0; i < scanlineLength; i++) {
                                byte = data[pos++];
                                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];
                                buffer[c++] = (byte + left) % 256;
                              }
                              break;
                            case 2:
                              for (i = 0; i < scanlineLength; i++) {
                                byte = data[pos++];
                                col = (i - i % pixelBytes) / pixelBytes;
                                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                                buffer[c++] = (upper + byte) % 256;
                              }
                              break;
                            case 3:
                              for (i = 0; i < scanlineLength; i++) {
                                byte = data[pos++];
                                col = (i - i % pixelBytes) / pixelBytes;
                                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];
                                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                                buffer[c++] = (byte + Math.floor((left + upper) / 2)) % 256;
                              }
                              break;
                            case 4:
                              for (i = 0; i < scanlineLength; i++) {
                                var paeth, upperLeft;
                                byte = data[pos++];
                                col = (i - i % pixelBytes) / pixelBytes;
                                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];
                                if (row === 0) {
                                  upper = upperLeft = 0;
                                } else {
                                  upper = buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                                  upperLeft = col && buffer[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];
                                }
                                var p = left + upper - upperLeft;
                                var pa = Math.abs(p - left);
                                var pb = Math.abs(p - upper);
                                var pc = Math.abs(p - upperLeft);
                                if (pa <= pb && pa <= pc) {
                                  paeth = left;
                                } else if (pb <= pc) {
                                  paeth = upper;
                                } else {
                                  paeth = upperLeft;
                                }
                                buffer[c++] = (byte + paeth) % 256;
                              }
                              break;
                            default:
                              throw new Error("Invalid filter algorithm: " + data[pos - 1]);
                          }
                          if (!singlePass) {
                            var pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;
                            var bufferPos = row * scanlineLength;
                            for (i = 0; i < w; i++) {
                              for (var j = 0; j < pixelBytes; j++) {
                                pixels[pixelsPos++] = buffer[bufferPos++];
                              }
                              pixelsPos += (dx - 1) * pixelBytes;
                            }
                          }
                          row++;
                        }
                      }
                      if (_this.interlaceMethod === 1) {
                        pass(0, 0, 8, 8);
                        pass(4, 0, 8, 8);
                        pass(0, 4, 4, 8);
                        pass(2, 0, 4, 4);
                        pass(0, 2, 2, 4);
                        pass(1, 0, 2, 2);
                        pass(0, 1, 1, 2);
                      } else {
                        pass(0, 0, 1, 1, true);
                      }
                      return fn(pixels);
                    });
                  };
                  _proto.decodePalette = function decodePalette() {
                    var palette = this.palette;
                    var length = palette.length;
                    var transparency = this.transparency.indexed || [];
                    var ret = new Buffer(transparency.length + length);
                    var pos = 0;
                    var c = 0;
                    for (var i = 0; i < length; i += 3) {
                      var left;
                      ret[pos++] = palette[i];
                      ret[pos++] = palette[i + 1];
                      ret[pos++] = palette[i + 2];
                      ret[pos++] = (left = transparency[c++]) != null ? left : 255;
                    }
                    return ret;
                  };
                  _proto.copyToImageData = function copyToImageData(imageData, pixels) {
                    var j, k;
                    var colors = this.colors;
                    var palette = null;
                    var alpha = this.hasAlphaChannel;
                    if (this.palette.length) {
                      palette = this._decodedPalette || (this._decodedPalette = this.decodePalette());
                      colors = 4;
                      alpha = true;
                    }
                    var data = imageData.data || imageData;
                    var length = data.length;
                    var input = palette || pixels;
                    var i = j = 0;
                    if (colors === 1) {
                      while (i < length) {
                        k = palette ? pixels[i / 4] * 4 : j;
                        var v = input[k++];
                        data[i++] = v;
                        data[i++] = v;
                        data[i++] = v;
                        data[i++] = alpha ? input[k++] : 255;
                        j = k;
                      }
                    } else {
                      while (i < length) {
                        k = palette ? pixels[i / 4] * 4 : j;
                        data[i++] = input[k++];
                        data[i++] = input[k++];
                        data[i++] = input[k++];
                        data[i++] = alpha ? input[k++] : 255;
                        j = k;
                      }
                    }
                  };
                  _proto.decode = function decode(fn) {
                    var _this2 = this;
                    var ret = new Buffer(this.width * this.height * 4);
                    return this.decodePixels(function(pixels) {
                      _this2.copyToImageData(ret, pixels);
                      return fn(ret);
                    });
                  };
                  return PNG;
                }();
              }
            ),
            /***/
            7103: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var process = __webpack_require__2(4155);
                __webpack_require__2(8145);
                __webpack_require__2(6992);
                __webpack_require__2(1539);
                __webpack_require__2(2472);
                __webpack_require__2(2990);
                __webpack_require__2(8927);
                __webpack_require__2(3105);
                __webpack_require__2(5035);
                __webpack_require__2(4345);
                __webpack_require__2(7174);
                __webpack_require__2(2846);
                __webpack_require__2(4731);
                __webpack_require__2(7209);
                __webpack_require__2(6319);
                __webpack_require__2(8867);
                __webpack_require__2(7789);
                __webpack_require__2(3739);
                __webpack_require__2(9368);
                __webpack_require__2(4483);
                __webpack_require__2(2056);
                __webpack_require__2(3462);
                __webpack_require__2(678);
                __webpack_require__2(7462);
                __webpack_require__2(3824);
                __webpack_require__2(5021);
                __webpack_require__2(2974);
                __webpack_require__2(5016);
                __webpack_require__2(3290);
                var buffer = __webpack_require__2(8823);
                var Buffer = buffer.Buffer;
                var safer = {};
                var key;
                for (key in buffer) {
                  if (!buffer.hasOwnProperty(key))
                    continue;
                  if (key === "SlowBuffer" || key === "Buffer")
                    continue;
                  safer[key] = buffer[key];
                }
                var Safer = safer.Buffer = {};
                for (key in Buffer) {
                  if (!Buffer.hasOwnProperty(key))
                    continue;
                  if (key === "allocUnsafe" || key === "allocUnsafeSlow")
                    continue;
                  Safer[key] = Buffer[key];
                }
                safer.Buffer.prototype = Buffer.prototype;
                if (!Safer.from || Safer.from === Uint8Array.from) {
                  Safer.from = function(value, encodingOrOffset, length) {
                    if (typeof value === "number") {
                      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
                    }
                    if (value && typeof value.length === "undefined") {
                      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
                    }
                    return Buffer(value, encodingOrOffset, length);
                  };
                }
                if (!Safer.alloc) {
                  Safer.alloc = function(size, fill, encoding) {
                    if (typeof size !== "number") {
                      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
                    }
                    if (size < 0 || size >= 2 * (1 << 30)) {
                      throw new RangeError('The value "' + size + '" is invalid for option "size"');
                    }
                    var buf = Buffer(size);
                    if (!fill || fill.length === 0) {
                      buf.fill(0);
                    } else if (typeof encoding === "string") {
                      buf.fill(fill, encoding);
                    } else {
                      buf.fill(fill);
                    }
                    return buf;
                  };
                }
                if (!safer.kStringMaxLength) {
                  try {
                    safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
                  } catch (e) {
                  }
                }
                if (!safer.constants) {
                  safer.constants = {
                    MAX_LENGTH: safer.kMaxLength
                  };
                  if (safer.kStringMaxLength) {
                    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
                  }
                }
                module2.exports = safer;
              }
            ),
            /***/
            3361: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                __webpack_require__2(7941);
                __webpack_require__2(2526);
                __webpack_require__2(7327);
                __webpack_require__2(1539);
                __webpack_require__2(5003);
                __webpack_require__2(4747);
                __webpack_require__2(9337);
                __webpack_require__2(7042);
                function ownKeys(object, enumerableOnly) {
                  var keys = Object.keys(object);
                  if (Object.getOwnPropertySymbols) {
                    var symbols = Object.getOwnPropertySymbols(object);
                    if (enumerableOnly)
                      symbols = symbols.filter(function(sym) {
                        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                      });
                    keys.push.apply(keys, symbols);
                  }
                  return keys;
                }
                function _objectSpread(target) {
                  for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i] != null ? arguments[i] : {};
                    if (i % 2) {
                      ownKeys(Object(source), true).forEach(function(key) {
                        _defineProperty(target, key, source[key]);
                      });
                    } else if (Object.getOwnPropertyDescriptors) {
                      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                    } else {
                      ownKeys(Object(source)).forEach(function(key) {
                        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                      });
                    }
                  }
                  return target;
                }
                function _defineProperty(obj, key, value) {
                  if (key in obj) {
                    Object.defineProperty(obj, key, {
                      value,
                      enumerable: true,
                      configurable: true,
                      writable: true
                    });
                  } else {
                    obj[key] = value;
                  }
                  return obj;
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  return Constructor;
                }
                var _require = __webpack_require__2(8823), Buffer = _require.Buffer;
                var _require2 = __webpack_require__2(9862), inspect = _require2.inspect;
                var custom = inspect && inspect.custom || "inspect";
                function copyBuffer(src, target, offset) {
                  Buffer.prototype.copy.call(src, target, offset);
                }
                module2.exports = function() {
                  function BufferList() {
                    _classCallCheck(this, BufferList);
                    this.head = null;
                    this.tail = null;
                    this.length = 0;
                  }
                  _createClass(BufferList, [{
                    key: "push",
                    value: function push(v) {
                      var entry = {
                        data: v,
                        next: null
                      };
                      if (this.length > 0)
                        this.tail.next = entry;
                      else
                        this.head = entry;
                      this.tail = entry;
                      ++this.length;
                    }
                  }, {
                    key: "unshift",
                    value: function unshift(v) {
                      var entry = {
                        data: v,
                        next: this.head
                      };
                      if (this.length === 0)
                        this.tail = entry;
                      this.head = entry;
                      ++this.length;
                    }
                  }, {
                    key: "shift",
                    value: function shift() {
                      if (this.length === 0)
                        return;
                      var ret = this.head.data;
                      if (this.length === 1)
                        this.head = this.tail = null;
                      else
                        this.head = this.head.next;
                      --this.length;
                      return ret;
                    }
                  }, {
                    key: "clear",
                    value: function clear() {
                      this.head = this.tail = null;
                      this.length = 0;
                    }
                  }, {
                    key: "join",
                    value: function join(s) {
                      if (this.length === 0)
                        return "";
                      var p = this.head;
                      var ret = "" + p.data;
                      while (p = p.next) {
                        ret += s + p.data;
                      }
                      return ret;
                    }
                  }, {
                    key: "concat",
                    value: function concat(n) {
                      if (this.length === 0)
                        return Buffer.alloc(0);
                      var ret = Buffer.allocUnsafe(n >>> 0);
                      var p = this.head;
                      var i = 0;
                      while (p) {
                        copyBuffer(p.data, ret, i);
                        i += p.data.length;
                        p = p.next;
                      }
                      return ret;
                    }
                    // Consumes a specified amount of bytes or characters from the buffered data.
                  }, {
                    key: "consume",
                    value: function consume(n, hasStrings) {
                      var ret;
                      if (n < this.head.data.length) {
                        ret = this.head.data.slice(0, n);
                        this.head.data = this.head.data.slice(n);
                      } else if (n === this.head.data.length) {
                        ret = this.shift();
                      } else {
                        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
                      }
                      return ret;
                    }
                  }, {
                    key: "first",
                    value: function first() {
                      return this.head.data;
                    }
                    // Consumes a specified amount of characters from the buffered data.
                  }, {
                    key: "_getString",
                    value: function _getString(n) {
                      var p = this.head;
                      var c = 1;
                      var ret = p.data;
                      n -= ret.length;
                      while (p = p.next) {
                        var str = p.data;
                        var nb = n > str.length ? str.length : n;
                        if (nb === str.length)
                          ret += str;
                        else
                          ret += str.slice(0, n);
                        n -= nb;
                        if (n === 0) {
                          if (nb === str.length) {
                            ++c;
                            if (p.next)
                              this.head = p.next;
                            else
                              this.head = this.tail = null;
                          } else {
                            this.head = p;
                            p.data = str.slice(nb);
                          }
                          break;
                        }
                        ++c;
                      }
                      this.length -= c;
                      return ret;
                    }
                    // Consumes a specified amount of bytes from the buffered data.
                  }, {
                    key: "_getBuffer",
                    value: function _getBuffer(n) {
                      var ret = Buffer.allocUnsafe(n);
                      var p = this.head;
                      var c = 1;
                      p.data.copy(ret);
                      n -= p.data.length;
                      while (p = p.next) {
                        var buf = p.data;
                        var nb = n > buf.length ? buf.length : n;
                        buf.copy(ret, ret.length - n, 0, nb);
                        n -= nb;
                        if (n === 0) {
                          if (nb === buf.length) {
                            ++c;
                            if (p.next)
                              this.head = p.next;
                            else
                              this.head = this.tail = null;
                          } else {
                            this.head = p;
                            p.data = buf.slice(nb);
                          }
                          break;
                        }
                        ++c;
                      }
                      this.length -= c;
                      return ret;
                    }
                    // Make sure the linked list only shows the minimal necessary information.
                  }, {
                    key: custom,
                    value: function value(_, options) {
                      return inspect(this, _objectSpread({}, options, {
                        // Only inspect one level.
                        depth: 0,
                        // It should not recurse.
                        customInspect: false
                      }));
                    }
                  }]);
                  return BufferList;
                }();
              }
            ),
            /***/
            5219: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var __dirname = "/";
                var Buffer = __webpack_require__2(8823)["Buffer"];
                Object.defineProperty(exports2, "__esModule", {
                  value: true
                });
                exports2["default"] = void 0;
                __webpack_require__2(7941);
                __webpack_require__2(2526);
                __webpack_require__2(7327);
                __webpack_require__2(1539);
                __webpack_require__2(5003);
                __webpack_require__2(4747);
                __webpack_require__2(9337);
                __webpack_require__2(489);
                __webpack_require__2(2419);
                __webpack_require__2(1817);
                __webpack_require__2(2165);
                __webpack_require__2(6992);
                __webpack_require__2(8783);
                __webpack_require__2(3948);
                __webpack_require__2(1038);
                __webpack_require__2(7042);
                __webpack_require__2(8309);
                __webpack_require__2(4916);
                __webpack_require__2(2707);
                __webpack_require__2(2222);
                __webpack_require__2(9600);
                __webpack_require__2(9714);
                __webpack_require__2(5306);
                __webpack_require__2(1249);
                __webpack_require__2(9841);
                __webpack_require__2(4953);
                __webpack_require__2(6977);
                __webpack_require__2(6699);
                __webpack_require__2(5192);
                __webpack_require__2(9653);
                __webpack_require__2(3123);
                __webpack_require__2(4723);
                __webpack_require__2(8734);
                __webpack_require__2(2472);
                __webpack_require__2(2990);
                __webpack_require__2(8927);
                __webpack_require__2(3105);
                __webpack_require__2(5035);
                __webpack_require__2(4345);
                __webpack_require__2(7174);
                __webpack_require__2(2846);
                __webpack_require__2(4731);
                __webpack_require__2(7209);
                __webpack_require__2(6319);
                __webpack_require__2(8867);
                __webpack_require__2(7789);
                __webpack_require__2(3739);
                __webpack_require__2(9368);
                __webpack_require__2(4483);
                __webpack_require__2(2056);
                __webpack_require__2(3462);
                __webpack_require__2(678);
                __webpack_require__2(7462);
                __webpack_require__2(3824);
                __webpack_require__2(5021);
                __webpack_require__2(2974);
                __webpack_require__2(5016);
                __webpack_require__2(7803);
                __webpack_require__2(3290);
                __webpack_require__2(9601);
                __webpack_require__2(3210);
                __webpack_require__2(9254);
                __webpack_require__2(7397);
                __webpack_require__2(8674);
                var _stream = _interopRequireDefault(__webpack_require__2(2830));
                var _zlib = _interopRequireDefault(__webpack_require__2(2635));
                var _cryptoJs = _interopRequireDefault(__webpack_require__2(5153));
                var _fontkit = _interopRequireDefault(__webpack_require__2(1917));
                var _events = __webpack_require__2(7187);
                var _linebreak = _interopRequireDefault(__webpack_require__2(7337));
                var _pngJs = _interopRequireDefault(__webpack_require__2(8478));
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : { default: obj };
                }
                var fs = __webpack_require__2(3857);
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  return Constructor;
                }
                function _defineProperty(obj, key, value) {
                  if (key in obj) {
                    Object.defineProperty(obj, key, {
                      value,
                      enumerable: true,
                      configurable: true,
                      writable: true
                    });
                  } else {
                    obj[key] = value;
                  }
                  return obj;
                }
                function ownKeys(object, enumerableOnly) {
                  var keys = Object.keys(object);
                  if (Object.getOwnPropertySymbols) {
                    var symbols = Object.getOwnPropertySymbols(object);
                    if (enumerableOnly)
                      symbols = symbols.filter(function(sym) {
                        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                      });
                    keys.push.apply(keys, symbols);
                  }
                  return keys;
                }
                function _objectSpread2(target) {
                  for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i] != null ? arguments[i] : {};
                    if (i % 2) {
                      ownKeys(Object(source), true).forEach(function(key) {
                        _defineProperty(target, key, source[key]);
                      });
                    } else if (Object.getOwnPropertyDescriptors) {
                      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                    } else {
                      ownKeys(Object(source)).forEach(function(key) {
                        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                      });
                    }
                  }
                  return target;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function");
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                      value: subClass,
                      writable: true,
                      configurable: true
                    }
                  });
                  if (superClass)
                    _setPrototypeOf(subClass, superClass);
                }
                function _getPrototypeOf(o) {
                  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                    return o2.__proto__ || Object.getPrototypeOf(o2);
                  };
                  return _getPrototypeOf(o);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                function _isNativeReflectConstruct() {
                  if (typeof Reflect === "undefined" || !Reflect.construct)
                    return false;
                  if (Reflect.construct.sham)
                    return false;
                  if (typeof Proxy === "function")
                    return true;
                  try {
                    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                    }));
                    return true;
                  } catch (e) {
                    return false;
                  }
                }
                function _assertThisInitialized(self2) {
                  if (self2 === void 0) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return self2;
                }
                function _possibleConstructorReturn(self2, call) {
                  if (call && (typeof call === "object" || typeof call === "function")) {
                    return call;
                  }
                  return _assertThisInitialized(self2);
                }
                function _createSuper(Derived) {
                  var hasNativeReflectConstruct = _isNativeReflectConstruct();
                  return function _createSuperInternal() {
                    var Super = _getPrototypeOf(Derived), result;
                    if (hasNativeReflectConstruct) {
                      var NewTarget = _getPrototypeOf(this).constructor;
                      result = Reflect.construct(Super, arguments, NewTarget);
                    } else {
                      result = Super.apply(this, arguments);
                    }
                    return _possibleConstructorReturn(this, result);
                  };
                }
                function _slicedToArray(arr, i) {
                  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
                }
                function _toConsumableArray(arr) {
                  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
                }
                function _arrayWithoutHoles(arr) {
                  if (Array.isArray(arr))
                    return _arrayLikeToArray(arr);
                }
                function _arrayWithHoles(arr) {
                  if (Array.isArray(arr))
                    return arr;
                }
                function _iterableToArray(iter) {
                  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
                    return Array.from(iter);
                }
                function _iterableToArrayLimit(arr, i) {
                  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
                    return;
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e = void 0;
                  try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                      _arr.push(_s.value);
                      if (i && _arr.length === i)
                        break;
                    }
                  } catch (err) {
                    _d = true;
                    _e = err;
                  } finally {
                    try {
                      if (!_n && _i["return"] != null)
                        _i["return"]();
                    } finally {
                      if (_d)
                        throw _e;
                    }
                  }
                  return _arr;
                }
                function _unsupportedIterableToArray(o, minLen) {
                  if (!o)
                    return;
                  if (typeof o === "string")
                    return _arrayLikeToArray(o, minLen);
                  var n = Object.prototype.toString.call(o).slice(8, -1);
                  if (n === "Object" && o.constructor)
                    n = o.constructor.name;
                  if (n === "Map" || n === "Set")
                    return Array.from(o);
                  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                    return _arrayLikeToArray(o, minLen);
                }
                function _arrayLikeToArray(arr, len) {
                  if (len == null || len > arr.length)
                    len = arr.length;
                  for (var i = 0, arr2 = new Array(len); i < len; i++) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                }
                function _nonIterableSpread() {
                  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                function _nonIterableRest() {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                function _createForOfIteratorHelper(o, allowArrayLike) {
                  var it;
                  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                      if (it)
                        o = it;
                      var i = 0;
                      var F = function F2() {
                      };
                      return {
                        s: F,
                        n: function n() {
                          if (i >= o.length)
                            return {
                              done: true
                            };
                          return {
                            done: false,
                            value: o[i++]
                          };
                        },
                        e: function e(_e2) {
                          throw _e2;
                        },
                        f: F
                      };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                  }
                  var normalCompletion = true, didErr = false, err;
                  return {
                    s: function s() {
                      it = o[Symbol.iterator]();
                    },
                    n: function n() {
                      var step = it.next();
                      normalCompletion = step.done;
                      return step;
                    },
                    e: function e(_e3) {
                      didErr = true;
                      err = _e3;
                    },
                    f: function f() {
                      try {
                        if (!normalCompletion && it.return != null)
                          it.return();
                      } finally {
                        if (didErr)
                          throw err;
                      }
                    }
                  };
                }
                var PDFAbstractReference = function() {
                  function PDFAbstractReference2() {
                    _classCallCheck(this, PDFAbstractReference2);
                  }
                  _createClass(PDFAbstractReference2, [{
                    key: "toString",
                    value: function toString() {
                      throw new Error("Must be implemented by subclasses");
                    }
                  }]);
                  return PDFAbstractReference2;
                }();
                var PDFTree = function() {
                  function PDFTree2() {
                    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    _classCallCheck(this, PDFTree2);
                    this._items = {};
                    this.limits = typeof options.limits === "boolean" ? options.limits : true;
                  }
                  _createClass(PDFTree2, [{
                    key: "add",
                    value: function add(key, val) {
                      return this._items[key] = val;
                    }
                  }, {
                    key: "get",
                    value: function get(key) {
                      return this._items[key];
                    }
                  }, {
                    key: "toString",
                    value: function toString() {
                      var _this = this;
                      var sortedKeys = Object.keys(this._items).sort(function(a, b) {
                        return _this._compareKeys(a, b);
                      });
                      var out = ["<<"];
                      if (this.limits && sortedKeys.length > 1) {
                        var first2 = sortedKeys[0], last2 = sortedKeys[sortedKeys.length - 1];
                        out.push("  /Limits ".concat(PDFObject.convert([this._dataForKey(first2), this._dataForKey(last2)])));
                      }
                      out.push("  /".concat(this._keysName(), " ["));
                      var _iterator = _createForOfIteratorHelper(sortedKeys), _step;
                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                          var key = _step.value;
                          out.push("    ".concat(PDFObject.convert(this._dataForKey(key)), " ").concat(PDFObject.convert(this._items[key])));
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }
                      out.push("]");
                      out.push(">>");
                      return out.join("\n");
                    }
                  }, {
                    key: "_compareKeys",
                    value: function _compareKeys() {
                      throw new Error("Must be implemented by subclasses");
                    }
                  }, {
                    key: "_keysName",
                    value: function _keysName() {
                      throw new Error("Must be implemented by subclasses");
                    }
                  }, {
                    key: "_dataForKey",
                    value: function _dataForKey() {
                      throw new Error("Must be implemented by subclasses");
                    }
                  }]);
                  return PDFTree2;
                }();
                var pad = function pad2(str, length) {
                  return (Array(length + 1).join("0") + str).slice(-length);
                };
                var escapableRe = /[\n\r\t\b\f()\\]/g;
                var escapable = {
                  "\n": "\\n",
                  "\r": "\\r",
                  "	": "\\t",
                  "\b": "\\b",
                  "\f": "\\f",
                  "\\": "\\\\",
                  "(": "\\(",
                  ")": "\\)"
                };
                var swapBytes = function swapBytes2(buff) {
                  var l = buff.length;
                  if (l & 1) {
                    throw new Error("Buffer length must be even");
                  } else {
                    for (var i = 0, end = l - 1; i < end; i += 2) {
                      var a = buff[i];
                      buff[i] = buff[i + 1];
                      buff[i + 1] = a;
                    }
                  }
                  return buff;
                };
                var PDFObject = function() {
                  function PDFObject2() {
                    _classCallCheck(this, PDFObject2);
                  }
                  _createClass(PDFObject2, null, [{
                    key: "convert",
                    value: function convert(object) {
                      var encryptFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                      if (typeof object === "string") {
                        return "/".concat(object);
                      } else if (object instanceof String) {
                        var string = object;
                        var isUnicode = false;
                        for (var i = 0, end = string.length; i < end; i++) {
                          if (string.charCodeAt(i) > 127) {
                            isUnicode = true;
                            break;
                          }
                        }
                        var stringBuffer;
                        if (isUnicode) {
                          stringBuffer = swapBytes(Buffer.from("\uFEFF".concat(string), "utf16le"));
                        } else {
                          stringBuffer = Buffer.from(string.valueOf(), "ascii");
                        }
                        if (encryptFn) {
                          string = encryptFn(stringBuffer).toString("binary");
                        } else {
                          string = stringBuffer.toString("binary");
                        }
                        string = string.replace(escapableRe, function(c) {
                          return escapable[c];
                        });
                        return "(".concat(string, ")");
                      } else if (Buffer.isBuffer(object)) {
                        return "<".concat(object.toString("hex"), ">");
                      } else if (object instanceof PDFAbstractReference || object instanceof PDFTree) {
                        return object.toString();
                      } else if (object instanceof Date) {
                        var _string = "D:".concat(pad(object.getUTCFullYear(), 4)) + pad(object.getUTCMonth() + 1, 2) + pad(object.getUTCDate(), 2) + pad(object.getUTCHours(), 2) + pad(object.getUTCMinutes(), 2) + pad(object.getUTCSeconds(), 2) + "Z";
                        if (encryptFn) {
                          _string = encryptFn(Buffer.from(_string, "ascii")).toString("binary");
                          _string = _string.replace(escapableRe, function(c) {
                            return escapable[c];
                          });
                        }
                        return "(".concat(_string, ")");
                      } else if (Array.isArray(object)) {
                        var items = object.map(function(e) {
                          return PDFObject2.convert(e, encryptFn);
                        }).join(" ");
                        return "[".concat(items, "]");
                      } else if ({}.toString.call(object) === "[object Object]") {
                        var out = ["<<"];
                        for (var key in object) {
                          var val = object[key];
                          out.push("/".concat(key, " ").concat(PDFObject2.convert(val, encryptFn)));
                        }
                        out.push(">>");
                        return out.join("\n");
                      } else if (typeof object === "number") {
                        return PDFObject2.number(object);
                      } else {
                        return "".concat(object);
                      }
                    }
                  }, {
                    key: "number",
                    value: function number2(n) {
                      if (n > -1e21 && n < 1e21) {
                        return Math.round(n * 1e6) / 1e6;
                      }
                      throw new Error("unsupported number: ".concat(n));
                    }
                  }]);
                  return PDFObject2;
                }();
                var PDFReference = function(_PDFAbstractReference) {
                  _inherits(PDFReference2, _PDFAbstractReference);
                  var _super = _createSuper(PDFReference2);
                  function PDFReference2(document2, id) {
                    var _this;
                    var data = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                    _classCallCheck(this, PDFReference2);
                    _this = _super.call(this);
                    _this.document = document2;
                    _this.id = id;
                    _this.data = data;
                    _this.gen = 0;
                    _this.compress = _this.document.compress && !_this.data.Filter;
                    _this.uncompressedLength = 0;
                    _this.buffer = [];
                    return _this;
                  }
                  _createClass(PDFReference2, [{
                    key: "write",
                    value: function write(chunk) {
                      if (!Buffer.isBuffer(chunk)) {
                        chunk = Buffer.from(chunk + "\n", "binary");
                      }
                      this.uncompressedLength += chunk.length;
                      if (this.data.Length == null) {
                        this.data.Length = 0;
                      }
                      this.buffer.push(chunk);
                      this.data.Length += chunk.length;
                      if (this.compress) {
                        return this.data.Filter = "FlateDecode";
                      }
                    }
                  }, {
                    key: "end",
                    value: function end(chunk) {
                      if (chunk) {
                        this.write(chunk);
                      }
                      return this.finalize();
                    }
                  }, {
                    key: "finalize",
                    value: function finalize() {
                      this.offset = this.document._offset;
                      var encryptFn = this.document._security ? this.document._security.getEncryptFn(this.id, this.gen) : null;
                      if (this.buffer.length) {
                        this.buffer = Buffer.concat(this.buffer);
                        if (this.compress) {
                          this.buffer = _zlib.default.deflateSync(this.buffer);
                        }
                        if (encryptFn) {
                          this.buffer = encryptFn(this.buffer);
                        }
                        this.data.Length = this.buffer.length;
                      }
                      this.document._write("".concat(this.id, " ").concat(this.gen, " obj"));
                      this.document._write(PDFObject.convert(this.data, encryptFn));
                      if (this.buffer.length) {
                        this.document._write("stream");
                        this.document._write(this.buffer);
                        this.buffer = [];
                        this.document._write("\nendstream");
                      }
                      this.document._write("endobj");
                      this.document._refEnd(this);
                    }
                  }, {
                    key: "toString",
                    value: function toString() {
                      return "".concat(this.id, " ").concat(this.gen, " R");
                    }
                  }]);
                  return PDFReference2;
                }(PDFAbstractReference);
                var DEFAULT_MARGINS = {
                  top: 72,
                  left: 72,
                  bottom: 72,
                  right: 72
                };
                var SIZES = {
                  "4A0": [4767.87, 6740.79],
                  "2A0": [3370.39, 4767.87],
                  A0: [2383.94, 3370.39],
                  A1: [1683.78, 2383.94],
                  A2: [1190.55, 1683.78],
                  A3: [841.89, 1190.55],
                  A4: [595.28, 841.89],
                  A5: [419.53, 595.28],
                  A6: [297.64, 419.53],
                  A7: [209.76, 297.64],
                  A8: [147.4, 209.76],
                  A9: [104.88, 147.4],
                  A10: [73.7, 104.88],
                  B0: [2834.65, 4008.19],
                  B1: [2004.09, 2834.65],
                  B2: [1417.32, 2004.09],
                  B3: [1000.63, 1417.32],
                  B4: [708.66, 1000.63],
                  B5: [498.9, 708.66],
                  B6: [354.33, 498.9],
                  B7: [249.45, 354.33],
                  B8: [175.75, 249.45],
                  B9: [124.72, 175.75],
                  B10: [87.87, 124.72],
                  C0: [2599.37, 3676.54],
                  C1: [1836.85, 2599.37],
                  C2: [1298.27, 1836.85],
                  C3: [918.43, 1298.27],
                  C4: [649.13, 918.43],
                  C5: [459.21, 649.13],
                  C6: [323.15, 459.21],
                  C7: [229.61, 323.15],
                  C8: [161.57, 229.61],
                  C9: [113.39, 161.57],
                  C10: [79.37, 113.39],
                  RA0: [2437.8, 3458.27],
                  RA1: [1729.13, 2437.8],
                  RA2: [1218.9, 1729.13],
                  RA3: [864.57, 1218.9],
                  RA4: [609.45, 864.57],
                  SRA0: [2551.18, 3628.35],
                  SRA1: [1814.17, 2551.18],
                  SRA2: [1275.59, 1814.17],
                  SRA3: [907.09, 1275.59],
                  SRA4: [637.8, 907.09],
                  EXECUTIVE: [521.86, 756],
                  FOLIO: [612, 936],
                  LEGAL: [612, 1008],
                  LETTER: [612, 792],
                  TABLOID: [792, 1224]
                };
                var PDFPage = function() {
                  function PDFPage2(document2) {
                    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                    _classCallCheck(this, PDFPage2);
                    this.document = document2;
                    this.size = options.size || "letter";
                    this.layout = options.layout || "portrait";
                    if (typeof options.margin === "number") {
                      this.margins = {
                        top: options.margin,
                        left: options.margin,
                        bottom: options.margin,
                        right: options.margin
                      };
                    } else {
                      this.margins = options.margins || DEFAULT_MARGINS;
                    }
                    var dimensions = Array.isArray(this.size) ? this.size : SIZES[this.size.toUpperCase()];
                    this.width = dimensions[this.layout === "portrait" ? 0 : 1];
                    this.height = dimensions[this.layout === "portrait" ? 1 : 0];
                    this.content = this.document.ref();
                    this.resources = this.document.ref({
                      ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"]
                    });
                    this.dictionary = this.document.ref({
                      Type: "Page",
                      Parent: this.document._root.data.Pages,
                      MediaBox: [0, 0, this.width, this.height],
                      Contents: this.content,
                      Resources: this.resources
                    });
                    this.markings = [];
                  }
                  _createClass(PDFPage2, [{
                    key: "maxY",
                    value: function maxY() {
                      return this.height - this.margins.bottom;
                    }
                  }, {
                    key: "write",
                    value: function write(chunk) {
                      return this.content.write(chunk);
                    }
                  }, {
                    key: "end",
                    value: function end() {
                      this.dictionary.end();
                      this.resources.end();
                      return this.content.end();
                    }
                  }, {
                    key: "fonts",
                    get: function get() {
                      var data = this.resources.data;
                      return data.Font != null ? data.Font : data.Font = {};
                    }
                  }, {
                    key: "xobjects",
                    get: function get() {
                      var data = this.resources.data;
                      return data.XObject != null ? data.XObject : data.XObject = {};
                    }
                  }, {
                    key: "ext_gstates",
                    get: function get() {
                      var data = this.resources.data;
                      return data.ExtGState != null ? data.ExtGState : data.ExtGState = {};
                    }
                  }, {
                    key: "patterns",
                    get: function get() {
                      var data = this.resources.data;
                      return data.Pattern != null ? data.Pattern : data.Pattern = {};
                    }
                  }, {
                    key: "colorSpaces",
                    get: function get() {
                      var data = this.resources.data;
                      return data.ColorSpace || (data.ColorSpace = {});
                    }
                  }, {
                    key: "annotations",
                    get: function get() {
                      var data = this.dictionary.data;
                      return data.Annots != null ? data.Annots : data.Annots = [];
                    }
                  }, {
                    key: "structParentTreeKey",
                    get: function get() {
                      var data = this.dictionary.data;
                      return data.StructParents != null ? data.StructParents : data.StructParents = this.document.createStructParentTreeNextKey();
                    }
                  }]);
                  return PDFPage2;
                }();
                var PDFNameTree = function(_PDFTree) {
                  _inherits(PDFNameTree2, _PDFTree);
                  var _super = _createSuper(PDFNameTree2);
                  function PDFNameTree2() {
                    _classCallCheck(this, PDFNameTree2);
                    return _super.apply(this, arguments);
                  }
                  _createClass(PDFNameTree2, [{
                    key: "_compareKeys",
                    value: function _compareKeys(a, b) {
                      return a.localeCompare(b);
                    }
                  }, {
                    key: "_keysName",
                    value: function _keysName() {
                      return "Names";
                    }
                  }, {
                    key: "_dataForKey",
                    value: function _dataForKey(k) {
                      return new String(k);
                    }
                  }]);
                  return PDFNameTree2;
                }(PDFTree);
                function inRange(value, rangeGroup) {
                  if (value < rangeGroup[0])
                    return false;
                  var startRange = 0;
                  var endRange = rangeGroup.length / 2;
                  while (startRange <= endRange) {
                    var middleRange = Math.floor((startRange + endRange) / 2);
                    var arrayIndex = middleRange * 2;
                    if (value >= rangeGroup[arrayIndex] && value <= rangeGroup[arrayIndex + 1]) {
                      return true;
                    }
                    if (value > rangeGroup[arrayIndex + 1]) {
                      startRange = middleRange + 1;
                    } else {
                      endRange = middleRange - 1;
                    }
                  }
                  return false;
                }
                var unassigned_code_points = [545, 545, 564, 591, 686, 687, 751, 767, 848, 863, 880, 883, 886, 889, 891, 893, 895, 899, 907, 907, 909, 909, 930, 930, 975, 975, 1015, 1023, 1159, 1159, 1231, 1231, 1270, 1271, 1274, 1279, 1296, 1328, 1367, 1368, 1376, 1376, 1416, 1416, 1419, 1424, 1442, 1442, 1466, 1466, 1477, 1487, 1515, 1519, 1525, 1547, 1549, 1562, 1564, 1566, 1568, 1568, 1595, 1599, 1622, 1631, 1774, 1775, 1791, 1791, 1806, 1806, 1837, 1839, 1867, 1919, 1970, 2304, 2308, 2308, 2362, 2363, 2382, 2383, 2389, 2391, 2417, 2432, 2436, 2436, 2445, 2446, 2449, 2450, 2473, 2473, 2481, 2481, 2483, 2485, 2490, 2491, 2493, 2493, 2501, 2502, 2505, 2506, 2510, 2518, 2520, 2523, 2526, 2526, 2532, 2533, 2555, 2561, 2563, 2564, 2571, 2574, 2577, 2578, 2601, 2601, 2609, 2609, 2612, 2612, 2615, 2615, 2618, 2619, 2621, 2621, 2627, 2630, 2633, 2634, 2638, 2648, 2653, 2653, 2655, 2661, 2677, 2688, 2692, 2692, 2700, 2700, 2702, 2702, 2706, 2706, 2729, 2729, 2737, 2737, 2740, 2740, 2746, 2747, 2758, 2758, 2762, 2762, 2766, 2767, 2769, 2783, 2785, 2789, 2800, 2816, 2820, 2820, 2829, 2830, 2833, 2834, 2857, 2857, 2865, 2865, 2868, 2869, 2874, 2875, 2884, 2886, 2889, 2890, 2894, 2901, 2904, 2907, 2910, 2910, 2914, 2917, 2929, 2945, 2948, 2948, 2955, 2957, 2961, 2961, 2966, 2968, 2971, 2971, 2973, 2973, 2976, 2978, 2981, 2983, 2987, 2989, 2998, 2998, 3002, 3005, 3011, 3013, 3017, 3017, 3022, 3030, 3032, 3046, 3059, 3072, 3076, 3076, 3085, 3085, 3089, 3089, 3113, 3113, 3124, 3124, 3130, 3133, 3141, 3141, 3145, 3145, 3150, 3156, 3159, 3167, 3170, 3173, 3184, 3201, 3204, 3204, 3213, 3213, 3217, 3217, 3241, 3241, 3252, 3252, 3258, 3261, 3269, 3269, 3273, 3273, 3278, 3284, 3287, 3293, 3295, 3295, 3298, 3301, 3312, 3329, 3332, 3332, 3341, 3341, 3345, 3345, 3369, 3369, 3386, 3389, 3396, 3397, 3401, 3401, 3406, 3414, 3416, 3423, 3426, 3429, 3440, 3457, 3460, 3460, 3479, 3481, 3506, 3506, 3516, 3516, 3518, 3519, 3527, 3529, 3531, 3534, 3541, 3541, 3543, 3543, 3552, 3569, 3573, 3584, 3643, 3646, 3676, 3712, 3715, 3715, 3717, 3718, 3721, 3721, 3723, 3724, 3726, 3731, 3736, 3736, 3744, 3744, 3748, 3748, 3750, 3750, 3752, 3753, 3756, 3756, 3770, 3770, 3774, 3775, 3781, 3781, 3783, 3783, 3790, 3791, 3802, 3803, 3806, 3839, 3912, 3912, 3947, 3952, 3980, 3983, 3992, 3992, 4029, 4029, 4045, 4046, 4048, 4095, 4130, 4130, 4136, 4136, 4139, 4139, 4147, 4149, 4154, 4159, 4186, 4255, 4294, 4303, 4345, 4346, 4348, 4351, 4442, 4446, 4515, 4519, 4602, 4607, 4615, 4615, 4679, 4679, 4681, 4681, 4686, 4687, 4695, 4695, 4697, 4697, 4702, 4703, 4743, 4743, 4745, 4745, 4750, 4751, 4783, 4783, 4785, 4785, 4790, 4791, 4799, 4799, 4801, 4801, 4806, 4807, 4815, 4815, 4823, 4823, 4847, 4847, 4879, 4879, 4881, 4881, 4886, 4887, 4895, 4895, 4935, 4935, 4955, 4960, 4989, 5023, 5109, 5120, 5751, 5759, 5789, 5791, 5873, 5887, 5901, 5901, 5909, 5919, 5943, 5951, 5972, 5983, 5997, 5997, 6001, 6001, 6004, 6015, 6109, 6111, 6122, 6143, 6159, 6159, 6170, 6175, 6264, 6271, 6314, 7679, 7836, 7839, 7930, 7935, 7958, 7959, 7966, 7967, 8006, 8007, 8014, 8015, 8024, 8024, 8026, 8026, 8028, 8028, 8030, 8030, 8062, 8063, 8117, 8117, 8133, 8133, 8148, 8149, 8156, 8156, 8176, 8177, 8181, 8181, 8191, 8191, 8275, 8278, 8280, 8286, 8292, 8297, 8306, 8307, 8335, 8351, 8370, 8399, 8427, 8447, 8507, 8508, 8524, 8530, 8580, 8591, 9167, 9215, 9255, 9279, 9291, 9311, 9471, 9471, 9748, 9749, 9752, 9752, 9854, 9855, 9866, 9984, 9989, 9989, 9994, 9995, 10024, 10024, 10060, 10060, 10062, 10062, 10067, 10069, 10071, 10071, 10079, 10080, 10133, 10135, 10160, 10160, 10175, 10191, 10220, 10223, 11008, 11903, 11930, 11930, 12020, 12031, 12246, 12271, 12284, 12287, 12352, 12352, 12439, 12440, 12544, 12548, 12589, 12592, 12687, 12687, 12728, 12783, 12829, 12831, 12868, 12880, 12924, 12926, 13004, 13007, 13055, 13055, 13175, 13178, 13278, 13279, 13311, 13311, 19894, 19967, 40870, 40959, 42125, 42127, 42183, 44031, 55204, 55295, 64046, 64047, 64107, 64255, 64263, 64274, 64280, 64284, 64311, 64311, 64317, 64317, 64319, 64319, 64322, 64322, 64325, 64325, 64434, 64466, 64832, 64847, 64912, 64913, 64968, 64975, 65021, 65023, 65040, 65055, 65060, 65071, 65095, 65096, 65107, 65107, 65127, 65127, 65132, 65135, 65141, 65141, 65277, 65278, 65280, 65280, 65471, 65473, 65480, 65481, 65488, 65489, 65496, 65497, 65501, 65503, 65511, 65511, 65519, 65528, 65536, 66303, 66335, 66335, 66340, 66351, 66379, 66559, 66598, 66599, 66638, 118783, 119030, 119039, 119079, 119081, 119262, 119807, 119893, 119893, 119965, 119965, 119968, 119969, 119971, 119972, 119975, 119976, 119981, 119981, 119994, 119994, 119996, 119996, 120001, 120001, 120004, 120004, 120070, 120070, 120075, 120076, 120085, 120085, 120093, 120093, 120122, 120122, 120127, 120127, 120133, 120133, 120135, 120137, 120145, 120145, 120484, 120487, 120778, 120781, 120832, 131069, 173783, 194559, 195102, 196605, 196608, 262141, 262144, 327677, 327680, 393213, 393216, 458749, 458752, 524285, 524288, 589821, 589824, 655357, 655360, 720893, 720896, 786429, 786432, 851965, 851968, 917501, 917504, 917504, 917506, 917535, 917632, 983037];
                var isUnassignedCodePoint = function isUnassignedCodePoint2(character) {
                  return inRange(character, unassigned_code_points);
                };
                var commonly_mapped_to_nothing = [173, 173, 847, 847, 6150, 6150, 6155, 6155, 6156, 6156, 6157, 6157, 8203, 8203, 8204, 8204, 8205, 8205, 8288, 8288, 65024, 65024, 65025, 65025, 65026, 65026, 65027, 65027, 65028, 65028, 65029, 65029, 65030, 65030, 65031, 65031, 65032, 65032, 65033, 65033, 65034, 65034, 65035, 65035, 65036, 65036, 65037, 65037, 65038, 65038, 65039, 65039, 65279, 65279];
                var isCommonlyMappedToNothing = function isCommonlyMappedToNothing2(character) {
                  return inRange(character, commonly_mapped_to_nothing);
                };
                var non_ASCII_space_characters = [
                  160,
                  160,
                  5760,
                  5760,
                  8192,
                  8192,
                  8193,
                  8193,
                  8194,
                  8194,
                  8195,
                  8195,
                  8196,
                  8196,
                  8197,
                  8197,
                  8198,
                  8198,
                  8199,
                  8199,
                  8200,
                  8200,
                  8201,
                  8201,
                  8202,
                  8202,
                  8203,
                  8203,
                  8239,
                  8239,
                  8287,
                  8287,
                  12288,
                  12288
                  /* IDEOGRAPHIC SPACE */
                ];
                var isNonASCIISpaceCharacter = function isNonASCIISpaceCharacter2(character) {
                  return inRange(character, non_ASCII_space_characters);
                };
                var non_ASCII_controls_characters = [
                  /**
                   * C.2.2 Non-ASCII control characters
                   * @link https://tools.ietf.org/html/rfc3454#appendix-C.2.2
                   */
                  128,
                  159,
                  1757,
                  1757,
                  1807,
                  1807,
                  6158,
                  6158,
                  8204,
                  8204,
                  8205,
                  8205,
                  8232,
                  8232,
                  8233,
                  8233,
                  8288,
                  8288,
                  8289,
                  8289,
                  8290,
                  8290,
                  8291,
                  8291,
                  8298,
                  8303,
                  65279,
                  65279,
                  65529,
                  65532,
                  119155,
                  119162
                  /* [MUSICAL CONTROL CHARACTERS] */
                ];
                var non_character_codepoints = [
                  /**
                   * C.4 Non-character code points
                   * @link https://tools.ietf.org/html/rfc3454#appendix-C.4
                   */
                  64976,
                  65007,
                  65534,
                  65535,
                  131070,
                  131071,
                  196606,
                  196607,
                  262142,
                  262143,
                  327678,
                  327679,
                  393214,
                  393215,
                  458750,
                  458751,
                  524286,
                  524287,
                  589822,
                  589823,
                  655358,
                  655359,
                  720894,
                  720895,
                  786430,
                  786431,
                  851966,
                  851967,
                  917502,
                  917503,
                  983038,
                  983039,
                  1114110,
                  1114111
                  /* [NONCHARACTER CODE POINTS] */
                ];
                var prohibited_characters = [
                  /**
                   * C.2.1 ASCII control characters
                   * @link https://tools.ietf.org/html/rfc3454#appendix-C.2.1
                   */
                  0,
                  31,
                  127,
                  127,
                  /**
                   * C.8 Change display properties or are deprecated
                   * @link https://tools.ietf.org/html/rfc3454#appendix-C.8
                   */
                  832,
                  832,
                  833,
                  833,
                  8206,
                  8206,
                  8207,
                  8207,
                  8234,
                  8234,
                  8235,
                  8235,
                  8236,
                  8236,
                  8237,
                  8237,
                  8238,
                  8238,
                  8298,
                  8298,
                  8299,
                  8299,
                  8300,
                  8300,
                  8301,
                  8301,
                  8302,
                  8302,
                  8303,
                  8303,
                  /**
                   * C.7 Inappropriate for canonical representation
                   * @link https://tools.ietf.org/html/rfc3454#appendix-C.7
                   */
                  12272,
                  12283,
                  /**
                   * C.5 Surrogate codes
                   * @link https://tools.ietf.org/html/rfc3454#appendix-C.5
                   */
                  55296,
                  57343,
                  /**
                   * C.3 Private use
                   * @link https://tools.ietf.org/html/rfc3454#appendix-C.3
                   */
                  57344,
                  63743,
                  /**
                   * C.6 Inappropriate for plain text
                   * @link https://tools.ietf.org/html/rfc3454#appendix-C.6
                   */
                  65529,
                  65529,
                  65530,
                  65530,
                  65531,
                  65531,
                  65532,
                  65532,
                  65533,
                  65533,
                  /**
                   * C.9 Tagging characters
                   * @link https://tools.ietf.org/html/rfc3454#appendix-C.9
                   */
                  917505,
                  917505,
                  917536,
                  917631,
                  /**
                   * C.3 Private use
                   * @link https://tools.ietf.org/html/rfc3454#appendix-C.3
                   */
                  983040,
                  1048573,
                  1048576,
                  1114109
                  /* [PRIVATE USE, PLANE 16] */
                ];
                var isProhibitedCharacter = function isProhibitedCharacter2(character) {
                  return inRange(character, non_ASCII_space_characters) || inRange(character, prohibited_characters) || inRange(character, non_ASCII_controls_characters) || inRange(character, non_character_codepoints);
                };
                var bidirectional_r_al = [1470, 1470, 1472, 1472, 1475, 1475, 1488, 1514, 1520, 1524, 1563, 1563, 1567, 1567, 1569, 1594, 1600, 1610, 1645, 1647, 1649, 1749, 1757, 1757, 1765, 1766, 1786, 1790, 1792, 1805, 1808, 1808, 1810, 1836, 1920, 1957, 1969, 1969, 8207, 8207, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65020, 65136, 65140, 65142, 65276];
                var isBidirectionalRAL = function isBidirectionalRAL2(character) {
                  return inRange(character, bidirectional_r_al);
                };
                var bidirectional_l = [65, 90, 97, 122, 170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 544, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 1013, 1024, 1154, 1162, 1230, 1232, 1269, 1272, 1273, 1280, 1295, 1329, 1366, 1369, 1375, 1377, 1415, 1417, 1417, 2307, 2307, 2309, 2361, 2365, 2368, 2377, 2380, 2384, 2384, 2392, 2401, 2404, 2416, 2434, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2494, 2496, 2503, 2504, 2507, 2508, 2519, 2519, 2524, 2525, 2527, 2529, 2534, 2545, 2548, 2554, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2622, 2624, 2649, 2652, 2654, 2654, 2662, 2671, 2674, 2676, 2691, 2691, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2752, 2761, 2761, 2763, 2764, 2768, 2768, 2784, 2784, 2790, 2799, 2818, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2878, 2880, 2880, 2887, 2888, 2891, 2892, 2903, 2903, 2908, 2909, 2911, 2913, 2918, 2928, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006, 3007, 3009, 3010, 3014, 3016, 3018, 3020, 3031, 3031, 3047, 3058, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3137, 3140, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3262, 3264, 3268, 3271, 3272, 3274, 3275, 3285, 3286, 3294, 3294, 3296, 3297, 3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3392, 3398, 3400, 3402, 3404, 3415, 3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3535, 3537, 3544, 3551, 3570, 3572, 3585, 3632, 3634, 3635, 3648, 3654, 3663, 3675, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3792, 3801, 3804, 3805, 3840, 3863, 3866, 3892, 3894, 3894, 3896, 3896, 3902, 3911, 3913, 3946, 3967, 3967, 3973, 3973, 3976, 3979, 4030, 4037, 4039, 4044, 4047, 4047, 4096, 4129, 4131, 4135, 4137, 4138, 4140, 4140, 4145, 4145, 4152, 4152, 4160, 4183, 4256, 4293, 4304, 4344, 4347, 4347, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4961, 4988, 5024, 5108, 5121, 5750, 5761, 5786, 5792, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5941, 5942, 5952, 5969, 5984, 5996, 5998, 6e3, 6016, 6070, 6078, 6085, 6087, 6088, 6100, 6106, 6108, 6108, 6112, 6121, 6160, 6169, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8206, 8206, 8305, 8305, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8509, 8511, 8517, 8521, 8544, 8579, 9014, 9082, 9109, 9109, 9372, 9449, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12588, 12593, 12686, 12688, 12727, 12784, 12828, 12832, 12867, 12896, 12923, 12927, 12976, 12992, 13003, 13008, 13054, 13056, 13174, 13179, 13277, 13280, 13310, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 55296, 64045, 64048, 64106, 64256, 64262, 64275, 64279, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 66304, 66334, 66336, 66339, 66352, 66378, 66560, 66597, 66600, 66637, 118784, 119029, 119040, 119078, 119082, 119142, 119146, 119154, 119171, 119172, 119180, 119209, 119214, 119261, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 12e4, 120002, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120483, 120488, 120777, 131072, 173782, 194560, 195101, 983040, 1048573, 1048576, 1114109];
                var isBidirectionalL = function isBidirectionalL2(character) {
                  return inRange(character, bidirectional_l);
                };
                var mapping2space = isNonASCIISpaceCharacter;
                var mapping2nothing = isCommonlyMappedToNothing;
                var getCodePoint = function getCodePoint2(character) {
                  return character.codePointAt(0);
                };
                var first = function first2(x) {
                  return x[0];
                };
                var last = function last2(x) {
                  return x[x.length - 1];
                };
                function toCodePoints(input) {
                  var codepoints = [];
                  var size = input.length;
                  for (var i = 0; i < size; i += 1) {
                    var before = input.charCodeAt(i);
                    if (before >= 55296 && before <= 56319 && size > i + 1) {
                      var next = input.charCodeAt(i + 1);
                      if (next >= 56320 && next <= 57343) {
                        codepoints.push((before - 55296) * 1024 + next - 56320 + 65536);
                        i += 1;
                        continue;
                      }
                    }
                    codepoints.push(before);
                  }
                  return codepoints;
                }
                function saslprep(input) {
                  var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  if (typeof input !== "string") {
                    throw new TypeError("Expected string.");
                  }
                  if (input.length === 0) {
                    return "";
                  }
                  var mapped_input = toCodePoints(input).map(function(character) {
                    return mapping2space(character) ? 32 : character;
                  }).filter(function(character) {
                    return !mapping2nothing(character);
                  });
                  var normalized_input = String.fromCodePoint.apply(null, mapped_input).normalize("NFKC");
                  var normalized_map = toCodePoints(normalized_input);
                  var hasProhibited = normalized_map.some(isProhibitedCharacter);
                  if (hasProhibited) {
                    throw new Error("Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3");
                  }
                  if (opts.allowUnassigned !== true) {
                    var hasUnassigned = normalized_map.some(isUnassignedCodePoint);
                    if (hasUnassigned) {
                      throw new Error("Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5");
                    }
                  }
                  var hasBidiRAL = normalized_map.some(isBidirectionalRAL);
                  var hasBidiL = normalized_map.some(isBidirectionalL);
                  if (hasBidiRAL && hasBidiL) {
                    throw new Error("String must not contain RandALCat and LCat at the same time, see https://tools.ietf.org/html/rfc3454#section-6");
                  }
                  var isFirstBidiRAL = isBidirectionalRAL(getCodePoint(first(normalized_input)));
                  var isLastBidiRAL = isBidirectionalRAL(getCodePoint(last(normalized_input)));
                  if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {
                    throw new Error("Bidirectional RandALCat character must be the first and the last character of the string, see https://tools.ietf.org/html/rfc3454#section-6");
                  }
                  return normalized_input;
                }
                var PDFSecurity = function() {
                  _createClass(PDFSecurity2, null, [{
                    key: "generateFileID",
                    value: function generateFileID() {
                      var info = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                      var infoStr = "".concat(info.CreationDate.getTime(), "\n");
                      for (var key in info) {
                        if (!info.hasOwnProperty(key)) {
                          continue;
                        }
                        infoStr += "".concat(key, ": ").concat(info[key].valueOf(), "\n");
                      }
                      return wordArrayToBuffer(_cryptoJs.default.MD5(infoStr));
                    }
                  }, {
                    key: "generateRandomWordArray",
                    value: function generateRandomWordArray(bytes) {
                      return _cryptoJs.default.lib.WordArray.random(bytes);
                    }
                  }, {
                    key: "create",
                    value: function create(document2) {
                      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                      if (!options.ownerPassword && !options.userPassword) {
                        return null;
                      }
                      return new PDFSecurity2(document2, options);
                    }
                  }]);
                  function PDFSecurity2(document2) {
                    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                    _classCallCheck(this, PDFSecurity2);
                    if (!options.ownerPassword && !options.userPassword) {
                      throw new Error("None of owner password and user password is defined.");
                    }
                    this.document = document2;
                    this._setupEncryption(options);
                  }
                  _createClass(PDFSecurity2, [{
                    key: "_setupEncryption",
                    value: function _setupEncryption(options) {
                      switch (options.pdfVersion) {
                        case "1.4":
                        case "1.5":
                          this.version = 2;
                          break;
                        case "1.6":
                        case "1.7":
                          this.version = 4;
                          break;
                        case "1.7ext3":
                          this.version = 5;
                          break;
                        default:
                          this.version = 1;
                          break;
                      }
                      var encDict = {
                        Filter: "Standard"
                      };
                      switch (this.version) {
                        case 1:
                        case 2:
                        case 4:
                          this._setupEncryptionV1V2V4(this.version, encDict, options);
                          break;
                        case 5:
                          this._setupEncryptionV5(encDict, options);
                          break;
                      }
                      this.dictionary = this.document.ref(encDict);
                    }
                  }, {
                    key: "_setupEncryptionV1V2V4",
                    value: function _setupEncryptionV1V2V4(v, encDict, options) {
                      var r, permissions;
                      switch (v) {
                        case 1:
                          r = 2;
                          this.keyBits = 40;
                          permissions = getPermissionsR2(options.permissions);
                          break;
                        case 2:
                          r = 3;
                          this.keyBits = 128;
                          permissions = getPermissionsR3(options.permissions);
                          break;
                        case 4:
                          r = 4;
                          this.keyBits = 128;
                          permissions = getPermissionsR3(options.permissions);
                          break;
                      }
                      var paddedUserPassword = processPasswordR2R3R4(options.userPassword);
                      var paddedOwnerPassword = options.ownerPassword ? processPasswordR2R3R4(options.ownerPassword) : paddedUserPassword;
                      var ownerPasswordEntry = getOwnerPasswordR2R3R4(r, this.keyBits, paddedUserPassword, paddedOwnerPassword);
                      this.encryptionKey = getEncryptionKeyR2R3R4(r, this.keyBits, this.document._id, paddedUserPassword, ownerPasswordEntry, permissions);
                      var userPasswordEntry;
                      if (r === 2) {
                        userPasswordEntry = getUserPasswordR2(this.encryptionKey);
                      } else {
                        userPasswordEntry = getUserPasswordR3R4(this.document._id, this.encryptionKey);
                      }
                      encDict.V = v;
                      if (v >= 2) {
                        encDict.Length = this.keyBits;
                      }
                      if (v === 4) {
                        encDict.CF = {
                          StdCF: {
                            AuthEvent: "DocOpen",
                            CFM: "AESV2",
                            Length: this.keyBits / 8
                          }
                        };
                        encDict.StmF = "StdCF";
                        encDict.StrF = "StdCF";
                      }
                      encDict.R = r;
                      encDict.O = wordArrayToBuffer(ownerPasswordEntry);
                      encDict.U = wordArrayToBuffer(userPasswordEntry);
                      encDict.P = permissions;
                    }
                  }, {
                    key: "_setupEncryptionV5",
                    value: function _setupEncryptionV5(encDict, options) {
                      this.keyBits = 256;
                      var permissions = getPermissionsR3(options.permissions);
                      var processedUserPassword = processPasswordR5(options.userPassword);
                      var processedOwnerPassword = options.ownerPassword ? processPasswordR5(options.ownerPassword) : processedUserPassword;
                      this.encryptionKey = getEncryptionKeyR5(PDFSecurity2.generateRandomWordArray);
                      var userPasswordEntry = getUserPasswordR5(processedUserPassword, PDFSecurity2.generateRandomWordArray);
                      var userKeySalt = _cryptoJs.default.lib.WordArray.create(userPasswordEntry.words.slice(10, 12), 8);
                      var userEncryptionKeyEntry = getUserEncryptionKeyR5(processedUserPassword, userKeySalt, this.encryptionKey);
                      var ownerPasswordEntry = getOwnerPasswordR5(processedOwnerPassword, userPasswordEntry, PDFSecurity2.generateRandomWordArray);
                      var ownerKeySalt = _cryptoJs.default.lib.WordArray.create(ownerPasswordEntry.words.slice(10, 12), 8);
                      var ownerEncryptionKeyEntry = getOwnerEncryptionKeyR5(processedOwnerPassword, ownerKeySalt, userPasswordEntry, this.encryptionKey);
                      var permsEntry = getEncryptedPermissionsR5(permissions, this.encryptionKey, PDFSecurity2.generateRandomWordArray);
                      encDict.V = 5;
                      encDict.Length = this.keyBits;
                      encDict.CF = {
                        StdCF: {
                          AuthEvent: "DocOpen",
                          CFM: "AESV3",
                          Length: this.keyBits / 8
                        }
                      };
                      encDict.StmF = "StdCF";
                      encDict.StrF = "StdCF";
                      encDict.R = 5;
                      encDict.O = wordArrayToBuffer(ownerPasswordEntry);
                      encDict.OE = wordArrayToBuffer(ownerEncryptionKeyEntry);
                      encDict.U = wordArrayToBuffer(userPasswordEntry);
                      encDict.UE = wordArrayToBuffer(userEncryptionKeyEntry);
                      encDict.P = permissions;
                      encDict.Perms = wordArrayToBuffer(permsEntry);
                    }
                  }, {
                    key: "getEncryptFn",
                    value: function getEncryptFn(obj, gen) {
                      var digest;
                      if (this.version < 5) {
                        digest = this.encryptionKey.clone().concat(_cryptoJs.default.lib.WordArray.create([(obj & 255) << 24 | (obj & 65280) << 8 | obj >> 8 & 65280 | gen & 255, (gen & 65280) << 16], 5));
                      }
                      if (this.version === 1 || this.version === 2) {
                        var _key = _cryptoJs.default.MD5(digest);
                        _key.sigBytes = Math.min(16, this.keyBits / 8 + 5);
                        return function(buffer) {
                          return wordArrayToBuffer(_cryptoJs.default.RC4.encrypt(_cryptoJs.default.lib.WordArray.create(buffer), _key).ciphertext);
                        };
                      }
                      var key;
                      if (this.version === 4) {
                        key = _cryptoJs.default.MD5(digest.concat(_cryptoJs.default.lib.WordArray.create([1933667412], 4)));
                      } else {
                        key = this.encryptionKey;
                      }
                      var iv = PDFSecurity2.generateRandomWordArray(16);
                      var options = {
                        mode: _cryptoJs.default.mode.CBC,
                        padding: _cryptoJs.default.pad.Pkcs7,
                        iv
                      };
                      return function(buffer) {
                        return wordArrayToBuffer(iv.clone().concat(_cryptoJs.default.AES.encrypt(_cryptoJs.default.lib.WordArray.create(buffer), key, options).ciphertext));
                      };
                    }
                  }, {
                    key: "end",
                    value: function end() {
                      this.dictionary.end();
                    }
                  }]);
                  return PDFSecurity2;
                }();
                function getPermissionsR2() {
                  var permissionObject = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  var permissions = 4294967232 >> 0;
                  if (permissionObject.printing) {
                    permissions |= 4;
                  }
                  if (permissionObject.modifying) {
                    permissions |= 8;
                  }
                  if (permissionObject.copying) {
                    permissions |= 16;
                  }
                  if (permissionObject.annotating) {
                    permissions |= 32;
                  }
                  return permissions;
                }
                function getPermissionsR3() {
                  var permissionObject = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  var permissions = 4294963392 >> 0;
                  if (permissionObject.printing === "lowResolution") {
                    permissions |= 4;
                  }
                  if (permissionObject.printing === "highResolution") {
                    permissions |= 2052;
                  }
                  if (permissionObject.modifying) {
                    permissions |= 8;
                  }
                  if (permissionObject.copying) {
                    permissions |= 16;
                  }
                  if (permissionObject.annotating) {
                    permissions |= 32;
                  }
                  if (permissionObject.fillingForms) {
                    permissions |= 256;
                  }
                  if (permissionObject.contentAccessibility) {
                    permissions |= 512;
                  }
                  if (permissionObject.documentAssembly) {
                    permissions |= 1024;
                  }
                  return permissions;
                }
                function getUserPasswordR2(encryptionKey) {
                  return _cryptoJs.default.RC4.encrypt(processPasswordR2R3R4(), encryptionKey).ciphertext;
                }
                function getUserPasswordR3R4(documentId, encryptionKey) {
                  var key = encryptionKey.clone();
                  var cipher = _cryptoJs.default.MD5(processPasswordR2R3R4().concat(_cryptoJs.default.lib.WordArray.create(documentId)));
                  for (var i = 0; i < 20; i++) {
                    var xorRound = Math.ceil(key.sigBytes / 4);
                    for (var j = 0; j < xorRound; j++) {
                      key.words[j] = encryptionKey.words[j] ^ (i | i << 8 | i << 16 | i << 24);
                    }
                    cipher = _cryptoJs.default.RC4.encrypt(cipher, key).ciphertext;
                  }
                  return cipher.concat(_cryptoJs.default.lib.WordArray.create(null, 16));
                }
                function getOwnerPasswordR2R3R4(r, keyBits, paddedUserPassword, paddedOwnerPassword) {
                  var digest = paddedOwnerPassword;
                  var round = r >= 3 ? 51 : 1;
                  for (var i = 0; i < round; i++) {
                    digest = _cryptoJs.default.MD5(digest);
                  }
                  var key = digest.clone();
                  key.sigBytes = keyBits / 8;
                  var cipher = paddedUserPassword;
                  round = r >= 3 ? 20 : 1;
                  for (var _i = 0; _i < round; _i++) {
                    var xorRound = Math.ceil(key.sigBytes / 4);
                    for (var j = 0; j < xorRound; j++) {
                      key.words[j] = digest.words[j] ^ (_i | _i << 8 | _i << 16 | _i << 24);
                    }
                    cipher = _cryptoJs.default.RC4.encrypt(cipher, key).ciphertext;
                  }
                  return cipher;
                }
                function getEncryptionKeyR2R3R4(r, keyBits, documentId, paddedUserPassword, ownerPasswordEntry, permissions) {
                  var key = paddedUserPassword.clone().concat(ownerPasswordEntry).concat(_cryptoJs.default.lib.WordArray.create([lsbFirstWord(permissions)], 4)).concat(_cryptoJs.default.lib.WordArray.create(documentId));
                  var round = r >= 3 ? 51 : 1;
                  for (var i = 0; i < round; i++) {
                    key = _cryptoJs.default.MD5(key);
                    key.sigBytes = keyBits / 8;
                  }
                  return key;
                }
                function getUserPasswordR5(processedUserPassword, generateRandomWordArray) {
                  var validationSalt = generateRandomWordArray(8);
                  var keySalt = generateRandomWordArray(8);
                  return _cryptoJs.default.SHA256(processedUserPassword.clone().concat(validationSalt)).concat(validationSalt).concat(keySalt);
                }
                function getUserEncryptionKeyR5(processedUserPassword, userKeySalt, encryptionKey) {
                  var key = _cryptoJs.default.SHA256(processedUserPassword.clone().concat(userKeySalt));
                  var options = {
                    mode: _cryptoJs.default.mode.CBC,
                    padding: _cryptoJs.default.pad.NoPadding,
                    iv: _cryptoJs.default.lib.WordArray.create(null, 16)
                  };
                  return _cryptoJs.default.AES.encrypt(encryptionKey, key, options).ciphertext;
                }
                function getOwnerPasswordR5(processedOwnerPassword, userPasswordEntry, generateRandomWordArray) {
                  var validationSalt = generateRandomWordArray(8);
                  var keySalt = generateRandomWordArray(8);
                  return _cryptoJs.default.SHA256(processedOwnerPassword.clone().concat(validationSalt).concat(userPasswordEntry)).concat(validationSalt).concat(keySalt);
                }
                function getOwnerEncryptionKeyR5(processedOwnerPassword, ownerKeySalt, userPasswordEntry, encryptionKey) {
                  var key = _cryptoJs.default.SHA256(processedOwnerPassword.clone().concat(ownerKeySalt).concat(userPasswordEntry));
                  var options = {
                    mode: _cryptoJs.default.mode.CBC,
                    padding: _cryptoJs.default.pad.NoPadding,
                    iv: _cryptoJs.default.lib.WordArray.create(null, 16)
                  };
                  return _cryptoJs.default.AES.encrypt(encryptionKey, key, options).ciphertext;
                }
                function getEncryptionKeyR5(generateRandomWordArray) {
                  return generateRandomWordArray(32);
                }
                function getEncryptedPermissionsR5(permissions, encryptionKey, generateRandomWordArray) {
                  var cipher = _cryptoJs.default.lib.WordArray.create([lsbFirstWord(permissions), 4294967295, 1415668834], 12).concat(generateRandomWordArray(4));
                  var options = {
                    mode: _cryptoJs.default.mode.ECB,
                    padding: _cryptoJs.default.pad.NoPadding
                  };
                  return _cryptoJs.default.AES.encrypt(cipher, encryptionKey, options).ciphertext;
                }
                function processPasswordR2R3R4() {
                  var password = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
                  var out = Buffer.alloc(32);
                  var length = password.length;
                  var index = 0;
                  while (index < length && index < 32) {
                    var code = password.charCodeAt(index);
                    if (code > 255) {
                      throw new Error("Password contains one or more invalid characters.");
                    }
                    out[index] = code;
                    index++;
                  }
                  while (index < 32) {
                    out[index] = PASSWORD_PADDING[index - length];
                    index++;
                  }
                  return _cryptoJs.default.lib.WordArray.create(out);
                }
                function processPasswordR5() {
                  var password = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
                  password = unescape(encodeURIComponent(saslprep(password)));
                  var length = Math.min(127, password.length);
                  var out = Buffer.alloc(length);
                  for (var i = 0; i < length; i++) {
                    out[i] = password.charCodeAt(i);
                  }
                  return _cryptoJs.default.lib.WordArray.create(out);
                }
                function lsbFirstWord(data) {
                  return (data & 255) << 24 | (data & 65280) << 8 | data >> 8 & 65280 | data >> 24 & 255;
                }
                function wordArrayToBuffer(wordArray) {
                  var byteArray = [];
                  for (var i = 0; i < wordArray.sigBytes; i++) {
                    byteArray.push(wordArray.words[Math.floor(i / 4)] >> 8 * (3 - i % 4) & 255);
                  }
                  return Buffer.from(byteArray);
                }
                var PASSWORD_PADDING = [40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122];
                var number = PDFObject.number;
                var PDFGradient = function() {
                  function PDFGradient2(doc) {
                    _classCallCheck(this, PDFGradient2);
                    this.doc = doc;
                    this.stops = [];
                    this.embedded = false;
                    this.transform = [1, 0, 0, 1, 0, 0];
                  }
                  _createClass(PDFGradient2, [{
                    key: "stop",
                    value: function stop(pos, color, opacity) {
                      if (opacity == null) {
                        opacity = 1;
                      }
                      color = this.doc._normalizeColor(color);
                      if (this.stops.length === 0) {
                        if (color.length === 3) {
                          this._colorSpace = "DeviceRGB";
                        } else if (color.length === 4) {
                          this._colorSpace = "DeviceCMYK";
                        } else if (color.length === 1) {
                          this._colorSpace = "DeviceGray";
                        } else {
                          throw new Error("Unknown color space");
                        }
                      } else if (this._colorSpace === "DeviceRGB" && color.length !== 3 || this._colorSpace === "DeviceCMYK" && color.length !== 4 || this._colorSpace === "DeviceGray" && color.length !== 1) {
                        throw new Error("All gradient stops must use the same color space");
                      }
                      opacity = Math.max(0, Math.min(1, opacity));
                      this.stops.push([pos, color, opacity]);
                      return this;
                    }
                  }, {
                    key: "setTransform",
                    value: function setTransform(m11, m12, m21, m22, dx, dy) {
                      this.transform = [m11, m12, m21, m22, dx, dy];
                      return this;
                    }
                  }, {
                    key: "embed",
                    value: function embed(m) {
                      var fn;
                      var stopsLength = this.stops.length;
                      if (stopsLength === 0) {
                        return;
                      }
                      this.embedded = true;
                      this.matrix = m;
                      var last2 = this.stops[stopsLength - 1];
                      if (last2[0] < 1) {
                        this.stops.push([1, last2[1], last2[2]]);
                      }
                      var bounds = [];
                      var encode = [];
                      var stops = [];
                      for (var i = 0; i < stopsLength - 1; i++) {
                        encode.push(0, 1);
                        if (i + 2 !== stopsLength) {
                          bounds.push(this.stops[i + 1][0]);
                        }
                        fn = this.doc.ref({
                          FunctionType: 2,
                          Domain: [0, 1],
                          C0: this.stops[i + 0][1],
                          C1: this.stops[i + 1][1],
                          N: 1
                        });
                        stops.push(fn);
                        fn.end();
                      }
                      if (stopsLength === 1) {
                        fn = stops[0];
                      } else {
                        fn = this.doc.ref({
                          FunctionType: 3,
                          // stitching function
                          Domain: [0, 1],
                          Functions: stops,
                          Bounds: bounds,
                          Encode: encode
                        });
                        fn.end();
                      }
                      this.id = "Sh".concat(++this.doc._gradCount);
                      var shader = this.shader(fn);
                      shader.end();
                      var pattern2 = this.doc.ref({
                        Type: "Pattern",
                        PatternType: 2,
                        Shading: shader,
                        Matrix: this.matrix.map(number)
                      });
                      pattern2.end();
                      if (this.stops.some(function(stop2) {
                        return stop2[2] < 1;
                      })) {
                        var grad = this.opacityGradient();
                        grad._colorSpace = "DeviceGray";
                        var _iterator = _createForOfIteratorHelper(this.stops), _step;
                        try {
                          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                            var stop = _step.value;
                            grad.stop(stop[0], [stop[2]]);
                          }
                        } catch (err) {
                          _iterator.e(err);
                        } finally {
                          _iterator.f();
                        }
                        grad = grad.embed(this.matrix);
                        var pageBBox = [0, 0, this.doc.page.width, this.doc.page.height];
                        var form = this.doc.ref({
                          Type: "XObject",
                          Subtype: "Form",
                          FormType: 1,
                          BBox: pageBBox,
                          Group: {
                            Type: "Group",
                            S: "Transparency",
                            CS: "DeviceGray"
                          },
                          Resources: {
                            ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
                            Pattern: {
                              Sh1: grad
                            }
                          }
                        });
                        form.write("/Pattern cs /Sh1 scn");
                        form.end("".concat(pageBBox.join(" "), " re f"));
                        var gstate = this.doc.ref({
                          Type: "ExtGState",
                          SMask: {
                            Type: "Mask",
                            S: "Luminosity",
                            G: form
                          }
                        });
                        gstate.end();
                        var opacityPattern = this.doc.ref({
                          Type: "Pattern",
                          PatternType: 1,
                          PaintType: 1,
                          TilingType: 2,
                          BBox: pageBBox,
                          XStep: pageBBox[2],
                          YStep: pageBBox[3],
                          Resources: {
                            ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
                            Pattern: {
                              Sh1: pattern2
                            },
                            ExtGState: {
                              Gs1: gstate
                            }
                          }
                        });
                        opacityPattern.write("/Gs1 gs /Pattern cs /Sh1 scn");
                        opacityPattern.end("".concat(pageBBox.join(" "), " re f"));
                        this.doc.page.patterns[this.id] = opacityPattern;
                      } else {
                        this.doc.page.patterns[this.id] = pattern2;
                      }
                      return pattern2;
                    }
                  }, {
                    key: "apply",
                    value: function apply(stroke) {
                      var _this$doc$_ctm = _slicedToArray(this.doc._ctm, 6), m0 = _this$doc$_ctm[0], m1 = _this$doc$_ctm[1], m2 = _this$doc$_ctm[2], m3 = _this$doc$_ctm[3], m4 = _this$doc$_ctm[4], m5 = _this$doc$_ctm[5];
                      var _this$transform = _slicedToArray(this.transform, 6), m11 = _this$transform[0], m12 = _this$transform[1], m21 = _this$transform[2], m22 = _this$transform[3], dx = _this$transform[4], dy = _this$transform[5];
                      var m = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];
                      if (!this.embedded || m.join(" ") !== this.matrix.join(" ")) {
                        this.embed(m);
                      }
                      this.doc._setColorSpace("Pattern", stroke);
                      var op = stroke ? "SCN" : "scn";
                      return this.doc.addContent("/".concat(this.id, " ").concat(op));
                    }
                  }]);
                  return PDFGradient2;
                }();
                var PDFLinearGradient = function(_PDFGradient) {
                  _inherits(PDFLinearGradient2, _PDFGradient);
                  var _super = _createSuper(PDFLinearGradient2);
                  function PDFLinearGradient2(doc, x1, y1, x2, y2) {
                    var _this;
                    _classCallCheck(this, PDFLinearGradient2);
                    _this = _super.call(this, doc);
                    _this.x1 = x1;
                    _this.y1 = y1;
                    _this.x2 = x2;
                    _this.y2 = y2;
                    return _this;
                  }
                  _createClass(PDFLinearGradient2, [{
                    key: "shader",
                    value: function shader(fn) {
                      return this.doc.ref({
                        ShadingType: 2,
                        ColorSpace: this._colorSpace,
                        Coords: [this.x1, this.y1, this.x2, this.y2],
                        Function: fn,
                        Extend: [true, true]
                      });
                    }
                  }, {
                    key: "opacityGradient",
                    value: function opacityGradient() {
                      return new PDFLinearGradient2(this.doc, this.x1, this.y1, this.x2, this.y2);
                    }
                  }]);
                  return PDFLinearGradient2;
                }(PDFGradient);
                var PDFRadialGradient = function(_PDFGradient2) {
                  _inherits(PDFRadialGradient2, _PDFGradient2);
                  var _super2 = _createSuper(PDFRadialGradient2);
                  function PDFRadialGradient2(doc, x1, y1, r1, x2, y2, r2) {
                    var _this2;
                    _classCallCheck(this, PDFRadialGradient2);
                    _this2 = _super2.call(this, doc);
                    _this2.doc = doc;
                    _this2.x1 = x1;
                    _this2.y1 = y1;
                    _this2.r1 = r1;
                    _this2.x2 = x2;
                    _this2.y2 = y2;
                    _this2.r2 = r2;
                    return _this2;
                  }
                  _createClass(PDFRadialGradient2, [{
                    key: "shader",
                    value: function shader(fn) {
                      return this.doc.ref({
                        ShadingType: 3,
                        ColorSpace: this._colorSpace,
                        Coords: [this.x1, this.y1, this.r1, this.x2, this.y2, this.r2],
                        Function: fn,
                        Extend: [true, true]
                      });
                    }
                  }, {
                    key: "opacityGradient",
                    value: function opacityGradient() {
                      return new PDFRadialGradient2(this.doc, this.x1, this.y1, this.r1, this.x2, this.y2, this.r2);
                    }
                  }]);
                  return PDFRadialGradient2;
                }(PDFGradient);
                var Gradient = {
                  PDFGradient,
                  PDFLinearGradient,
                  PDFRadialGradient
                };
                var underlyingColorSpaces = ["DeviceCMYK", "DeviceRGB"];
                var PDFTilingPattern = function() {
                  function PDFTilingPattern2(doc, bBox, xStep, yStep, stream) {
                    _classCallCheck(this, PDFTilingPattern2);
                    this.doc = doc;
                    this.bBox = bBox;
                    this.xStep = xStep;
                    this.yStep = yStep;
                    this.stream = stream;
                  }
                  _createClass(PDFTilingPattern2, [{
                    key: "createPattern",
                    value: function createPattern() {
                      var resources = this.doc.ref();
                      resources.end();
                      var _this$doc$_ctm = _slicedToArray(this.doc._ctm, 6), m0 = _this$doc$_ctm[0], m1 = _this$doc$_ctm[1], m2 = _this$doc$_ctm[2], m3 = _this$doc$_ctm[3], m4 = _this$doc$_ctm[4], m5 = _this$doc$_ctm[5];
                      var m11 = 1, m12 = 0, m21 = 0, m22 = 1, dx = 0, dy = 0;
                      var m = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];
                      var pattern2 = this.doc.ref({
                        Type: "Pattern",
                        PatternType: 1,
                        // tiling
                        PaintType: 2,
                        // 1-colored, 2-uncolored
                        TilingType: 2,
                        // 2-no distortion
                        BBox: this.bBox,
                        XStep: this.xStep,
                        YStep: this.yStep,
                        Matrix: m.map(function(v) {
                          return +v.toFixed(5);
                        }),
                        Resources: resources
                      });
                      pattern2.end(this.stream);
                      return pattern2;
                    }
                  }, {
                    key: "embedPatternColorSpaces",
                    value: function embedPatternColorSpaces() {
                      var _this = this;
                      underlyingColorSpaces.forEach(function(csName) {
                        var csId = _this.getPatternColorSpaceId(csName);
                        if (_this.doc.page.colorSpaces[csId])
                          return;
                        var cs = _this.doc.ref(["Pattern", csName]);
                        cs.end();
                        _this.doc.page.colorSpaces[csId] = cs;
                      });
                    }
                  }, {
                    key: "getPatternColorSpaceId",
                    value: function getPatternColorSpaceId(underlyingColorspace) {
                      return "CsP".concat(underlyingColorspace);
                    }
                  }, {
                    key: "embed",
                    value: function embed() {
                      if (!this.id) {
                        this.doc._patternCount = this.doc._patternCount + 1;
                        this.id = "P" + this.doc._patternCount;
                        this.pattern = this.createPattern();
                      }
                      if (!this.doc.page.patterns[this.id]) {
                        this.doc.page.patterns[this.id] = this.pattern;
                      }
                    }
                  }, {
                    key: "apply",
                    value: function apply(stroke, patternColor) {
                      this.embedPatternColorSpaces();
                      this.embed();
                      var normalizedColor = this.doc._normalizeColor(patternColor);
                      if (!normalizedColor)
                        throw Error("invalid pattern color. (value: ".concat(patternColor, ")"));
                      var csId = this.getPatternColorSpaceId(this.doc._getColorSpace(normalizedColor));
                      this.doc._setColorSpace(csId, stroke);
                      var op = stroke ? "SCN" : "scn";
                      return this.doc.addContent("".concat(normalizedColor.join(" "), " /").concat(this.id, " ").concat(op));
                    }
                  }]);
                  return PDFTilingPattern2;
                }();
                var pattern = {
                  PDFTilingPattern
                };
                var PDFGradient$1 = Gradient.PDFGradient, PDFLinearGradient$1 = Gradient.PDFLinearGradient, PDFRadialGradient$1 = Gradient.PDFRadialGradient;
                var PDFTilingPattern$1 = pattern.PDFTilingPattern;
                var ColorMixin = {
                  initColor: function initColor() {
                    this._opacityRegistry = {};
                    this._opacityCount = 0;
                    this._patternCount = 0;
                    return this._gradCount = 0;
                  },
                  _normalizeColor: function _normalizeColor(color) {
                    if (typeof color === "string") {
                      if (color.charAt(0) === "#") {
                        if (color.length === 4) {
                          color = color.replace(/#([0-9A-F])([0-9A-F])([0-9A-F])/i, "#$1$1$2$2$3$3");
                        }
                        var hex = parseInt(color.slice(1), 16);
                        color = [hex >> 16, hex >> 8 & 255, hex & 255];
                      } else if (namedColors[color]) {
                        color = namedColors[color];
                      }
                    }
                    if (Array.isArray(color)) {
                      if (color.length === 3) {
                        color = color.map(function(part) {
                          return part / 255;
                        });
                      } else if (color.length === 4) {
                        color = color.map(function(part) {
                          return part / 100;
                        });
                      }
                      return color;
                    }
                    return null;
                  },
                  _setColor: function _setColor(color, stroke) {
                    if (color instanceof PDFGradient$1) {
                      color.apply(stroke);
                      return true;
                    } else if (Array.isArray(color) && color[0] instanceof PDFTilingPattern$1) {
                      color[0].apply(stroke, color[1]);
                      return true;
                    }
                    return this._setColorCore(color, stroke);
                  },
                  _setColorCore: function _setColorCore(color, stroke) {
                    color = this._normalizeColor(color);
                    if (!color) {
                      return false;
                    }
                    var op = stroke ? "SCN" : "scn";
                    var space = this._getColorSpace(color);
                    this._setColorSpace(space, stroke);
                    color = color.join(" ");
                    this.addContent("".concat(color, " ").concat(op));
                    return true;
                  },
                  _setColorSpace: function _setColorSpace(space, stroke) {
                    var op = stroke ? "CS" : "cs";
                    return this.addContent("/".concat(space, " ").concat(op));
                  },
                  _getColorSpace: function _getColorSpace(color) {
                    return color.length === 4 ? "DeviceCMYK" : "DeviceRGB";
                  },
                  fillColor: function fillColor(color, opacity) {
                    var set = this._setColor(color, false);
                    if (set) {
                      this.fillOpacity(opacity);
                    }
                    this._fillColor = [color, opacity];
                    return this;
                  },
                  strokeColor: function strokeColor(color, opacity) {
                    var set = this._setColor(color, true);
                    if (set) {
                      this.strokeOpacity(opacity);
                    }
                    return this;
                  },
                  opacity: function opacity(_opacity) {
                    this._doOpacity(_opacity, _opacity);
                    return this;
                  },
                  fillOpacity: function fillOpacity(opacity) {
                    this._doOpacity(opacity, null);
                    return this;
                  },
                  strokeOpacity: function strokeOpacity(opacity) {
                    this._doOpacity(null, opacity);
                    return this;
                  },
                  _doOpacity: function _doOpacity(fillOpacity, strokeOpacity) {
                    var dictionary, name;
                    if (fillOpacity == null && strokeOpacity == null) {
                      return;
                    }
                    if (fillOpacity != null) {
                      fillOpacity = Math.max(0, Math.min(1, fillOpacity));
                    }
                    if (strokeOpacity != null) {
                      strokeOpacity = Math.max(0, Math.min(1, strokeOpacity));
                    }
                    var key = "".concat(fillOpacity, "_").concat(strokeOpacity);
                    if (this._opacityRegistry[key]) {
                      var _this$_opacityRegistr = _slicedToArray(this._opacityRegistry[key], 2);
                      dictionary = _this$_opacityRegistr[0];
                      name = _this$_opacityRegistr[1];
                    } else {
                      dictionary = {
                        Type: "ExtGState"
                      };
                      if (fillOpacity != null) {
                        dictionary.ca = fillOpacity;
                      }
                      if (strokeOpacity != null) {
                        dictionary.CA = strokeOpacity;
                      }
                      dictionary = this.ref(dictionary);
                      dictionary.end();
                      var id = ++this._opacityCount;
                      name = "Gs".concat(id);
                      this._opacityRegistry[key] = [dictionary, name];
                    }
                    this.page.ext_gstates[name] = dictionary;
                    return this.addContent("/".concat(name, " gs"));
                  },
                  linearGradient: function linearGradient(x1, y1, x2, y2) {
                    return new PDFLinearGradient$1(this, x1, y1, x2, y2);
                  },
                  radialGradient: function radialGradient(x1, y1, r1, x2, y2, r2) {
                    return new PDFRadialGradient$1(this, x1, y1, r1, x2, y2, r2);
                  },
                  pattern: function pattern2(bbox, xStep, yStep, stream) {
                    return new PDFTilingPattern$1(this, bbox, xStep, yStep, stream);
                  }
                };
                var namedColors = {
                  aliceblue: [240, 248, 255],
                  antiquewhite: [250, 235, 215],
                  aqua: [0, 255, 255],
                  aquamarine: [127, 255, 212],
                  azure: [240, 255, 255],
                  beige: [245, 245, 220],
                  bisque: [255, 228, 196],
                  black: [0, 0, 0],
                  blanchedalmond: [255, 235, 205],
                  blue: [0, 0, 255],
                  blueviolet: [138, 43, 226],
                  brown: [165, 42, 42],
                  burlywood: [222, 184, 135],
                  cadetblue: [95, 158, 160],
                  chartreuse: [127, 255, 0],
                  chocolate: [210, 105, 30],
                  coral: [255, 127, 80],
                  cornflowerblue: [100, 149, 237],
                  cornsilk: [255, 248, 220],
                  crimson: [220, 20, 60],
                  cyan: [0, 255, 255],
                  darkblue: [0, 0, 139],
                  darkcyan: [0, 139, 139],
                  darkgoldenrod: [184, 134, 11],
                  darkgray: [169, 169, 169],
                  darkgreen: [0, 100, 0],
                  darkgrey: [169, 169, 169],
                  darkkhaki: [189, 183, 107],
                  darkmagenta: [139, 0, 139],
                  darkolivegreen: [85, 107, 47],
                  darkorange: [255, 140, 0],
                  darkorchid: [153, 50, 204],
                  darkred: [139, 0, 0],
                  darksalmon: [233, 150, 122],
                  darkseagreen: [143, 188, 143],
                  darkslateblue: [72, 61, 139],
                  darkslategray: [47, 79, 79],
                  darkslategrey: [47, 79, 79],
                  darkturquoise: [0, 206, 209],
                  darkviolet: [148, 0, 211],
                  deeppink: [255, 20, 147],
                  deepskyblue: [0, 191, 255],
                  dimgray: [105, 105, 105],
                  dimgrey: [105, 105, 105],
                  dodgerblue: [30, 144, 255],
                  firebrick: [178, 34, 34],
                  floralwhite: [255, 250, 240],
                  forestgreen: [34, 139, 34],
                  fuchsia: [255, 0, 255],
                  gainsboro: [220, 220, 220],
                  ghostwhite: [248, 248, 255],
                  gold: [255, 215, 0],
                  goldenrod: [218, 165, 32],
                  gray: [128, 128, 128],
                  grey: [128, 128, 128],
                  green: [0, 128, 0],
                  greenyellow: [173, 255, 47],
                  honeydew: [240, 255, 240],
                  hotpink: [255, 105, 180],
                  indianred: [205, 92, 92],
                  indigo: [75, 0, 130],
                  ivory: [255, 255, 240],
                  khaki: [240, 230, 140],
                  lavender: [230, 230, 250],
                  lavenderblush: [255, 240, 245],
                  lawngreen: [124, 252, 0],
                  lemonchiffon: [255, 250, 205],
                  lightblue: [173, 216, 230],
                  lightcoral: [240, 128, 128],
                  lightcyan: [224, 255, 255],
                  lightgoldenrodyellow: [250, 250, 210],
                  lightgray: [211, 211, 211],
                  lightgreen: [144, 238, 144],
                  lightgrey: [211, 211, 211],
                  lightpink: [255, 182, 193],
                  lightsalmon: [255, 160, 122],
                  lightseagreen: [32, 178, 170],
                  lightskyblue: [135, 206, 250],
                  lightslategray: [119, 136, 153],
                  lightslategrey: [119, 136, 153],
                  lightsteelblue: [176, 196, 222],
                  lightyellow: [255, 255, 224],
                  lime: [0, 255, 0],
                  limegreen: [50, 205, 50],
                  linen: [250, 240, 230],
                  magenta: [255, 0, 255],
                  maroon: [128, 0, 0],
                  mediumaquamarine: [102, 205, 170],
                  mediumblue: [0, 0, 205],
                  mediumorchid: [186, 85, 211],
                  mediumpurple: [147, 112, 219],
                  mediumseagreen: [60, 179, 113],
                  mediumslateblue: [123, 104, 238],
                  mediumspringgreen: [0, 250, 154],
                  mediumturquoise: [72, 209, 204],
                  mediumvioletred: [199, 21, 133],
                  midnightblue: [25, 25, 112],
                  mintcream: [245, 255, 250],
                  mistyrose: [255, 228, 225],
                  moccasin: [255, 228, 181],
                  navajowhite: [255, 222, 173],
                  navy: [0, 0, 128],
                  oldlace: [253, 245, 230],
                  olive: [128, 128, 0],
                  olivedrab: [107, 142, 35],
                  orange: [255, 165, 0],
                  orangered: [255, 69, 0],
                  orchid: [218, 112, 214],
                  palegoldenrod: [238, 232, 170],
                  palegreen: [152, 251, 152],
                  paleturquoise: [175, 238, 238],
                  palevioletred: [219, 112, 147],
                  papayawhip: [255, 239, 213],
                  peachpuff: [255, 218, 185],
                  peru: [205, 133, 63],
                  pink: [255, 192, 203],
                  plum: [221, 160, 221],
                  powderblue: [176, 224, 230],
                  purple: [128, 0, 128],
                  red: [255, 0, 0],
                  rosybrown: [188, 143, 143],
                  royalblue: [65, 105, 225],
                  saddlebrown: [139, 69, 19],
                  salmon: [250, 128, 114],
                  sandybrown: [244, 164, 96],
                  seagreen: [46, 139, 87],
                  seashell: [255, 245, 238],
                  sienna: [160, 82, 45],
                  silver: [192, 192, 192],
                  skyblue: [135, 206, 235],
                  slateblue: [106, 90, 205],
                  slategray: [112, 128, 144],
                  slategrey: [112, 128, 144],
                  snow: [255, 250, 250],
                  springgreen: [0, 255, 127],
                  steelblue: [70, 130, 180],
                  tan: [210, 180, 140],
                  teal: [0, 128, 128],
                  thistle: [216, 191, 216],
                  tomato: [255, 99, 71],
                  turquoise: [64, 224, 208],
                  violet: [238, 130, 238],
                  wheat: [245, 222, 179],
                  white: [255, 255, 255],
                  whitesmoke: [245, 245, 245],
                  yellow: [255, 255, 0],
                  yellowgreen: [154, 205, 50]
                };
                var cx, cy, px, py, sx, sy;
                cx = cy = px = py = sx = sy = 0;
                var parameters = {
                  A: 7,
                  a: 7,
                  C: 6,
                  c: 6,
                  H: 1,
                  h: 1,
                  L: 2,
                  l: 2,
                  M: 2,
                  m: 2,
                  Q: 4,
                  q: 4,
                  S: 4,
                  s: 4,
                  T: 2,
                  t: 2,
                  V: 1,
                  v: 1,
                  Z: 0,
                  z: 0
                };
                var parse = function parse2(path) {
                  var cmd;
                  var ret = [];
                  var args = [];
                  var curArg = "";
                  var foundDecimal = false;
                  var params = 0;
                  var _iterator = _createForOfIteratorHelper(path), _step;
                  try {
                    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                      var c = _step.value;
                      if (parameters[c] != null) {
                        params = parameters[c];
                        if (cmd) {
                          if (curArg.length > 0) {
                            args[args.length] = +curArg;
                          }
                          ret[ret.length] = {
                            cmd,
                            args
                          };
                          args = [];
                          curArg = "";
                          foundDecimal = false;
                        }
                        cmd = c;
                      } else if ([" ", ","].includes(c) || c === "-" && curArg.length > 0 && curArg[curArg.length - 1] !== "e" || c === "." && foundDecimal) {
                        if (curArg.length === 0) {
                          continue;
                        }
                        if (args.length === params) {
                          ret[ret.length] = {
                            cmd,
                            args
                          };
                          args = [+curArg];
                          if (cmd === "M") {
                            cmd = "L";
                          }
                          if (cmd === "m") {
                            cmd = "l";
                          }
                        } else {
                          args[args.length] = +curArg;
                        }
                        foundDecimal = c === ".";
                        curArg = ["-", "."].includes(c) ? c : "";
                      } else {
                        curArg += c;
                        if (c === ".") {
                          foundDecimal = true;
                        }
                      }
                    }
                  } catch (err) {
                    _iterator.e(err);
                  } finally {
                    _iterator.f();
                  }
                  if (curArg.length > 0) {
                    if (args.length === params) {
                      ret[ret.length] = {
                        cmd,
                        args
                      };
                      args = [+curArg];
                      if (cmd === "M") {
                        cmd = "L";
                      }
                      if (cmd === "m") {
                        cmd = "l";
                      }
                    } else {
                      args[args.length] = +curArg;
                    }
                  }
                  ret[ret.length] = {
                    cmd,
                    args
                  };
                  return ret;
                };
                var _apply = function apply(commands, doc) {
                  cx = cy = px = py = sx = sy = 0;
                  for (var i = 0; i < commands.length; i++) {
                    var c = commands[i];
                    if (typeof runners[c.cmd] === "function") {
                      runners[c.cmd](doc, c.args);
                    }
                  }
                };
                var runners = {
                  M: function M(doc, a) {
                    cx = a[0];
                    cy = a[1];
                    px = py = null;
                    sx = cx;
                    sy = cy;
                    return doc.moveTo(cx, cy);
                  },
                  m: function m(doc, a) {
                    cx += a[0];
                    cy += a[1];
                    px = py = null;
                    sx = cx;
                    sy = cy;
                    return doc.moveTo(cx, cy);
                  },
                  C: function C(doc, a) {
                    cx = a[4];
                    cy = a[5];
                    px = a[2];
                    py = a[3];
                    return doc.bezierCurveTo.apply(doc, _toConsumableArray(a));
                  },
                  c: function c(doc, a) {
                    doc.bezierCurveTo(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy, a[4] + cx, a[5] + cy);
                    px = cx + a[2];
                    py = cy + a[3];
                    cx += a[4];
                    return cy += a[5];
                  },
                  S: function S(doc, a) {
                    if (px === null) {
                      px = cx;
                      py = cy;
                    }
                    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), a[0], a[1], a[2], a[3]);
                    px = a[0];
                    py = a[1];
                    cx = a[2];
                    return cy = a[3];
                  },
                  s: function s(doc, a) {
                    if (px === null) {
                      px = cx;
                      py = cy;
                    }
                    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), cx + a[0], cy + a[1], cx + a[2], cy + a[3]);
                    px = cx + a[0];
                    py = cy + a[1];
                    cx += a[2];
                    return cy += a[3];
                  },
                  Q: function Q(doc, a) {
                    px = a[0];
                    py = a[1];
                    cx = a[2];
                    cy = a[3];
                    return doc.quadraticCurveTo(a[0], a[1], cx, cy);
                  },
                  q: function q(doc, a) {
                    doc.quadraticCurveTo(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy);
                    px = cx + a[0];
                    py = cy + a[1];
                    cx += a[2];
                    return cy += a[3];
                  },
                  T: function T(doc, a) {
                    if (px === null) {
                      px = cx;
                      py = cy;
                    } else {
                      px = cx - (px - cx);
                      py = cy - (py - cy);
                    }
                    doc.quadraticCurveTo(px, py, a[0], a[1]);
                    px = cx - (px - cx);
                    py = cy - (py - cy);
                    cx = a[0];
                    return cy = a[1];
                  },
                  t: function t(doc, a) {
                    if (px === null) {
                      px = cx;
                      py = cy;
                    } else {
                      px = cx - (px - cx);
                      py = cy - (py - cy);
                    }
                    doc.quadraticCurveTo(px, py, cx + a[0], cy + a[1]);
                    cx += a[0];
                    return cy += a[1];
                  },
                  A: function A(doc, a) {
                    solveArc(doc, cx, cy, a);
                    cx = a[5];
                    return cy = a[6];
                  },
                  a: function a(doc, _a) {
                    _a[5] += cx;
                    _a[6] += cy;
                    solveArc(doc, cx, cy, _a);
                    cx = _a[5];
                    return cy = _a[6];
                  },
                  L: function L(doc, a) {
                    cx = a[0];
                    cy = a[1];
                    px = py = null;
                    return doc.lineTo(cx, cy);
                  },
                  l: function l(doc, a) {
                    cx += a[0];
                    cy += a[1];
                    px = py = null;
                    return doc.lineTo(cx, cy);
                  },
                  H: function H(doc, a) {
                    cx = a[0];
                    px = py = null;
                    return doc.lineTo(cx, cy);
                  },
                  h: function h(doc, a) {
                    cx += a[0];
                    px = py = null;
                    return doc.lineTo(cx, cy);
                  },
                  V: function V(doc, a) {
                    cy = a[0];
                    px = py = null;
                    return doc.lineTo(cx, cy);
                  },
                  v: function v(doc, a) {
                    cy += a[0];
                    px = py = null;
                    return doc.lineTo(cx, cy);
                  },
                  Z: function Z(doc) {
                    doc.closePath();
                    cx = sx;
                    return cy = sy;
                  },
                  z: function z(doc) {
                    doc.closePath();
                    cx = sx;
                    return cy = sy;
                  }
                };
                var solveArc = function solveArc2(doc, x, y, coords) {
                  var _coords = _slicedToArray(coords, 7), rx = _coords[0], ry = _coords[1], rot = _coords[2], large = _coords[3], sweep = _coords[4], ex = _coords[5], ey = _coords[6];
                  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);
                  var _iterator2 = _createForOfIteratorHelper(segs), _step2;
                  try {
                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                      var seg = _step2.value;
                      var bez = segmentToBezier.apply(void 0, _toConsumableArray(seg));
                      doc.bezierCurveTo.apply(doc, _toConsumableArray(bez));
                    }
                  } catch (err) {
                    _iterator2.e(err);
                  } finally {
                    _iterator2.f();
                  }
                };
                var arcToSegments = function arcToSegments2(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
                  var th = rotateX * (Math.PI / 180);
                  var sin_th = Math.sin(th);
                  var cos_th = Math.cos(th);
                  rx = Math.abs(rx);
                  ry = Math.abs(ry);
                  px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;
                  py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
                  var pl = px * px / (rx * rx) + py * py / (ry * ry);
                  if (pl > 1) {
                    pl = Math.sqrt(pl);
                    rx *= pl;
                    ry *= pl;
                  }
                  var a00 = cos_th / rx;
                  var a01 = sin_th / rx;
                  var a10 = -sin_th / ry;
                  var a11 = cos_th / ry;
                  var x0 = a00 * ox + a01 * oy;
                  var y0 = a10 * ox + a11 * oy;
                  var x1 = a00 * x + a01 * y;
                  var y1 = a10 * x + a11 * y;
                  var d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
                  var sfactor_sq = 1 / d - 0.25;
                  if (sfactor_sq < 0) {
                    sfactor_sq = 0;
                  }
                  var sfactor = Math.sqrt(sfactor_sq);
                  if (sweep === large) {
                    sfactor = -sfactor;
                  }
                  var xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
                  var yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
                  var th0 = Math.atan2(y0 - yc, x0 - xc);
                  var th1 = Math.atan2(y1 - yc, x1 - xc);
                  var th_arc = th1 - th0;
                  if (th_arc < 0 && sweep === 1) {
                    th_arc += 2 * Math.PI;
                  } else if (th_arc > 0 && sweep === 0) {
                    th_arc -= 2 * Math.PI;
                  }
                  var segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 1e-3)));
                  var result = [];
                  for (var i = 0; i < segments; i++) {
                    var th2 = th0 + i * th_arc / segments;
                    var th3 = th0 + (i + 1) * th_arc / segments;
                    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
                  }
                  return result;
                };
                var segmentToBezier = function segmentToBezier2(cx2, cy2, th0, th1, rx, ry, sin_th, cos_th) {
                  var a00 = cos_th * rx;
                  var a01 = -sin_th * ry;
                  var a10 = sin_th * rx;
                  var a11 = cos_th * ry;
                  var th_half = 0.5 * (th1 - th0);
                  var t = 8 / 3 * Math.sin(th_half * 0.5) * Math.sin(th_half * 0.5) / Math.sin(th_half);
                  var x1 = cx2 + Math.cos(th0) - t * Math.sin(th0);
                  var y1 = cy2 + Math.sin(th0) + t * Math.cos(th0);
                  var x3 = cx2 + Math.cos(th1);
                  var y3 = cy2 + Math.sin(th1);
                  var x2 = x3 + t * Math.sin(th1);
                  var y2 = y3 - t * Math.cos(th1);
                  return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
                };
                var SVGPath = function() {
                  function SVGPath2() {
                    _classCallCheck(this, SVGPath2);
                  }
                  _createClass(SVGPath2, null, [{
                    key: "apply",
                    value: function apply(doc, path) {
                      var commands = parse(path);
                      _apply(commands, doc);
                    }
                  }]);
                  return SVGPath2;
                }();
                var number$1 = PDFObject.number;
                var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
                var VectorMixin = {
                  initVector: function initVector() {
                    this._ctm = [1, 0, 0, 1, 0, 0];
                    return this._ctmStack = [];
                  },
                  save: function save() {
                    this._ctmStack.push(this._ctm.slice());
                    return this.addContent("q");
                  },
                  restore: function restore() {
                    this._ctm = this._ctmStack.pop() || [1, 0, 0, 1, 0, 0];
                    return this.addContent("Q");
                  },
                  closePath: function closePath() {
                    return this.addContent("h");
                  },
                  lineWidth: function lineWidth(w) {
                    return this.addContent("".concat(number$1(w), " w"));
                  },
                  _CAP_STYLES: {
                    BUTT: 0,
                    ROUND: 1,
                    SQUARE: 2
                  },
                  lineCap: function lineCap(c) {
                    if (typeof c === "string") {
                      c = this._CAP_STYLES[c.toUpperCase()];
                    }
                    return this.addContent("".concat(c, " J"));
                  },
                  _JOIN_STYLES: {
                    MITER: 0,
                    ROUND: 1,
                    BEVEL: 2
                  },
                  lineJoin: function lineJoin(j) {
                    if (typeof j === "string") {
                      j = this._JOIN_STYLES[j.toUpperCase()];
                    }
                    return this.addContent("".concat(j, " j"));
                  },
                  miterLimit: function miterLimit(m) {
                    return this.addContent("".concat(number$1(m), " M"));
                  },
                  dash: function dash(length) {
                    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                    var originalLength = length;
                    if (!Array.isArray(length)) {
                      length = [length, options.space || length];
                    }
                    var valid = length.every(function(x) {
                      return Number.isFinite(x) && x > 0;
                    });
                    if (!valid) {
                      throw new Error("dash(".concat(JSON.stringify(originalLength), ", ").concat(JSON.stringify(options), ") invalid, lengths must be numeric and greater than zero"));
                    }
                    length = length.map(number$1).join(" ");
                    return this.addContent("[".concat(length, "] ").concat(number$1(options.phase || 0), " d"));
                  },
                  undash: function undash() {
                    return this.addContent("[] 0 d");
                  },
                  moveTo: function moveTo(x, y) {
                    return this.addContent("".concat(number$1(x), " ").concat(number$1(y), " m"));
                  },
                  lineTo: function lineTo(x, y) {
                    return this.addContent("".concat(number$1(x), " ").concat(number$1(y), " l"));
                  },
                  bezierCurveTo: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
                    return this.addContent("".concat(number$1(cp1x), " ").concat(number$1(cp1y), " ").concat(number$1(cp2x), " ").concat(number$1(cp2y), " ").concat(number$1(x), " ").concat(number$1(y), " c"));
                  },
                  quadraticCurveTo: function quadraticCurveTo(cpx, cpy, x, y) {
                    return this.addContent("".concat(number$1(cpx), " ").concat(number$1(cpy), " ").concat(number$1(x), " ").concat(number$1(y), " v"));
                  },
                  rect: function rect(x, y, w, h) {
                    return this.addContent("".concat(number$1(x), " ").concat(number$1(y), " ").concat(number$1(w), " ").concat(number$1(h), " re"));
                  },
                  roundedRect: function roundedRect(x, y, w, h, r) {
                    if (r == null) {
                      r = 0;
                    }
                    r = Math.min(r, 0.5 * w, 0.5 * h);
                    var c = r * (1 - KAPPA);
                    this.moveTo(x + r, y);
                    this.lineTo(x + w - r, y);
                    this.bezierCurveTo(x + w - c, y, x + w, y + c, x + w, y + r);
                    this.lineTo(x + w, y + h - r);
                    this.bezierCurveTo(x + w, y + h - c, x + w - c, y + h, x + w - r, y + h);
                    this.lineTo(x + r, y + h);
                    this.bezierCurveTo(x + c, y + h, x, y + h - c, x, y + h - r);
                    this.lineTo(x, y + r);
                    this.bezierCurveTo(x, y + c, x + c, y, x + r, y);
                    return this.closePath();
                  },
                  ellipse: function ellipse(x, y, r1, r2) {
                    if (r2 == null) {
                      r2 = r1;
                    }
                    x -= r1;
                    y -= r2;
                    var ox = r1 * KAPPA;
                    var oy = r2 * KAPPA;
                    var xe = x + r1 * 2;
                    var ye = y + r2 * 2;
                    var xm = x + r1;
                    var ym = y + r2;
                    this.moveTo(x, ym);
                    this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                    this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                    this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                    this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                    return this.closePath();
                  },
                  circle: function circle(x, y, radius) {
                    return this.ellipse(x, y, radius);
                  },
                  arc: function arc(x, y, radius, startAngle, endAngle, anticlockwise) {
                    if (anticlockwise == null) {
                      anticlockwise = false;
                    }
                    var TWO_PI = 2 * Math.PI;
                    var HALF_PI = 0.5 * Math.PI;
                    var deltaAng = endAngle - startAngle;
                    if (Math.abs(deltaAng) > TWO_PI) {
                      deltaAng = TWO_PI;
                    } else if (deltaAng !== 0 && anticlockwise !== deltaAng < 0) {
                      var dir = anticlockwise ? -1 : 1;
                      deltaAng = dir * TWO_PI + deltaAng;
                    }
                    var numSegs = Math.ceil(Math.abs(deltaAng) / HALF_PI);
                    var segAng = deltaAng / numSegs;
                    var handleLen = segAng / HALF_PI * KAPPA * radius;
                    var curAng = startAngle;
                    var deltaCx = -Math.sin(curAng) * handleLen;
                    var deltaCy = Math.cos(curAng) * handleLen;
                    var ax = x + Math.cos(curAng) * radius;
                    var ay = y + Math.sin(curAng) * radius;
                    this.moveTo(ax, ay);
                    for (var segIdx = 0; segIdx < numSegs; segIdx++) {
                      var cp1x = ax + deltaCx;
                      var cp1y = ay + deltaCy;
                      curAng += segAng;
                      ax = x + Math.cos(curAng) * radius;
                      ay = y + Math.sin(curAng) * radius;
                      deltaCx = -Math.sin(curAng) * handleLen;
                      deltaCy = Math.cos(curAng) * handleLen;
                      var cp2x = ax - deltaCx;
                      var cp2y = ay - deltaCy;
                      this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ax, ay);
                    }
                    return this;
                  },
                  polygon: function polygon() {
                    for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {
                      points[_key] = arguments[_key];
                    }
                    this.moveTo.apply(this, _toConsumableArray(points.shift() || []));
                    for (var _i = 0, _points = points; _i < _points.length; _i++) {
                      var point = _points[_i];
                      this.lineTo.apply(this, _toConsumableArray(point || []));
                    }
                    return this.closePath();
                  },
                  path: function path(_path) {
                    SVGPath.apply(this, _path);
                    return this;
                  },
                  _windingRule: function _windingRule(rule) {
                    if (/even-?odd/.test(rule)) {
                      return "*";
                    }
                    return "";
                  },
                  fill: function fill(color, rule) {
                    if (/(even-?odd)|(non-?zero)/.test(color)) {
                      rule = color;
                      color = null;
                    }
                    if (color) {
                      this.fillColor(color);
                    }
                    return this.addContent("f".concat(this._windingRule(rule)));
                  },
                  stroke: function stroke(color) {
                    if (color) {
                      this.strokeColor(color);
                    }
                    return this.addContent("S");
                  },
                  fillAndStroke: function fillAndStroke(fillColor, strokeColor, rule) {
                    if (strokeColor == null) {
                      strokeColor = fillColor;
                    }
                    var isFillRule = /(even-?odd)|(non-?zero)/;
                    if (isFillRule.test(fillColor)) {
                      rule = fillColor;
                      fillColor = null;
                    }
                    if (isFillRule.test(strokeColor)) {
                      rule = strokeColor;
                      strokeColor = fillColor;
                    }
                    if (fillColor) {
                      this.fillColor(fillColor);
                      this.strokeColor(strokeColor);
                    }
                    return this.addContent("B".concat(this._windingRule(rule)));
                  },
                  clip: function clip(rule) {
                    return this.addContent("W".concat(this._windingRule(rule), " n"));
                  },
                  transform: function transform(m11, m12, m21, m22, dx, dy) {
                    var m = this._ctm;
                    var _m = _slicedToArray(m, 6), m0 = _m[0], m1 = _m[1], m2 = _m[2], m3 = _m[3], m4 = _m[4], m5 = _m[5];
                    m[0] = m0 * m11 + m2 * m12;
                    m[1] = m1 * m11 + m3 * m12;
                    m[2] = m0 * m21 + m2 * m22;
                    m[3] = m1 * m21 + m3 * m22;
                    m[4] = m0 * dx + m2 * dy + m4;
                    m[5] = m1 * dx + m3 * dy + m5;
                    var values = [m11, m12, m21, m22, dx, dy].map(function(v) {
                      return number$1(v);
                    }).join(" ");
                    return this.addContent("".concat(values, " cm"));
                  },
                  translate: function translate(x, y) {
                    return this.transform(1, 0, 0, 1, x, y);
                  },
                  rotate: function rotate(angle) {
                    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                    var y;
                    var rad = angle * Math.PI / 180;
                    var cos = Math.cos(rad);
                    var sin = Math.sin(rad);
                    var x = y = 0;
                    if (options.origin != null) {
                      var _options$origin = _slicedToArray(options.origin, 2);
                      x = _options$origin[0];
                      y = _options$origin[1];
                      var x1 = x * cos - y * sin;
                      var y1 = x * sin + y * cos;
                      x -= x1;
                      y -= y1;
                    }
                    return this.transform(cos, sin, -sin, cos, x, y);
                  },
                  scale: function scale(xFactor, yFactor) {
                    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                    var y;
                    if (yFactor == null) {
                      yFactor = xFactor;
                    }
                    if (typeof yFactor === "object") {
                      options = yFactor;
                      yFactor = xFactor;
                    }
                    var x = y = 0;
                    if (options.origin != null) {
                      var _options$origin2 = _slicedToArray(options.origin, 2);
                      x = _options$origin2[0];
                      y = _options$origin2[1];
                      x -= xFactor * x;
                      y -= yFactor * y;
                    }
                    return this.transform(xFactor, 0, 0, yFactor, x, y);
                  }
                };
                var WIN_ANSI_MAP = {
                  402: 131,
                  8211: 150,
                  8212: 151,
                  8216: 145,
                  8217: 146,
                  8218: 130,
                  8220: 147,
                  8221: 148,
                  8222: 132,
                  8224: 134,
                  8225: 135,
                  8226: 149,
                  8230: 133,
                  8364: 128,
                  8240: 137,
                  8249: 139,
                  8250: 155,
                  710: 136,
                  8482: 153,
                  338: 140,
                  339: 156,
                  732: 152,
                  352: 138,
                  353: 154,
                  376: 159,
                  381: 142,
                  382: 158
                };
                var characters = ".notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n  \nspace         exclam         quotedbl       numbersign\ndollar        percent        ampersand      quotesingle\nparenleft     parenright     asterisk       plus\ncomma         hyphen         period         slash\nzero          one            two            three\nfour          five           six            seven\neight         nine           colon          semicolon\nless          equal          greater        question\n  \nat            A              B              C\nD             E              F              G\nH             I              J              K\nL             M              N              O\nP             Q              R              S\nT             U              V              W\nX             Y              Z              bracketleft\nbackslash     bracketright   asciicircum    underscore\n  \ngrave         a              b              c\nd             e              f              g\nh             i              j              k\nl             m              n              o\np             q              r              s\nt             u              v              w\nx             y              z              braceleft\nbar           braceright     asciitilde     .notdef\n  \nEuro          .notdef        quotesinglbase florin\nquotedblbase  ellipsis       dagger         daggerdbl\ncircumflex    perthousand    Scaron         guilsinglleft\nOE            .notdef        Zcaron         .notdef\n.notdef       quoteleft      quoteright     quotedblleft\nquotedblright bullet         endash         emdash\ntilde         trademark      scaron         guilsinglright\noe            .notdef        zcaron         ydieresis\n  \nspace         exclamdown     cent           sterling\ncurrency      yen            brokenbar      section\ndieresis      copyright      ordfeminine    guillemotleft\nlogicalnot    hyphen         registered     macron\ndegree        plusminus      twosuperior    threesuperior\nacute         mu             paragraph      periodcentered\ncedilla       onesuperior    ordmasculine   guillemotright\nonequarter    onehalf        threequarters  questiondown\n  \nAgrave        Aacute         Acircumflex    Atilde\nAdieresis     Aring          AE             Ccedilla\nEgrave        Eacute         Ecircumflex    Edieresis\nIgrave        Iacute         Icircumflex    Idieresis\nEth           Ntilde         Ograve         Oacute\nOcircumflex   Otilde         Odieresis      multiply\nOslash        Ugrave         Uacute         Ucircumflex\nUdieresis     Yacute         Thorn          germandbls\n  \nagrave        aacute         acircumflex    atilde\nadieresis     aring          ae             ccedilla\negrave        eacute         ecircumflex    edieresis\nigrave        iacute         icircumflex    idieresis\neth           ntilde         ograve         oacute\nocircumflex   otilde         odieresis      divide\noslash        ugrave         uacute         ucircumflex\nudieresis     yacute         thorn          ydieresis".split(/\s+/);
                var AFMFont = function() {
                  _createClass(AFMFont2, null, [{
                    key: "open",
                    value: function open2(filename) {
                      return new AFMFont2(fs.readFileSync(filename, "utf8"));
                    }
                  }]);
                  function AFMFont2(contents) {
                    _classCallCheck(this, AFMFont2);
                    this.contents = contents;
                    this.attributes = {};
                    this.glyphWidths = {};
                    this.boundingBoxes = {};
                    this.kernPairs = {};
                    this.parse();
                    this.charWidths = new Array(256);
                    for (var char = 0; char <= 255; char++) {
                      this.charWidths[char] = this.glyphWidths[characters[char]];
                    }
                    this.bbox = this.attributes["FontBBox"].split(/\s+/).map(function(e) {
                      return +e;
                    });
                    this.ascender = +(this.attributes["Ascender"] || 0);
                    this.descender = +(this.attributes["Descender"] || 0);
                    this.xHeight = +(this.attributes["XHeight"] || 0);
                    this.capHeight = +(this.attributes["CapHeight"] || 0);
                    this.lineGap = this.bbox[3] - this.bbox[1] - (this.ascender - this.descender);
                  }
                  _createClass(AFMFont2, [{
                    key: "parse",
                    value: function parse2() {
                      var section = "";
                      var _iterator = _createForOfIteratorHelper(this.contents.split("\n")), _step;
                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                          var line = _step.value;
                          var match;
                          var a;
                          if (match = line.match(/^Start(\w+)/)) {
                            section = match[1];
                            continue;
                          } else if (match = line.match(/^End(\w+)/)) {
                            section = "";
                            continue;
                          }
                          switch (section) {
                            case "FontMetrics":
                              match = line.match(/(^\w+)\s+(.*)/);
                              var key = match[1];
                              var value = match[2];
                              if (a = this.attributes[key]) {
                                if (!Array.isArray(a)) {
                                  a = this.attributes[key] = [a];
                                }
                                a.push(value);
                              } else {
                                this.attributes[key] = value;
                              }
                              break;
                            case "CharMetrics":
                              if (!/^CH?\s/.test(line)) {
                                continue;
                              }
                              var name = line.match(/\bN\s+(\.?\w+)\s*;/)[1];
                              this.glyphWidths[name] = +line.match(/\bWX\s+(\d+)\s*;/)[1];
                              break;
                            case "KernPairs":
                              match = line.match(/^KPX\s+(\.?\w+)\s+(\.?\w+)\s+(-?\d+)/);
                              if (match) {
                                this.kernPairs[match[1] + "\0" + match[2]] = parseInt(match[3]);
                              }
                              break;
                          }
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }
                    }
                  }, {
                    key: "encodeText",
                    value: function encodeText(text) {
                      var res = [];
                      for (var i = 0, len = text.length; i < len; i++) {
                        var char = text.charCodeAt(i);
                        char = WIN_ANSI_MAP[char] || char;
                        res.push(char.toString(16));
                      }
                      return res;
                    }
                  }, {
                    key: "glyphsForString",
                    value: function glyphsForString(string) {
                      var glyphs = [];
                      for (var i = 0, len = string.length; i < len; i++) {
                        var charCode = string.charCodeAt(i);
                        glyphs.push(this.characterToGlyph(charCode));
                      }
                      return glyphs;
                    }
                  }, {
                    key: "characterToGlyph",
                    value: function characterToGlyph(character) {
                      return characters[WIN_ANSI_MAP[character] || character] || ".notdef";
                    }
                  }, {
                    key: "widthOfGlyph",
                    value: function widthOfGlyph(glyph) {
                      return this.glyphWidths[glyph] || 0;
                    }
                  }, {
                    key: "getKernPair",
                    value: function getKernPair(left, right) {
                      return this.kernPairs[left + "\0" + right] || 0;
                    }
                  }, {
                    key: "advancesForGlyphs",
                    value: function advancesForGlyphs(glyphs) {
                      var advances = [];
                      for (var index = 0; index < glyphs.length; index++) {
                        var left = glyphs[index];
                        var right = glyphs[index + 1];
                        advances.push(this.widthOfGlyph(left) + this.getKernPair(left, right));
                      }
                      return advances;
                    }
                  }]);
                  return AFMFont2;
                }();
                var PDFFont = function() {
                  function PDFFont2() {
                    _classCallCheck(this, PDFFont2);
                  }
                  _createClass(PDFFont2, [{
                    key: "encode",
                    value: function encode() {
                      throw new Error("Must be implemented by subclasses");
                    }
                  }, {
                    key: "widthOfString",
                    value: function widthOfString() {
                      throw new Error("Must be implemented by subclasses");
                    }
                  }, {
                    key: "ref",
                    value: function ref() {
                      return this.dictionary != null ? this.dictionary : this.dictionary = this.document.ref();
                    }
                  }, {
                    key: "finalize",
                    value: function finalize() {
                      if (this.embedded || this.dictionary == null) {
                        return;
                      }
                      this.embed();
                      return this.embedded = true;
                    }
                  }, {
                    key: "embed",
                    value: function embed() {
                      throw new Error("Must be implemented by subclasses");
                    }
                  }, {
                    key: "lineHeight",
                    value: function lineHeight(size, includeGap) {
                      if (includeGap == null) {
                        includeGap = false;
                      }
                      var gap = includeGap ? this.lineGap : 0;
                      return (this.ascender + gap - this.descender) / 1e3 * size;
                    }
                  }]);
                  return PDFFont2;
                }();
                var STANDARD_FONTS = {
                  Courier: function Courier() {
                    return fs.readFileSync(__dirname + "/data/Courier.afm", "utf8");
                  },
                  "Courier-Bold": function CourierBold() {
                    return fs.readFileSync(__dirname + "/data/Courier-Bold.afm", "utf8");
                  },
                  "Courier-Oblique": function CourierOblique() {
                    return fs.readFileSync(__dirname + "/data/Courier-Oblique.afm", "utf8");
                  },
                  "Courier-BoldOblique": function CourierBoldOblique() {
                    return fs.readFileSync(__dirname + "/data/Courier-BoldOblique.afm", "utf8");
                  },
                  Helvetica: function Helvetica() {
                    return fs.readFileSync(__dirname + "/data/Helvetica.afm", "utf8");
                  },
                  "Helvetica-Bold": function HelveticaBold() {
                    return fs.readFileSync(__dirname + "/data/Helvetica-Bold.afm", "utf8");
                  },
                  "Helvetica-Oblique": function HelveticaOblique() {
                    return fs.readFileSync(__dirname + "/data/Helvetica-Oblique.afm", "utf8");
                  },
                  "Helvetica-BoldOblique": function HelveticaBoldOblique() {
                    return fs.readFileSync(__dirname + "/data/Helvetica-BoldOblique.afm", "utf8");
                  },
                  "Times-Roman": function TimesRoman() {
                    return fs.readFileSync(__dirname + "/data/Times-Roman.afm", "utf8");
                  },
                  "Times-Bold": function TimesBold() {
                    return fs.readFileSync(__dirname + "/data/Times-Bold.afm", "utf8");
                  },
                  "Times-Italic": function TimesItalic() {
                    return fs.readFileSync(__dirname + "/data/Times-Italic.afm", "utf8");
                  },
                  "Times-BoldItalic": function TimesBoldItalic() {
                    return fs.readFileSync(__dirname + "/data/Times-BoldItalic.afm", "utf8");
                  },
                  Symbol: function Symbol2() {
                    return fs.readFileSync(__dirname + "/data/Symbol.afm", "utf8");
                  },
                  ZapfDingbats: function ZapfDingbats() {
                    return fs.readFileSync(__dirname + "/data/ZapfDingbats.afm", "utf8");
                  }
                };
                var StandardFont = function(_PDFFont) {
                  _inherits(StandardFont2, _PDFFont);
                  var _super = _createSuper(StandardFont2);
                  function StandardFont2(document2, name, id) {
                    var _this;
                    _classCallCheck(this, StandardFont2);
                    _this = _super.call(this);
                    _this.document = document2;
                    _this.name = name;
                    _this.id = id;
                    _this.font = new AFMFont(STANDARD_FONTS[_this.name]());
                    var _this$font = _this.font;
                    _this.ascender = _this$font.ascender;
                    _this.descender = _this$font.descender;
                    _this.bbox = _this$font.bbox;
                    _this.lineGap = _this$font.lineGap;
                    _this.xHeight = _this$font.xHeight;
                    _this.capHeight = _this$font.capHeight;
                    return _this;
                  }
                  _createClass(StandardFont2, [{
                    key: "embed",
                    value: function embed() {
                      this.dictionary.data = {
                        Type: "Font",
                        BaseFont: this.name,
                        Subtype: "Type1",
                        Encoding: "WinAnsiEncoding"
                      };
                      return this.dictionary.end();
                    }
                  }, {
                    key: "encode",
                    value: function encode(text) {
                      var encoded = this.font.encodeText(text);
                      var glyphs = this.font.glyphsForString("".concat(text));
                      var advances = this.font.advancesForGlyphs(glyphs);
                      var positions = [];
                      for (var i = 0; i < glyphs.length; i++) {
                        var glyph = glyphs[i];
                        positions.push({
                          xAdvance: advances[i],
                          yAdvance: 0,
                          xOffset: 0,
                          yOffset: 0,
                          advanceWidth: this.font.widthOfGlyph(glyph)
                        });
                      }
                      return [encoded, positions];
                    }
                  }, {
                    key: "widthOfString",
                    value: function widthOfString(string, size) {
                      var glyphs = this.font.glyphsForString("".concat(string));
                      var advances = this.font.advancesForGlyphs(glyphs);
                      var width = 0;
                      var _iterator = _createForOfIteratorHelper(advances), _step;
                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                          var advance = _step.value;
                          width += advance;
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }
                      var scale = size / 1e3;
                      return width * scale;
                    }
                  }], [{
                    key: "isStandardFont",
                    value: function isStandardFont(name) {
                      return name in STANDARD_FONTS;
                    }
                  }]);
                  return StandardFont2;
                }(PDFFont);
                var toHex = function toHex2(num) {
                  return "0000".concat(num.toString(16)).slice(-4);
                };
                var EmbeddedFont = function(_PDFFont) {
                  _inherits(EmbeddedFont2, _PDFFont);
                  var _super = _createSuper(EmbeddedFont2);
                  function EmbeddedFont2(document2, font, id) {
                    var _this;
                    _classCallCheck(this, EmbeddedFont2);
                    _this = _super.call(this);
                    _this.document = document2;
                    _this.font = font;
                    _this.id = id;
                    _this.subset = _this.font.createSubset();
                    _this.unicode = [[0]];
                    _this.widths = [_this.font.getGlyph(0).advanceWidth];
                    _this.name = _this.font.postscriptName;
                    _this.scale = 1e3 / _this.font.unitsPerEm;
                    _this.ascender = _this.font.ascent * _this.scale;
                    _this.descender = _this.font.descent * _this.scale;
                    _this.xHeight = _this.font.xHeight * _this.scale;
                    _this.capHeight = _this.font.capHeight * _this.scale;
                    _this.lineGap = _this.font.lineGap * _this.scale;
                    _this.bbox = _this.font.bbox;
                    if (document2.options.fontLayoutCache !== false) {
                      _this.layoutCache = /* @__PURE__ */ Object.create(null);
                    }
                    return _this;
                  }
                  _createClass(EmbeddedFont2, [{
                    key: "layoutRun",
                    value: function layoutRun(text, features) {
                      var run = this.font.layout(text, features);
                      for (var i = 0; i < run.positions.length; i++) {
                        var position = run.positions[i];
                        for (var key in position) {
                          position[key] *= this.scale;
                        }
                        position.advanceWidth = run.glyphs[i].advanceWidth * this.scale;
                      }
                      return run;
                    }
                  }, {
                    key: "layoutCached",
                    value: function layoutCached(text) {
                      if (!this.layoutCache) {
                        return this.layoutRun(text);
                      }
                      var cached;
                      if (cached = this.layoutCache[text]) {
                        return cached;
                      }
                      var run = this.layoutRun(text);
                      this.layoutCache[text] = run;
                      return run;
                    }
                  }, {
                    key: "layout",
                    value: function layout(text, features, onlyWidth) {
                      if (features) {
                        return this.layoutRun(text, features);
                      }
                      var glyphs = onlyWidth ? null : [];
                      var positions = onlyWidth ? null : [];
                      var advanceWidth = 0;
                      var last2 = 0;
                      var index = 0;
                      while (index <= text.length) {
                        var needle;
                        if (index === text.length && last2 < index || (needle = text.charAt(index), [" ", "	"].includes(needle))) {
                          var run = this.layoutCached(text.slice(last2, ++index));
                          if (!onlyWidth) {
                            glyphs = glyphs.concat(run.glyphs);
                            positions = positions.concat(run.positions);
                          }
                          advanceWidth += run.advanceWidth;
                          last2 = index;
                        } else {
                          index++;
                        }
                      }
                      return {
                        glyphs,
                        positions,
                        advanceWidth
                      };
                    }
                  }, {
                    key: "encode",
                    value: function encode(text, features) {
                      var _this$layout = this.layout(text, features), glyphs = _this$layout.glyphs, positions = _this$layout.positions;
                      var res = [];
                      for (var i = 0; i < glyphs.length; i++) {
                        var glyph = glyphs[i];
                        var gid = this.subset.includeGlyph(glyph.id);
                        res.push("0000".concat(gid.toString(16)).slice(-4));
                        if (this.widths[gid] == null) {
                          this.widths[gid] = glyph.advanceWidth * this.scale;
                        }
                        if (this.unicode[gid] == null) {
                          this.unicode[gid] = glyph.codePoints;
                        }
                      }
                      return [res, positions];
                    }
                  }, {
                    key: "widthOfString",
                    value: function widthOfString(string, size, features) {
                      var width = this.layout(string, features, true).advanceWidth;
                      var scale = size / 1e3;
                      return width * scale;
                    }
                  }, {
                    key: "embed",
                    value: function embed() {
                      var _this2 = this;
                      var isCFF = this.subset.cff != null;
                      var fontFile = this.document.ref();
                      if (isCFF) {
                        fontFile.data.Subtype = "CIDFontType0C";
                      }
                      this.subset.encodeStream().on("data", function(data) {
                        return fontFile.write(data);
                      }).on("end", function() {
                        return fontFile.end();
                      });
                      var familyClass = ((this.font["OS/2"] != null ? this.font["OS/2"].sFamilyClass : void 0) || 0) >> 8;
                      var flags = 0;
                      if (this.font.post.isFixedPitch) {
                        flags |= 1 << 0;
                      }
                      if (1 <= familyClass && familyClass <= 7) {
                        flags |= 1 << 1;
                      }
                      flags |= 1 << 2;
                      if (familyClass === 10) {
                        flags |= 1 << 3;
                      }
                      if (this.font.head.macStyle.italic) {
                        flags |= 1 << 6;
                      }
                      var tag = [1, 2, 3, 4, 5, 6].map(function(i) {
                        return String.fromCharCode((_this2.id.charCodeAt(i) || 73) + 17);
                      }).join("");
                      var name = tag + "+" + this.font.postscriptName;
                      var bbox = this.font.bbox;
                      var descriptor = this.document.ref({
                        Type: "FontDescriptor",
                        FontName: name,
                        Flags: flags,
                        FontBBox: [bbox.minX * this.scale, bbox.minY * this.scale, bbox.maxX * this.scale, bbox.maxY * this.scale],
                        ItalicAngle: this.font.italicAngle,
                        Ascent: this.ascender,
                        Descent: this.descender,
                        CapHeight: (this.font.capHeight || this.font.ascent) * this.scale,
                        XHeight: (this.font.xHeight || 0) * this.scale,
                        StemV: 0
                      });
                      if (isCFF) {
                        descriptor.data.FontFile3 = fontFile;
                      } else {
                        descriptor.data.FontFile2 = fontFile;
                      }
                      descriptor.end();
                      var descendantFontData = {
                        Type: "Font",
                        Subtype: "CIDFontType0",
                        BaseFont: name,
                        CIDSystemInfo: {
                          Registry: new String("Adobe"),
                          Ordering: new String("Identity"),
                          Supplement: 0
                        },
                        FontDescriptor: descriptor,
                        W: [0, this.widths]
                      };
                      if (!isCFF) {
                        descendantFontData.Subtype = "CIDFontType2";
                        descendantFontData.CIDToGIDMap = "Identity";
                      }
                      var descendantFont = this.document.ref(descendantFontData);
                      descendantFont.end();
                      this.dictionary.data = {
                        Type: "Font",
                        Subtype: "Type0",
                        BaseFont: name,
                        Encoding: "Identity-H",
                        DescendantFonts: [descendantFont],
                        ToUnicode: this.toUnicodeCmap()
                      };
                      return this.dictionary.end();
                    }
                    // Maps the glyph ids encoded in the PDF back to unicode strings
                    // Because of ligature substitutions and the like, there may be one or more
                    // unicode characters represented by each glyph.
                  }, {
                    key: "toUnicodeCmap",
                    value: function toUnicodeCmap() {
                      var cmap = this.document.ref();
                      var entries = [];
                      var _iterator = _createForOfIteratorHelper(this.unicode), _step;
                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                          var codePoints = _step.value;
                          var encoded = [];
                          var _iterator2 = _createForOfIteratorHelper(codePoints), _step2;
                          try {
                            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                              var value = _step2.value;
                              if (value > 65535) {
                                value -= 65536;
                                encoded.push(toHex(value >>> 10 & 1023 | 55296));
                                value = 56320 | value & 1023;
                              }
                              encoded.push(toHex(value));
                            }
                          } catch (err) {
                            _iterator2.e(err);
                          } finally {
                            _iterator2.f();
                          }
                          entries.push("<".concat(encoded.join(" "), ">"));
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }
                      cmap.end("/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange\n1 beginbfrange\n<0000> <".concat(toHex(entries.length - 1), "> [").concat(entries.join(" "), "]\nendbfrange\nendcmap\nCMapName currentdict /CMap defineresource pop\nend\nend"));
                      return cmap;
                    }
                  }]);
                  return EmbeddedFont2;
                }(PDFFont);
                var PDFFontFactory = function() {
                  function PDFFontFactory2() {
                    _classCallCheck(this, PDFFontFactory2);
                  }
                  _createClass(PDFFontFactory2, null, [{
                    key: "open",
                    value: function open2(document2, src, family, id) {
                      var font;
                      if (typeof src === "string") {
                        if (StandardFont.isStandardFont(src)) {
                          return new StandardFont(document2, src, id);
                        }
                        src = fs.readFileSync(src);
                      }
                      if (Buffer.isBuffer(src)) {
                        font = _fontkit.default.create(src, family);
                      } else if (src instanceof Uint8Array) {
                        font = _fontkit.default.create(Buffer.from(src), family);
                      } else if (src instanceof ArrayBuffer) {
                        font = _fontkit.default.create(Buffer.from(new Uint8Array(src)), family);
                      }
                      if (font == null) {
                        throw new Error("Not a supported font format or standard PDF font.");
                      }
                      return new EmbeddedFont(document2, font, id);
                    }
                  }]);
                  return PDFFontFactory2;
                }();
                var FontsMixin = {
                  initFonts: function initFonts() {
                    var defaultFont = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "Helvetica";
                    this._fontFamilies = {};
                    this._fontCount = 0;
                    this._fontSize = 12;
                    this._font = null;
                    this._registeredFonts = {};
                    if (defaultFont) {
                      this.font(defaultFont);
                    }
                  },
                  font: function font(src, family, size) {
                    var cacheKey, font2;
                    if (typeof family === "number") {
                      size = family;
                      family = null;
                    }
                    if (typeof src === "string" && this._registeredFonts[src]) {
                      cacheKey = src;
                      var _this$_registeredFont = this._registeredFonts[src];
                      src = _this$_registeredFont.src;
                      family = _this$_registeredFont.family;
                    } else {
                      cacheKey = family || src;
                      if (typeof cacheKey !== "string") {
                        cacheKey = null;
                      }
                    }
                    if (size != null) {
                      this.fontSize(size);
                    }
                    if (font2 = this._fontFamilies[cacheKey]) {
                      this._font = font2;
                      return this;
                    }
                    var id = "F".concat(++this._fontCount);
                    this._font = PDFFontFactory.open(this, src, family, id);
                    if (font2 = this._fontFamilies[this._font.name]) {
                      this._font = font2;
                      return this;
                    }
                    if (cacheKey) {
                      this._fontFamilies[cacheKey] = this._font;
                    }
                    if (this._font.name) {
                      this._fontFamilies[this._font.name] = this._font;
                    }
                    return this;
                  },
                  fontSize: function fontSize(_fontSize) {
                    this._fontSize = _fontSize;
                    return this;
                  },
                  currentLineHeight: function currentLineHeight(includeGap) {
                    if (includeGap == null) {
                      includeGap = false;
                    }
                    return this._font.lineHeight(this._fontSize, includeGap);
                  },
                  registerFont: function registerFont(name, src, family) {
                    this._registeredFonts[name] = {
                      src,
                      family
                    };
                    return this;
                  }
                };
                var LineWrapper = function(_EventEmitter) {
                  _inherits(LineWrapper2, _EventEmitter);
                  var _super = _createSuper(LineWrapper2);
                  function LineWrapper2(document2, options) {
                    var _this;
                    _classCallCheck(this, LineWrapper2);
                    _this = _super.call(this);
                    _this.document = document2;
                    _this.indent = options.indent || 0;
                    _this.characterSpacing = options.characterSpacing || 0;
                    _this.wordSpacing = options.wordSpacing === 0;
                    _this.columns = options.columns || 1;
                    _this.columnGap = options.columnGap != null ? options.columnGap : 18;
                    _this.lineWidth = (options.width - _this.columnGap * (_this.columns - 1)) / _this.columns;
                    _this.spaceLeft = _this.lineWidth;
                    _this.startX = _this.document.x;
                    _this.startY = _this.document.y;
                    _this.column = 1;
                    _this.ellipsis = options.ellipsis;
                    _this.continuedX = 0;
                    _this.features = options.features;
                    if (options.height != null) {
                      _this.height = options.height;
                      _this.maxY = _this.startY + options.height;
                    } else {
                      _this.maxY = _this.document.page.maxY();
                    }
                    _this.on("firstLine", function(options2) {
                      var indent = _this.continuedX || _this.indent;
                      _this.document.x += indent;
                      _this.lineWidth -= indent;
                      return _this.once("line", function() {
                        _this.document.x -= indent;
                        _this.lineWidth += indent;
                        if (options2.continued && !_this.continuedX) {
                          _this.continuedX = _this.indent;
                        }
                        if (!options2.continued) {
                          return _this.continuedX = 0;
                        }
                      });
                    });
                    _this.on("lastLine", function(options2) {
                      var align = options2.align;
                      if (align === "justify") {
                        options2.align = "left";
                      }
                      _this.lastLine = true;
                      return _this.once("line", function() {
                        _this.document.y += options2.paragraphGap || 0;
                        options2.align = align;
                        return _this.lastLine = false;
                      });
                    });
                    return _this;
                  }
                  _createClass(LineWrapper2, [{
                    key: "wordWidth",
                    value: function wordWidth(word) {
                      return this.document.widthOfString(word, this) + this.characterSpacing + this.wordSpacing;
                    }
                  }, {
                    key: "eachWord",
                    value: function eachWord(text, fn) {
                      var bk;
                      var breaker = new _linebreak.default(text);
                      var last2 = null;
                      var wordWidths = /* @__PURE__ */ Object.create(null);
                      while (bk = breaker.nextBreak()) {
                        var shouldContinue;
                        var word = text.slice((last2 != null ? last2.position : void 0) || 0, bk.position);
                        var w = wordWidths[word] != null ? wordWidths[word] : wordWidths[word] = this.wordWidth(word);
                        if (w > this.lineWidth + this.continuedX) {
                          var lbk = last2;
                          var fbk = {};
                          while (word.length) {
                            var l, mightGrow;
                            if (w > this.spaceLeft) {
                              l = Math.ceil(this.spaceLeft / (w / word.length));
                              w = this.wordWidth(word.slice(0, l));
                              mightGrow = w <= this.spaceLeft && l < word.length;
                            } else {
                              l = word.length;
                            }
                            var mustShrink = w > this.spaceLeft && l > 0;
                            while (mustShrink || mightGrow) {
                              if (mustShrink) {
                                w = this.wordWidth(word.slice(0, --l));
                                mustShrink = w > this.spaceLeft && l > 0;
                              } else {
                                w = this.wordWidth(word.slice(0, ++l));
                                mustShrink = w > this.spaceLeft && l > 0;
                                mightGrow = w <= this.spaceLeft && l < word.length;
                              }
                            }
                            if (l === 0 && this.spaceLeft === this.lineWidth) {
                              l = 1;
                            }
                            fbk.required = bk.required || l < word.length;
                            shouldContinue = fn(word.slice(0, l), w, fbk, lbk);
                            lbk = {
                              required: false
                            };
                            word = word.slice(l);
                            w = this.wordWidth(word);
                            if (shouldContinue === false) {
                              break;
                            }
                          }
                        } else {
                          shouldContinue = fn(word, w, bk, last2);
                        }
                        if (shouldContinue === false) {
                          break;
                        }
                        last2 = bk;
                      }
                    }
                  }, {
                    key: "wrap",
                    value: function wrap(text, options) {
                      var _this2 = this;
                      if (options.indent != null) {
                        this.indent = options.indent;
                      }
                      if (options.characterSpacing != null) {
                        this.characterSpacing = options.characterSpacing;
                      }
                      if (options.wordSpacing != null) {
                        this.wordSpacing = options.wordSpacing;
                      }
                      if (options.ellipsis != null) {
                        this.ellipsis = options.ellipsis;
                      }
                      var nextY = this.document.y + this.document.currentLineHeight(true);
                      if (this.document.y > this.maxY || nextY > this.maxY) {
                        this.nextSection();
                      }
                      var buffer = "";
                      var textWidth = 0;
                      var wc = 0;
                      var lc = 0;
                      var y = this.document.y;
                      var emitLine = function emitLine2() {
                        options.textWidth = textWidth + _this2.wordSpacing * (wc - 1);
                        options.wordCount = wc;
                        options.lineWidth = _this2.lineWidth;
                        y = _this2.document.y;
                        _this2.emit("line", buffer, options, _this2);
                        return lc++;
                      };
                      this.emit("sectionStart", options, this);
                      this.eachWord(text, function(word, w, bk, last2) {
                        if (last2 == null || last2.required) {
                          _this2.emit("firstLine", options, _this2);
                          _this2.spaceLeft = _this2.lineWidth;
                        }
                        if (w <= _this2.spaceLeft) {
                          buffer += word;
                          textWidth += w;
                          wc++;
                        }
                        if (bk.required || w > _this2.spaceLeft) {
                          var lh = _this2.document.currentLineHeight(true);
                          if (_this2.height != null && _this2.ellipsis && _this2.document.y + lh * 2 > _this2.maxY && _this2.column >= _this2.columns) {
                            if (_this2.ellipsis === true) {
                              _this2.ellipsis = "";
                            }
                            buffer = buffer.replace(/\s+$/, "");
                            textWidth = _this2.wordWidth(buffer + _this2.ellipsis);
                            while (buffer && textWidth > _this2.lineWidth) {
                              buffer = buffer.slice(0, -1).replace(/\s+$/, "");
                              textWidth = _this2.wordWidth(buffer + _this2.ellipsis);
                            }
                            if (textWidth <= _this2.lineWidth) {
                              buffer = buffer + _this2.ellipsis;
                            }
                            textWidth = _this2.wordWidth(buffer);
                          }
                          if (bk.required) {
                            if (w > _this2.spaceLeft) {
                              emitLine();
                              buffer = word;
                              textWidth = w;
                              wc = 1;
                            }
                            _this2.emit("lastLine", options, _this2);
                          }
                          emitLine();
                          if (_this2.document.y + lh > _this2.maxY) {
                            var shouldContinue = _this2.nextSection();
                            if (!shouldContinue) {
                              wc = 0;
                              buffer = "";
                              return false;
                            }
                          }
                          if (bk.required) {
                            _this2.spaceLeft = _this2.lineWidth;
                            buffer = "";
                            textWidth = 0;
                            return wc = 0;
                          } else {
                            _this2.spaceLeft = _this2.lineWidth - w;
                            buffer = word;
                            textWidth = w;
                            return wc = 1;
                          }
                        } else {
                          return _this2.spaceLeft -= w;
                        }
                      });
                      if (wc > 0) {
                        this.emit("lastLine", options, this);
                        emitLine();
                      }
                      this.emit("sectionEnd", options, this);
                      if (options.continued === true) {
                        if (lc > 1) {
                          this.continuedX = 0;
                        }
                        this.continuedX += options.textWidth || 0;
                        return this.document.y = y;
                      } else {
                        return this.document.x = this.startX;
                      }
                    }
                  }, {
                    key: "nextSection",
                    value: function nextSection(options) {
                      this.emit("sectionEnd", options, this);
                      if (++this.column > this.columns) {
                        if (this.height != null) {
                          return false;
                        }
                        this.document.continueOnNewPage();
                        this.column = 1;
                        this.startY = this.document.page.margins.top;
                        this.maxY = this.document.page.maxY();
                        this.document.x = this.startX;
                        if (this.document._fillColor) {
                          var _this$document;
                          (_this$document = this.document).fillColor.apply(_this$document, _toConsumableArray(this.document._fillColor));
                        }
                        this.emit("pageBreak", options, this);
                      } else {
                        this.document.x += this.lineWidth + this.columnGap;
                        this.document.y = this.startY;
                        this.emit("columnBreak", options, this);
                      }
                      this.emit("sectionStart", options, this);
                      return true;
                    }
                  }]);
                  return LineWrapper2;
                }(_events.EventEmitter);
                var number$2 = PDFObject.number;
                var TextMixin = {
                  initText: function initText() {
                    this._line = this._line.bind(this);
                    this.x = 0;
                    this.y = 0;
                    return this._lineGap = 0;
                  },
                  lineGap: function lineGap(_lineGap) {
                    this._lineGap = _lineGap;
                    return this;
                  },
                  moveDown: function moveDown(lines) {
                    if (lines == null) {
                      lines = 1;
                    }
                    this.y += this.currentLineHeight(true) * lines + this._lineGap;
                    return this;
                  },
                  moveUp: function moveUp(lines) {
                    if (lines == null) {
                      lines = 1;
                    }
                    this.y -= this.currentLineHeight(true) * lines + this._lineGap;
                    return this;
                  },
                  _text: function _text(text, x, y, options, lineCallback) {
                    var _this = this;
                    options = this._initOptions(x, y, options);
                    text = text == null ? "" : "".concat(text);
                    if (options.wordSpacing) {
                      text = text.replace(/\s{2,}/g, " ");
                    }
                    var addStructure = function addStructure2() {
                      if (options.structParent) {
                        options.structParent.add(_this.struct(options.structType || "P", [_this.markStructureContent(options.structType || "P")]));
                      }
                    };
                    if (options.width) {
                      var wrapper = this._wrapper;
                      if (!wrapper) {
                        wrapper = new LineWrapper(this, options);
                        wrapper.on("line", lineCallback);
                        wrapper.on("firstLine", addStructure);
                      }
                      this._wrapper = options.continued ? wrapper : null;
                      this._textOptions = options.continued ? options : null;
                      wrapper.wrap(text, options);
                    } else {
                      var _iterator = _createForOfIteratorHelper(text.split("\n")), _step;
                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                          var line = _step.value;
                          addStructure();
                          lineCallback(line, options);
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }
                    }
                    return this;
                  },
                  text: function text(_text2, x, y, options) {
                    return this._text(_text2, x, y, options, this._line);
                  },
                  widthOfString: function widthOfString(string) {
                    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                    return this._font.widthOfString(string, this._fontSize, options.features) + (options.characterSpacing || 0) * (string.length - 1);
                  },
                  heightOfString: function heightOfString(text, options) {
                    var _this2 = this;
                    var x = this.x, y = this.y;
                    options = this._initOptions(options);
                    options.height = Infinity;
                    var lineGap = options.lineGap || this._lineGap || 0;
                    this._text(text, this.x, this.y, options, function() {
                      return _this2.y += _this2.currentLineHeight(true) + lineGap;
                    });
                    var height = this.y - y;
                    this.x = x;
                    this.y = y;
                    return height;
                  },
                  list: function list(_list, x, y, options, wrapper) {
                    var _this3 = this;
                    options = this._initOptions(x, y, options);
                    var listType = options.listType || "bullet";
                    var unit = Math.round(this._font.ascender / 1e3 * this._fontSize);
                    var midLine = unit / 2;
                    var r = options.bulletRadius || unit / 3;
                    var indent = options.textIndent || (listType === "bullet" ? r * 5 : unit * 2);
                    var itemIndent = options.bulletIndent || (listType === "bullet" ? r * 8 : unit * 2);
                    var level = 1;
                    var items = [];
                    var levels = [];
                    var numbers = [];
                    var flatten = function flatten2(list2) {
                      var n = 1;
                      for (var _i = 0; _i < list2.length; _i++) {
                        var item = list2[_i];
                        if (Array.isArray(item)) {
                          level++;
                          flatten2(item);
                          level--;
                        } else {
                          items.push(item);
                          levels.push(level);
                          if (listType !== "bullet") {
                            numbers.push(n++);
                          }
                        }
                      }
                    };
                    flatten(_list);
                    var label = function label2(n) {
                      switch (listType) {
                        case "numbered":
                          return "".concat(n, ".");
                        case "lettered":
                          var letter = String.fromCharCode((n - 1) % 26 + 65);
                          var times = Math.floor((n - 1) / 26 + 1);
                          var text = Array(times + 1).join(letter);
                          return "".concat(text, ".");
                      }
                    };
                    wrapper = new LineWrapper(this, options);
                    wrapper.on("line", this._line);
                    level = 1;
                    var i = 0;
                    wrapper.on("firstLine", function() {
                      var item, itemType, labelType, bodyType;
                      if (options.structParent) {
                        if (options.structTypes) {
                          var _options$structTypes = _slicedToArray(options.structTypes, 3);
                          itemType = _options$structTypes[0];
                          labelType = _options$structTypes[1];
                          bodyType = _options$structTypes[2];
                        } else {
                          itemType = "LI";
                          labelType = "Lbl";
                          bodyType = "LBody";
                        }
                      }
                      if (itemType) {
                        item = _this3.struct(itemType);
                        options.structParent.add(item);
                      } else if (options.structParent) {
                        item = options.structParent;
                      }
                      var l;
                      if ((l = levels[i++]) !== level) {
                        var diff = itemIndent * (l - level);
                        _this3.x += diff;
                        wrapper.lineWidth -= diff;
                        level = l;
                      }
                      if (item && (labelType || bodyType)) {
                        item.add(_this3.struct(labelType || bodyType, [_this3.markStructureContent(labelType || bodyType)]));
                      }
                      switch (listType) {
                        case "bullet":
                          _this3.circle(_this3.x - indent + r, _this3.y + midLine, r);
                          _this3.fill();
                          break;
                        case "numbered":
                        case "lettered":
                          var text = label(numbers[i - 1]);
                          _this3._fragment(text, _this3.x - indent, _this3.y, options);
                          break;
                      }
                      if (item && labelType && bodyType) {
                        item.add(_this3.struct(bodyType, [_this3.markStructureContent(bodyType)]));
                      }
                      if (item && item !== options.structParent) {
                        item.end();
                      }
                    });
                    wrapper.on("sectionStart", function() {
                      var pos = indent + itemIndent * (level - 1);
                      _this3.x += pos;
                      return wrapper.lineWidth -= pos;
                    });
                    wrapper.on("sectionEnd", function() {
                      var pos = indent + itemIndent * (level - 1);
                      _this3.x -= pos;
                      return wrapper.lineWidth += pos;
                    });
                    wrapper.wrap(items.join("\n"), options);
                    return this;
                  },
                  _initOptions: function _initOptions() {
                    var x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    var y = arguments.length > 1 ? arguments[1] : void 0;
                    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                    if (typeof x === "object") {
                      options = x;
                      x = null;
                    }
                    var result = Object.assign({}, options);
                    if (this._textOptions) {
                      for (var key in this._textOptions) {
                        var val = this._textOptions[key];
                        if (key !== "continued") {
                          if (result[key] === void 0) {
                            result[key] = val;
                          }
                        }
                      }
                    }
                    if (x != null) {
                      this.x = x;
                    }
                    if (y != null) {
                      this.y = y;
                    }
                    if (result.lineBreak !== false) {
                      if (result.width == null) {
                        result.width = this.page.width - this.x - this.page.margins.right;
                      }
                      result.width = Math.max(result.width, 0);
                    }
                    if (!result.columns) {
                      result.columns = 0;
                    }
                    if (result.columnGap == null) {
                      result.columnGap = 18;
                    }
                    return result;
                  },
                  _line: function _line(text) {
                    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                    var wrapper = arguments.length > 2 ? arguments[2] : void 0;
                    this._fragment(text, this.x, this.y, options);
                    var lineGap = options.lineGap || this._lineGap || 0;
                    if (!wrapper) {
                      return this.x += this.widthOfString(text);
                    } else {
                      return this.y += this.currentLineHeight(true) + lineGap;
                    }
                  },
                  _fragment: function _fragment(text, x, y, options) {
                    var _this4 = this;
                    var dy, encoded, i, positions, textWidth, words;
                    text = "".concat(text).replace(/\n/g, "");
                    if (text.length === 0) {
                      return;
                    }
                    var align = options.align || "left";
                    var wordSpacing = options.wordSpacing || 0;
                    var characterSpacing = options.characterSpacing || 0;
                    if (options.width) {
                      switch (align) {
                        case "right":
                          textWidth = this.widthOfString(text.replace(/\s+$/, ""), options);
                          x += options.lineWidth - textWidth;
                          break;
                        case "center":
                          x += options.lineWidth / 2 - options.textWidth / 2;
                          break;
                        case "justify":
                          words = text.trim().split(/\s+/);
                          textWidth = this.widthOfString(text.replace(/\s+/g, ""), options);
                          var spaceWidth = this.widthOfString(" ") + characterSpacing;
                          wordSpacing = Math.max(0, (options.lineWidth - textWidth) / Math.max(1, words.length - 1) - spaceWidth);
                          break;
                      }
                    }
                    if (typeof options.baseline === "number") {
                      dy = -options.baseline;
                    } else {
                      switch (options.baseline) {
                        case "svg-middle":
                          dy = 0.5 * this._font.xHeight;
                          break;
                        case "middle":
                        case "svg-central":
                          dy = 0.5 * (this._font.descender + this._font.ascender);
                          break;
                        case "bottom":
                        case "ideographic":
                          dy = this._font.descender;
                          break;
                        case "alphabetic":
                          dy = 0;
                          break;
                        case "mathematical":
                          dy = 0.5 * this._font.ascender;
                          break;
                        case "hanging":
                          dy = 0.8 * this._font.ascender;
                          break;
                        case "top":
                          dy = this._font.ascender;
                          break;
                        default:
                          dy = this._font.ascender;
                      }
                      dy = dy / 1e3 * this._fontSize;
                    }
                    var renderedWidth = options.textWidth + wordSpacing * (options.wordCount - 1) + characterSpacing * (text.length - 1);
                    if (options.link != null) {
                      this.link(x, y, renderedWidth, this.currentLineHeight(), options.link);
                    }
                    if (options.goTo != null) {
                      this.goTo(x, y, renderedWidth, this.currentLineHeight(), options.goTo);
                    }
                    if (options.destination != null) {
                      this.addNamedDestination(options.destination, "XYZ", x, y, null);
                    }
                    if (options.underline) {
                      this.save();
                      if (!options.stroke) {
                        this.strokeColor.apply(this, _toConsumableArray(this._fillColor || []));
                      }
                      var lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);
                      this.lineWidth(lineWidth);
                      var lineY = y + this.currentLineHeight() - lineWidth;
                      this.moveTo(x, lineY);
                      this.lineTo(x + renderedWidth, lineY);
                      this.stroke();
                      this.restore();
                    }
                    if (options.strike) {
                      this.save();
                      if (!options.stroke) {
                        this.strokeColor.apply(this, _toConsumableArray(this._fillColor || []));
                      }
                      var _lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);
                      this.lineWidth(_lineWidth);
                      var _lineY = y + this.currentLineHeight() / 2;
                      this.moveTo(x, _lineY);
                      this.lineTo(x + renderedWidth, _lineY);
                      this.stroke();
                      this.restore();
                    }
                    this.save();
                    if (options.oblique) {
                      var skew;
                      if (typeof options.oblique === "number") {
                        skew = -Math.tan(options.oblique * Math.PI / 180);
                      } else {
                        skew = -0.25;
                      }
                      this.transform(1, 0, 0, 1, x, y);
                      this.transform(1, 0, skew, 1, -skew * dy, 0);
                      this.transform(1, 0, 0, 1, -x, -y);
                    }
                    this.transform(1, 0, 0, -1, 0, this.page.height);
                    y = this.page.height - y - dy;
                    if (this.page.fonts[this._font.id] == null) {
                      this.page.fonts[this._font.id] = this._font.ref();
                    }
                    this.addContent("BT");
                    this.addContent("1 0 0 1 ".concat(number$2(x), " ").concat(number$2(y), " Tm"));
                    this.addContent("/".concat(this._font.id, " ").concat(number$2(this._fontSize), " Tf"));
                    var mode = options.fill && options.stroke ? 2 : options.stroke ? 1 : 0;
                    if (mode) {
                      this.addContent("".concat(mode, " Tr"));
                    }
                    if (characterSpacing) {
                      this.addContent("".concat(number$2(characterSpacing), " Tc"));
                    }
                    if (wordSpacing) {
                      words = text.trim().split(/\s+/);
                      wordSpacing += this.widthOfString(" ") + characterSpacing;
                      wordSpacing *= 1e3 / this._fontSize;
                      encoded = [];
                      positions = [];
                      var _iterator2 = _createForOfIteratorHelper(words), _step2;
                      try {
                        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                          var word = _step2.value;
                          var _this$_font$encode = this._font.encode(word, options.features), _this$_font$encode2 = _slicedToArray(_this$_font$encode, 2), encodedWord = _this$_font$encode2[0], positionsWord = _this$_font$encode2[1];
                          encoded = encoded.concat(encodedWord);
                          positions = positions.concat(positionsWord);
                          var space = {};
                          var object = positions[positions.length - 1];
                          for (var key in object) {
                            var val = object[key];
                            space[key] = val;
                          }
                          space.xAdvance += wordSpacing;
                          positions[positions.length - 1] = space;
                        }
                      } catch (err) {
                        _iterator2.e(err);
                      } finally {
                        _iterator2.f();
                      }
                    } else {
                      var _this$_font$encode3 = this._font.encode(text, options.features);
                      var _this$_font$encode4 = _slicedToArray(_this$_font$encode3, 2);
                      encoded = _this$_font$encode4[0];
                      positions = _this$_font$encode4[1];
                    }
                    var scale = this._fontSize / 1e3;
                    var commands = [];
                    var last2 = 0;
                    var hadOffset = false;
                    var addSegment = function addSegment2(cur) {
                      if (last2 < cur) {
                        var hex = encoded.slice(last2, cur).join("");
                        var advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;
                        commands.push("<".concat(hex, "> ").concat(number$2(-advance)));
                      }
                      return last2 = cur;
                    };
                    var flush = function flush2(i2) {
                      addSegment(i2);
                      if (commands.length > 0) {
                        _this4.addContent("[".concat(commands.join(" "), "] TJ"));
                        return commands.length = 0;
                      }
                    };
                    for (i = 0; i < positions.length; i++) {
                      var pos = positions[i];
                      if (pos.xOffset || pos.yOffset) {
                        flush(i);
                        this.addContent("1 0 0 1 ".concat(number$2(x + pos.xOffset * scale), " ").concat(number$2(y + pos.yOffset * scale), " Tm"));
                        flush(i + 1);
                        hadOffset = true;
                      } else {
                        if (hadOffset) {
                          this.addContent("1 0 0 1 ".concat(number$2(x), " ").concat(number$2(y), " Tm"));
                          hadOffset = false;
                        }
                        if (pos.xAdvance - pos.advanceWidth !== 0) {
                          addSegment(i + 1);
                        }
                      }
                      x += pos.xAdvance * scale;
                    }
                    flush(i);
                    this.addContent("ET");
                    return this.restore();
                  }
                };
                var MARKERS = [65472, 65473, 65474, 65475, 65477, 65478, 65479, 65480, 65481, 65482, 65483, 65484, 65485, 65486, 65487];
                var COLOR_SPACE_MAP = {
                  1: "DeviceGray",
                  3: "DeviceRGB",
                  4: "DeviceCMYK"
                };
                var JPEG = function() {
                  function JPEG2(data, label) {
                    _classCallCheck(this, JPEG2);
                    var marker;
                    this.data = data;
                    this.label = label;
                    if (this.data.readUInt16BE(0) !== 65496) {
                      throw "SOI not found in JPEG";
                    }
                    var pos = 2;
                    while (pos < this.data.length) {
                      marker = this.data.readUInt16BE(pos);
                      pos += 2;
                      if (MARKERS.includes(marker)) {
                        break;
                      }
                      pos += this.data.readUInt16BE(pos);
                    }
                    if (!MARKERS.includes(marker)) {
                      throw "Invalid JPEG.";
                    }
                    pos += 2;
                    this.bits = this.data[pos++];
                    this.height = this.data.readUInt16BE(pos);
                    pos += 2;
                    this.width = this.data.readUInt16BE(pos);
                    pos += 2;
                    var channels = this.data[pos++];
                    this.colorSpace = COLOR_SPACE_MAP[channels];
                    this.obj = null;
                  }
                  _createClass(JPEG2, [{
                    key: "embed",
                    value: function embed(document2) {
                      if (this.obj) {
                        return;
                      }
                      this.obj = document2.ref({
                        Type: "XObject",
                        Subtype: "Image",
                        BitsPerComponent: this.bits,
                        Width: this.width,
                        Height: this.height,
                        ColorSpace: this.colorSpace,
                        Filter: "DCTDecode"
                      });
                      if (this.colorSpace === "DeviceCMYK") {
                        this.obj.data["Decode"] = [1, 0, 1, 0, 1, 0, 1, 0];
                      }
                      this.obj.end(this.data);
                      return this.data = null;
                    }
                  }]);
                  return JPEG2;
                }();
                var PNGImage = function() {
                  function PNGImage2(data, label) {
                    _classCallCheck(this, PNGImage2);
                    this.label = label;
                    this.image = new _pngJs.default(data);
                    this.width = this.image.width;
                    this.height = this.image.height;
                    this.imgData = this.image.imgData;
                    this.obj = null;
                  }
                  _createClass(PNGImage2, [{
                    key: "embed",
                    value: function embed(document2) {
                      var dataDecoded = false;
                      this.document = document2;
                      if (this.obj) {
                        return;
                      }
                      var hasAlphaChannel = this.image.hasAlphaChannel;
                      var isInterlaced = this.image.interlaceMethod === 1;
                      this.obj = this.document.ref({
                        Type: "XObject",
                        Subtype: "Image",
                        BitsPerComponent: hasAlphaChannel ? 8 : this.image.bits,
                        Width: this.width,
                        Height: this.height,
                        Filter: "FlateDecode"
                      });
                      if (!hasAlphaChannel) {
                        var params = this.document.ref({
                          Predictor: isInterlaced ? 1 : 15,
                          Colors: this.image.colors,
                          BitsPerComponent: this.image.bits,
                          Columns: this.width
                        });
                        this.obj.data["DecodeParms"] = params;
                        params.end();
                      }
                      if (this.image.palette.length === 0) {
                        this.obj.data["ColorSpace"] = this.image.colorSpace;
                      } else {
                        var palette = this.document.ref();
                        palette.end(Buffer.from(this.image.palette));
                        this.obj.data["ColorSpace"] = ["Indexed", "DeviceRGB", this.image.palette.length / 3 - 1, palette];
                      }
                      if (this.image.transparency.grayscale != null) {
                        var val = this.image.transparency.grayscale;
                        this.obj.data["Mask"] = [val, val];
                      } else if (this.image.transparency.rgb) {
                        var rgb = this.image.transparency.rgb;
                        var mask = [];
                        var _iterator = _createForOfIteratorHelper(rgb), _step;
                        try {
                          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                            var x = _step.value;
                            mask.push(x, x);
                          }
                        } catch (err) {
                          _iterator.e(err);
                        } finally {
                          _iterator.f();
                        }
                        this.obj.data["Mask"] = mask;
                      } else if (this.image.transparency.indexed) {
                        dataDecoded = true;
                        return this.loadIndexedAlphaChannel();
                      } else if (hasAlphaChannel) {
                        dataDecoded = true;
                        return this.splitAlphaChannel();
                      }
                      if (isInterlaced && !dataDecoded) {
                        return this.decodeData();
                      }
                      this.finalize();
                    }
                  }, {
                    key: "finalize",
                    value: function finalize() {
                      if (this.alphaChannel) {
                        var sMask = this.document.ref({
                          Type: "XObject",
                          Subtype: "Image",
                          Height: this.height,
                          Width: this.width,
                          BitsPerComponent: 8,
                          Filter: "FlateDecode",
                          ColorSpace: "DeviceGray",
                          Decode: [0, 1]
                        });
                        sMask.end(this.alphaChannel);
                        this.obj.data["SMask"] = sMask;
                      }
                      this.obj.end(this.imgData);
                      this.image = null;
                      return this.imgData = null;
                    }
                  }, {
                    key: "splitAlphaChannel",
                    value: function splitAlphaChannel() {
                      var _this = this;
                      return this.image.decodePixels(function(pixels) {
                        var a, p;
                        var colorCount = _this.image.colors;
                        var pixelCount = _this.width * _this.height;
                        var imgData = Buffer.alloc(pixelCount * colorCount);
                        var alphaChannel = Buffer.alloc(pixelCount);
                        var i = p = a = 0;
                        var len = pixels.length;
                        var skipByteCount = _this.image.bits === 16 ? 1 : 0;
                        while (i < len) {
                          for (var colorIndex = 0; colorIndex < colorCount; colorIndex++) {
                            imgData[p++] = pixels[i++];
                            i += skipByteCount;
                          }
                          alphaChannel[a++] = pixels[i++];
                          i += skipByteCount;
                        }
                        _this.imgData = _zlib.default.deflateSync(imgData);
                        _this.alphaChannel = _zlib.default.deflateSync(alphaChannel);
                        return _this.finalize();
                      });
                    }
                  }, {
                    key: "loadIndexedAlphaChannel",
                    value: function loadIndexedAlphaChannel() {
                      var _this2 = this;
                      var transparency = this.image.transparency.indexed;
                      return this.image.decodePixels(function(pixels) {
                        var alphaChannel = Buffer.alloc(_this2.width * _this2.height);
                        var i = 0;
                        for (var j = 0, end = pixels.length; j < end; j++) {
                          alphaChannel[i++] = transparency[pixels[j]];
                        }
                        _this2.alphaChannel = _zlib.default.deflateSync(alphaChannel);
                        return _this2.finalize();
                      });
                    }
                  }, {
                    key: "decodeData",
                    value: function decodeData() {
                      var _this3 = this;
                      this.image.decodePixels(function(pixels) {
                        _this3.imgData = _zlib.default.deflateSync(pixels);
                        _this3.finalize();
                      });
                    }
                  }]);
                  return PNGImage2;
                }();
                var PDFImage = function() {
                  function PDFImage2() {
                    _classCallCheck(this, PDFImage2);
                  }
                  _createClass(PDFImage2, null, [{
                    key: "open",
                    value: function open2(src, label) {
                      var data;
                      if (Buffer.isBuffer(src)) {
                        data = src;
                      } else if (src instanceof ArrayBuffer) {
                        data = Buffer.from(new Uint8Array(src));
                      } else {
                        var match;
                        if (match = /^data:.+;base64,(.*)$/.exec(src)) {
                          data = Buffer.from(match[1], "base64");
                        } else {
                          data = fs.readFileSync(src);
                          if (!data) {
                            return;
                          }
                        }
                      }
                      if (data[0] === 255 && data[1] === 216) {
                        return new JPEG(data, label);
                      } else if (data[0] === 137 && data.toString("ascii", 1, 4) === "PNG") {
                        return new PNGImage(data, label);
                      } else {
                        throw new Error("Unknown image format.");
                      }
                    }
                  }]);
                  return PDFImage2;
                }();
                var ImagesMixin = {
                  initImages: function initImages() {
                    this._imageRegistry = {};
                    return this._imageCount = 0;
                  },
                  image: function image(src, x, y) {
                    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
                    var bh, bp, bw, image2, ip, left, left1;
                    if (typeof x === "object") {
                      options = x;
                      x = null;
                    }
                    x = (left = x != null ? x : options.x) != null ? left : this.x;
                    y = (left1 = y != null ? y : options.y) != null ? left1 : this.y;
                    if (typeof src === "string") {
                      image2 = this._imageRegistry[src];
                    }
                    if (!image2) {
                      if (src.width && src.height) {
                        image2 = src;
                      } else {
                        image2 = this.openImage(src);
                      }
                    }
                    if (!image2.obj) {
                      image2.embed(this);
                    }
                    if (this.page.xobjects[image2.label] == null) {
                      this.page.xobjects[image2.label] = image2.obj;
                    }
                    var w = options.width || image2.width;
                    var h = options.height || image2.height;
                    if (options.width && !options.height) {
                      var wp = w / image2.width;
                      w = image2.width * wp;
                      h = image2.height * wp;
                    } else if (options.height && !options.width) {
                      var hp = h / image2.height;
                      w = image2.width * hp;
                      h = image2.height * hp;
                    } else if (options.scale) {
                      w = image2.width * options.scale;
                      h = image2.height * options.scale;
                    } else if (options.fit) {
                      var _options$fit = _slicedToArray(options.fit, 2);
                      bw = _options$fit[0];
                      bh = _options$fit[1];
                      bp = bw / bh;
                      ip = image2.width / image2.height;
                      if (ip > bp) {
                        w = bw;
                        h = bw / ip;
                      } else {
                        h = bh;
                        w = bh * ip;
                      }
                    } else if (options.cover) {
                      var _options$cover = _slicedToArray(options.cover, 2);
                      bw = _options$cover[0];
                      bh = _options$cover[1];
                      bp = bw / bh;
                      ip = image2.width / image2.height;
                      if (ip > bp) {
                        h = bh;
                        w = bh * ip;
                      } else {
                        w = bw;
                        h = bw / ip;
                      }
                    }
                    if (options.fit || options.cover) {
                      if (options.align === "center") {
                        x = x + bw / 2 - w / 2;
                      } else if (options.align === "right") {
                        x = x + bw - w;
                      }
                      if (options.valign === "center") {
                        y = y + bh / 2 - h / 2;
                      } else if (options.valign === "bottom") {
                        y = y + bh - h;
                      }
                    }
                    if (options.link != null) {
                      this.link(x, y, w, h, options.link);
                    }
                    if (options.goTo != null) {
                      this.goTo(x, y, w, h, options.goTo);
                    }
                    if (options.destination != null) {
                      this.addNamedDestination(options.destination, "XYZ", x, y, null);
                    }
                    if (this.y === y) {
                      this.y += h;
                    }
                    this.save();
                    this.transform(w, 0, 0, -h, x, y + h);
                    this.addContent("/".concat(image2.label, " Do"));
                    this.restore();
                    return this;
                  },
                  openImage: function openImage(src) {
                    var image;
                    if (typeof src === "string") {
                      image = this._imageRegistry[src];
                    }
                    if (!image) {
                      image = PDFImage.open(src, "I".concat(++this._imageCount));
                      if (typeof src === "string") {
                        this._imageRegistry[src] = image;
                      }
                    }
                    return image;
                  }
                };
                var AnnotationsMixin = {
                  annotate: function annotate(x, y, w, h, options) {
                    options.Type = "Annot";
                    options.Rect = this._convertRect(x, y, w, h);
                    options.Border = [0, 0, 0];
                    if (options.Subtype === "Link" && typeof options.F === "undefined") {
                      options.F = 1 << 2;
                    }
                    if (options.Subtype !== "Link") {
                      if (options.C == null) {
                        options.C = this._normalizeColor(options.color || [0, 0, 0]);
                      }
                    }
                    delete options.color;
                    if (typeof options.Dest === "string") {
                      options.Dest = new String(options.Dest);
                    }
                    for (var key in options) {
                      var val = options[key];
                      options[key[0].toUpperCase() + key.slice(1)] = val;
                    }
                    var ref = this.ref(options);
                    this.page.annotations.push(ref);
                    ref.end();
                    return this;
                  },
                  note: function note(x, y, w, h, contents) {
                    var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                    options.Subtype = "Text";
                    options.Contents = new String(contents);
                    options.Name = "Comment";
                    if (options.color == null) {
                      options.color = [243, 223, 92];
                    }
                    return this.annotate(x, y, w, h, options);
                  },
                  goTo: function goTo(x, y, w, h, name) {
                    var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                    options.Subtype = "Link";
                    options.A = this.ref({
                      S: "GoTo",
                      D: new String(name)
                    });
                    options.A.end();
                    return this.annotate(x, y, w, h, options);
                  },
                  link: function link(x, y, w, h, url) {
                    var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                    options.Subtype = "Link";
                    if (typeof url === "number") {
                      var pages = this._root.data.Pages.data;
                      if (url >= 0 && url < pages.Kids.length) {
                        options.A = this.ref({
                          S: "GoTo",
                          D: [pages.Kids[url], "XYZ", null, null, null]
                        });
                        options.A.end();
                      } else {
                        throw new Error("The document has no page ".concat(url));
                      }
                    } else {
                      options.A = this.ref({
                        S: "URI",
                        URI: new String(url)
                      });
                      options.A.end();
                    }
                    return this.annotate(x, y, w, h, options);
                  },
                  _markup: function _markup(x, y, w, h) {
                    var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
                    var _this$_convertRect = this._convertRect(x, y, w, h), _this$_convertRect2 = _slicedToArray(_this$_convertRect, 4), x1 = _this$_convertRect2[0], y1 = _this$_convertRect2[1], x2 = _this$_convertRect2[2], y2 = _this$_convertRect2[3];
                    options.QuadPoints = [x1, y2, x2, y2, x1, y1, x2, y1];
                    options.Contents = new String();
                    return this.annotate(x, y, w, h, options);
                  },
                  highlight: function highlight(x, y, w, h) {
                    var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
                    options.Subtype = "Highlight";
                    if (options.color == null) {
                      options.color = [241, 238, 148];
                    }
                    return this._markup(x, y, w, h, options);
                  },
                  underline: function underline(x, y, w, h) {
                    var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
                    options.Subtype = "Underline";
                    return this._markup(x, y, w, h, options);
                  },
                  strike: function strike(x, y, w, h) {
                    var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
                    options.Subtype = "StrikeOut";
                    return this._markup(x, y, w, h, options);
                  },
                  lineAnnotation: function lineAnnotation(x1, y1, x2, y2) {
                    var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
                    options.Subtype = "Line";
                    options.Contents = new String();
                    options.L = [x1, this.page.height - y1, x2, this.page.height - y2];
                    return this.annotate(x1, y1, x2, y2, options);
                  },
                  rectAnnotation: function rectAnnotation(x, y, w, h) {
                    var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
                    options.Subtype = "Square";
                    options.Contents = new String();
                    return this.annotate(x, y, w, h, options);
                  },
                  ellipseAnnotation: function ellipseAnnotation(x, y, w, h) {
                    var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
                    options.Subtype = "Circle";
                    options.Contents = new String();
                    return this.annotate(x, y, w, h, options);
                  },
                  textAnnotation: function textAnnotation(x, y, w, h, text) {
                    var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                    options.Subtype = "FreeText";
                    options.Contents = new String(text);
                    options.DA = new String();
                    return this.annotate(x, y, w, h, options);
                  },
                  fileAnnotation: function fileAnnotation(x, y, w, h) {
                    var file = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
                    var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                    var filespec = this.file(file.src, Object.assign({
                      hidden: true
                    }, file));
                    options.Subtype = "FileAttachment";
                    options.FS = filespec;
                    if (options.Contents) {
                      options.Contents = new String(options.Contents);
                    } else if (filespec.data.Desc) {
                      options.Contents = filespec.data.Desc;
                    }
                    return this.annotate(x, y, w, h, options);
                  },
                  _convertRect: function _convertRect(x1, y1, w, h) {
                    var y2 = y1;
                    y1 += h;
                    var x2 = x1 + w;
                    var _this$_ctm = _slicedToArray(this._ctm, 6), m0 = _this$_ctm[0], m1 = _this$_ctm[1], m2 = _this$_ctm[2], m3 = _this$_ctm[3], m4 = _this$_ctm[4], m5 = _this$_ctm[5];
                    x1 = m0 * x1 + m2 * y1 + m4;
                    y1 = m1 * x1 + m3 * y1 + m5;
                    x2 = m0 * x2 + m2 * y2 + m4;
                    y2 = m1 * x2 + m3 * y2 + m5;
                    return [x1, y1, x2, y2];
                  }
                };
                var PDFOutline = function() {
                  function PDFOutline2(document2, parent, title, dest) {
                    var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
                      expanded: false
                    };
                    _classCallCheck(this, PDFOutline2);
                    this.document = document2;
                    this.options = options;
                    this.outlineData = {};
                    if (dest !== null) {
                      this.outlineData["Dest"] = [dest.dictionary, "Fit"];
                    }
                    if (parent !== null) {
                      this.outlineData["Parent"] = parent;
                    }
                    if (title !== null) {
                      this.outlineData["Title"] = new String(title);
                    }
                    this.dictionary = this.document.ref(this.outlineData);
                    this.children = [];
                  }
                  _createClass(PDFOutline2, [{
                    key: "addItem",
                    value: function addItem(title) {
                      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                        expanded: false
                      };
                      var result = new PDFOutline2(this.document, this.dictionary, title, this.document.page, options);
                      this.children.push(result);
                      return result;
                    }
                  }, {
                    key: "endOutline",
                    value: function endOutline() {
                      if (this.children.length > 0) {
                        if (this.options.expanded) {
                          this.outlineData.Count = this.children.length;
                        }
                        var first2 = this.children[0], last2 = this.children[this.children.length - 1];
                        this.outlineData.First = first2.dictionary;
                        this.outlineData.Last = last2.dictionary;
                        for (var i = 0, len = this.children.length; i < len; i++) {
                          var child = this.children[i];
                          if (i > 0) {
                            child.outlineData.Prev = this.children[i - 1].dictionary;
                          }
                          if (i < this.children.length - 1) {
                            child.outlineData.Next = this.children[i + 1].dictionary;
                          }
                          child.endOutline();
                        }
                      }
                      return this.dictionary.end();
                    }
                  }]);
                  return PDFOutline2;
                }();
                var OutlineMixin = {
                  initOutline: function initOutline() {
                    return this.outline = new PDFOutline(this, null, null, null);
                  },
                  endOutline: function endOutline() {
                    this.outline.endOutline();
                    if (this.outline.children.length > 0) {
                      this._root.data.Outlines = this.outline.dictionary;
                      return this._root.data.PageMode = "UseOutlines";
                    }
                  }
                };
                var PDFStructureContent = function() {
                  function PDFStructureContent2(pageRef, mcid) {
                    _classCallCheck(this, PDFStructureContent2);
                    this.refs = [{
                      pageRef,
                      mcid
                    }];
                  }
                  _createClass(PDFStructureContent2, [{
                    key: "push",
                    value: function push(structContent) {
                      var _this = this;
                      structContent.refs.forEach(function(ref) {
                        return _this.refs.push(ref);
                      });
                    }
                  }]);
                  return PDFStructureContent2;
                }();
                var PDFStructureElement = function() {
                  function PDFStructureElement2(document2, type) {
                    var _this = this;
                    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                    var children = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
                    _classCallCheck(this, PDFStructureElement2);
                    this.document = document2;
                    this._attached = false;
                    this._ended = false;
                    this._flushed = false;
                    this.dictionary = document2.ref({
                      // Type: "StructElem",
                      S: type
                    });
                    var data = this.dictionary.data;
                    if (Array.isArray(options) || this._isValidChild(options)) {
                      children = options;
                      options = {};
                    }
                    if (typeof options.title !== "undefined") {
                      data.T = new String(options.title);
                    }
                    if (typeof options.lang !== "undefined") {
                      data.Lang = new String(options.lang);
                    }
                    if (typeof options.alt !== "undefined") {
                      data.Alt = new String(options.alt);
                    }
                    if (typeof options.expanded !== "undefined") {
                      data.E = new String(options.expanded);
                    }
                    if (typeof options.actual !== "undefined") {
                      data.ActualText = new String(options.actual);
                    }
                    this._children = [];
                    if (children) {
                      if (!Array.isArray(children)) {
                        children = [children];
                      }
                      children.forEach(function(child) {
                        return _this.add(child);
                      });
                      this.end();
                    }
                  }
                  _createClass(PDFStructureElement2, [{
                    key: "add",
                    value: function add(child) {
                      if (this._ended) {
                        throw new Error("Cannot add child to already-ended structure element");
                      }
                      if (!this._isValidChild(child)) {
                        throw new Error("Invalid structure element child");
                      }
                      if (child instanceof PDFStructureElement2) {
                        child.setParent(this.dictionary);
                        if (this._attached) {
                          child.setAttached();
                        }
                      }
                      if (child instanceof PDFStructureContent) {
                        this._addContentToParentTree(child);
                      }
                      if (typeof child === "function" && this._attached) {
                        child = this._contentForClosure(child);
                      }
                      this._children.push(child);
                      return this;
                    }
                  }, {
                    key: "_addContentToParentTree",
                    value: function _addContentToParentTree(content) {
                      var _this2 = this;
                      content.refs.forEach(function(_ref) {
                        var pageRef = _ref.pageRef, mcid = _ref.mcid;
                        var pageStructParents = _this2.document.getStructParentTree().get(pageRef.data.StructParents);
                        pageStructParents[mcid] = _this2.dictionary;
                      });
                    }
                  }, {
                    key: "setParent",
                    value: function setParent(parentRef) {
                      if (this.dictionary.data.P) {
                        throw new Error("Structure element added to more than one parent");
                      }
                      this.dictionary.data.P = parentRef;
                      this._flush();
                    }
                  }, {
                    key: "setAttached",
                    value: function setAttached() {
                      var _this3 = this;
                      if (this._attached) {
                        return;
                      }
                      this._children.forEach(function(child, index) {
                        if (child instanceof PDFStructureElement2) {
                          child.setAttached();
                        }
                        if (typeof child === "function") {
                          _this3._children[index] = _this3._contentForClosure(child);
                        }
                      });
                      this._attached = true;
                      this._flush();
                    }
                  }, {
                    key: "end",
                    value: function end() {
                      if (this._ended) {
                        return;
                      }
                      this._children.filter(function(child) {
                        return child instanceof PDFStructureElement2;
                      }).forEach(function(child) {
                        return child.end();
                      });
                      this._ended = true;
                      this._flush();
                    }
                  }, {
                    key: "_isValidChild",
                    value: function _isValidChild(child) {
                      return child instanceof PDFStructureElement2 || child instanceof PDFStructureContent || typeof child === "function";
                    }
                  }, {
                    key: "_contentForClosure",
                    value: function _contentForClosure(closure) {
                      var content = this.document.markStructureContent(this.dictionary.data.S);
                      closure();
                      this.document.endMarkedContent();
                      this._addContentToParentTree(content);
                      return content;
                    }
                  }, {
                    key: "_isFlushable",
                    value: function _isFlushable() {
                      if (!this.dictionary.data.P || !this._ended) {
                        return false;
                      }
                      return this._children.every(function(child) {
                        if (typeof child === "function") {
                          return false;
                        }
                        if (child instanceof PDFStructureElement2) {
                          return child._isFlushable();
                        }
                        return true;
                      });
                    }
                  }, {
                    key: "_flush",
                    value: function _flush() {
                      var _this4 = this;
                      if (this._flushed || !this._isFlushable()) {
                        return;
                      }
                      this.dictionary.data.K = [];
                      this._children.forEach(function(child) {
                        return _this4._flushChild(child);
                      });
                      this.dictionary.end();
                      this._children = [];
                      this.dictionary.data.K = null;
                      this._flushed = true;
                    }
                  }, {
                    key: "_flushChild",
                    value: function _flushChild(child) {
                      var _this5 = this;
                      if (child instanceof PDFStructureElement2) {
                        this.dictionary.data.K.push(child.dictionary);
                      }
                      if (child instanceof PDFStructureContent) {
                        child.refs.forEach(function(_ref2) {
                          var pageRef = _ref2.pageRef, mcid = _ref2.mcid;
                          if (!_this5.dictionary.data.Pg) {
                            _this5.dictionary.data.Pg = pageRef;
                          }
                          if (_this5.dictionary.data.Pg === pageRef) {
                            _this5.dictionary.data.K.push(mcid);
                          } else {
                            _this5.dictionary.data.K.push({
                              Type: "MCR",
                              Pg: pageRef,
                              MCID: mcid
                            });
                          }
                        });
                      }
                    }
                  }]);
                  return PDFStructureElement2;
                }();
                var PDFNumberTree = function(_PDFTree) {
                  _inherits(PDFNumberTree2, _PDFTree);
                  var _super = _createSuper(PDFNumberTree2);
                  function PDFNumberTree2() {
                    _classCallCheck(this, PDFNumberTree2);
                    return _super.apply(this, arguments);
                  }
                  _createClass(PDFNumberTree2, [{
                    key: "_compareKeys",
                    value: function _compareKeys(a, b) {
                      return parseInt(a) - parseInt(b);
                    }
                  }, {
                    key: "_keysName",
                    value: function _keysName() {
                      return "Nums";
                    }
                  }, {
                    key: "_dataForKey",
                    value: function _dataForKey(k) {
                      return parseInt(k);
                    }
                  }]);
                  return PDFNumberTree2;
                }(PDFTree);
                var MarkingsMixin = {
                  initMarkings: function initMarkings(options) {
                    this.structChildren = [];
                    if (options.tagged) {
                      this.getMarkInfoDictionary().data.Marked = true;
                      this.getStructTreeRoot();
                    }
                  },
                  markContent: function markContent(tag) {
                    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                    if (tag === "Artifact" || options && options.mcid) {
                      var toClose = 0;
                      this.page.markings.forEach(function(marking) {
                        if (toClose || marking.structContent || marking.tag === "Artifact") {
                          toClose++;
                        }
                      });
                      while (toClose--) {
                        this.endMarkedContent();
                      }
                    }
                    if (!options) {
                      this.page.markings.push({
                        tag
                      });
                      this.addContent("/".concat(tag, " BMC"));
                      return this;
                    }
                    this.page.markings.push({
                      tag,
                      options
                    });
                    var dictionary = {};
                    if (typeof options.mcid !== "undefined") {
                      dictionary.MCID = options.mcid;
                    }
                    if (tag === "Artifact") {
                      if (typeof options.type === "string") {
                        dictionary.Type = options.type;
                      }
                      if (Array.isArray(options.bbox)) {
                        dictionary.BBox = [options.bbox[0], this.page.height - options.bbox[3], options.bbox[2], this.page.height - options.bbox[1]];
                      }
                      if (Array.isArray(options.attached) && options.attached.every(function(val) {
                        return typeof val === "string";
                      })) {
                        dictionary.Attached = options.attached;
                      }
                    }
                    if (tag === "Span") {
                      if (options.lang) {
                        dictionary.Lang = new String(options.lang);
                      }
                      if (options.alt) {
                        dictionary.Alt = new String(options.alt);
                      }
                      if (options.expanded) {
                        dictionary.E = new String(options.expanded);
                      }
                      if (options.actual) {
                        dictionary.ActualText = new String(options.actual);
                      }
                    }
                    this.addContent("/".concat(tag, " ").concat(PDFObject.convert(dictionary), " BDC"));
                    return this;
                  },
                  markStructureContent: function markStructureContent(tag) {
                    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                    var pageStructParents = this.getStructParentTree().get(this.page.structParentTreeKey);
                    var mcid = pageStructParents.length;
                    pageStructParents.push(null);
                    this.markContent(tag, _objectSpread2(_objectSpread2({}, options), {}, {
                      mcid
                    }));
                    var structContent = new PDFStructureContent(this.page.dictionary, mcid);
                    this.page.markings.slice(-1)[0].structContent = structContent;
                    return structContent;
                  },
                  endMarkedContent: function endMarkedContent() {
                    this.page.markings.pop();
                    this.addContent("EMC");
                    return this;
                  },
                  struct: function struct(type) {
                    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                    var children = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                    return new PDFStructureElement(this, type, options, children);
                  },
                  addStructure: function addStructure(structElem) {
                    var structTreeRoot = this.getStructTreeRoot();
                    structElem.setParent(structTreeRoot);
                    structElem.setAttached();
                    this.structChildren.push(structElem);
                    if (!structTreeRoot.data.K) {
                      structTreeRoot.data.K = [];
                    }
                    structTreeRoot.data.K.push(structElem.dictionary);
                    return this;
                  },
                  initPageMarkings: function initPageMarkings(pageMarkings) {
                    var _this = this;
                    pageMarkings.forEach(function(marking) {
                      if (marking.structContent) {
                        var structContent = marking.structContent;
                        var newStructContent = _this.markStructureContent(marking.tag, marking.options);
                        structContent.push(newStructContent);
                        _this.page.markings.slice(-1)[0].structContent = structContent;
                      } else {
                        _this.markContent(marking.tag, marking.options);
                      }
                    });
                  },
                  endPageMarkings: function endPageMarkings(page) {
                    var pageMarkings = page.markings;
                    pageMarkings.forEach(function() {
                      return page.write("EMC");
                    });
                    page.markings = [];
                    return pageMarkings;
                  },
                  getMarkInfoDictionary: function getMarkInfoDictionary() {
                    if (!this._root.data.MarkInfo) {
                      this._root.data.MarkInfo = this.ref({});
                    }
                    return this._root.data.MarkInfo;
                  },
                  getStructTreeRoot: function getStructTreeRoot() {
                    if (!this._root.data.StructTreeRoot) {
                      this._root.data.StructTreeRoot = this.ref({
                        Type: "StructTreeRoot",
                        ParentTree: new PDFNumberTree(),
                        ParentTreeNextKey: 0
                      });
                    }
                    return this._root.data.StructTreeRoot;
                  },
                  getStructParentTree: function getStructParentTree() {
                    return this.getStructTreeRoot().data.ParentTree;
                  },
                  createStructParentTreeNextKey: function createStructParentTreeNextKey() {
                    this.getMarkInfoDictionary();
                    var structTreeRoot = this.getStructTreeRoot();
                    var key = structTreeRoot.data.ParentTreeNextKey++;
                    structTreeRoot.data.ParentTree.add(key, []);
                    return key;
                  },
                  endMarkings: function endMarkings() {
                    var structTreeRoot = this._root.data.StructTreeRoot;
                    if (structTreeRoot) {
                      structTreeRoot.end();
                      this.structChildren.forEach(function(structElem) {
                        return structElem.end();
                      });
                    }
                    if (this._root.data.MarkInfo) {
                      this._root.data.MarkInfo.end();
                    }
                  }
                };
                var FIELD_FLAGS = {
                  readOnly: 1,
                  required: 2,
                  noExport: 4,
                  multiline: 4096,
                  password: 8192,
                  toggleToOffButton: 16384,
                  radioButton: 32768,
                  pushButton: 65536,
                  combo: 131072,
                  edit: 262144,
                  sort: 524288,
                  multiSelect: 2097152,
                  noSpell: 4194304
                };
                var FIELD_JUSTIFY = {
                  left: 0,
                  center: 1,
                  right: 2
                };
                var VALUE_MAP = {
                  value: "V",
                  defaultValue: "DV"
                };
                var FORMAT_SPECIAL = {
                  zip: "0",
                  zipPlus4: "1",
                  zip4: "1",
                  phone: "2",
                  ssn: "3"
                };
                var FORMAT_DEFAULT = {
                  number: {
                    nDec: 0,
                    sepComma: false,
                    negStyle: "MinusBlack",
                    currency: "",
                    currencyPrepend: true
                  },
                  percent: {
                    nDec: 0,
                    sepComma: false
                  }
                };
                var AcroFormMixin = {
                  /**
                   * Must call if adding AcroForms to a document. Must also call font() before
                   * this method to set the default font.
                   */
                  initForm: function initForm() {
                    if (!this._font) {
                      throw new Error("Must set a font before calling initForm method");
                    }
                    this._acroform = {
                      fonts: {},
                      defaultFont: this._font.name
                    };
                    this._acroform.fonts[this._font.id] = this._font.ref();
                    var data = {
                      Fields: [],
                      NeedAppearances: true,
                      DA: new String("/".concat(this._font.id, " 0 Tf 0 g")),
                      DR: {
                        Font: {}
                      }
                    };
                    data.DR.Font[this._font.id] = this._font.ref();
                    var AcroForm = this.ref(data);
                    this._root.data.AcroForm = AcroForm;
                    return this;
                  },
                  /**
                   * Called automatically by document.js
                   */
                  endAcroForm: function endAcroForm() {
                    var _this = this;
                    if (this._root.data.AcroForm) {
                      if (!Object.keys(this._acroform.fonts).length && !this._acroform.defaultFont) {
                        throw new Error("No fonts specified for PDF form");
                      }
                      var fontDict = this._root.data.AcroForm.data.DR.Font;
                      Object.keys(this._acroform.fonts).forEach(function(name) {
                        fontDict[name] = _this._acroform.fonts[name];
                      });
                      this._root.data.AcroForm.data.Fields.forEach(function(fieldRef) {
                        _this._endChild(fieldRef);
                      });
                      this._root.data.AcroForm.end();
                    }
                    return this;
                  },
                  _endChild: function _endChild(ref) {
                    var _this2 = this;
                    if (Array.isArray(ref.data.Kids)) {
                      ref.data.Kids.forEach(function(childRef) {
                        _this2._endChild(childRef);
                      });
                      ref.end();
                    }
                    return this;
                  },
                  /**
                   * Creates and adds a form field to the document. Form fields are intermediate
                   * nodes in a PDF form that are used to specify form name heirarchy and form
                   * value defaults.
                   * @param {string} name - field name (T attribute in field dictionary)
                   * @param {object} options  - other attributes to include in field dictionary
                   */
                  formField: function formField(name) {
                    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                    var fieldDict = this._fieldDict(name, null, options);
                    var fieldRef = this.ref(fieldDict);
                    this._addToParent(fieldRef);
                    return fieldRef;
                  },
                  /**
                   * Creates and adds a Form Annotation to the document. Form annotations are
                   * called Widget annotations internally within a PDF file.
                   * @param {string} name - form field name (T attribute of widget annotation
                   * dictionary)
                   * @param {number} x
                   * @param {number} y
                   * @param {number} w
                   * @param {number} h
                   * @param {object} options
                   */
                  formAnnotation: function formAnnotation(name, type, x, y, w, h) {
                    var options = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : {};
                    var fieldDict = this._fieldDict(name, type, options);
                    fieldDict.Subtype = "Widget";
                    if (fieldDict.F === void 0) {
                      fieldDict.F = 4;
                    }
                    this.annotate(x, y, w, h, fieldDict);
                    var annotRef = this.page.annotations[this.page.annotations.length - 1];
                    return this._addToParent(annotRef);
                  },
                  formText: function formText(name, x, y, w, h) {
                    var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                    return this.formAnnotation(name, "text", x, y, w, h, options);
                  },
                  formPushButton: function formPushButton(name, x, y, w, h) {
                    var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                    return this.formAnnotation(name, "pushButton", x, y, w, h, options);
                  },
                  formCombo: function formCombo(name, x, y, w, h) {
                    var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                    return this.formAnnotation(name, "combo", x, y, w, h, options);
                  },
                  formList: function formList(name, x, y, w, h) {
                    var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                    return this.formAnnotation(name, "list", x, y, w, h, options);
                  },
                  formRadioButton: function formRadioButton(name, x, y, w, h) {
                    var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                    return this.formAnnotation(name, "radioButton", x, y, w, h, options);
                  },
                  formCheckbox: function formCheckbox(name, x, y, w, h) {
                    var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
                    return this.formAnnotation(name, "checkbox", x, y, w, h, options);
                  },
                  _addToParent: function _addToParent(fieldRef) {
                    var parent = fieldRef.data.Parent;
                    if (parent) {
                      if (!parent.data.Kids) {
                        parent.data.Kids = [];
                      }
                      parent.data.Kids.push(fieldRef);
                    } else {
                      this._root.data.AcroForm.data.Fields.push(fieldRef);
                    }
                    return this;
                  },
                  _fieldDict: function _fieldDict(name, type) {
                    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                    if (!this._acroform) {
                      throw new Error("Call document.initForms() method before adding form elements to document");
                    }
                    var opts = Object.assign({}, options);
                    if (type !== null) {
                      opts = this._resolveType(type, options);
                    }
                    opts = this._resolveFlags(opts);
                    opts = this._resolveJustify(opts);
                    opts = this._resolveFont(opts);
                    opts = this._resolveStrings(opts);
                    opts = this._resolveColors(opts);
                    opts = this._resolveFormat(opts);
                    opts.T = new String(name);
                    if (opts.parent) {
                      opts.Parent = opts.parent;
                      delete opts.parent;
                    }
                    return opts;
                  },
                  _resolveType: function _resolveType(type, opts) {
                    if (type === "text") {
                      opts.FT = "Tx";
                    } else if (type === "pushButton") {
                      opts.FT = "Btn";
                      opts.pushButton = true;
                    } else if (type === "radioButton") {
                      opts.FT = "Btn";
                      opts.radioButton = true;
                    } else if (type === "checkbox") {
                      opts.FT = "Btn";
                    } else if (type === "combo") {
                      opts.FT = "Ch";
                      opts.combo = true;
                    } else if (type === "list") {
                      opts.FT = "Ch";
                    } else {
                      throw new Error("Invalid form annotation type '".concat(type, "'"));
                    }
                    return opts;
                  },
                  _resolveFormat: function _resolveFormat(opts) {
                    var f = opts.format;
                    if (f && f.type) {
                      var fnKeystroke;
                      var fnFormat;
                      var params = "";
                      if (FORMAT_SPECIAL[f.type] !== void 0) {
                        fnKeystroke = "AFSpecial_Keystroke";
                        fnFormat = "AFSpecial_Format";
                        params = FORMAT_SPECIAL[f.type];
                      } else {
                        var format = f.type.charAt(0).toUpperCase() + f.type.slice(1);
                        fnKeystroke = "AF".concat(format, "_Keystroke");
                        fnFormat = "AF".concat(format, "_Format");
                        if (f.type === "date") {
                          fnKeystroke += "Ex";
                          params = String(f.param);
                        } else if (f.type === "time") {
                          params = String(f.param);
                        } else if (f.type === "number") {
                          var p = Object.assign({}, FORMAT_DEFAULT.number, f);
                          params = String([String(p.nDec), p.sepComma ? "0" : "1", '"' + p.negStyle + '"', "null", '"' + p.currency + '"', String(p.currencyPrepend)].join(","));
                        } else if (f.type === "percent") {
                          var _p = Object.assign({}, FORMAT_DEFAULT.percent, f);
                          params = String([String(_p.nDec), _p.sepComma ? "0" : "1"].join(","));
                        }
                      }
                      opts.AA = opts.AA ? opts.AA : {};
                      opts.AA.K = {
                        S: "JavaScript",
                        JS: new String("".concat(fnKeystroke, "(").concat(params, ");"))
                      };
                      opts.AA.F = {
                        S: "JavaScript",
                        JS: new String("".concat(fnFormat, "(").concat(params, ");"))
                      };
                    }
                    delete opts.format;
                    return opts;
                  },
                  _resolveColors: function _resolveColors(opts) {
                    var color = this._normalizeColor(opts.backgroundColor);
                    if (color) {
                      if (!opts.MK) {
                        opts.MK = {};
                      }
                      opts.MK.BG = color;
                    }
                    color = this._normalizeColor(opts.borderColor);
                    if (color) {
                      if (!opts.MK) {
                        opts.MK = {};
                      }
                      opts.MK.BC = color;
                    }
                    delete opts.backgroundColor;
                    delete opts.borderColor;
                    return opts;
                  },
                  _resolveFlags: function _resolveFlags(options) {
                    var result = 0;
                    Object.keys(options).forEach(function(key) {
                      if (FIELD_FLAGS[key]) {
                        result |= FIELD_FLAGS[key];
                        delete options[key];
                      }
                    });
                    if (result !== 0) {
                      options.Ff = options.Ff ? options.Ff : 0;
                      options.Ff |= result;
                    }
                    return options;
                  },
                  _resolveJustify: function _resolveJustify(options) {
                    var result = 0;
                    if (options.align !== void 0) {
                      if (typeof FIELD_JUSTIFY[options.align] === "number") {
                        result = FIELD_JUSTIFY[options.align];
                      }
                      delete options.align;
                    }
                    if (result !== 0) {
                      options.Q = result;
                    }
                    return options;
                  },
                  _resolveFont: function _resolveFont(options) {
                    if (this._acroform.fonts[this._font.id] === null) {
                      this._acroform.fonts[this._font.id] = this._font.ref();
                    }
                    if (this._acroform.defaultFont !== this._font.name) {
                      options.DR = {
                        Font: {}
                      };
                      var fontSize = options.fontSize || 0;
                      options.DR.Font[this._font.id] = this._font.ref();
                      options.DA = new String("/".concat(this._font.id, " ").concat(fontSize, " Tf 0 g"));
                    }
                    return options;
                  },
                  _resolveStrings: function _resolveStrings(options) {
                    var select = [];
                    function appendChoices(a) {
                      if (Array.isArray(a)) {
                        for (var idx = 0; idx < a.length; idx++) {
                          if (typeof a[idx] === "string") {
                            select.push(new String(a[idx]));
                          } else {
                            select.push(a[idx]);
                          }
                        }
                      }
                    }
                    appendChoices(options.Opt);
                    if (options.select) {
                      appendChoices(options.select);
                      delete options.select;
                    }
                    if (select.length) {
                      options.Opt = select;
                    }
                    Object.keys(VALUE_MAP).forEach(function(key) {
                      if (options[key] !== void 0) {
                        options[VALUE_MAP[key]] = options[key];
                        delete options[key];
                      }
                    });
                    ["V", "DV"].forEach(function(key) {
                      if (typeof options[key] === "string") {
                        options[key] = new String(options[key]);
                      }
                    });
                    if (options.MK && options.MK.CA) {
                      options.MK.CA = new String(options.MK.CA);
                    }
                    if (options.label) {
                      options.MK = options.MK ? options.MK : {};
                      options.MK.CA = new String(options.label);
                      delete options.label;
                    }
                    return options;
                  }
                };
                var AttachmentsMixin = {
                  /**
                   * Embed contents of `src` in PDF
                   * @param {Buffer | ArrayBuffer | string} src input Buffer, ArrayBuffer, base64 encoded string or path to file
                   * @param {object} options
                   *  * options.name: filename to be shown in PDF, will use `src` if none set
                   *  * options.type: filetype to be shown in PDF
                   *  * options.description: description to be shown in PDF
                   *  * options.hidden: if true, do not add attachment to EmbeddedFiles dictionary. Useful for file attachment annotations
                   *  * options.creationDate: override creation date
                   *  * options.modifiedDate: override modified date
                   * @returns filespec reference
                   */
                  file: function file(src) {
                    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                    options.name = options.name || src;
                    var refBody = {
                      Type: "EmbeddedFile",
                      Params: {}
                    };
                    var data;
                    if (!src) {
                      throw new Error("No src specified");
                    }
                    if (Buffer.isBuffer(src)) {
                      data = src;
                    } else if (src instanceof ArrayBuffer) {
                      data = Buffer.from(new Uint8Array(src));
                    } else {
                      var match;
                      if (match = /^data:(.*);base64,(.*)$/.exec(src)) {
                        if (match[1]) {
                          refBody.Subtype = match[1].replace("/", "#2F");
                        }
                        data = Buffer.from(match[2], "base64");
                      } else {
                        data = fs.readFileSync(src);
                        if (!data) {
                          throw new Error("Could not read contents of file at filepath ".concat(src));
                        }
                        var _fs$statSync = fs.statSync(src), birthtime = _fs$statSync.birthtime, ctime = _fs$statSync.ctime;
                        refBody.Params.CreationDate = birthtime;
                        refBody.Params.ModDate = ctime;
                      }
                    }
                    if (options.creationDate instanceof Date) {
                      refBody.Params.CreationDate = options.creationDate;
                    }
                    if (options.modifiedDate instanceof Date) {
                      refBody.Params.ModDate = options.modifiedDate;
                    }
                    if (options.type) {
                      refBody.Subtype = options.type.replace("/", "#2F");
                    }
                    var checksum = _cryptoJs.default.MD5(_cryptoJs.default.lib.WordArray.create(new Uint8Array(data)));
                    refBody.Params.CheckSum = new String(checksum);
                    refBody.Params.Size = data.byteLength;
                    var ref;
                    if (!this._fileRegistry)
                      this._fileRegistry = {};
                    var file2 = this._fileRegistry[options.name];
                    if (file2 && isEqual(refBody, file2)) {
                      ref = file2.ref;
                    } else {
                      ref = this.ref(refBody);
                      ref.end(data);
                      this._fileRegistry[options.name] = _objectSpread2(_objectSpread2({}, refBody), {}, {
                        ref
                      });
                    }
                    var fileSpecBody = {
                      Type: "Filespec",
                      F: new String(options.name),
                      EF: {
                        F: ref
                      },
                      UF: new String(options.name)
                    };
                    if (options.description) {
                      fileSpecBody.Desc = new String(options.description);
                    }
                    var filespec = this.ref(fileSpecBody);
                    filespec.end();
                    if (!options.hidden) {
                      this.addNamedEmbeddedFile(options.name, filespec);
                    }
                    return filespec;
                  }
                };
                function isEqual(a, b) {
                  return a.Subtype === b.Subtype && a.Params.CheckSum.toString() === b.Params.CheckSum.toString() && a.Params.Size === b.Params.Size && a.Params.CreationDate === b.Params.CreationDate && a.Params.ModDate === b.Params.ModDate;
                }
                var PDFDocument = function(_stream$Readable) {
                  _inherits(PDFDocument2, _stream$Readable);
                  var _super = _createSuper(PDFDocument2);
                  function PDFDocument2() {
                    var _this;
                    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    _classCallCheck(this, PDFDocument2);
                    _this = _super.call(this, options);
                    _this.options = options;
                    switch (options.pdfVersion) {
                      case "1.4":
                        _this.version = 1.4;
                        break;
                      case "1.5":
                        _this.version = 1.5;
                        break;
                      case "1.6":
                        _this.version = 1.6;
                        break;
                      case "1.7":
                      case "1.7ext3":
                        _this.version = 1.7;
                        break;
                      default:
                        _this.version = 1.3;
                        break;
                    }
                    _this.compress = _this.options.compress != null ? _this.options.compress : true;
                    _this._pageBuffer = [];
                    _this._pageBufferStart = 0;
                    _this._offsets = [];
                    _this._waiting = 0;
                    _this._ended = false;
                    _this._offset = 0;
                    var Pages = _this.ref({
                      Type: "Pages",
                      Count: 0,
                      Kids: []
                    });
                    var Names = _this.ref({
                      Dests: new PDFNameTree()
                    });
                    _this._root = _this.ref({
                      Type: "Catalog",
                      Pages,
                      Names
                    });
                    if (_this.options.lang) {
                      _this._root.data.Lang = new String(_this.options.lang);
                    }
                    _this.page = null;
                    _this.initColor();
                    _this.initVector();
                    _this.initFonts(options.font);
                    _this.initText();
                    _this.initImages();
                    _this.initOutline();
                    _this.initMarkings(options);
                    _this.info = {
                      Producer: "PDFKit",
                      Creator: "PDFKit",
                      CreationDate: /* @__PURE__ */ new Date()
                    };
                    if (_this.options.info) {
                      for (var key in _this.options.info) {
                        var val = _this.options.info[key];
                        _this.info[key] = val;
                      }
                    }
                    if (_this.options.displayTitle) {
                      _this._root.data.ViewerPreferences = _this.ref({
                        DisplayDocTitle: true
                      });
                    }
                    _this._id = PDFSecurity.generateFileID(_this.info);
                    _this._security = PDFSecurity.create(_assertThisInitialized(_this), options);
                    _this._write("%PDF-".concat(_this.version));
                    _this._write("%");
                    if (_this.options.autoFirstPage !== false) {
                      _this.addPage();
                    }
                    return _this;
                  }
                  _createClass(PDFDocument2, [{
                    key: "addPage",
                    value: function addPage(options) {
                      if (options == null) {
                        options = this.options;
                      }
                      if (!this.options.bufferPages) {
                        this.flushPages();
                      }
                      this.page = new PDFPage(this, options);
                      this._pageBuffer.push(this.page);
                      var pages = this._root.data.Pages.data;
                      pages.Kids.push(this.page.dictionary);
                      pages.Count++;
                      this.x = this.page.margins.left;
                      this.y = this.page.margins.top;
                      this._ctm = [1, 0, 0, 1, 0, 0];
                      this.transform(1, 0, 0, -1, 0, this.page.height);
                      this.emit("pageAdded");
                      return this;
                    }
                  }, {
                    key: "continueOnNewPage",
                    value: function continueOnNewPage(options) {
                      var pageMarkings = this.endPageMarkings(this.page);
                      this.addPage(options);
                      this.initPageMarkings(pageMarkings);
                      return this;
                    }
                  }, {
                    key: "bufferedPageRange",
                    value: function bufferedPageRange() {
                      return {
                        start: this._pageBufferStart,
                        count: this._pageBuffer.length
                      };
                    }
                  }, {
                    key: "switchToPage",
                    value: function switchToPage(n) {
                      var page;
                      if (!(page = this._pageBuffer[n - this._pageBufferStart])) {
                        throw new Error("switchToPage(".concat(n, ") out of bounds, current buffer covers pages ").concat(this._pageBufferStart, " to ").concat(this._pageBufferStart + this._pageBuffer.length - 1));
                      }
                      return this.page = page;
                    }
                  }, {
                    key: "flushPages",
                    value: function flushPages() {
                      var pages = this._pageBuffer;
                      this._pageBuffer = [];
                      this._pageBufferStart += pages.length;
                      var _iterator = _createForOfIteratorHelper(pages), _step;
                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                          var page = _step.value;
                          this.endPageMarkings(page);
                          page.end();
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }
                    }
                  }, {
                    key: "addNamedDestination",
                    value: function addNamedDestination(name) {
                      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                        args[_key - 1] = arguments[_key];
                      }
                      if (args.length === 0) {
                        args = ["XYZ", null, null, null];
                      }
                      if (args[0] === "XYZ" && args[2] !== null) {
                        args[2] = this.page.height - args[2];
                      }
                      args.unshift(this.page.dictionary);
                      this._root.data.Names.data.Dests.add(name, args);
                    }
                  }, {
                    key: "addNamedEmbeddedFile",
                    value: function addNamedEmbeddedFile(name, ref) {
                      if (!this._root.data.Names.data.EmbeddedFiles) {
                        this._root.data.Names.data.EmbeddedFiles = new PDFNameTree({
                          limits: false
                        });
                      }
                      this._root.data.Names.data.EmbeddedFiles.add(name, ref);
                    }
                  }, {
                    key: "addNamedJavaScript",
                    value: function addNamedJavaScript(name, js) {
                      if (!this._root.data.Names.data.JavaScript) {
                        this._root.data.Names.data.JavaScript = new PDFNameTree();
                      }
                      var data = {
                        JS: new String(js),
                        S: "JavaScript"
                      };
                      this._root.data.Names.data.JavaScript.add(name, data);
                    }
                  }, {
                    key: "ref",
                    value: function ref(data) {
                      var ref2 = new PDFReference(this, this._offsets.length + 1, data);
                      this._offsets.push(null);
                      this._waiting++;
                      return ref2;
                    }
                  }, {
                    key: "_read",
                    value: function _read() {
                    }
                    // do nothing, but this method is required by node
                  }, {
                    key: "_write",
                    value: function _write(data) {
                      if (!Buffer.isBuffer(data)) {
                        data = Buffer.from(data + "\n", "binary");
                      }
                      this.push(data);
                      return this._offset += data.length;
                    }
                  }, {
                    key: "addContent",
                    value: function addContent(data) {
                      this.page.write(data);
                      return this;
                    }
                  }, {
                    key: "_refEnd",
                    value: function _refEnd(ref) {
                      this._offsets[ref.id - 1] = ref.offset;
                      if (--this._waiting === 0 && this._ended) {
                        this._finalize();
                        return this._ended = false;
                      }
                    }
                  }, {
                    key: "write",
                    value: function write(filename, fn) {
                      var err = new Error("PDFDocument#write is deprecated, and will be removed in a future version of PDFKit. Please pipe the document into a Node stream.");
                      console.warn(err.stack);
                      this.pipe(fs.createWriteStream(filename));
                      this.end();
                      return this.once("end", fn);
                    }
                  }, {
                    key: "end",
                    value: function end() {
                      this.flushPages();
                      this._info = this.ref();
                      for (var key in this.info) {
                        var val = this.info[key];
                        if (typeof val === "string") {
                          val = new String(val);
                        }
                        var entry = this.ref(val);
                        entry.end();
                        this._info.data[key] = entry;
                      }
                      this._info.end();
                      for (var name in this._fontFamilies) {
                        var font = this._fontFamilies[name];
                        font.finalize();
                      }
                      this.endOutline();
                      this.endMarkings();
                      this._root.end();
                      this._root.data.Pages.end();
                      this._root.data.Names.end();
                      this.endAcroForm();
                      if (this._root.data.ViewerPreferences) {
                        this._root.data.ViewerPreferences.end();
                      }
                      if (this._security) {
                        this._security.end();
                      }
                      if (this._waiting === 0) {
                        return this._finalize();
                      } else {
                        return this._ended = true;
                      }
                    }
                  }, {
                    key: "_finalize",
                    value: function _finalize() {
                      var xRefOffset = this._offset;
                      this._write("xref");
                      this._write("0 ".concat(this._offsets.length + 1));
                      this._write("0000000000 65535 f ");
                      var _iterator2 = _createForOfIteratorHelper(this._offsets), _step2;
                      try {
                        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                          var offset = _step2.value;
                          offset = "0000000000".concat(offset).slice(-10);
                          this._write(offset + " 00000 n ");
                        }
                      } catch (err) {
                        _iterator2.e(err);
                      } finally {
                        _iterator2.f();
                      }
                      var trailer = {
                        Size: this._offsets.length + 1,
                        Root: this._root,
                        Info: this._info,
                        ID: [this._id, this._id]
                      };
                      if (this._security) {
                        trailer.Encrypt = this._security.dictionary;
                      }
                      this._write("trailer");
                      this._write(PDFObject.convert(trailer));
                      this._write("startxref");
                      this._write("".concat(xRefOffset));
                      this._write("%%EOF");
                      return this.push(null);
                    }
                  }, {
                    key: "toString",
                    value: function toString() {
                      return "[object PDFDocument]";
                    }
                  }]);
                  return PDFDocument2;
                }(_stream.default.Readable);
                var mixin = function mixin2(methods) {
                  Object.assign(PDFDocument.prototype, methods);
                };
                mixin(ColorMixin);
                mixin(VectorMixin);
                mixin(FontsMixin);
                mixin(TextMixin);
                mixin(ImagesMixin);
                mixin(AnnotationsMixin);
                mixin(OutlineMixin);
                mixin(MarkingsMixin);
                mixin(AcroFormMixin);
                mixin(AttachmentsMixin);
                PDFDocument.LineWrapper = LineWrapper;
                var _default = PDFDocument;
                exports2["default"] = _default;
              }
            ),
            /***/
            4559: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                __webpack_require__2(3290);
                var buffer = __webpack_require__2(8823);
                var Buffer = buffer.Buffer;
                function copyProps(src, dst) {
                  for (var key in src) {
                    dst[key] = src[key];
                  }
                }
                if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
                  module2.exports = buffer;
                } else {
                  copyProps(buffer, exports2);
                  exports2.Buffer = SafeBuffer;
                }
                function SafeBuffer(arg, encodingOrOffset, length) {
                  return Buffer(arg, encodingOrOffset, length);
                }
                copyProps(Buffer, SafeBuffer);
                SafeBuffer.from = function(arg, encodingOrOffset, length) {
                  if (typeof arg === "number") {
                    throw new TypeError("Argument must not be a number");
                  }
                  return Buffer(arg, encodingOrOffset, length);
                };
                SafeBuffer.alloc = function(size, fill, encoding) {
                  if (typeof size !== "number") {
                    throw new TypeError("Argument must be a number");
                  }
                  var buf = Buffer(size);
                  if (fill !== void 0) {
                    if (typeof encoding === "string") {
                      buf.fill(fill, encoding);
                    } else {
                      buf.fill(fill);
                    }
                  } else {
                    buf.fill(0);
                  }
                  return buf;
                };
                SafeBuffer.allocUnsafe = function(size) {
                  if (typeof size !== "number") {
                    throw new TypeError("Argument must be a number");
                  }
                  return Buffer(size);
                };
                SafeBuffer.allocUnsafeSlow = function(size) {
                  if (typeof size !== "number") {
                    throw new TypeError("Argument must be a number");
                  }
                  return buffer.SlowBuffer(size);
                };
              }
            ),
            /***/
            4781: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                __webpack_require__2(7042);
                __webpack_require__2(6992);
                __webpack_require__2(1539);
                __webpack_require__2(2472);
                __webpack_require__2(2990);
                __webpack_require__2(8927);
                __webpack_require__2(3105);
                __webpack_require__2(5035);
                __webpack_require__2(4345);
                __webpack_require__2(7174);
                __webpack_require__2(2846);
                __webpack_require__2(4731);
                __webpack_require__2(7209);
                __webpack_require__2(6319);
                __webpack_require__2(8867);
                __webpack_require__2(7789);
                __webpack_require__2(3739);
                __webpack_require__2(9368);
                __webpack_require__2(4483);
                __webpack_require__2(2056);
                __webpack_require__2(3462);
                __webpack_require__2(678);
                __webpack_require__2(7462);
                __webpack_require__2(3824);
                __webpack_require__2(5021);
                __webpack_require__2(2974);
                __webpack_require__2(5016);
                __webpack_require__2(9135);
                var inflate = __webpack_require__2(311);
                var _require = __webpack_require__2(1753), swap32LE = _require.swap32LE;
                var SHIFT_1 = 6 + 5;
                var SHIFT_2 = 5;
                var SHIFT_1_2 = SHIFT_1 - SHIFT_2;
                var OMITTED_BMP_INDEX_1_LENGTH = 65536 >> SHIFT_1;
                var INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;
                var INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;
                var INDEX_SHIFT = 2;
                var DATA_BLOCK_LENGTH = 1 << SHIFT_2;
                var DATA_MASK = DATA_BLOCK_LENGTH - 1;
                var LSCP_INDEX_2_OFFSET = 65536 >> SHIFT_2;
                var LSCP_INDEX_2_LENGTH = 1024 >> SHIFT_2;
                var INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;
                var UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
                var UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
                var INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;
                var DATA_GRANULARITY = 1 << INDEX_SHIFT;
                var UnicodeTrie = function() {
                  function UnicodeTrie2(data) {
                    var isBuffer = typeof data.readUInt32BE === "function" && typeof data.slice === "function";
                    if (isBuffer || data instanceof Uint8Array) {
                      var uncompressedLength;
                      if (isBuffer) {
                        this.highStart = data.readUInt32LE(0);
                        this.errorValue = data.readUInt32LE(4);
                        uncompressedLength = data.readUInt32LE(8);
                        data = data.slice(12);
                      } else {
                        var view = new DataView(data.buffer);
                        this.highStart = view.getUint32(0, true);
                        this.errorValue = view.getUint32(4, true);
                        uncompressedLength = view.getUint32(8, true);
                        data = data.subarray(12);
                      }
                      data = inflate(data, new Uint8Array(uncompressedLength));
                      data = inflate(data, new Uint8Array(uncompressedLength));
                      swap32LE(data);
                      this.data = new Uint32Array(data.buffer);
                    } else {
                      var _data = data;
                      this.data = _data.data;
                      this.highStart = _data.highStart;
                      this.errorValue = _data.errorValue;
                    }
                  }
                  var _proto = UnicodeTrie2.prototype;
                  _proto.get = function get(codePoint) {
                    var index;
                    if (codePoint < 0 || codePoint > 1114111) {
                      return this.errorValue;
                    }
                    if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
                      index = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
                      return this.data[index];
                    }
                    if (codePoint <= 65535) {
                      index = (this.data[LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
                      return this.data[index];
                    }
                    if (codePoint < this.highStart) {
                      index = this.data[INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> SHIFT_1)];
                      index = this.data[index + (codePoint >> SHIFT_2 & INDEX_2_MASK)];
                      index = (index << INDEX_SHIFT) + (codePoint & DATA_MASK);
                      return this.data[index];
                    }
                    return this.data[this.data.length - DATA_GRANULARITY];
                  };
                  return UnicodeTrie2;
                }();
                module2.exports = UnicodeTrie;
              }
            ),
            /***/
            1753: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                __webpack_require__2(6992);
                __webpack_require__2(1539);
                __webpack_require__2(2472);
                __webpack_require__2(2990);
                __webpack_require__2(8927);
                __webpack_require__2(3105);
                __webpack_require__2(5035);
                __webpack_require__2(4345);
                __webpack_require__2(7174);
                __webpack_require__2(2846);
                __webpack_require__2(4731);
                __webpack_require__2(7209);
                __webpack_require__2(6319);
                __webpack_require__2(8867);
                __webpack_require__2(7789);
                __webpack_require__2(3739);
                __webpack_require__2(9368);
                __webpack_require__2(4483);
                __webpack_require__2(2056);
                __webpack_require__2(3462);
                __webpack_require__2(678);
                __webpack_require__2(7462);
                __webpack_require__2(3824);
                __webpack_require__2(5021);
                __webpack_require__2(2974);
                __webpack_require__2(5016);
                __webpack_require__2(9135);
                var isBigEndian = new Uint8Array(new Uint32Array([305419896]).buffer)[0] === 18;
                var swap = function swap2(b, n, m) {
                  var i = b[n];
                  b[n] = b[m];
                  b[m] = i;
                };
                var swap32 = function swap322(array) {
                  var len = array.length;
                  for (var i = 0; i < len; i += 4) {
                    swap(array, i, i + 3);
                    swap(array, i + 1, i + 2);
                  }
                };
                var swap32LE = function swap32LE2(array) {
                  if (isBigEndian) {
                    swap32(array);
                  }
                };
                module2.exports = {
                  swap32LE
                };
              }
            ),
            /***/
            8071: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var SVGtoPDF = __webpack_require__2(8519);
                module2.exports = SVGtoPDF;
              }
            ),
            /***/
            8519: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                module2 = __webpack_require__2.nmd(module2);
                __webpack_require__2(8309);
                __webpack_require__2(7941);
                __webpack_require__2(3210);
                __webpack_require__2(4916);
                __webpack_require__2(4723);
                __webpack_require__2(3728);
                __webpack_require__2(5306);
                __webpack_require__2(7042);
                __webpack_require__2(9653);
                __webpack_require__2(3123);
                __webpack_require__2(2222);
                __webpack_require__2(6992);
                __webpack_require__2(1539);
                __webpack_require__2(3948);
                __webpack_require__2(9254);
                __webpack_require__2(3290);
                var SVGtoPDF = function SVGtoPDF2(doc, svg, x, y, options) {
                  "use strict";
                  var NamedColors = {
                    aliceblue: [240, 248, 255],
                    antiquewhite: [250, 235, 215],
                    aqua: [0, 255, 255],
                    aquamarine: [127, 255, 212],
                    azure: [240, 255, 255],
                    beige: [245, 245, 220],
                    bisque: [255, 228, 196],
                    black: [0, 0, 0],
                    blanchedalmond: [255, 235, 205],
                    blue: [0, 0, 255],
                    blueviolet: [138, 43, 226],
                    brown: [165, 42, 42],
                    burlywood: [222, 184, 135],
                    cadetblue: [95, 158, 160],
                    chartreuse: [127, 255, 0],
                    chocolate: [210, 105, 30],
                    coral: [255, 127, 80],
                    cornflowerblue: [100, 149, 237],
                    cornsilk: [255, 248, 220],
                    crimson: [220, 20, 60],
                    cyan: [0, 255, 255],
                    darkblue: [0, 0, 139],
                    darkcyan: [0, 139, 139],
                    darkgoldenrod: [184, 134, 11],
                    darkgray: [169, 169, 169],
                    darkgrey: [169, 169, 169],
                    darkgreen: [0, 100, 0],
                    darkkhaki: [189, 183, 107],
                    darkmagenta: [139, 0, 139],
                    darkolivegreen: [85, 107, 47],
                    darkorange: [255, 140, 0],
                    darkorchid: [153, 50, 204],
                    darkred: [139, 0, 0],
                    darksalmon: [233, 150, 122],
                    darkseagreen: [143, 188, 143],
                    darkslateblue: [72, 61, 139],
                    darkslategray: [47, 79, 79],
                    darkslategrey: [47, 79, 79],
                    darkturquoise: [0, 206, 209],
                    darkviolet: [148, 0, 211],
                    deeppink: [255, 20, 147],
                    deepskyblue: [0, 191, 255],
                    dimgray: [105, 105, 105],
                    dimgrey: [105, 105, 105],
                    dodgerblue: [30, 144, 255],
                    firebrick: [178, 34, 34],
                    floralwhite: [255, 250, 240],
                    forestgreen: [34, 139, 34],
                    fuchsia: [255, 0, 255],
                    gainsboro: [220, 220, 220],
                    ghostwhite: [248, 248, 255],
                    gold: [255, 215, 0],
                    goldenrod: [218, 165, 32],
                    gray: [128, 128, 128],
                    grey: [128, 128, 128],
                    green: [0, 128, 0],
                    greenyellow: [173, 255, 47],
                    honeydew: [240, 255, 240],
                    hotpink: [255, 105, 180],
                    indianred: [205, 92, 92],
                    indigo: [75, 0, 130],
                    ivory: [255, 255, 240],
                    khaki: [240, 230, 140],
                    lavender: [230, 230, 250],
                    lavenderblush: [255, 240, 245],
                    lawngreen: [124, 252, 0],
                    lemonchiffon: [255, 250, 205],
                    lightblue: [173, 216, 230],
                    lightcoral: [240, 128, 128],
                    lightcyan: [224, 255, 255],
                    lightgoldenrodyellow: [250, 250, 210],
                    lightgray: [211, 211, 211],
                    lightgrey: [211, 211, 211],
                    lightgreen: [144, 238, 144],
                    lightpink: [255, 182, 193],
                    lightsalmon: [255, 160, 122],
                    lightseagreen: [32, 178, 170],
                    lightskyblue: [135, 206, 250],
                    lightslategray: [119, 136, 153],
                    lightslategrey: [119, 136, 153],
                    lightsteelblue: [176, 196, 222],
                    lightyellow: [255, 255, 224],
                    lime: [0, 255, 0],
                    limegreen: [50, 205, 50],
                    linen: [250, 240, 230],
                    magenta: [255, 0, 255],
                    maroon: [128, 0, 0],
                    mediumaquamarine: [102, 205, 170],
                    mediumblue: [0, 0, 205],
                    mediumorchid: [186, 85, 211],
                    mediumpurple: [147, 112, 219],
                    mediumseagreen: [60, 179, 113],
                    mediumslateblue: [123, 104, 238],
                    mediumspringgreen: [0, 250, 154],
                    mediumturquoise: [72, 209, 204],
                    mediumvioletred: [199, 21, 133],
                    midnightblue: [25, 25, 112],
                    mintcream: [245, 255, 250],
                    mistyrose: [255, 228, 225],
                    moccasin: [255, 228, 181],
                    navajowhite: [255, 222, 173],
                    navy: [0, 0, 128],
                    oldlace: [253, 245, 230],
                    olive: [128, 128, 0],
                    olivedrab: [107, 142, 35],
                    orange: [255, 165, 0],
                    orangered: [255, 69, 0],
                    orchid: [218, 112, 214],
                    palegoldenrod: [238, 232, 170],
                    palegreen: [152, 251, 152],
                    paleturquoise: [175, 238, 238],
                    palevioletred: [219, 112, 147],
                    papayawhip: [255, 239, 213],
                    peachpuff: [255, 218, 185],
                    peru: [205, 133, 63],
                    pink: [255, 192, 203],
                    plum: [221, 160, 221],
                    powderblue: [176, 224, 230],
                    purple: [128, 0, 128],
                    rebeccapurple: [102, 51, 153],
                    red: [255, 0, 0],
                    rosybrown: [188, 143, 143],
                    royalblue: [65, 105, 225],
                    saddlebrown: [139, 69, 19],
                    salmon: [250, 128, 114],
                    sandybrown: [244, 164, 96],
                    seagreen: [46, 139, 87],
                    seashell: [255, 245, 238],
                    sienna: [160, 82, 45],
                    silver: [192, 192, 192],
                    skyblue: [135, 206, 235],
                    slateblue: [106, 90, 205],
                    slategray: [112, 128, 144],
                    slategrey: [112, 128, 144],
                    snow: [255, 250, 250],
                    springgreen: [0, 255, 127],
                    steelblue: [70, 130, 180],
                    tan: [210, 180, 140],
                    teal: [0, 128, 128],
                    thistle: [216, 191, 216],
                    tomato: [255, 99, 71],
                    turquoise: [64, 224, 208],
                    violet: [238, 130, 238],
                    wheat: [245, 222, 179],
                    white: [255, 255, 255],
                    whitesmoke: [245, 245, 245],
                    yellow: [255, 255, 0]
                  };
                  var DefaultColors = {
                    black: [NamedColors.black, 1],
                    white: [NamedColors.white, 1],
                    transparent: [NamedColors.black, 0]
                  };
                  var Entities = {
                    quot: 34,
                    amp: 38,
                    lt: 60,
                    gt: 62,
                    apos: 39,
                    OElig: 338,
                    oelig: 339,
                    Scaron: 352,
                    scaron: 353,
                    Yuml: 376,
                    circ: 710,
                    tilde: 732,
                    ensp: 8194,
                    emsp: 8195,
                    thinsp: 8201,
                    zwnj: 8204,
                    zwj: 8205,
                    lrm: 8206,
                    rlm: 8207,
                    ndash: 8211,
                    mdash: 8212,
                    lsquo: 8216,
                    rsquo: 8217,
                    sbquo: 8218,
                    ldquo: 8220,
                    rdquo: 8221,
                    bdquo: 8222,
                    dagger: 8224,
                    Dagger: 8225,
                    permil: 8240,
                    lsaquo: 8249,
                    rsaquo: 8250,
                    euro: 8364,
                    nbsp: 160,
                    iexcl: 161,
                    cent: 162,
                    pound: 163,
                    curren: 164,
                    yen: 165,
                    brvbar: 166,
                    sect: 167,
                    uml: 168,
                    copy: 169,
                    ordf: 170,
                    laquo: 171,
                    not: 172,
                    shy: 173,
                    reg: 174,
                    macr: 175,
                    deg: 176,
                    plusmn: 177,
                    sup2: 178,
                    sup3: 179,
                    acute: 180,
                    micro: 181,
                    para: 182,
                    middot: 183,
                    cedil: 184,
                    sup1: 185,
                    ordm: 186,
                    raquo: 187,
                    frac14: 188,
                    frac12: 189,
                    frac34: 190,
                    iquest: 191,
                    Agrave: 192,
                    Aacute: 193,
                    Acirc: 194,
                    Atilde: 195,
                    Auml: 196,
                    Aring: 197,
                    AElig: 198,
                    Ccedil: 199,
                    Egrave: 200,
                    Eacute: 201,
                    Ecirc: 202,
                    Euml: 203,
                    Igrave: 204,
                    Iacute: 205,
                    Icirc: 206,
                    Iuml: 207,
                    ETH: 208,
                    Ntilde: 209,
                    Ograve: 210,
                    Oacute: 211,
                    Ocirc: 212,
                    Otilde: 213,
                    Ouml: 214,
                    times: 215,
                    Oslash: 216,
                    Ugrave: 217,
                    Uacute: 218,
                    Ucirc: 219,
                    Uuml: 220,
                    Yacute: 221,
                    THORN: 222,
                    szlig: 223,
                    agrave: 224,
                    aacute: 225,
                    acirc: 226,
                    atilde: 227,
                    auml: 228,
                    aring: 229,
                    aelig: 230,
                    ccedil: 231,
                    egrave: 232,
                    eacute: 233,
                    ecirc: 234,
                    euml: 235,
                    igrave: 236,
                    iacute: 237,
                    icirc: 238,
                    iuml: 239,
                    eth: 240,
                    ntilde: 241,
                    ograve: 242,
                    oacute: 243,
                    ocirc: 244,
                    otilde: 245,
                    ouml: 246,
                    divide: 247,
                    oslash: 248,
                    ugrave: 249,
                    uacute: 250,
                    ucirc: 251,
                    uuml: 252,
                    yacute: 253,
                    thorn: 254,
                    yuml: 255,
                    fnof: 402,
                    Alpha: 913,
                    Beta: 914,
                    Gamma: 915,
                    Delta: 916,
                    Epsilon: 917,
                    Zeta: 918,
                    Eta: 919,
                    Theta: 920,
                    Iota: 921,
                    Kappa: 922,
                    Lambda: 923,
                    Mu: 924,
                    Nu: 925,
                    Xi: 926,
                    Omicron: 927,
                    Pi: 928,
                    Rho: 929,
                    Sigma: 931,
                    Tau: 932,
                    Upsilon: 933,
                    Phi: 934,
                    Chi: 935,
                    Psi: 936,
                    Omega: 937,
                    alpha: 945,
                    beta: 946,
                    gamma: 947,
                    delta: 948,
                    epsilon: 949,
                    zeta: 950,
                    eta: 951,
                    theta: 952,
                    iota: 953,
                    kappa: 954,
                    lambda: 955,
                    mu: 956,
                    nu: 957,
                    xi: 958,
                    omicron: 959,
                    pi: 960,
                    rho: 961,
                    sigmaf: 962,
                    sigma: 963,
                    tau: 964,
                    upsilon: 965,
                    phi: 966,
                    chi: 967,
                    psi: 968,
                    omega: 969,
                    thetasym: 977,
                    upsih: 978,
                    piv: 982,
                    bull: 8226,
                    hellip: 8230,
                    prime: 8242,
                    Prime: 8243,
                    oline: 8254,
                    frasl: 8260,
                    weierp: 8472,
                    image: 8465,
                    real: 8476,
                    trade: 8482,
                    alefsym: 8501,
                    larr: 8592,
                    uarr: 8593,
                    rarr: 8594,
                    darr: 8595,
                    harr: 8596,
                    crarr: 8629,
                    lArr: 8656,
                    uArr: 8657,
                    rArr: 8658,
                    dArr: 8659,
                    hArr: 8660,
                    forall: 8704,
                    part: 8706,
                    exist: 8707,
                    empty: 8709,
                    nabla: 8711,
                    isin: 8712,
                    notin: 8713,
                    ni: 8715,
                    prod: 8719,
                    sum: 8721,
                    minus: 8722,
                    lowast: 8727,
                    radic: 8730,
                    prop: 8733,
                    infin: 8734,
                    ang: 8736,
                    and: 8743,
                    or: 8744,
                    cap: 8745,
                    cup: 8746,
                    int: 8747,
                    there4: 8756,
                    sim: 8764,
                    cong: 8773,
                    asymp: 8776,
                    ne: 8800,
                    equiv: 8801,
                    le: 8804,
                    ge: 8805,
                    sub: 8834,
                    sup: 8835,
                    nsub: 8836,
                    sube: 8838,
                    supe: 8839,
                    oplus: 8853,
                    otimes: 8855,
                    perp: 8869,
                    sdot: 8901,
                    lceil: 8968,
                    rceil: 8969,
                    lfloor: 8970,
                    rfloor: 8971,
                    lang: 9001,
                    rang: 9002,
                    loz: 9674,
                    spades: 9824,
                    clubs: 9827,
                    hearts: 9829,
                    diams: 9830
                  };
                  var PathArguments = {
                    A: 7,
                    a: 7,
                    C: 6,
                    c: 6,
                    H: 1,
                    h: 1,
                    L: 2,
                    l: 2,
                    M: 2,
                    m: 2,
                    Q: 4,
                    q: 4,
                    S: 4,
                    s: 4,
                    T: 2,
                    t: 2,
                    V: 1,
                    v: 1,
                    Z: 0,
                    z: 0
                  };
                  var PathFlags = {
                    A3: true,
                    A4: true,
                    a3: true,
                    a4: true
                  };
                  var Properties = {
                    "color": {
                      inherit: true,
                      initial: void 0
                    },
                    "visibility": {
                      inherit: true,
                      initial: "visible",
                      values: {
                        "hidden": "hidden",
                        "collapse": "hidden",
                        "visible": "visible"
                      }
                    },
                    "fill": {
                      inherit: true,
                      initial: DefaultColors.black
                    },
                    "stroke": {
                      inherit: true,
                      initial: "none"
                    },
                    "stop-color": {
                      inherit: false,
                      initial: DefaultColors.black
                    },
                    "fill-opacity": {
                      inherit: true,
                      initial: 1
                    },
                    "stroke-opacity": {
                      inherit: true,
                      initial: 1
                    },
                    "stop-opacity": {
                      inherit: false,
                      initial: 1
                    },
                    "fill-rule": {
                      inherit: true,
                      initial: "nonzero",
                      values: {
                        "nonzero": "nonzero",
                        "evenodd": "evenodd"
                      }
                    },
                    "clip-rule": {
                      inherit: true,
                      initial: "nonzero",
                      values: {
                        "nonzero": "nonzero",
                        "evenodd": "evenodd"
                      }
                    },
                    "stroke-width": {
                      inherit: true,
                      initial: 1
                    },
                    "stroke-dasharray": {
                      inherit: true,
                      initial: []
                    },
                    "stroke-dashoffset": {
                      inherit: true,
                      initial: 0
                    },
                    "stroke-miterlimit": {
                      inherit: true,
                      initial: 4
                    },
                    "stroke-linejoin": {
                      inherit: true,
                      initial: "miter",
                      values: {
                        "miter": "miter",
                        "round": "round",
                        "bevel": "bevel"
                      }
                    },
                    "stroke-linecap": {
                      inherit: true,
                      initial: "butt",
                      values: {
                        "butt": "butt",
                        "round": "round",
                        "square": "square"
                      }
                    },
                    "font-size": {
                      inherit: true,
                      initial: 16,
                      values: {
                        "xx-small": 9,
                        "x-small": 10,
                        "small": 13,
                        "medium": 16,
                        "large": 18,
                        "x-large": 24,
                        "xx-large": 32
                      }
                    },
                    "font-family": {
                      inherit: true,
                      initial: "sans-serif"
                    },
                    "font-weight": {
                      inherit: true,
                      initial: "normal",
                      values: {
                        "600": "bold",
                        "700": "bold",
                        "800": "bold",
                        "900": "bold",
                        "bold": "bold",
                        "bolder": "bold",
                        "500": "normal",
                        "400": "normal",
                        "300": "normal",
                        "200": "normal",
                        "100": "normal",
                        "normal": "normal",
                        "lighter": "normal"
                      }
                    },
                    "font-style": {
                      inherit: true,
                      initial: "normal",
                      values: {
                        "italic": "italic",
                        "oblique": "italic",
                        "normal": "normal"
                      }
                    },
                    "text-anchor": {
                      inherit: true,
                      initial: "start",
                      values: {
                        "start": "start",
                        "middle": "middle",
                        "end": "end"
                      }
                    },
                    "direction": {
                      inherit: true,
                      initial: "ltr",
                      values: {
                        "ltr": "ltr",
                        "rtl": "rtl"
                      }
                    },
                    "dominant-baseline": {
                      inherit: true,
                      initial: "baseline",
                      values: {
                        "auto": "baseline",
                        "baseline": "baseline",
                        "before-edge": "before-edge",
                        "text-before-edge": "before-edge",
                        "middle": "middle",
                        "central": "central",
                        "after-edge": "after-edge",
                        "text-after-edge": "after-edge",
                        "ideographic": "ideographic",
                        "alphabetic": "alphabetic",
                        "hanging": "hanging",
                        "mathematical": "mathematical"
                      }
                    },
                    "alignment-baseline": {
                      inherit: false,
                      initial: void 0,
                      values: {
                        "auto": "baseline",
                        "baseline": "baseline",
                        "before-edge": "before-edge",
                        "text-before-edge": "before-edge",
                        "middle": "middle",
                        "central": "central",
                        "after-edge": "after-edge",
                        "text-after-edge": "after-edge",
                        "ideographic": "ideographic",
                        "alphabetic": "alphabetic",
                        "hanging": "hanging",
                        "mathematical": "mathematical"
                      }
                    },
                    "baseline-shift": {
                      inherit: true,
                      initial: "baseline",
                      values: {
                        "baseline": "baseline",
                        "sub": "sub",
                        "super": "super"
                      }
                    },
                    "word-spacing": {
                      inherit: true,
                      initial: 0,
                      values: {
                        normal: 0
                      }
                    },
                    "letter-spacing": {
                      inherit: true,
                      initial: 0,
                      values: {
                        normal: 0
                      }
                    },
                    "text-decoration": {
                      inherit: false,
                      initial: "none",
                      values: {
                        "none": "none",
                        "underline": "underline",
                        "overline": "overline",
                        "line-through": "line-through"
                      }
                    },
                    "xml:space": {
                      inherit: true,
                      initial: "default",
                      css: "white-space",
                      values: {
                        "preserve": "preserve",
                        "default": "default",
                        "pre": "preserve",
                        "pre-line": "preserve",
                        "pre-wrap": "preserve",
                        "nowrap": "default"
                      }
                    },
                    "marker-start": {
                      inherit: true,
                      initial: "none"
                    },
                    "marker-mid": {
                      inherit: true,
                      initial: "none"
                    },
                    "marker-end": {
                      inherit: true,
                      initial: "none"
                    },
                    "opacity": {
                      inherit: false,
                      initial: 1
                    },
                    "transform": {
                      inherit: false,
                      initial: [1, 0, 0, 1, 0, 0]
                    },
                    "display": {
                      inherit: false,
                      initial: "inline",
                      values: {
                        "none": "none",
                        "inline": "inline",
                        "block": "inline"
                      }
                    },
                    "clip-path": {
                      inherit: false,
                      initial: "none"
                    },
                    "mask": {
                      inherit: false,
                      initial: "none"
                    },
                    "overflow": {
                      inherit: false,
                      initial: "hidden",
                      values: {
                        "hidden": "hidden",
                        "scroll": "hidden",
                        "visible": "visible"
                      }
                    }
                  };
                  function docBeginGroup(bbox) {
                    var group = new function PDFGroup() {
                    }();
                    group.name = "G" + (doc._groupCount = (doc._groupCount || 0) + 1);
                    group.resources = doc.ref();
                    group.xobj = doc.ref({
                      Type: "XObject",
                      Subtype: "Form",
                      FormType: 1,
                      BBox: bbox,
                      Group: {
                        S: "Transparency",
                        CS: "DeviceRGB",
                        I: true,
                        K: false
                      },
                      Resources: group.resources
                    });
                    group.xobj.write("");
                    group.savedMatrix = doc._ctm;
                    group.savedPage = doc.page;
                    groupStack.push(group);
                    doc._ctm = [1, 0, 0, 1, 0, 0];
                    doc.page = {
                      width: doc.page.width,
                      height: doc.page.height,
                      write: function write(data) {
                        group.xobj.write(data);
                      },
                      fonts: {},
                      xobjects: {},
                      ext_gstates: {},
                      patterns: {}
                    };
                    return group;
                  }
                  function docEndGroup(group) {
                    if (group !== groupStack.pop()) {
                      throw "Group not matching";
                    }
                    if (Object.keys(doc.page.fonts).length) {
                      group.resources.data.Font = doc.page.fonts;
                    }
                    if (Object.keys(doc.page.xobjects).length) {
                      group.resources.data.XObject = doc.page.xobjects;
                    }
                    if (Object.keys(doc.page.ext_gstates).length) {
                      group.resources.data.ExtGState = doc.page.ext_gstates;
                    }
                    if (Object.keys(doc.page.patterns).length) {
                      group.resources.data.Pattern = doc.page.patterns;
                    }
                    group.resources.end();
                    group.xobj.end();
                    doc._ctm = group.savedMatrix;
                    doc.page = group.savedPage;
                  }
                  function docInsertGroup(group) {
                    doc.page.xobjects[group.name] = group.xobj;
                    doc.addContent("/" + group.name + " Do");
                  }
                  function docApplyMask(group, clip) {
                    var name = "M" + (doc._maskCount = (doc._maskCount || 0) + 1);
                    var gstate = doc.ref({
                      Type: "ExtGState",
                      CA: 1,
                      ca: 1,
                      BM: "Normal",
                      SMask: {
                        S: "Luminosity",
                        G: group.xobj,
                        BC: clip ? [0, 0, 0] : [1, 1, 1]
                      }
                    });
                    gstate.end();
                    doc.page.ext_gstates[name] = gstate;
                    doc.addContent("/" + name + " gs");
                  }
                  function docCreatePattern(group, dx, dy, matrix) {
                    var pattern = new function PDFPattern() {
                    }();
                    pattern.group = group;
                    pattern.dx = dx;
                    pattern.dy = dy;
                    pattern.matrix = matrix || [1, 0, 0, 1, 0, 0];
                    return pattern;
                  }
                  function docUsePattern(pattern, stroke) {
                    var name = "P" + (doc._patternCount = (doc._patternCount || 0) + 1);
                    var ref = doc.ref({
                      Type: "Pattern",
                      PatternType: 1,
                      PaintType: 1,
                      TilingType: 2,
                      BBox: [0, 0, pattern.dx, pattern.dy],
                      XStep: pattern.dx,
                      YStep: pattern.dy,
                      Matrix: multiplyMatrix(doc._ctm, pattern.matrix),
                      Resources: {
                        ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
                        XObject: function() {
                          var temp = {};
                          temp[pattern.group.name] = pattern.group.xobj;
                          return temp;
                        }()
                      }
                    });
                    ref.write("/" + pattern.group.name + " Do");
                    ref.end();
                    doc.page.patterns[name] = ref;
                    if (stroke) {
                      doc.addContent("/Pattern CS");
                      doc.addContent("/" + name + " SCN");
                    } else {
                      doc.addContent("/Pattern cs");
                      doc.addContent("/" + name + " scn");
                    }
                  }
                  function docBeginText(font, size) {
                    if (!doc.page.fonts[font.id]) {
                      doc.page.fonts[font.id] = font.ref();
                    }
                    doc.addContent("BT").addContent("/" + font.id + " " + size + " Tf");
                  }
                  function docSetTextMatrix(a, b, c, d, e, f) {
                    doc.addContent(validateNumber(a) + " " + validateNumber(b) + " " + validateNumber(-c) + " " + validateNumber(-d) + " " + validateNumber(e) + " " + validateNumber(f) + " Tm");
                  }
                  function docSetTextMode(fill, stroke) {
                    var mode = fill && stroke ? 2 : stroke ? 1 : fill ? 0 : 3;
                    doc.addContent(mode + " Tr");
                  }
                  function docWriteGlyph(glyph) {
                    doc.addContent("<" + glyph + "> Tj");
                  }
                  function docEndText() {
                    doc.addContent("ET");
                  }
                  function docFillColor(color2) {
                    if (color2[0].constructor.name === "PDFPattern") {
                      doc.fillOpacity(color2[1]);
                      docUsePattern(color2[0], false);
                    } else {
                      doc.fillColor(color2[0], color2[1]);
                    }
                  }
                  function docStrokeColor(color2) {
                    if (color2[0].constructor.name === "PDFPattern") {
                      doc.strokeOpacity(color2[1]);
                      docUsePattern(color2[0], true);
                    } else {
                      doc.strokeColor(color2[0], color2[1]);
                    }
                  }
                  function docInsertLink(x2, y2, w, h, url) {
                    var ref = doc.ref({
                      Type: "Annot",
                      Subtype: "Link",
                      Rect: [x2, y2, w, h],
                      Border: [0, 0, 0],
                      A: {
                        S: "URI",
                        URI: new String(url)
                      }
                    });
                    ref.end();
                    links.push(ref);
                  }
                  function parseXml(xml) {
                    var SvgNode = function SvgNode2(tag, type, value, error2) {
                      this.error = error2;
                      this.nodeName = tag;
                      this.nodeValue = value;
                      this.nodeType = type;
                      this.attributes = /* @__PURE__ */ Object.create(null);
                      this.childNodes = [];
                      this.parentNode = null;
                      this.id = "";
                      this.textContent = "";
                      this.classList = [];
                    };
                    SvgNode.prototype.getAttribute = function(attr) {
                      return this.attributes[attr] != null ? this.attributes[attr] : null;
                    };
                    SvgNode.prototype.getElementById = function(id) {
                      var result2 = null;
                      (function recursive2(node) {
                        if (result2) {
                          return;
                        }
                        if (node.nodeType === 1) {
                          if (node.id === id) {
                            result2 = node;
                          }
                          for (var i2 = 0; i2 < node.childNodes.length; i2++) {
                            recursive2(node.childNodes[i2]);
                          }
                        }
                      })(this);
                      return result2;
                    };
                    SvgNode.prototype.getElementsByTagName = function(tag) {
                      var result2 = [];
                      (function recursive2(node) {
                        if (node.nodeType === 1) {
                          if (node.nodeName === tag) {
                            result2.push(node);
                          }
                          for (var i2 = 0; i2 < node.childNodes.length; i2++) {
                            recursive2(node.childNodes[i2]);
                          }
                        }
                      })(this);
                      return result2;
                    };
                    var parser = new StringParser(xml.trim()), result, child, error = false;
                    var recursive = function recursive2() {
                      var temp, child2;
                      if (temp = parser.match(/^<([\w:.-]+)\s*/, true)) {
                        var node = new SvgNode(temp[1], 1, null, error);
                        while (temp = parser.match(/^([\w:.-]+)(?:\s*=\s*"([^"]*)"|\s*=\s*'([^']*)')?\s*/, true)) {
                          var attr = temp[1], value = decodeEntities(temp[2] || temp[3] || "");
                          if (!node.attributes[attr]) {
                            node.attributes[attr] = value;
                            if (attr === "id") {
                              node.id = value;
                            }
                            if (attr === "class") {
                              node.classList = value.split(" ");
                            }
                          } else {
                            warningCallback('parseXml: duplicate attribute "' + attr + '"');
                            error = true;
                          }
                        }
                        if (parser.match(/^>/)) {
                          while (child2 = recursive2()) {
                            node.childNodes.push(child2);
                            child2.parentNode = node;
                            node.textContent += child2.nodeType === 3 || child2.nodeType === 4 ? child2.nodeValue : child2.textContent;
                          }
                          if (temp = parser.match(/^<\/([\w:.-]+)\s*>/, true)) {
                            if (temp[1] === node.nodeName) {
                              return node;
                            } else {
                              warningCallback('parseXml: tag not matching, opening "' + node.nodeName + '" & closing "' + temp[1] + '"');
                              error = true;
                              return node;
                            }
                          } else {
                            warningCallback('parseXml: tag not matching, opening "' + node.nodeName + '" & not closing');
                            error = true;
                            return node;
                          }
                        } else if (parser.match(/^\/>/)) {
                          return node;
                        } else {
                          warningCallback('parseXml: tag could not be parsed "' + node.nodeName + '"');
                          error = true;
                        }
                      } else if (temp = parser.match(/^<!--[\s\S]*?-->/)) {
                        return new SvgNode(null, 8, temp, error);
                      } else if (temp = parser.match(/^<\?[\s\S]*?\?>/)) {
                        return new SvgNode(null, 7, temp, error);
                      } else if (temp = parser.match(/^<!DOCTYPE\s*([\s\S]*?)>/)) {
                        return new SvgNode(null, 10, temp, error);
                      } else if (temp = parser.match(/^<!\[CDATA\[([\s\S]*?)\]\]>/, true)) {
                        return new SvgNode("#cdata-section", 4, temp[1], error);
                      } else if (temp = parser.match(/^([^<]+)/, true)) {
                        return new SvgNode("#text", 3, decodeEntities(temp[1]), error);
                      }
                    };
                    while (child = recursive()) {
                      if (child.nodeType === 1 && !result) {
                        result = child;
                      } else if (child.nodeType === 1 || child.nodeType === 3 && child.nodeValue.trim() !== "") {
                        warningCallback("parseXml: data after document end has been discarded");
                      }
                    }
                    if (parser.matchAll()) {
                      warningCallback("parseXml: parsing error");
                    }
                    return result;
                  }
                  ;
                  function decodeEntities(str) {
                    return str.replace(/&(?:#([0-9]+)|#[xX]([0-9A-Fa-f]+)|([0-9A-Za-z]+));/g, function(mt, m0, m1, m2) {
                      if (m0) {
                        return String.fromCharCode(parseInt(m0, 10));
                      } else if (m1) {
                        return String.fromCharCode(parseInt(m1, 16));
                      } else if (m2 && Entities[m2]) {
                        return String.fromCharCode(Entities[m2]);
                      } else {
                        return mt;
                      }
                    });
                  }
                  function parseColor(raw) {
                    var temp, result;
                    raw = (raw || "").trim();
                    if (temp = NamedColors[raw]) {
                      result = [temp.slice(), 1];
                    } else if (temp = raw.match(/^rgba\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9.]+)\s*\)$/i)) {
                      temp[1] = parseInt(temp[1]);
                      temp[2] = parseInt(temp[2]);
                      temp[3] = parseInt(temp[3]);
                      temp[4] = parseFloat(temp[4]);
                      if (temp[1] < 256 && temp[2] < 256 && temp[3] < 256 && temp[4] <= 1) {
                        result = [temp.slice(1, 4), temp[4]];
                      }
                    } else if (temp = raw.match(/^rgb\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)$/i)) {
                      temp[1] = parseInt(temp[1]);
                      temp[2] = parseInt(temp[2]);
                      temp[3] = parseInt(temp[3]);
                      if (temp[1] < 256 && temp[2] < 256 && temp[3] < 256) {
                        result = [temp.slice(1, 4), 1];
                      }
                    } else if (temp = raw.match(/^rgb\(\s*([0-9.]+)%\s*,\s*([0-9.]+)%\s*,\s*([0-9.]+)%\s*\)$/i)) {
                      temp[1] = 2.55 * parseFloat(temp[1]);
                      temp[2] = 2.55 * parseFloat(temp[2]);
                      temp[3] = 2.55 * parseFloat(temp[3]);
                      if (temp[1] < 256 && temp[2] < 256 && temp[3] < 256) {
                        result = [temp.slice(1, 4), 1];
                      }
                    } else if (temp = raw.match(/^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i)) {
                      result = [[parseInt(temp[1], 16), parseInt(temp[2], 16), parseInt(temp[3], 16)], 1];
                    } else if (temp = raw.match(/^#([0-9a-f])([0-9a-f])([0-9a-f])$/i)) {
                      result = [[17 * parseInt(temp[1], 16), 17 * parseInt(temp[2], 16), 17 * parseInt(temp[3], 16)], 1];
                    }
                    return colorCallback ? colorCallback(result, raw) : result;
                  }
                  function opacityToColor(color2, opacity, isMask) {
                    var newColor2 = color2[0].slice(), newOpacity = color2[1] * opacity;
                    if (isMask) {
                      for (var i2 = 0; i2 < color2.length; i2++) {
                        newColor2[i2] *= newOpacity;
                      }
                      return [newColor2, 1];
                    } else {
                      return [newColor2, newOpacity];
                    }
                  }
                  function multiplyMatrix() {
                    function multiply(a, b) {
                      return [a[0] * b[0] + a[2] * b[1], a[1] * b[0] + a[3] * b[1], a[0] * b[2] + a[2] * b[3], a[1] * b[2] + a[3] * b[3], a[0] * b[4] + a[2] * b[5] + a[4], a[1] * b[4] + a[3] * b[5] + a[5]];
                    }
                    var result = arguments[0];
                    for (var i2 = 1; i2 < arguments.length; i2++) {
                      result = multiply(result, arguments[i2]);
                    }
                    return result;
                  }
                  function transformPoint(p, m) {
                    return [m[0] * p[0] + m[2] * p[1] + m[4], m[1] * p[0] + m[3] * p[1] + m[5]];
                  }
                  function getGlobalMatrix() {
                    var ctm = doc._ctm;
                    for (var i2 = groupStack.length - 1; i2 >= 0; i2--) {
                      ctm = multiplyMatrix(groupStack[i2].savedMatrix, ctm);
                    }
                    return ctm;
                  }
                  function getPageBBox() {
                    return new SvgShape().M(0, 0).L(doc.page.width, 0).L(doc.page.width, doc.page.height).L(0, doc.page.height).transform(inverseMatrix(getGlobalMatrix())).getBoundingBox();
                  }
                  function inverseMatrix(m) {
                    var dt = m[0] * m[3] - m[1] * m[2];
                    return [m[3] / dt, -m[1] / dt, -m[2] / dt, m[0] / dt, (m[2] * m[5] - m[3] * m[4]) / dt, (m[1] * m[4] - m[0] * m[5]) / dt];
                  }
                  function validateMatrix(m) {
                    var m0 = validateNumber(m[0]), m1 = validateNumber(m[1]), m2 = validateNumber(m[2]), m3 = validateNumber(m[3]), m4 = validateNumber(m[4]), m5 = validateNumber(m[5]);
                    if (isNotEqual(m0 * m3 - m1 * m2, 0)) {
                      return [m0, m1, m2, m3, m4, m5];
                    }
                  }
                  function solveEquation(curve) {
                    var a = curve[2] || 0, b = curve[1] || 0, c = curve[0] || 0;
                    if (isEqual(a, 0) && isEqual(b, 0)) {
                      return [];
                    } else if (isEqual(a, 0)) {
                      return [-c / b];
                    } else {
                      var d = b * b - 4 * a * c;
                      if (isNotEqual(d, 0) && d > 0) {
                        return [(-b + Math.sqrt(d)) / (2 * a), (-b - Math.sqrt(d)) / (2 * a)];
                      } else if (isEqual(d, 0)) {
                        return [-b / (2 * a)];
                      } else {
                        return [];
                      }
                    }
                  }
                  function getCurveValue(t, curve) {
                    return (curve[0] || 0) + (curve[1] || 0) * t + (curve[2] || 0) * t * t + (curve[3] || 0) * t * t * t;
                  }
                  function isEqual(number, ref) {
                    return Math.abs(number - ref) < 1e-10;
                  }
                  function isNotEqual(number, ref) {
                    return Math.abs(number - ref) >= 1e-10;
                  }
                  function validateNumber(n) {
                    return n > -1e21 && n < 1e21 ? Math.round(n * 1e6) / 1e6 : 0;
                  }
                  function isArrayLike(v) {
                    return typeof v === "object" && v !== null && typeof v.length === "number";
                  }
                  function parseTranform(v) {
                    var parser = new StringParser((v || "").trim()), result = [1, 0, 0, 1, 0, 0], temp;
                    while (temp = parser.match(/^([A-Za-z]+)\s*[(]([^(]+)[)]/, true)) {
                      var func = temp[1], nums = [], parser2 = new StringParser(temp[2].trim()), temp2 = void 0;
                      while (temp2 = parser2.matchNumber()) {
                        nums.push(Number(temp2));
                        parser2.matchSeparator();
                      }
                      if (func === "matrix" && nums.length === 6) {
                        result = multiplyMatrix(result, [nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]]);
                      } else if (func === "translate" && nums.length === 2) {
                        result = multiplyMatrix(result, [1, 0, 0, 1, nums[0], nums[1]]);
                      } else if (func === "translate" && nums.length === 1) {
                        result = multiplyMatrix(result, [1, 0, 0, 1, nums[0], 0]);
                      } else if (func === "scale" && nums.length === 2) {
                        result = multiplyMatrix(result, [nums[0], 0, 0, nums[1], 0, 0]);
                      } else if (func === "scale" && nums.length === 1) {
                        result = multiplyMatrix(result, [nums[0], 0, 0, nums[0], 0, 0]);
                      } else if (func === "rotate" && nums.length === 3) {
                        var a = nums[0] * Math.PI / 180;
                        result = multiplyMatrix(result, [1, 0, 0, 1, nums[1], nums[2]], [Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0], [1, 0, 0, 1, -nums[1], -nums[2]]);
                      } else if (func === "rotate" && nums.length === 1) {
                        var _a = nums[0] * Math.PI / 180;
                        result = multiplyMatrix(result, [Math.cos(_a), Math.sin(_a), -Math.sin(_a), Math.cos(_a), 0, 0]);
                      } else if (func === "skewX" && nums.length === 1) {
                        var _a2 = nums[0] * Math.PI / 180;
                        result = multiplyMatrix(result, [1, 0, Math.tan(_a2), 1, 0, 0]);
                      } else if (func === "skewY" && nums.length === 1) {
                        var _a3 = nums[0] * Math.PI / 180;
                        result = multiplyMatrix(result, [1, Math.tan(_a3), 0, 1, 0, 0]);
                      } else {
                        return;
                      }
                      parser.matchSeparator();
                    }
                    if (parser.matchAll()) {
                      return;
                    }
                    return result;
                  }
                  function parseAspectRatio(aspectRatio, availWidth, availHeight, elemWidth, elemHeight, initAlign) {
                    var temp = (aspectRatio || "").trim().match(/^(none)$|^x(Min|Mid|Max)Y(Min|Mid|Max)(?:\s+(meet|slice))?$/) || [], ratioType = temp[1] || temp[4] || "meet", xAlign = temp[2] || "Mid", yAlign = temp[3] || "Mid", scaleX = availWidth / elemWidth, scaleY = availHeight / elemHeight, dx = {
                      "Min": 0,
                      "Mid": 0.5,
                      "Max": 1
                    }[xAlign] - (initAlign || 0), dy = {
                      "Min": 0,
                      "Mid": 0.5,
                      "Max": 1
                    }[yAlign] - (initAlign || 0);
                    if (ratioType === "slice") {
                      scaleY = scaleX = Math.max(scaleX, scaleY);
                    } else if (ratioType === "meet") {
                      scaleY = scaleX = Math.min(scaleX, scaleY);
                    }
                    return [scaleX, 0, 0, scaleY, dx * (availWidth - elemWidth * scaleX), dy * (availHeight - elemHeight * scaleY)];
                  }
                  function parseStyleAttr(v) {
                    var result = /* @__PURE__ */ Object.create(null);
                    v = (v || "").trim().split(/;/);
                    for (var i2 = 0; i2 < v.length; i2++) {
                      var key = (v[i2].split(":")[0] || "").trim(), value = (v[i2].split(":")[1] || "").trim();
                      if (key) {
                        result[key] = value;
                      }
                    }
                    if (result["marker"]) {
                      if (!result["marker-start"]) {
                        result["marker-start"] = result["marker"];
                      }
                      if (!result["marker-mid"]) {
                        result["marker-mid"] = result["marker"];
                      }
                      if (!result["marker-end"]) {
                        result["marker-end"] = result["marker"];
                      }
                    }
                    if (result["font"]) {
                      var fontFamily = null, fontSize = null, fontStyle = "normal", fontWeight = "normal", fontVariant = "normal";
                      var parts = result["font"].split(/\s+/);
                      for (var _i = 0; _i < parts.length; _i++) {
                        switch (parts[_i]) {
                          case "normal":
                            break;
                          case "italic":
                          case "oblique":
                            fontStyle = parts[_i];
                            break;
                          case "small-caps":
                            fontVariant = parts[_i];
                            break;
                          case "bold":
                          case "bolder":
                          case "lighter":
                          case "100":
                          case "200":
                          case "300":
                          case "400":
                          case "500":
                          case "600":
                          case "700":
                          case "800":
                          case "900":
                            fontWeight = parts[_i];
                            break;
                          default:
                            if (!fontSize) {
                              fontSize = parts[_i].split("/")[0];
                            } else {
                              if (!fontFamily) {
                                fontFamily = parts[_i];
                              } else {
                                fontFamily += " " + parts[_i];
                              }
                            }
                            break;
                        }
                      }
                      if (!result["font-style"]) {
                        result["font-style"] = fontStyle;
                      }
                      if (!result["font-variant"]) {
                        result["font-variant"] = fontVariant;
                      }
                      if (!result["font-weight"]) {
                        result["font-weight"] = fontWeight;
                      }
                      if (!result["font-size"]) {
                        result["font-size"] = fontSize;
                      }
                      if (!result["font-family"]) {
                        result["font-family"] = fontFamily;
                      }
                    }
                    return result;
                  }
                  function parseSelector(v) {
                    var parts = v.split(/(?=[.#])/g), ids = [], classes = [], tags = [], temp;
                    for (var i2 = 0; i2 < parts.length; i2++) {
                      if (temp = parts[i2].match(/^[#]([_A-Za-z0-9-]+)$/)) {
                        ids.push(temp[1]);
                      } else if (temp = parts[i2].match(/^[.]([_A-Za-z0-9-]+)$/)) {
                        classes.push(temp[1]);
                      } else if (temp = parts[i2].match(/^([_A-Za-z0-9-]+)$/)) {
                        tags.push(temp[1]);
                      } else if (parts[i2] !== "*") {
                        return;
                      }
                    }
                    return {
                      tags,
                      ids,
                      classes,
                      specificity: ids.length * 1e4 + classes.length * 100 + tags.length
                    };
                  }
                  function parseStyleSheet(v) {
                    var parser = new StringParser(v.trim()), rules = [], rule;
                    while (rule = parser.match(/^\s*([^\{\}]*?)\s*\{([^\{\}]*?)\}/, true)) {
                      var selectors = rule[1].split(/\s*,\s*/g), css = parseStyleAttr(rule[2]);
                      for (var i2 = 0; i2 < selectors.length; i2++) {
                        var selector = parseSelector(selectors[i2]);
                        if (selector) {
                          rules.push({
                            selector,
                            css
                          });
                        }
                      }
                    }
                    return rules;
                  }
                  function matchesSelector(elem2, selector) {
                    if (elem2.nodeType !== 1) {
                      return false;
                    }
                    for (var i2 = 0; i2 < selector.tags.length; i2++) {
                      if (selector.tags[i2] !== elem2.nodeName) {
                        return false;
                      }
                    }
                    for (var _i2 = 0; _i2 < selector.ids.length; _i2++) {
                      if (selector.ids[_i2] !== elem2.id) {
                        return false;
                      }
                    }
                    for (var _i3 = 0; _i3 < selector.classes.length; _i3++) {
                      if (elem2.classList.indexOf(selector.classes[_i3]) === -1) {
                        return false;
                      }
                    }
                    return true;
                  }
                  function getStyle(elem2) {
                    var result = /* @__PURE__ */ Object.create(null);
                    var specificities = /* @__PURE__ */ Object.create(null);
                    for (var i2 = 0; i2 < styleRules.length; i2++) {
                      var rule = styleRules[i2];
                      if (matchesSelector(elem2, rule.selector)) {
                        for (var key in rule.css) {
                          if (!(specificities[key] > rule.selector.specificity)) {
                            result[key] = rule.css[key];
                            specificities[key] = rule.selector.specificity;
                          }
                        }
                      }
                    }
                    return result;
                  }
                  function combineArrays(array1, array2) {
                    return array1.concat(array2.slice(array1.length));
                  }
                  function getAscent(font, size) {
                    return Math.max(font.ascender, (font.bbox[3] || font.bbox.maxY) * (font.scale || 1)) * size / 1e3;
                  }
                  function getDescent(font, size) {
                    return Math.min(font.descender, (font.bbox[1] || font.bbox.minY) * (font.scale || 1)) * size / 1e3;
                  }
                  function getXHeight(font, size) {
                    return (font.xHeight || 0.5 * (font.ascender - font.descender)) * size / 1e3;
                  }
                  function getBaseline(font, size, baseline, shift) {
                    var dy1, dy2;
                    switch (baseline) {
                      case "middle":
                        dy1 = 0.5 * getXHeight(font, size);
                        break;
                      case "central":
                        dy1 = 0.5 * (getDescent(font, size) + getAscent(font, size));
                        break;
                      case "after-edge":
                      case "text-after-edge":
                        dy1 = getDescent(font, size);
                        break;
                      case "alphabetic":
                      case "auto":
                      case "baseline":
                        dy1 = 0;
                        break;
                      case "mathematical":
                        dy1 = 0.5 * getAscent(font, size);
                        break;
                      case "hanging":
                        dy1 = 0.8 * getAscent(font, size);
                        break;
                      case "before-edge":
                      case "text-before-edge":
                        dy1 = getAscent(font, size);
                        break;
                      default:
                        dy1 = 0;
                        break;
                    }
                    switch (shift) {
                      case "baseline":
                        dy2 = 0;
                        break;
                      case "super":
                        dy2 = 0.6 * size;
                        break;
                      case "sub":
                        dy2 = -0.6 * size;
                        break;
                      default:
                        dy2 = shift;
                        break;
                    }
                    return dy1 - dy2;
                  }
                  function getTextPos(font, size, text) {
                    var encoded = font.encode("" + text), hex = encoded[0], pos = encoded[1], data = [];
                    for (var i2 = 0; i2 < hex.length; i2++) {
                      var unicode = font.unicode ? font.unicode[parseInt(hex[i2], 16)] : [text.charCodeAt(i2)];
                      data.push({
                        glyph: hex[i2],
                        unicode,
                        width: pos[i2].advanceWidth * size / 1e3,
                        xOffset: pos[i2].xOffset * size / 1e3,
                        yOffset: pos[i2].yOffset * size / 1e3,
                        xAdvance: pos[i2].xAdvance * size / 1e3,
                        yAdvance: pos[i2].yAdvance * size / 1e3
                      });
                    }
                    return data;
                  }
                  function createSVGElement(obj, inherits) {
                    switch (obj.nodeName) {
                      case "use":
                        return new SvgElemUse(obj, inherits);
                      case "symbol":
                        return new SvgElemSymbol(obj, inherits);
                      case "g":
                        return new SvgElemGroup(obj, inherits);
                      case "a":
                        return new SvgElemLink(obj, inherits);
                      case "svg":
                        return new SvgElemSvg(obj, inherits);
                      case "image":
                        return new SVGElemImage(obj, inherits);
                      case "rect":
                        return new SvgElemRect(obj, inherits);
                      case "circle":
                        return new SvgElemCircle(obj, inherits);
                      case "ellipse":
                        return new SvgElemEllipse(obj, inherits);
                      case "line":
                        return new SvgElemLine(obj, inherits);
                      case "polyline":
                        return new SvgElemPolyline(obj, inherits);
                      case "polygon":
                        return new SvgElemPolygon(obj, inherits);
                      case "path":
                        return new SvgElemPath(obj, inherits);
                      case "text":
                        return new SvgElemText(obj, inherits);
                      case "tspan":
                        return new SvgElemTspan(obj, inherits);
                      case "textPath":
                        return new SvgElemTextPath(obj, inherits);
                      case "#text":
                      case "#cdata-section":
                        return new SvgElemTextNode(obj, inherits);
                      default:
                        return new SvgElem(obj, inherits);
                    }
                  }
                  var StringParser = function StringParser2(str) {
                    this.match = function(exp, all) {
                      var temp = str.match(exp);
                      if (!temp || temp.index !== 0) {
                        return;
                      }
                      str = str.substring(temp[0].length);
                      return all ? temp : temp[0];
                    };
                    this.matchSeparator = function() {
                      return this.match(/^(?:\s*,\s*|\s*|)/);
                    };
                    this.matchSpace = function() {
                      return this.match(/^(?:\s*)/);
                    };
                    this.matchLengthUnit = function() {
                      return this.match(/^(?:px|pt|cm|mm|in|pc|em|ex|%|)/);
                    };
                    this.matchNumber = function() {
                      return this.match(/^(?:[-+]?(?:[0-9]+[.][0-9]+|[0-9]+[.]|[.][0-9]+|[0-9]+)(?:[eE][-+]?[0-9]+)?)/);
                    };
                    this.matchAll = function() {
                      return this.match(/^[\s\S]+/);
                    };
                  };
                  var BezierSegment = function BezierSegment2(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
                    var divisions = 6 * precision;
                    var equationX = [p1x, -3 * p1x + 3 * c1x, 3 * p1x - 6 * c1x + 3 * c2x, -p1x + 3 * c1x - 3 * c2x + p2x];
                    var equationY = [p1y, -3 * p1y + 3 * c1y, 3 * p1y - 6 * c1y + 3 * c2y, -p1y + 3 * c1y - 3 * c2y + p2y];
                    var derivativeX = [-3 * p1x + 3 * c1x, 6 * p1x - 12 * c1x + 6 * c2x, -3 * p1x + 9 * c1x - 9 * c2x + 3 * p2x];
                    var derivativeY = [-3 * p1y + 3 * c1y, 6 * p1y - 12 * c1y + 6 * c2y, -3 * p1y + 9 * c1y - 9 * c2y + 3 * p2y];
                    var lengthMap = [0];
                    for (var i2 = 1; i2 <= divisions; i2++) {
                      var t = (i2 - 0.5) / divisions;
                      var dx = getCurveValue(t, derivativeX) / divisions, dy = getCurveValue(t, derivativeY) / divisions, l = Math.sqrt(dx * dx + dy * dy);
                      lengthMap[i2] = lengthMap[i2 - 1] + l;
                    }
                    this.totalLength = lengthMap[divisions];
                    this.startPoint = [p1x, p1y, isEqual(p1x, c1x) && isEqual(p1y, c1y) ? Math.atan2(c2y - c1y, c2x - c1x) : Math.atan2(c1y - p1y, c1x - p1x)];
                    this.endPoint = [p2x, p2y, isEqual(c2x, p2x) && isEqual(c2y, p2y) ? Math.atan2(c2y - c1y, c2x - c1x) : Math.atan2(p2y - c2y, p2x - c2x)];
                    this.getBoundingBox = function() {
                      var temp;
                      var minX = getCurveValue(0, equationX), minY = getCurveValue(0, equationY), maxX = getCurveValue(1, equationX), maxY = getCurveValue(1, equationY);
                      if (minX > maxX) {
                        temp = maxX;
                        maxX = minX;
                        minX = temp;
                      }
                      if (minY > maxY) {
                        temp = maxY;
                        maxY = minY;
                        minY = temp;
                      }
                      var rootsX = solveEquation(derivativeX);
                      for (var _i4 = 0; _i4 < rootsX.length; _i4++) {
                        if (rootsX[_i4] >= 0 && rootsX[_i4] <= 1) {
                          var _x = getCurveValue(rootsX[_i4], equationX);
                          if (_x < minX) {
                            minX = _x;
                          }
                          if (_x > maxX) {
                            maxX = _x;
                          }
                        }
                      }
                      var rootsY = solveEquation(derivativeY);
                      for (var _i5 = 0; _i5 < rootsY.length; _i5++) {
                        if (rootsY[_i5] >= 0 && rootsY[_i5] <= 1) {
                          var _y = getCurveValue(rootsY[_i5], equationY);
                          if (_y < minY) {
                            minY = _y;
                          }
                          if (_y > maxY) {
                            maxY = _y;
                          }
                        }
                      }
                      return [minX, minY, maxX, maxY];
                    };
                    this.getPointAtLength = function(l2) {
                      if (isEqual(l2, 0)) {
                        return this.startPoint;
                      }
                      if (isEqual(l2, this.totalLength)) {
                        return this.endPoint;
                      }
                      if (l2 < 0 || l2 > this.totalLength) {
                        return;
                      }
                      for (var _i6 = 1; _i6 <= divisions; _i6++) {
                        var l1 = lengthMap[_i6 - 1], l22 = lengthMap[_i6];
                        if (l1 <= l2 && l2 <= l22) {
                          var _t = (_i6 - (l22 - l2) / (l22 - l1)) / divisions, _x2 = getCurveValue(_t, equationX), _y2 = getCurveValue(_t, equationY), _dx = getCurveValue(_t, derivativeX), _dy = getCurveValue(_t, derivativeY);
                          return [_x2, _y2, Math.atan2(_dy, _dx)];
                        }
                      }
                    };
                  };
                  var LineSegment = function LineSegment2(p1x, p1y, p2x, p2y) {
                    this.totalLength = Math.sqrt((p2x - p1x) * (p2x - p1x) + (p2y - p1y) * (p2y - p1y));
                    this.startPoint = [p1x, p1y, Math.atan2(p2y - p1y, p2x - p1x)];
                    this.endPoint = [p2x, p2y, Math.atan2(p2y - p1y, p2x - p1x)];
                    this.getBoundingBox = function() {
                      return [Math.min(this.startPoint[0], this.endPoint[0]), Math.min(this.startPoint[1], this.endPoint[1]), Math.max(this.startPoint[0], this.endPoint[0]), Math.max(this.startPoint[1], this.endPoint[1])];
                    };
                    this.getPointAtLength = function(l) {
                      if (l >= 0 && l <= this.totalLength) {
                        var r = l / this.totalLength || 0, _x3 = this.startPoint[0] + r * (this.endPoint[0] - this.startPoint[0]), _y3 = this.startPoint[1] + r * (this.endPoint[1] - this.startPoint[1]);
                        return [_x3, _y3, this.startPoint[2]];
                      }
                    };
                  };
                  var SvgShape = function SvgShape2() {
                    this.pathCommands = [];
                    this.pathSegments = [];
                    this.startPoint = null;
                    this.endPoint = null;
                    this.totalLength = 0;
                    var startX = 0, startY = 0, currX = 0, currY = 0, lastCom, lastCtrlX, lastCtrlY;
                    this.move = function(x2, y2) {
                      startX = currX = x2;
                      startY = currY = y2;
                      return null;
                    };
                    this.line = function(x2, y2) {
                      var segment = new LineSegment(currX, currY, x2, y2);
                      currX = x2;
                      currY = y2;
                      return segment;
                    };
                    this.curve = function(c1x, c1y, c2x, c2y, x2, y2) {
                      var segment = new BezierSegment(currX, currY, c1x, c1y, c2x, c2y, x2, y2);
                      currX = x2;
                      currY = y2;
                      return segment;
                    };
                    this.close = function() {
                      var segment = new LineSegment(currX, currY, startX, startY);
                      currX = startX;
                      currY = startY;
                      return segment;
                    };
                    this.addCommand = function(data) {
                      this.pathCommands.push(data);
                      var segment = this[data[0]].apply(this, data.slice(3));
                      if (segment) {
                        segment.hasStart = data[1];
                        segment.hasEnd = data[2];
                        this.startPoint = this.startPoint || segment.startPoint;
                        this.endPoint = segment.endPoint;
                        this.pathSegments.push(segment);
                        this.totalLength += segment.totalLength;
                      }
                    };
                    this.M = function(x2, y2) {
                      this.addCommand(["move", true, true, x2, y2]);
                      lastCom = "M";
                      return this;
                    };
                    this.m = function(x2, y2) {
                      return this.M(currX + x2, currY + y2);
                    };
                    this.Z = this.z = function() {
                      this.addCommand(["close", true, true]);
                      lastCom = "Z";
                      return this;
                    };
                    this.L = function(x2, y2) {
                      this.addCommand(["line", true, true, x2, y2]);
                      lastCom = "L";
                      return this;
                    };
                    this.l = function(x2, y2) {
                      return this.L(currX + x2, currY + y2);
                    };
                    this.H = function(x2) {
                      return this.L(x2, currY);
                    };
                    this.h = function(x2) {
                      return this.L(currX + x2, currY);
                    };
                    this.V = function(y2) {
                      return this.L(currX, y2);
                    };
                    this.v = function(y2) {
                      return this.L(currX, currY + y2);
                    };
                    this.C = function(c1x, c1y, c2x, c2y, x2, y2) {
                      this.addCommand(["curve", true, true, c1x, c1y, c2x, c2y, x2, y2]);
                      lastCom = "C";
                      lastCtrlX = c2x;
                      lastCtrlY = c2y;
                      return this;
                    };
                    this.c = function(c1x, c1y, c2x, c2y, x2, y2) {
                      return this.C(currX + c1x, currY + c1y, currX + c2x, currY + c2y, currX + x2, currY + y2);
                    };
                    this.S = function(c1x, c1y, x2, y2) {
                      return this.C(currX + (lastCom === "C" ? currX - lastCtrlX : 0), currY + (lastCom === "C" ? currY - lastCtrlY : 0), c1x, c1y, x2, y2);
                    };
                    this.s = function(c1x, c1y, x2, y2) {
                      return this.C(currX + (lastCom === "C" ? currX - lastCtrlX : 0), currY + (lastCom === "C" ? currY - lastCtrlY : 0), currX + c1x, currY + c1y, currX + x2, currY + y2);
                    };
                    this.Q = function(cx, cy, x2, y2) {
                      var c1x = currX + 2 / 3 * (cx - currX), c1y = currY + 2 / 3 * (cy - currY), c2x = x2 + 2 / 3 * (cx - x2), c2y = y2 + 2 / 3 * (cy - y2);
                      this.addCommand(["curve", true, true, c1x, c1y, c2x, c2y, x2, y2]);
                      lastCom = "Q";
                      lastCtrlX = cx;
                      lastCtrlY = cy;
                      return this;
                    };
                    this.q = function(c1x, c1y, x2, y2) {
                      return this.Q(currX + c1x, currY + c1y, currX + x2, currY + y2);
                    };
                    this.T = function(x2, y2) {
                      return this.Q(currX + (lastCom === "Q" ? currX - lastCtrlX : 0), currY + (lastCom === "Q" ? currY - lastCtrlY : 0), x2, y2);
                    };
                    this.t = function(x2, y2) {
                      return this.Q(currX + (lastCom === "Q" ? currX - lastCtrlX : 0), currY + (lastCom === "Q" ? currY - lastCtrlY : 0), currX + x2, currY + y2);
                    };
                    this.A = function(rx, ry, fi, fa, fs, x2, y2) {
                      if (isEqual(rx, 0) || isEqual(ry, 0)) {
                        this.addCommand(["line", true, true, x2, y2]);
                      } else {
                        fi = fi * (Math.PI / 180);
                        rx = Math.abs(rx);
                        ry = Math.abs(ry);
                        fa = 1 * !!fa;
                        fs = 1 * !!fs;
                        var x1 = Math.cos(fi) * (currX - x2) / 2 + Math.sin(fi) * (currY - y2) / 2, y1 = Math.cos(fi) * (currY - y2) / 2 - Math.sin(fi) * (currX - x2) / 2, lambda = x1 * x1 / (rx * rx) + y1 * y1 / (ry * ry);
                        if (lambda > 1) {
                          rx *= Math.sqrt(lambda);
                          ry *= Math.sqrt(lambda);
                        }
                        var r = Math.sqrt(Math.max(0, rx * rx * ry * ry - rx * rx * y1 * y1 - ry * ry * x1 * x1) / (rx * rx * y1 * y1 + ry * ry * x1 * x1)), x22 = (fa === fs ? -1 : 1) * r * rx * y1 / ry, y22 = (fa === fs ? 1 : -1) * r * ry * x1 / rx;
                        var cx = Math.cos(fi) * x22 - Math.sin(fi) * y22 + (currX + x2) / 2, cy = Math.sin(fi) * x22 + Math.cos(fi) * y22 + (currY + y2) / 2, th1 = Math.atan2((y1 - y22) / ry, (x1 - x22) / rx), th2 = Math.atan2((-y1 - y22) / ry, (-x1 - x22) / rx);
                        if (fs === 0 && th2 - th1 > 0) {
                          th2 -= 2 * Math.PI;
                        } else if (fs === 1 && th2 - th1 < 0) {
                          th2 += 2 * Math.PI;
                        }
                        var segms = Math.ceil(Math.abs(th2 - th1) / (Math.PI / precision));
                        for (var i2 = 0; i2 < segms; i2++) {
                          var th3 = th1 + i2 * (th2 - th1) / segms, th4 = th1 + (i2 + 1) * (th2 - th1) / segms, t = 4 / 3 * Math.tan((th4 - th3) / 4);
                          var c1x = cx + Math.cos(fi) * rx * (Math.cos(th3) - t * Math.sin(th3)) - Math.sin(fi) * ry * (Math.sin(th3) + t * Math.cos(th3)), c1y = cy + Math.sin(fi) * rx * (Math.cos(th3) - t * Math.sin(th3)) + Math.cos(fi) * ry * (Math.sin(th3) + t * Math.cos(th3)), c2x = cx + Math.cos(fi) * rx * (Math.cos(th4) + t * Math.sin(th4)) - Math.sin(fi) * ry * (Math.sin(th4) - t * Math.cos(th4)), c2y = cy + Math.sin(fi) * rx * (Math.cos(th4) + t * Math.sin(th4)) + Math.cos(fi) * ry * (Math.sin(th4) - t * Math.cos(th4)), endX = cx + Math.cos(fi) * rx * Math.cos(th4) - Math.sin(fi) * ry * Math.sin(th4), endY = cy + Math.sin(fi) * rx * Math.cos(th4) + Math.cos(fi) * ry * Math.sin(th4);
                          this.addCommand(["curve", i2 === 0, i2 === segms - 1, c1x, c1y, c2x, c2y, endX, endY]);
                        }
                      }
                      lastCom = "A";
                      return this;
                    };
                    this.a = function(rx, ry, fi, fa, fs, x2, y2) {
                      return this.A(rx, ry, fi, fa, fs, currX + x2, currY + y2);
                    };
                    this.path = function(d) {
                      var command, value, temp, parser = new StringParser((d || "").trim());
                      while (command = parser.match(/^[astvzqmhlcASTVZQMHLC]/)) {
                        parser.matchSeparator();
                        var values = [];
                        while (value = PathFlags[command + values.length] ? parser.match(/^[01]/) : parser.matchNumber()) {
                          parser.matchSeparator();
                          if (values.length === PathArguments[command]) {
                            this[command].apply(this, values);
                            values = [];
                            if (command === "M") {
                              command = "L";
                            } else if (command === "m") {
                              command = "l";
                            }
                          }
                          values.push(Number(value));
                        }
                        if (values.length === PathArguments[command]) {
                          this[command].apply(this, values);
                        } else {
                          warningCallback("SvgPath: command " + command + " with " + values.length + " numbers");
                          return;
                        }
                      }
                      if (temp = parser.matchAll()) {
                        warningCallback("SvgPath: unexpected string " + temp);
                      }
                      return this;
                    };
                    this.getBoundingBox = function() {
                      var bbox = [Infinity, Infinity, -Infinity, -Infinity];
                      function addBounds(bbox1) {
                        if (bbox1[0] < bbox[0]) {
                          bbox[0] = bbox1[0];
                        }
                        if (bbox1[2] > bbox[2]) {
                          bbox[2] = bbox1[2];
                        }
                        if (bbox1[1] < bbox[1]) {
                          bbox[1] = bbox1[1];
                        }
                        if (bbox1[3] > bbox[3]) {
                          bbox[3] = bbox1[3];
                        }
                      }
                      for (var i2 = 0; i2 < this.pathSegments.length; i2++) {
                        addBounds(this.pathSegments[i2].getBoundingBox());
                      }
                      if (bbox[0] === Infinity) {
                        bbox[0] = 0;
                      }
                      if (bbox[1] === Infinity) {
                        bbox[1] = 0;
                      }
                      if (bbox[2] === -Infinity) {
                        bbox[2] = 0;
                      }
                      if (bbox[3] === -Infinity) {
                        bbox[3] = 0;
                      }
                      return bbox;
                    };
                    this.getPointAtLength = function(l) {
                      if (l >= 0 && l <= this.totalLength) {
                        var temp;
                        for (var i2 = 0; i2 < this.pathSegments.length; i2++) {
                          if (temp = this.pathSegments[i2].getPointAtLength(l)) {
                            return temp;
                          }
                          l -= this.pathSegments[i2].totalLength;
                        }
                        return this.endPoint;
                      }
                    };
                    this.transform = function(m) {
                      this.pathSegments = [];
                      this.startPoint = null;
                      this.endPoint = null;
                      this.totalLength = 0;
                      for (var i2 = 0; i2 < this.pathCommands.length; i2++) {
                        var data = this.pathCommands.shift();
                        for (var j = 3; j < data.length; j += 2) {
                          var p = transformPoint([data[j], data[j + 1]], m);
                          data[j] = p[0];
                          data[j + 1] = p[1];
                        }
                        this.addCommand(data);
                      }
                      return this;
                    };
                    this.mergeShape = function(shape) {
                      for (var i2 = 0; i2 < shape.pathCommands.length; i2++) {
                        this.addCommand(shape.pathCommands[i2].slice());
                      }
                      return this;
                    };
                    this.clone = function() {
                      return new SvgShape2().mergeShape(this);
                    };
                    this.insertInDocument = function() {
                      for (var i2 = 0; i2 < this.pathCommands.length; i2++) {
                        var command = this.pathCommands[i2][0], values = this.pathCommands[i2].slice(3);
                        switch (command) {
                          case "move":
                            doc.moveTo(values[0], values[1]);
                            break;
                          case "line":
                            doc.lineTo(values[0], values[1]);
                            break;
                          case "curve":
                            doc.bezierCurveTo(values[0], values[1], values[2], values[3], values[4], values[5]);
                            break;
                          case "close":
                            doc.closePath();
                            break;
                        }
                      }
                    };
                    this.getSubPaths = function() {
                      var subPaths = [], shape = new SvgShape2();
                      for (var i2 = 0; i2 < this.pathCommands.length; i2++) {
                        var data = this.pathCommands[i2], command = this.pathCommands[i2][0];
                        if (command === "move" && i2 !== 0) {
                          subPaths.push(shape);
                          shape = new SvgShape2();
                        }
                        shape.addCommand(data);
                      }
                      subPaths.push(shape);
                      return subPaths;
                    };
                    this.getMarkers = function() {
                      var markers = [], subPaths = this.getSubPaths();
                      for (var i2 = 0; i2 < subPaths.length; i2++) {
                        var subPath = subPaths[i2], subPathMarkers = [];
                        for (var j = 0; j < subPath.pathSegments.length; j++) {
                          var segment = subPath.pathSegments[j];
                          if (isNotEqual(segment.totalLength, 0) || j === 0 || j === subPath.pathSegments.length - 1) {
                            if (segment.hasStart) {
                              var startMarker = segment.getPointAtLength(0), prevEndMarker = subPathMarkers.pop();
                              if (prevEndMarker) {
                                startMarker[2] = 0.5 * (prevEndMarker[2] + startMarker[2]);
                              }
                              subPathMarkers.push(startMarker);
                            }
                            if (segment.hasEnd) {
                              var endMarker = segment.getPointAtLength(segment.totalLength);
                              subPathMarkers.push(endMarker);
                            }
                          }
                        }
                        markers = markers.concat(subPathMarkers);
                      }
                      return markers;
                    };
                  };
                  var SvgElem = function SvgElem2(obj, inherits) {
                    var styleCache = /* @__PURE__ */ Object.create(null);
                    var childrenCache = null;
                    this.name = obj.nodeName;
                    this.isOuterElement = obj === svg || !obj.parentNode;
                    this.inherits = inherits || (!this.isOuterElement ? createSVGElement(obj.parentNode, null) : null);
                    this.stack = this.inherits ? this.inherits.stack.concat(obj) : [obj];
                    this.style = parseStyleAttr(typeof obj.getAttribute === "function" && obj.getAttribute("style"));
                    this.css = useCSS ? getComputedStyle(obj) : getStyle(obj);
                    this.allowedChildren = [];
                    this.attr = function(key) {
                      if (typeof obj.getAttribute === "function") {
                        return obj.getAttribute(key);
                      }
                    };
                    this.resolveUrl = function(value) {
                      var temp = (value || "").match(/^\s*(?:url\("(.*)#(.*)"\)|url\('(.*)#(.*)'\)|url\((.*)#(.*)\)|(.*)#(.*))\s*$/) || [];
                      var file = temp[1] || temp[3] || temp[5] || temp[7], id = temp[2] || temp[4] || temp[6] || temp[8];
                      if (id) {
                        if (!file) {
                          var svgObj = svg.getElementById(id);
                          if (svgObj) {
                            if (this.stack.indexOf(svgObj) === -1) {
                              return svgObj;
                            } else {
                              warningCallback('SVGtoPDF: loop of circular references for id "' + id + '"');
                              return;
                            }
                          }
                        }
                        if (documentCallback) {
                          var svgs = documentCache[file];
                          if (!svgs) {
                            svgs = documentCallback(file);
                            if (!isArrayLike(svgs)) {
                              svgs = [svgs];
                            }
                            for (var i2 = 0; i2 < svgs.length; i2++) {
                              if (typeof svgs[i2] === "string") {
                                svgs[i2] = parseXml(svgs[i2]);
                              }
                            }
                            documentCache[file] = svgs;
                          }
                          for (var _i7 = 0; _i7 < svgs.length; _i7++) {
                            var _svgObj = svgs[_i7].getElementById(id);
                            if (_svgObj) {
                              if (this.stack.indexOf(_svgObj) === -1) {
                                return _svgObj;
                              } else {
                                warningCallback('SVGtoPDF: loop of circular references for id "' + file + "#" + id + '"');
                                return;
                              }
                            }
                          }
                        }
                      }
                    };
                    this.computeUnits = function(value, unit, percent, isFontSize) {
                      if (unit === "%") {
                        return parseFloat(value) / 100 * (isFontSize || percent != null ? percent : this.getViewport());
                      } else if (unit === "ex" || unit === "em") {
                        return value * {
                          "em": 1,
                          "ex": 0.5
                        }[unit] * (isFontSize ? percent : this.get("font-size"));
                      } else {
                        return value * {
                          "": 1,
                          "px": 1,
                          "pt": 96 / 72,
                          "cm": 96 / 2.54,
                          "mm": 96 / 25.4,
                          "in": 96,
                          "pc": 96 / 6
                        }[unit];
                      }
                    };
                    this.computeLength = function(value, percent, initial, isFontSize) {
                      var parser = new StringParser((value || "").trim()), temp1, temp2;
                      if (typeof (temp1 = parser.matchNumber()) === "string" && typeof (temp2 = parser.matchLengthUnit()) === "string" && !parser.matchAll()) {
                        return this.computeUnits(temp1, temp2, percent, isFontSize);
                      }
                      return initial;
                    };
                    this.computeLengthList = function(value, percent, strict) {
                      var parser = new StringParser((value || "").trim()), result = [], temp1, temp2;
                      while (typeof (temp1 = parser.matchNumber()) === "string" && typeof (temp2 = parser.matchLengthUnit()) === "string") {
                        result.push(this.computeUnits(temp1, temp2, percent));
                        parser.matchSeparator();
                      }
                      if (strict && parser.matchAll()) {
                        return;
                      }
                      return result;
                    };
                    this.getLength = function(key, percent, initial) {
                      return this.computeLength(this.attr(key), percent, initial);
                    };
                    this.getLengthList = function(key, percent) {
                      return this.computeLengthList(this.attr(key), percent);
                    };
                    this.getUrl = function(key) {
                      return this.resolveUrl(this.attr(key));
                    };
                    this.getNumberList = function(key) {
                      var parser = new StringParser((this.attr(key) || "").trim()), result = [], temp;
                      while (temp = parser.matchNumber()) {
                        result.push(Number(temp));
                        parser.matchSeparator();
                      }
                      result.error = parser.matchAll();
                      return result;
                    };
                    this.getViewbox = function(key, initial) {
                      var viewBox = this.getNumberList(key);
                      if (viewBox.length === 4 && viewBox[2] >= 0 && viewBox[3] >= 0) {
                        return viewBox;
                      }
                      return initial;
                    };
                    this.getPercent = function(key, initial) {
                      var value = this.attr(key);
                      var parser = new StringParser((value || "").trim()), temp1, temp2;
                      var number = parser.matchNumber();
                      if (!number) {
                        return initial;
                      }
                      if (parser.match("%")) {
                        number *= 0.01;
                      }
                      if (parser.matchAll()) {
                        return initial;
                      }
                      return Math.max(0, Math.min(1, number));
                    };
                    this.chooseValue = function(args) {
                      for (var i2 = 0; i2 < arguments.length; i2++) {
                        if (arguments[i2] != null && arguments[i2] === arguments[i2]) {
                          return arguments[i2];
                        }
                      }
                      return arguments[arguments.length - 1];
                    };
                    this.get = function(key) {
                      if (styleCache[key] !== void 0) {
                        return styleCache[key];
                      }
                      var keyInfo = Properties[key] || {}, value, result;
                      for (var i2 = 0; i2 < 3; i2++) {
                        switch (i2) {
                          case 0:
                            if (key !== "transform") {
                              value = this.css[keyInfo.css || key];
                            }
                            break;
                          case 1:
                            value = this.style[key];
                            break;
                          case 2:
                            value = this.attr(key);
                            break;
                        }
                        if (value === "inherit") {
                          result = this.inherits ? this.inherits.get(key) : keyInfo.initial;
                          if (result != null) {
                            return styleCache[key] = result;
                          }
                        }
                        if (keyInfo.values != null) {
                          result = keyInfo.values[value];
                          if (result != null) {
                            return styleCache[key] = result;
                          }
                        }
                        if (value != null) {
                          var parsed = void 0;
                          switch (key) {
                            case "font-size":
                              result = this.computeLength(value, this.inherits ? this.inherits.get(key) : keyInfo.initial, void 0, true);
                              break;
                            case "baseline-shift":
                              result = this.computeLength(value, this.get("font-size"));
                              break;
                            case "font-family":
                              result = value || void 0;
                              break;
                            case "opacity":
                            case "stroke-opacity":
                            case "fill-opacity":
                            case "stop-opacity":
                              parsed = parseFloat(value);
                              if (!isNaN(parsed)) {
                                result = Math.max(0, Math.min(1, parsed));
                              }
                              break;
                            case "transform":
                              result = parseTranform(value);
                              break;
                            case "stroke-dasharray":
                              if (value === "none") {
                                result = [];
                              } else if (parsed = this.computeLengthList(value, this.getViewport(), true)) {
                                var sum = 0, error = false;
                                for (var j = 0; j < parsed.length; j++) {
                                  if (parsed[j] < 0) {
                                    error = true;
                                  }
                                  sum += parsed[j];
                                }
                                if (!error) {
                                  if (parsed.length % 2 === 1) {
                                    parsed = parsed.concat(parsed);
                                  }
                                  result = sum === 0 ? [] : parsed;
                                }
                              }
                              break;
                            case "color":
                              if (value === "none" || value === "transparent") {
                                result = "none";
                              } else {
                                result = parseColor(value);
                              }
                              break;
                            case "fill":
                            case "stroke":
                              if (value === "none" || value === "transparent") {
                                result = "none";
                              } else if (value === "currentColor") {
                                result = this.get("color");
                              } else if (parsed = parseColor(value)) {
                                return parsed;
                              } else if (parsed = (value || "").split(" ")) {
                                var object = this.resolveUrl(parsed[0]), fallbackColor = parseColor(parsed[1]);
                                if (object == null) {
                                  result = fallbackColor;
                                } else if (object.nodeName === "linearGradient" || object.nodeName === "radialGradient") {
                                  result = new SvgElemGradient(object, null, fallbackColor);
                                } else if (object.nodeName === "pattern") {
                                  result = new SvgElemPattern(object, null, fallbackColor);
                                } else {
                                  result = fallbackColor;
                                }
                              }
                              break;
                            case "stop-color":
                              if (value === "none" || value === "transparent") {
                                result = "none";
                              } else if (value === "currentColor") {
                                result = this.get("color");
                              } else {
                                result = parseColor(value);
                              }
                              break;
                            case "marker-start":
                            case "marker-mid":
                            case "marker-end":
                            case "clip-path":
                            case "mask":
                              if (value === "none") {
                                result = "none";
                              } else {
                                result = this.resolveUrl(value);
                              }
                              break;
                            case "stroke-width":
                              parsed = this.computeLength(value, this.getViewport());
                              if (parsed != null && parsed >= 0) {
                                result = parsed;
                              }
                              break;
                            case "stroke-miterlimit":
                              parsed = parseFloat(value);
                              if (parsed != null && parsed >= 1) {
                                result = parsed;
                              }
                              break;
                            case "word-spacing":
                            case "letter-spacing":
                              result = this.computeLength(value, this.getViewport());
                              break;
                            case "stroke-dashoffset":
                              result = this.computeLength(value, this.getViewport());
                              if (result != null) {
                                if (result < 0) {
                                  var dasharray = this.get("stroke-dasharray");
                                  for (var _j = 0; _j < dasharray.length; _j++) {
                                    result += dasharray[_j];
                                  }
                                }
                              }
                              break;
                          }
                          if (result != null) {
                            return styleCache[key] = result;
                          }
                        }
                      }
                      return styleCache[key] = keyInfo.inherit && this.inherits ? this.inherits.get(key) : keyInfo.initial;
                    };
                    this.getChildren = function() {
                      if (childrenCache != null) {
                        return childrenCache;
                      }
                      var children = [];
                      for (var i2 = 0; i2 < obj.childNodes.length; i2++) {
                        var child = obj.childNodes[i2];
                        if (!child.error && this.allowedChildren.indexOf(child.nodeName) !== -1) {
                          children.push(createSVGElement(child, this));
                        }
                      }
                      return childrenCache = children;
                    };
                    this.getParentVWidth = function() {
                      return this.inherits ? this.inherits.getVWidth() : viewportWidth;
                    };
                    this.getParentVHeight = function() {
                      return this.inherits ? this.inherits.getVHeight() : viewportHeight;
                    };
                    this.getParentViewport = function() {
                      return Math.sqrt(0.5 * this.getParentVWidth() * this.getParentVWidth() + 0.5 * this.getParentVHeight() * this.getParentVHeight());
                    };
                    this.getVWidth = function() {
                      return this.getParentVWidth();
                    };
                    this.getVHeight = function() {
                      return this.getParentVHeight();
                    };
                    this.getViewport = function() {
                      return Math.sqrt(0.5 * this.getVWidth() * this.getVWidth() + 0.5 * this.getVHeight() * this.getVHeight());
                    };
                    this.getBoundingBox = function() {
                      var shape = this.getBoundingShape();
                      return shape.getBoundingBox();
                    };
                  };
                  var SvgElemStylable = function SvgElemStylable2(obj, inherits) {
                    SvgElem.call(this, obj, inherits);
                    this.transform = function() {
                      doc.transform.apply(doc, this.getTransformation());
                    };
                    this.clip = function() {
                      if (this.get("clip-path") !== "none") {
                        var clipPath = new SvgElemClipPath(this.get("clip-path"), null);
                        clipPath.useMask(this.getBoundingBox());
                        return true;
                      }
                    };
                    this.mask = function() {
                      if (this.get("mask") !== "none") {
                        var mask = new SvgElemMask(this.get("mask"), null);
                        mask.useMask(this.getBoundingBox());
                        return true;
                      }
                    };
                    this.getFill = function(isClip, isMask) {
                      var opacity = this.get("opacity"), fill = this.get("fill"), fillOpacity = this.get("fill-opacity");
                      if (isClip) {
                        return DefaultColors.white;
                      }
                      if (fill !== "none" && opacity && fillOpacity) {
                        if (fill instanceof SvgElemGradient || fill instanceof SvgElemPattern) {
                          return fill.getPaint(this.getBoundingBox(), fillOpacity * opacity, isClip, isMask);
                        }
                        return opacityToColor(fill, fillOpacity * opacity, isMask);
                      }
                    };
                    this.getStroke = function(isClip, isMask) {
                      var opacity = this.get("opacity"), stroke = this.get("stroke"), strokeOpacity = this.get("stroke-opacity");
                      if (isClip || isEqual(this.get("stroke-width"), 0)) {
                        return;
                      }
                      if (stroke !== "none" && opacity && strokeOpacity) {
                        if (stroke instanceof SvgElemGradient || stroke instanceof SvgElemPattern) {
                          return stroke.getPaint(this.getBoundingBox(), strokeOpacity * opacity, isClip, isMask);
                        }
                        return opacityToColor(stroke, strokeOpacity * opacity, isMask);
                      }
                    };
                  };
                  var SvgElemHasChildren = function SvgElemHasChildren2(obj, inherits) {
                    SvgElemStylable.call(this, obj, inherits);
                    this.allowedChildren = ["use", "g", "a", "svg", "image", "rect", "circle", "ellipse", "line", "polyline", "polygon", "path", "text"];
                    this.getBoundingShape = function() {
                      var shape = new SvgShape(), children = this.getChildren();
                      for (var i2 = 0; i2 < children.length; i2++) {
                        if (children[i2].get("display") !== "none") {
                          if (typeof children[i2].getBoundingShape === "function") {
                            var childShape = children[i2].getBoundingShape().clone();
                            if (typeof children[i2].getTransformation === "function") {
                              childShape.transform(children[i2].getTransformation());
                            }
                            shape.mergeShape(childShape);
                          }
                        }
                      }
                      return shape;
                    };
                    this.drawChildren = function(isClip, isMask) {
                      var children = this.getChildren();
                      for (var i2 = 0; i2 < children.length; i2++) {
                        if (children[i2].get("display") !== "none") {
                          if (typeof children[i2].drawInDocument === "function") {
                            children[i2].drawInDocument(isClip, isMask);
                          }
                        }
                      }
                    };
                  };
                  var SvgElemContainer = function SvgElemContainer2(obj, inherits) {
                    SvgElemHasChildren.call(this, obj, inherits);
                    this.drawContent = function(isClip, isMask) {
                      this.transform();
                      var clipped = this.clip(), masked = this.mask(), group;
                      if ((this.get("opacity") < 1 || clipped || masked) && !isClip) {
                        group = docBeginGroup(getPageBBox());
                      }
                      this.drawChildren(isClip, isMask);
                      if (group) {
                        docEndGroup(group);
                        doc.fillOpacity(this.get("opacity"));
                        docInsertGroup(group);
                      }
                    };
                  };
                  var SvgElemUse = function SvgElemUse2(obj, inherits) {
                    SvgElemContainer.call(this, obj, inherits);
                    var x2 = this.getLength("x", this.getVWidth(), 0), y2 = this.getLength("y", this.getVHeight(), 0), child = this.getUrl("href") || this.getUrl("xlink:href");
                    if (child) {
                      child = createSVGElement(child, this);
                    }
                    this.getChildren = function() {
                      return child ? [child] : [];
                    };
                    this.drawInDocument = function(isClip, isMask) {
                      doc.save();
                      this.drawContent(isClip, isMask);
                      doc.restore();
                    };
                    this.getTransformation = function() {
                      return multiplyMatrix(this.get("transform"), [1, 0, 0, 1, x2, y2]);
                    };
                  };
                  var SvgElemSymbol = function SvgElemSymbol2(obj, inherits) {
                    SvgElemContainer.call(this, obj, inherits);
                    var width = this.getLength("width", this.getParentVWidth(), this.getParentVWidth()), height = this.getLength("height", this.getParentVHeight(), this.getParentVHeight());
                    if (inherits instanceof SvgElemUse) {
                      width = inherits.getLength("width", inherits.getParentVWidth(), width);
                      height = inherits.getLength("height", inherits.getParentVHeight(), height);
                    }
                    var aspectRatio = (this.attr("preserveAspectRatio") || "").trim(), viewBox = this.getViewbox("viewBox", [0, 0, width, height]);
                    this.getVWidth = function() {
                      return viewBox[2];
                    };
                    this.getVHeight = function() {
                      return viewBox[3];
                    };
                    this.drawInDocument = function(isClip, isMask) {
                      doc.save();
                      this.drawContent(isClip, isMask);
                      doc.restore();
                    };
                    this.getTransformation = function() {
                      return multiplyMatrix(parseAspectRatio(aspectRatio, width, height, viewBox[2], viewBox[3]), [1, 0, 0, 1, -viewBox[0], -viewBox[1]]);
                    };
                  };
                  var SvgElemGroup = function SvgElemGroup2(obj, inherits) {
                    SvgElemContainer.call(this, obj, inherits);
                    this.drawInDocument = function(isClip, isMask) {
                      doc.save();
                      if (this.link && !isClip && !isMask) {
                        this.addLink();
                      }
                      this.drawContent(isClip, isMask);
                      doc.restore();
                    };
                    this.getTransformation = function() {
                      return this.get("transform");
                    };
                  };
                  var SvgElemLink = function SvgElemLink2(obj, inherits) {
                    if (inherits && inherits.isText) {
                      SvgElemTspan.call(this, obj, inherits);
                      this.allowedChildren = ["textPath", "tspan", "#text", "#cdata-section", "a"];
                    } else {
                      SvgElemGroup.call(this, obj, inherits);
                    }
                    this.link = this.attr("href") || this.attr("xlink:href");
                    this.addLink = function() {
                      if (this.link.match(/^(?:[a-z][a-z0-9+.-]*:|\/\/)?/i) && this.getChildren().length) {
                        var bbox = this.getBoundingShape().transform(getGlobalMatrix()).getBoundingBox();
                        docInsertLink(bbox[0], bbox[1], bbox[2], bbox[3], this.link);
                      }
                    };
                  };
                  var SvgElemSvg = function SvgElemSvg2(obj, inherits) {
                    SvgElemContainer.call(this, obj, inherits);
                    var width = this.getLength("width", this.getParentVWidth(), this.getParentVWidth()), height = this.getLength("height", this.getParentVHeight(), this.getParentVHeight()), x2 = this.getLength("x", this.getParentVWidth(), 0), y2 = this.getLength("y", this.getParentVHeight(), 0);
                    if (inherits instanceof SvgElemUse) {
                      width = inherits.getLength("width", inherits.getParentVWidth(), width);
                      height = inherits.getLength("height", inherits.getParentVHeight(), height);
                    }
                    var aspectRatio = this.attr("preserveAspectRatio"), viewBox = this.getViewbox("viewBox", [0, 0, width, height]);
                    if (this.isOuterElement && preserveAspectRatio) {
                      x2 = y2 = 0;
                      width = viewportWidth;
                      height = viewportHeight;
                      aspectRatio = preserveAspectRatio;
                    }
                    this.getVWidth = function() {
                      return viewBox[2];
                    };
                    this.getVHeight = function() {
                      return viewBox[3];
                    };
                    this.drawInDocument = function(isClip, isMask) {
                      doc.save();
                      if (this.get("overflow") === "hidden") {
                        new SvgShape().M(x2, y2).L(x2 + width, y2).L(x2 + width, y2 + height).L(x2, y2 + height).Z().transform(this.get("transform")).insertInDocument();
                        doc.clip();
                      }
                      this.drawContent(isClip, isMask);
                      doc.restore();
                    };
                    this.getTransformation = function() {
                      return multiplyMatrix(this.get("transform"), [1, 0, 0, 1, x2, y2], parseAspectRatio(aspectRatio, width, height, viewBox[2], viewBox[3]), [1, 0, 0, 1, -viewBox[0], -viewBox[1]]);
                    };
                  };
                  var SVGElemImage = function SVGElemImage2(obj, inherits) {
                    SvgElemStylable.call(this, obj, inherits);
                    var link = imageCallback(this.attr("href") || this.attr("xlink:href") || ""), x2 = this.getLength("x", this.getVWidth(), 0), y2 = this.getLength("y", this.getVHeight(), 0), width = this.getLength("width", this.getVWidth(), "auto"), height = this.getLength("height", this.getVHeight(), "auto"), image;
                    try {
                      image = doc.openImage(link);
                    } catch (e) {
                      warningCallback('SVGElemImage: failed to open image "' + link + '" in PDFKit');
                    }
                    if (image) {
                      if (width === "auto" && height !== "auto") {
                        width = height * image.width / image.height;
                      } else if (height === "auto" && width !== "auto") {
                        height = width * image.height / image.width;
                      } else if (width === "auto" && height === "auto") {
                        width = image.width;
                        height = image.height;
                      }
                    }
                    if (width === "auto" || width < 0) {
                      width = 0;
                    }
                    if (height === "auto" || height < 0) {
                      height = 0;
                    }
                    this.getTransformation = function() {
                      return this.get("transform");
                    };
                    this.getBoundingShape = function() {
                      return new SvgShape().M(x2, y2).L(x2 + width, y2).M(x2 + width, y2 + height).L(x2, y2 + height);
                    };
                    this.drawInDocument = function(isClip, isMask) {
                      if (this.get("visibility") === "hidden" || !image) {
                        return;
                      }
                      doc.save();
                      this.transform();
                      if (this.get("overflow") === "hidden") {
                        doc.rect(x2, y2, width, height).clip();
                      }
                      this.clip();
                      this.mask();
                      doc.translate(x2, y2);
                      doc.transform.apply(doc, parseAspectRatio(this.attr("preserveAspectRatio"), width, height, image ? image.width : width, image ? image.height : height));
                      if (!isClip) {
                        doc.fillOpacity(this.get("opacity"));
                        doc.image(image, 0, 0);
                      } else {
                        doc.rect(0, 0, image.width, image.height);
                        docFillColor(DefaultColors.white).fill();
                      }
                      doc.restore();
                    };
                  };
                  var SvgElemPattern = function SvgElemPattern2(obj, inherits, fallback) {
                    SvgElemHasChildren.call(this, obj, inherits);
                    this.ref = function() {
                      var ref = this.getUrl("href") || this.getUrl("xlink:href");
                      if (ref && ref.nodeName === obj.nodeName) {
                        return new SvgElemPattern2(ref, inherits, fallback);
                      }
                    }.call(this);
                    var _attr = this.attr;
                    this.attr = function(key) {
                      var attr = _attr.call(this, key);
                      if (attr != null || key === "href" || key === "xlink:href") {
                        return attr;
                      }
                      return this.ref ? this.ref.attr(key) : null;
                    };
                    var _getChildren = this.getChildren;
                    this.getChildren = function() {
                      var children = _getChildren.call(this);
                      if (children.length > 0) {
                        return children;
                      }
                      return this.ref ? this.ref.getChildren() : [];
                    };
                    this.getPaint = function(bBox, gOpacity, isClip, isMask) {
                      var bBoxUnitsPattern = this.attr("patternUnits") !== "userSpaceOnUse", bBoxUnitsContent = this.attr("patternContentUnits") === "objectBoundingBox", x2 = this.getLength("x", bBoxUnitsPattern ? 1 : this.getParentVWidth(), 0), y2 = this.getLength("y", bBoxUnitsPattern ? 1 : this.getParentVHeight(), 0), width = this.getLength("width", bBoxUnitsPattern ? 1 : this.getParentVWidth(), 0), height = this.getLength("height", bBoxUnitsPattern ? 1 : this.getParentVHeight(), 0);
                      if (bBoxUnitsContent && !bBoxUnitsPattern) {
                        x2 = (x2 - bBox[0]) / (bBox[2] - bBox[0]) || 0;
                        y2 = (y2 - bBox[1]) / (bBox[3] - bBox[1]) || 0;
                        width = width / (bBox[2] - bBox[0]) || 0;
                        height = height / (bBox[3] - bBox[1]) || 0;
                      } else if (!bBoxUnitsContent && bBoxUnitsPattern) {
                        x2 = bBox[0] + x2 * (bBox[2] - bBox[0]);
                        y2 = bBox[1] + y2 * (bBox[3] - bBox[1]);
                        width = width * (bBox[2] - bBox[0]);
                        height = height * (bBox[3] - bBox[1]);
                      }
                      var viewBox = this.getViewbox("viewBox", [0, 0, width, height]), aspectRatio = (this.attr("preserveAspectRatio") || "").trim(), aspectRatioMatrix = multiplyMatrix(parseAspectRatio(aspectRatio, width, height, viewBox[2], viewBox[3], 0), [1, 0, 0, 1, -viewBox[0], -viewBox[1]]), matrix = parseTranform(this.attr("patternTransform"));
                      if (bBoxUnitsContent) {
                        matrix = multiplyMatrix([bBox[2] - bBox[0], 0, 0, bBox[3] - bBox[1], bBox[0], bBox[1]], matrix);
                      }
                      matrix = multiplyMatrix(matrix, [1, 0, 0, 1, x2, y2]);
                      if ((matrix = validateMatrix(matrix)) && (aspectRatioMatrix = validateMatrix(aspectRatioMatrix)) && (width = validateNumber(width)) && (height = validateNumber(height))) {
                        var group = docBeginGroup([0, 0, width, height]);
                        doc.transform.apply(doc, aspectRatioMatrix);
                        this.drawChildren(isClip, isMask);
                        docEndGroup(group);
                        return [docCreatePattern(group, width, height, matrix), gOpacity];
                      } else {
                        return fallback ? [fallback[0], fallback[1] * gOpacity] : void 0;
                      }
                    };
                    this.getVWidth = function() {
                      var bBoxUnitsPattern = this.attr("patternUnits") !== "userSpaceOnUse", width = this.getLength("width", bBoxUnitsPattern ? 1 : this.getParentVWidth(), 0);
                      return this.getViewbox("viewBox", [0, 0, width, 0])[2];
                    };
                    this.getVHeight = function() {
                      var bBoxUnitsPattern = this.attr("patternUnits") !== "userSpaceOnUse", height = this.getLength("height", bBoxUnitsPattern ? 1 : this.getParentVHeight(), 0);
                      return this.getViewbox("viewBox", [0, 0, 0, height])[3];
                    };
                  };
                  var SvgElemGradient = function SvgElemGradient2(obj, inherits, fallback) {
                    SvgElem.call(this, obj, inherits);
                    this.allowedChildren = ["stop"];
                    this.ref = function() {
                      var ref = this.getUrl("href") || this.getUrl("xlink:href");
                      if (ref && ref.nodeName === obj.nodeName) {
                        return new SvgElemGradient2(ref, inherits, fallback);
                      }
                    }.call(this);
                    var _attr = this.attr;
                    this.attr = function(key) {
                      var attr = _attr.call(this, key);
                      if (attr != null || key === "href" || key === "xlink:href") {
                        return attr;
                      }
                      return this.ref ? this.ref.attr(key) : null;
                    };
                    var _getChildren = this.getChildren;
                    this.getChildren = function() {
                      var children = _getChildren.call(this);
                      if (children.length > 0) {
                        return children;
                      }
                      return this.ref ? this.ref.getChildren() : [];
                    };
                    this.getPaint = function(bBox, gOpacity, isClip, isMask) {
                      var children = this.getChildren();
                      if (children.length === 0) {
                        return;
                      }
                      if (children.length === 1) {
                        var child = children[0], stopColor = child.get("stop-color");
                        if (stopColor === "none") {
                          return;
                        }
                        return opacityToColor(stopColor, child.get("stop-opacity") * gOpacity, isMask);
                      }
                      var bBoxUnits = this.attr("gradientUnits") !== "userSpaceOnUse", matrix = parseTranform(this.attr("gradientTransform")), spread = this.attr("spreadMethod"), grad, x1, x2, y1, y2, r2, nAfter = 0, nBefore = 0, nTotal = 1;
                      if (bBoxUnits) {
                        matrix = multiplyMatrix([bBox[2] - bBox[0], 0, 0, bBox[3] - bBox[1], bBox[0], bBox[1]], matrix);
                      }
                      if (matrix = validateMatrix(matrix)) {
                        if (this.name === "linearGradient") {
                          x1 = this.getLength("x1", bBoxUnits ? 1 : this.getVWidth(), 0);
                          x2 = this.getLength("x2", bBoxUnits ? 1 : this.getVWidth(), bBoxUnits ? 1 : this.getVWidth());
                          y1 = this.getLength("y1", bBoxUnits ? 1 : this.getVHeight(), 0);
                          y2 = this.getLength("y2", bBoxUnits ? 1 : this.getVHeight(), 0);
                        } else {
                          x2 = this.getLength("cx", bBoxUnits ? 1 : this.getVWidth(), bBoxUnits ? 0.5 : 0.5 * this.getVWidth());
                          y2 = this.getLength("cy", bBoxUnits ? 1 : this.getVHeight(), bBoxUnits ? 0.5 : 0.5 * this.getVHeight());
                          r2 = this.getLength("r", bBoxUnits ? 1 : this.getViewport(), bBoxUnits ? 0.5 : 0.5 * this.getViewport());
                          x1 = this.getLength("fx", bBoxUnits ? 1 : this.getVWidth(), x2);
                          y1 = this.getLength("fy", bBoxUnits ? 1 : this.getVHeight(), y2);
                          if (r2 < 0) {
                            warningCallback("SvgElemGradient: negative r value");
                          }
                          var d = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)), multiplier = 1;
                          if (d > r2) {
                            multiplier = r2 / d;
                            x1 = x2 + (x1 - x2) * multiplier;
                            y1 = y2 + (y1 - y2) * multiplier;
                          }
                          r2 = Math.max(r2, d * multiplier * (1 + 1e-6));
                        }
                        if (spread === "reflect" || spread === "repeat") {
                          var inv = inverseMatrix(matrix), corner1 = transformPoint([bBox[0], bBox[1]], inv), corner2 = transformPoint([bBox[2], bBox[1]], inv), corner3 = transformPoint([bBox[2], bBox[3]], inv), corner4 = transformPoint([bBox[0], bBox[3]], inv);
                          if (this.name === "linearGradient") {
                            nAfter = Math.max((corner1[0] - x2) * (x2 - x1) + (corner1[1] - y2) * (y2 - y1), (corner2[0] - x2) * (x2 - x1) + (corner2[1] - y2) * (y2 - y1), (corner3[0] - x2) * (x2 - x1) + (corner3[1] - y2) * (y2 - y1), (corner4[0] - x2) * (x2 - x1) + (corner4[1] - y2) * (y2 - y1)) / (Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                            nBefore = Math.max((corner1[0] - x1) * (x1 - x2) + (corner1[1] - y1) * (y1 - y2), (corner2[0] - x1) * (x1 - x2) + (corner2[1] - y1) * (y1 - y2), (corner3[0] - x1) * (x1 - x2) + (corner3[1] - y1) * (y1 - y2), (corner4[0] - x1) * (x1 - x2) + (corner4[1] - y1) * (y1 - y2)) / (Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                          } else {
                            nAfter = Math.sqrt(Math.max(Math.pow(corner1[0] - x2, 2) + Math.pow(corner1[1] - y2, 2), Math.pow(corner2[0] - x2, 2) + Math.pow(corner2[1] - y2, 2), Math.pow(corner3[0] - x2, 2) + Math.pow(corner3[1] - y2, 2), Math.pow(corner4[0] - x2, 2) + Math.pow(corner4[1] - y2, 2))) / r2 - 1;
                          }
                          nAfter = Math.ceil(nAfter + 0.5);
                          nBefore = Math.ceil(nBefore + 0.5);
                          nTotal = nBefore + 1 + nAfter;
                        }
                        if (this.name === "linearGradient") {
                          grad = doc.linearGradient(x1 - nBefore * (x2 - x1), y1 - nBefore * (y2 - y1), x2 + nAfter * (x2 - x1), y2 + nAfter * (y2 - y1));
                        } else {
                          grad = doc.radialGradient(x1, y1, 0, x2, y2, r2 + nAfter * r2);
                        }
                        for (var n = 0; n < nTotal; n++) {
                          var offset = 0, inOrder = spread !== "reflect" || (n - nBefore) % 2 === 0;
                          for (var i2 = 0; i2 < children.length; i2++) {
                            var _child = children[inOrder ? i2 : children.length - 1 - i2], _stopColor = _child.get("stop-color");
                            if (_stopColor === "none") {
                              _stopColor = DefaultColors.transparent;
                            }
                            _stopColor = opacityToColor(_stopColor, _child.get("stop-opacity") * gOpacity, isMask);
                            offset = Math.max(offset, inOrder ? _child.getPercent("offset", 0) : 1 - _child.getPercent("offset", 0));
                            if (i2 === 0 && _stopColor[0].length === 4) {
                              grad._colorSpace = "DeviceCMYK";
                            }
                            if (i2 === 0 && offset > 0) {
                              grad.stop((n + 0) / nTotal, _stopColor[0], _stopColor[1]);
                            }
                            grad.stop((n + offset) / (nAfter + nBefore + 1), _stopColor[0], _stopColor[1]);
                            if (i2 === children.length - 1 && offset < 1) {
                              grad.stop((n + 1) / nTotal, _stopColor[0], _stopColor[1]);
                            }
                          }
                        }
                        grad.setTransform.apply(grad, matrix);
                        return [grad, 1];
                      } else {
                        return fallback ? [fallback[0], fallback[1] * gOpacity] : void 0;
                      }
                    };
                  };
                  var SvgElemBasicShape = function SvgElemBasicShape2(obj, inherits) {
                    SvgElemStylable.call(this, obj, inherits);
                    this.dashScale = 1;
                    this.getBoundingShape = function() {
                      return this.shape;
                    };
                    this.getTransformation = function() {
                      return this.get("transform");
                    };
                    this.drawInDocument = function(isClip, isMask) {
                      if (this.get("visibility") === "hidden" || !this.shape) {
                        return;
                      }
                      doc.save();
                      this.transform();
                      this.clip();
                      if (!isClip) {
                        var masked = this.mask(), group;
                        if (masked) {
                          group = docBeginGroup(getPageBBox());
                        }
                        var subPaths = this.shape.getSubPaths(), fill = this.getFill(isClip, isMask), stroke = this.getStroke(isClip, isMask), lineWidth = this.get("stroke-width"), lineCap = this.get("stroke-linecap");
                        if (fill || stroke) {
                          if (fill) {
                            docFillColor(fill);
                          }
                          if (stroke) {
                            for (var j = 0; j < subPaths.length; j++) {
                              if (isEqual(subPaths[j].totalLength, 0)) {
                                if ((lineCap === "square" || lineCap === "round") && lineWidth > 0) {
                                  if (subPaths[j].startPoint && subPaths[j].startPoint.length > 1) {
                                    var _x4 = subPaths[j].startPoint[0], _y4 = subPaths[j].startPoint[1];
                                    docFillColor(stroke);
                                    if (lineCap === "square") {
                                      doc.rect(_x4 - 0.5 * lineWidth, _y4 - 0.5 * lineWidth, lineWidth, lineWidth);
                                    } else if (lineCap === "round") {
                                      doc.circle(_x4, _y4, 0.5 * lineWidth);
                                    }
                                    doc.fill();
                                  }
                                }
                              }
                            }
                            var dashArray = this.get("stroke-dasharray"), dashOffset = this.get("stroke-dashoffset");
                            if (isNotEqual(this.dashScale, 1)) {
                              for (var _j2 = 0; _j2 < dashArray.length; _j2++) {
                                dashArray[_j2] *= this.dashScale;
                              }
                              dashOffset *= this.dashScale;
                            }
                            docStrokeColor(stroke);
                            doc.lineWidth(lineWidth).miterLimit(this.get("stroke-miterlimit")).lineJoin(this.get("stroke-linejoin")).lineCap(lineCap).dash(dashArray, {
                              phase: dashOffset
                            });
                          }
                          for (var _j3 = 0; _j3 < subPaths.length; _j3++) {
                            if (subPaths[_j3].totalLength > 0) {
                              subPaths[_j3].insertInDocument();
                            }
                          }
                          if (fill && stroke) {
                            doc.fillAndStroke(this.get("fill-rule"));
                          } else if (fill) {
                            doc.fill(this.get("fill-rule"));
                          } else if (stroke) {
                            doc.stroke();
                          }
                        }
                        var markerStart = this.get("marker-start"), markerMid = this.get("marker-mid"), markerEnd = this.get("marker-end");
                        if (markerStart !== "none" || markerMid !== "none" || markerEnd !== "none") {
                          var markersPos = this.shape.getMarkers();
                          if (markerStart !== "none") {
                            var marker = new SvgElemMarker(markerStart, null);
                            marker.drawMarker(false, isMask, markersPos[0], lineWidth);
                          }
                          if (markerMid !== "none") {
                            for (var i2 = 1; i2 < markersPos.length - 1; i2++) {
                              var _marker = new SvgElemMarker(markerMid, null);
                              _marker.drawMarker(false, isMask, markersPos[i2], lineWidth);
                            }
                          }
                          if (markerEnd !== "none") {
                            var _marker2 = new SvgElemMarker(markerEnd, null);
                            _marker2.drawMarker(false, isMask, markersPos[markersPos.length - 1], lineWidth);
                          }
                        }
                        if (group) {
                          docEndGroup(group);
                          docInsertGroup(group);
                        }
                      } else {
                        this.shape.insertInDocument();
                        docFillColor(DefaultColors.white);
                        doc.fill(this.get("clip-rule"));
                      }
                      doc.restore();
                    };
                  };
                  var SvgElemRect = function SvgElemRect2(obj, inherits) {
                    SvgElemBasicShape.call(this, obj, inherits);
                    var x2 = this.getLength("x", this.getVWidth(), 0), y2 = this.getLength("y", this.getVHeight(), 0), w = this.getLength("width", this.getVWidth(), 0), h = this.getLength("height", this.getVHeight(), 0), rx = this.getLength("rx", this.getVWidth()), ry = this.getLength("ry", this.getVHeight());
                    if (rx === void 0 && ry === void 0) {
                      rx = ry = 0;
                    } else if (rx === void 0 && ry !== void 0) {
                      rx = ry;
                    } else if (rx !== void 0 && ry === void 0) {
                      ry = rx;
                    }
                    if (w > 0 && h > 0) {
                      if (rx && ry) {
                        rx = Math.min(rx, 0.5 * w);
                        ry = Math.min(ry, 0.5 * h);
                        this.shape = new SvgShape().M(x2 + rx, y2).L(x2 + w - rx, y2).A(rx, ry, 0, 0, 1, x2 + w, y2 + ry).L(x2 + w, y2 + h - ry).A(rx, ry, 0, 0, 1, x2 + w - rx, y2 + h).L(x2 + rx, y2 + h).A(rx, ry, 0, 0, 1, x2, y2 + h - ry).L(x2, y2 + ry).A(rx, ry, 0, 0, 1, x2 + rx, y2).Z();
                      } else {
                        this.shape = new SvgShape().M(x2, y2).L(x2 + w, y2).L(x2 + w, y2 + h).L(x2, y2 + h).Z();
                      }
                    } else {
                      this.shape = new SvgShape();
                    }
                  };
                  var SvgElemCircle = function SvgElemCircle2(obj, inherits) {
                    SvgElemBasicShape.call(this, obj, inherits);
                    var cx = this.getLength("cx", this.getVWidth(), 0), cy = this.getLength("cy", this.getVHeight(), 0), r = this.getLength("r", this.getViewport(), 0);
                    if (r > 0) {
                      this.shape = new SvgShape().M(cx + r, cy).A(r, r, 0, 0, 1, cx - r, cy).A(r, r, 0, 0, 1, cx + r, cy).Z();
                    } else {
                      this.shape = new SvgShape();
                    }
                  };
                  var SvgElemEllipse = function SvgElemEllipse2(obj, inherits) {
                    SvgElemBasicShape.call(this, obj, inherits);
                    var cx = this.getLength("cx", this.getVWidth(), 0), cy = this.getLength("cy", this.getVHeight(), 0), rx = this.getLength("rx", this.getVWidth(), 0), ry = this.getLength("ry", this.getVHeight(), 0);
                    if (rx > 0 && ry > 0) {
                      this.shape = new SvgShape().M(cx + rx, cy).A(rx, ry, 0, 0, 1, cx - rx, cy).A(rx, ry, 0, 0, 1, cx + rx, cy).Z();
                    } else {
                      this.shape = new SvgShape();
                    }
                  };
                  var SvgElemLine = function SvgElemLine2(obj, inherits) {
                    SvgElemBasicShape.call(this, obj, inherits);
                    var x1 = this.getLength("x1", this.getVWidth(), 0), y1 = this.getLength("y1", this.getVHeight(), 0), x2 = this.getLength("x2", this.getVWidth(), 0), y2 = this.getLength("y2", this.getVHeight(), 0);
                    this.shape = new SvgShape().M(x1, y1).L(x2, y2);
                  };
                  var SvgElemPolyline = function SvgElemPolyline2(obj, inherits) {
                    SvgElemBasicShape.call(this, obj, inherits);
                    var points = this.getNumberList("points");
                    this.shape = new SvgShape();
                    for (var i2 = 0; i2 < points.length - 1; i2 += 2) {
                      if (i2 === 0) {
                        this.shape.M(points[i2], points[i2 + 1]);
                      } else {
                        this.shape.L(points[i2], points[i2 + 1]);
                      }
                    }
                    if (points.error) {
                      warningCallback("SvgElemPolygon: unexpected string " + points.error);
                    }
                    if (points.length % 2 === 1) {
                      warningCallback("SvgElemPolyline: uneven number of coordinates");
                    }
                  };
                  var SvgElemPolygon = function SvgElemPolygon2(obj, inherits) {
                    SvgElemBasicShape.call(this, obj, inherits);
                    var points = this.getNumberList("points");
                    this.shape = new SvgShape();
                    for (var i2 = 0; i2 < points.length - 1; i2 += 2) {
                      if (i2 === 0) {
                        this.shape.M(points[i2], points[i2 + 1]);
                      } else {
                        this.shape.L(points[i2], points[i2 + 1]);
                      }
                    }
                    this.shape.Z();
                    if (points.error) {
                      warningCallback("SvgElemPolygon: unexpected string " + points.error);
                    }
                    if (points.length % 2 === 1) {
                      warningCallback("SvgElemPolygon: uneven number of coordinates");
                    }
                  };
                  var SvgElemPath = function SvgElemPath2(obj, inherits) {
                    SvgElemBasicShape.call(this, obj, inherits);
                    this.shape = new SvgShape().path(this.attr("d"));
                    var pathLength = this.getLength("pathLength", this.getViewport());
                    this.pathLength = pathLength > 0 ? pathLength : void 0;
                    this.dashScale = this.pathLength !== void 0 ? this.shape.totalLength / this.pathLength : 1;
                  };
                  var SvgElemMarker = function SvgElemMarker2(obj, inherits) {
                    SvgElemHasChildren.call(this, obj, inherits);
                    var width = this.getLength("markerWidth", this.getParentVWidth(), 3), height = this.getLength("markerHeight", this.getParentVHeight(), 3), viewBox = this.getViewbox("viewBox", [0, 0, width, height]);
                    this.getVWidth = function() {
                      return viewBox[2];
                    };
                    this.getVHeight = function() {
                      return viewBox[3];
                    };
                    this.drawMarker = function(isClip, isMask, posArray, strokeWidth) {
                      doc.save();
                      var orient = this.attr("orient"), units = this.attr("markerUnits"), rotate = orient === "auto" ? posArray[2] : (parseFloat(orient) || 0) * Math.PI / 180, scale = units === "userSpaceOnUse" ? 1 : strokeWidth;
                      doc.transform(Math.cos(rotate) * scale, Math.sin(rotate) * scale, -Math.sin(rotate) * scale, Math.cos(rotate) * scale, posArray[0], posArray[1]);
                      var refX = this.getLength("refX", this.getVWidth(), 0), refY = this.getLength("refY", this.getVHeight(), 0), aspectRatioMatrix = parseAspectRatio(this.attr("preserveAspectRatio"), width, height, viewBox[2], viewBox[3], 0.5);
                      if (this.get("overflow") === "hidden") {
                        doc.rect(aspectRatioMatrix[0] * (viewBox[0] + viewBox[2] / 2 - refX) - width / 2, aspectRatioMatrix[3] * (viewBox[1] + viewBox[3] / 2 - refY) - height / 2, width, height).clip();
                      }
                      doc.transform.apply(doc, aspectRatioMatrix);
                      doc.translate(-refX, -refY);
                      var group;
                      if (this.get("opacity") < 1 && !isClip) {
                        group = docBeginGroup(getPageBBox());
                      }
                      this.drawChildren(isClip, isMask);
                      if (group) {
                        docEndGroup(group);
                        doc.fillOpacity(this.get("opacity"));
                        docInsertGroup(group);
                      }
                      doc.restore();
                    };
                  };
                  var SvgElemClipPath = function SvgElemClipPath2(obj, inherits) {
                    SvgElemHasChildren.call(this, obj, inherits);
                    this.useMask = function(bBox) {
                      var group = docBeginGroup(getPageBBox());
                      doc.save();
                      if (this.attr("clipPathUnits") === "objectBoundingBox") {
                        doc.transform(bBox[2] - bBox[0], 0, 0, bBox[3] - bBox[1], bBox[0], bBox[1]);
                      }
                      this.clip();
                      this.drawChildren(true, false);
                      doc.restore();
                      docEndGroup(group);
                      docApplyMask(group, true);
                    };
                  };
                  var SvgElemMask = function SvgElemMask2(obj, inherits) {
                    SvgElemHasChildren.call(this, obj, inherits);
                    this.useMask = function(bBox) {
                      var group = docBeginGroup(getPageBBox());
                      doc.save();
                      var x2, y2, w, h;
                      if (this.attr("maskUnits") === "userSpaceOnUse") {
                        x2 = this.getLength("x", this.getVWidth(), -0.1 * (bBox[2] - bBox[0]) + bBox[0]);
                        y2 = this.getLength("y", this.getVHeight(), -0.1 * (bBox[3] - bBox[1]) + bBox[1]);
                        w = this.getLength("width", this.getVWidth(), 1.2 * (bBox[2] - bBox[0]));
                        h = this.getLength("height", this.getVHeight(), 1.2 * (bBox[3] - bBox[1]));
                      } else {
                        x2 = this.getLength("x", this.getVWidth(), -0.1) * (bBox[2] - bBox[0]) + bBox[0];
                        y2 = this.getLength("y", this.getVHeight(), -0.1) * (bBox[3] - bBox[1]) + bBox[1];
                        w = this.getLength("width", this.getVWidth(), 1.2) * (bBox[2] - bBox[0]);
                        h = this.getLength("height", this.getVHeight(), 1.2) * (bBox[3] - bBox[1]);
                      }
                      doc.rect(x2, y2, w, h).clip();
                      if (this.attr("maskContentUnits") === "objectBoundingBox") {
                        doc.transform(bBox[2] - bBox[0], 0, 0, bBox[3] - bBox[1], bBox[0], bBox[1]);
                      }
                      this.clip();
                      this.drawChildren(false, true);
                      doc.restore();
                      docEndGroup(group);
                      docApplyMask(group, true);
                    };
                  };
                  var SvgElemTextContainer = function SvgElemTextContainer2(obj, inherits) {
                    SvgElemStylable.call(this, obj, inherits);
                    this.allowedChildren = ["tspan", "#text", "#cdata-section", "a"];
                    this.isText = true;
                    this.getBoundingShape = function() {
                      var shape = new SvgShape();
                      for (var i2 = 0; i2 < this._pos.length; i2++) {
                        var pos = this._pos[i2];
                        if (!pos.hidden) {
                          var dx0 = pos.ascent * Math.sin(pos.rotate), dy0 = -pos.ascent * Math.cos(pos.rotate), dx1 = pos.descent * Math.sin(pos.rotate), dy1 = -pos.descent * Math.cos(pos.rotate), dx2 = pos.width * Math.cos(pos.rotate), dy2 = pos.width * Math.sin(pos.rotate);
                          shape.M(pos.x + dx0, pos.y + dy0).L(pos.x + dx0 + dx2, pos.y + dy0 + dy2).M(pos.x + dx1 + dx2, pos.y + dy1 + dy2).L(pos.x + dx1, pos.y + dy1);
                        }
                      }
                      return shape;
                    };
                    this.drawTextInDocument = function(isClip, isMask) {
                      if (this.link && !isClip && !isMask) {
                        this.addLink();
                      }
                      if (this.get("text-decoration") === "underline") {
                        this.decorate(0.05 * this._font.size, -0.075 * this._font.size, isClip, isMask);
                      }
                      if (this.get("text-decoration") === "overline") {
                        this.decorate(0.05 * this._font.size, getAscent(this._font.font, this._font.size) + 0.075 * this._font.size, isClip, isMask);
                      }
                      var fill = this.getFill(isClip, isMask), stroke = this.getStroke(isClip, isMask), strokeWidth = this.get("stroke-width");
                      if (this._font.fauxBold) {
                        if (!stroke) {
                          stroke = fill;
                          strokeWidth = this._font.size * 0.03;
                        } else {
                          strokeWidth += this._font.size * 0.03;
                        }
                      }
                      var children = this.getChildren();
                      for (var i2 = 0; i2 < children.length; i2++) {
                        var childElem = children[i2];
                        switch (childElem.name) {
                          case "tspan":
                          case "textPath":
                          case "a":
                            if (childElem.get("display") !== "none") {
                              childElem.drawTextInDocument(isClip, isMask);
                            }
                            break;
                          case "#text":
                          case "#cdata-section":
                            if (this.get("visibility") === "hidden") {
                              continue;
                            }
                            if (fill || stroke || isClip) {
                              if (fill) {
                                docFillColor(fill);
                              }
                              if (stroke && strokeWidth) {
                                docStrokeColor(stroke);
                                doc.lineWidth(strokeWidth).miterLimit(this.get("stroke-miterlimit")).lineJoin(this.get("stroke-linejoin")).lineCap(this.get("stroke-linecap")).dash(this.get("stroke-dasharray"), {
                                  phase: this.get("stroke-dashoffset")
                                });
                              }
                              docBeginText(this._font.font, this._font.size);
                              docSetTextMode(!!fill, !!stroke);
                              for (var j = 0, pos = childElem._pos; j < pos.length; j++) {
                                if (!pos[j].hidden && isNotEqual(pos[j].width, 0)) {
                                  var cos = Math.cos(pos[j].rotate), sin = Math.sin(pos[j].rotate), skew = this._font.fauxItalic ? -0.25 : 0;
                                  docSetTextMatrix(cos * pos[j].scale, sin * pos[j].scale, cos * skew - sin, sin * skew + cos, pos[j].x, pos[j].y);
                                  docWriteGlyph(pos[j].glyph);
                                }
                              }
                              docEndText();
                            }
                            break;
                        }
                      }
                      if (this.get("text-decoration") === "line-through") {
                        this.decorate(0.05 * this._font.size, 0.5 * (getAscent(this._font.font, this._font.size) + getDescent(this._font.font, this._font.size)), isClip, isMask);
                      }
                    };
                    this.decorate = function(lineWidth, linePosition, isClip, isMask) {
                      var fill = this.getFill(isClip, isMask), stroke = this.getStroke(isClip, isMask);
                      if (fill) {
                        docFillColor(fill);
                      }
                      if (stroke) {
                        docStrokeColor(stroke);
                        doc.lineWidth(this.get("stroke-width")).miterLimit(this.get("stroke-miterlimit")).lineJoin(this.get("stroke-linejoin")).lineCap(this.get("stroke-linecap")).dash(this.get("stroke-dasharray"), {
                          phase: this.get("stroke-dashoffset")
                        });
                      }
                      for (var j = 0, pos = this._pos; j < pos.length; j++) {
                        if (!pos[j].hidden && isNotEqual(pos[j].width, 0)) {
                          var dx0 = (linePosition + lineWidth / 2) * Math.sin(pos[j].rotate), dy0 = -(linePosition + lineWidth / 2) * Math.cos(pos[j].rotate), dx1 = (linePosition - lineWidth / 2) * Math.sin(pos[j].rotate), dy1 = -(linePosition - lineWidth / 2) * Math.cos(pos[j].rotate), dx2 = pos[j].width * Math.cos(pos[j].rotate), dy2 = pos[j].width * Math.sin(pos[j].rotate);
                          new SvgShape().M(pos[j].x + dx0, pos[j].y + dy0).L(pos[j].x + dx0 + dx2, pos[j].y + dy0 + dy2).L(pos[j].x + dx1 + dx2, pos[j].y + dy1 + dy2).L(pos[j].x + dx1, pos[j].y + dy1).Z().insertInDocument();
                          if (fill && stroke) {
                            doc.fillAndStroke();
                          } else if (fill) {
                            doc.fill();
                          } else if (stroke) {
                            doc.stroke();
                          }
                        }
                      }
                    };
                  };
                  var SvgElemTextNode = function SvgElemTextNode2(obj, inherits) {
                    this.name = obj.nodeName;
                    this.textContent = obj.nodeValue;
                  };
                  var SvgElemTspan = function SvgElemTspan2(obj, inherits) {
                    SvgElemTextContainer.call(this, obj, inherits);
                  };
                  var SvgElemTextPath = function SvgElemTextPath2(obj, inherits) {
                    SvgElemTextContainer.call(this, obj, inherits);
                    var pathObject, pathLength, temp;
                    if ((temp = this.attr("path")) && temp.trim() !== "") {
                      var _pathLength = this.getLength("pathLength", this.getViewport());
                      this.pathObject = new SvgShape().path(temp);
                      this.pathLength = _pathLength > 0 ? _pathLength : this.pathObject.totalLength;
                      this.pathScale = this.pathObject.totalLength / this.pathLength;
                    } else if ((temp = this.getUrl("href") || this.getUrl("xlink:href")) && temp.nodeName === "path") {
                      var pathElem = new SvgElemPath(temp, this);
                      this.pathObject = pathElem.shape.clone().transform(pathElem.get("transform"));
                      this.pathLength = this.chooseValue(pathElem.pathLength, this.pathObject.totalLength);
                      this.pathScale = this.pathObject.totalLength / this.pathLength;
                    }
                  };
                  var SvgElemText = function SvgElemText2(obj, inherits) {
                    SvgElemTextContainer.call(this, obj, inherits);
                    this.allowedChildren = ["textPath", "tspan", "#text", "#cdata-section", "a"];
                    (function(textParentElem) {
                      var processedText = "", remainingText = obj.textContent, textPaths = [], currentChunk = [], currentAnchor, currentDirection, currentX = 0, currentY = 0;
                      function doAnchoring() {
                        if (currentChunk.length) {
                          var last = currentChunk[currentChunk.length - 1];
                          var first = currentChunk[0];
                          var width = last.x + last.width - first.x;
                          var anchordx = {
                            "startltr": 0,
                            "middleltr": 0.5,
                            "endltr": 1,
                            "startrtl": 1,
                            "middlertl": 0.5,
                            "endrtl": 0
                          }[currentAnchor + currentDirection] * width || 0;
                          for (var i3 = 0; i3 < currentChunk.length; i3++) {
                            currentChunk[i3].x -= anchordx;
                          }
                        }
                        currentChunk = [];
                      }
                      function adjustLength(pos, length, spacingAndGlyphs) {
                        var firstChar = pos[0], lastChar = pos[pos.length - 1], startX = firstChar.x, endX = lastChar.x + lastChar.width;
                        if (spacingAndGlyphs) {
                          var textScale = length / (endX - startX);
                          if (textScale > 0 && textScale < Infinity) {
                            for (var j = 0; j < pos.length; j++) {
                              pos[j].x = startX + textScale * (pos[j].x - startX);
                              pos[j].scale *= textScale;
                              pos[j].width *= textScale;
                            }
                          }
                        } else {
                          if (pos.length >= 2) {
                            var spaceDiff = (length - (endX - startX)) / (pos.length - 1);
                            for (var _j4 = 0; _j4 < pos.length; _j4++) {
                              pos[_j4].x += _j4 * spaceDiff;
                            }
                          }
                        }
                        currentX += length - (endX - startX);
                      }
                      function recursive(currentElem, parentElem) {
                        currentElem._x = combineArrays(currentElem.getLengthList("x", currentElem.getVWidth()), parentElem ? parentElem._x.slice(parentElem._pos.length) : []);
                        currentElem._y = combineArrays(currentElem.getLengthList("y", currentElem.getVHeight()), parentElem ? parentElem._y.slice(parentElem._pos.length) : []);
                        currentElem._dx = combineArrays(currentElem.getLengthList("dx", currentElem.getVWidth()), parentElem ? parentElem._dx.slice(parentElem._pos.length) : []);
                        currentElem._dy = combineArrays(currentElem.getLengthList("dy", currentElem.getVHeight()), parentElem ? parentElem._dy.slice(parentElem._pos.length) : []);
                        currentElem._rot = combineArrays(currentElem.getNumberList("rotate"), parentElem ? parentElem._rot.slice(parentElem._pos.length) : []);
                        currentElem._defRot = currentElem.chooseValue(currentElem._rot[currentElem._rot.length - 1], parentElem && parentElem._defRot, 0);
                        if (currentElem.name === "textPath") {
                          currentElem._y = [];
                        }
                        var fontOptions = {
                          fauxItalic: false,
                          fauxBold: false
                        }, fontNameorLink = fontCallback(currentElem.get("font-family"), currentElem.get("font-weight") === "bold", currentElem.get("font-style") === "italic", fontOptions);
                        try {
                          doc.font(fontNameorLink);
                        } catch (e) {
                          warningCallback('SVGElemText: failed to open font "' + fontNameorLink + '" in PDFKit');
                        }
                        currentElem._pos = [];
                        currentElem._index = 0;
                        currentElem._font = {
                          font: doc._font,
                          size: currentElem.get("font-size"),
                          fauxItalic: fontOptions.fauxItalic,
                          fauxBold: fontOptions.fauxBold
                        };
                        var textLength = currentElem.getLength("textLength", currentElem.getVWidth(), void 0), spacingAndGlyphs = currentElem.attr("lengthAdjust") === "spacingAndGlyphs", wordSpacing = currentElem.get("word-spacing"), letterSpacing = currentElem.get("letter-spacing"), textAnchor = currentElem.get("text-anchor"), textDirection = currentElem.get("direction"), baseline = getBaseline(currentElem._font.font, currentElem._font.size, currentElem.get("alignment-baseline") || currentElem.get("dominant-baseline"), currentElem.get("baseline-shift"));
                        if (currentElem.name === "textPath") {
                          doAnchoring();
                          currentX = currentY = 0;
                        }
                        var children = currentElem.getChildren();
                        for (var i3 = 0; i3 < children.length; i3++) {
                          var childElem = children[i3];
                          switch (childElem.name) {
                            case "tspan":
                            case "textPath":
                            case "a":
                              recursive(childElem, currentElem);
                              break;
                            case "#text":
                            case "#cdata-section":
                              var rawText = childElem.textContent, renderedText = rawText, words = void 0;
                              childElem._font = currentElem._font;
                              childElem._pos = [];
                              remainingText = remainingText.substring(rawText.length);
                              if (currentElem.get("xml:space") === "preserve") {
                                renderedText = renderedText.replace(/[\s]/g, " ");
                              } else {
                                renderedText = renderedText.replace(/[\s]+/g, " ");
                                if (processedText.match(/[\s]$|^$/)) {
                                  renderedText = renderedText.replace(/^[\s]/, "");
                                }
                                if (remainingText.match(/^[\s]*$/)) {
                                  renderedText = renderedText.replace(/[\s]$/, "");
                                }
                              }
                              processedText += rawText;
                              if (wordSpacing === 0) {
                                words = [renderedText];
                              } else {
                                words = renderedText.split(/(\s)/);
                              }
                              for (var w = 0; w < words.length; w++) {
                                var pos = getTextPos(currentElem._font.font, currentElem._font.size, words[w]);
                                for (var j = 0; j < pos.length; j++) {
                                  var index = currentElem._index, xAttr = currentElem._x[index], yAttr = currentElem._y[index], dxAttr = currentElem._dx[index], dyAttr = currentElem._dy[index], rotAttr = currentElem._rot[index], continuous = !(w === 0 && j === 0);
                                  if (xAttr !== void 0) {
                                    continuous = false;
                                    doAnchoring();
                                    currentX = xAttr;
                                  }
                                  if (yAttr !== void 0) {
                                    continuous = false;
                                    doAnchoring();
                                    currentY = yAttr;
                                  }
                                  if (dxAttr !== void 0) {
                                    continuous = false;
                                    currentX += dxAttr;
                                  }
                                  if (dyAttr !== void 0) {
                                    continuous = false;
                                    currentY += dyAttr;
                                  }
                                  if (rotAttr !== void 0 || currentElem._defRot !== 0) {
                                    continuous = false;
                                  }
                                  var position = {
                                    glyph: pos[j].glyph,
                                    rotate: Math.PI / 180 * currentElem.chooseValue(rotAttr, currentElem._defRot),
                                    x: currentX + pos[j].xOffset,
                                    y: currentY + baseline + pos[j].yOffset,
                                    width: pos[j].width,
                                    ascent: getAscent(currentElem._font.font, currentElem._font.size),
                                    descent: getDescent(currentElem._font.font, currentElem._font.size),
                                    scale: 1,
                                    hidden: false,
                                    continuous
                                  };
                                  currentChunk.push(position);
                                  childElem._pos.push(position);
                                  currentElem._pos.push(position);
                                  currentElem._index += pos[j].unicode.length;
                                  if (currentChunk.length === 1) {
                                    currentAnchor = textAnchor;
                                    currentDirection = textDirection;
                                  }
                                  currentX += pos[j].xAdvance + letterSpacing;
                                  currentY += pos[j].yAdvance;
                                }
                                if (words[w] === " ") {
                                  currentX += wordSpacing;
                                }
                              }
                              break;
                            default:
                              remainingText = remainingText.substring(childElem.textContent.length);
                          }
                        }
                        if (textLength && currentElem._pos.length) {
                          adjustLength(currentElem._pos, textLength, spacingAndGlyphs);
                        }
                        if (currentElem.name === "textPath" || currentElem.name === "text") {
                          doAnchoring();
                        }
                        if (currentElem.name === "textPath") {
                          textPaths.push(currentElem);
                          var pathObject = currentElem.pathObject;
                          if (pathObject) {
                            currentX = pathObject.endPoint[0];
                            currentY = pathObject.endPoint[1];
                          }
                        }
                        if (parentElem) {
                          parentElem._pos = parentElem._pos.concat(currentElem._pos);
                          parentElem._index += currentElem._index;
                        }
                      }
                      function textOnPath(currentElem) {
                        var pathObject = currentElem.pathObject, pathLength = currentElem.pathLength, pathScale = currentElem.pathScale;
                        if (pathObject) {
                          var textOffset = currentElem.getLength("startOffset", pathLength, 0);
                          for (var j = 0; j < currentElem._pos.length; j++) {
                            var charMidX = textOffset + currentElem._pos[j].x + 0.5 * currentElem._pos[j].width;
                            if (charMidX > pathLength || charMidX < 0) {
                              currentElem._pos[j].hidden = true;
                            } else {
                              var pointOnPath = pathObject.getPointAtLength(charMidX * pathScale);
                              if (isNotEqual(pathScale, 1)) {
                                currentElem._pos[j].scale *= pathScale;
                                currentElem._pos[j].width *= pathScale;
                              }
                              currentElem._pos[j].x = pointOnPath[0] - 0.5 * currentElem._pos[j].width * Math.cos(pointOnPath[2]) - currentElem._pos[j].y * Math.sin(pointOnPath[2]);
                              currentElem._pos[j].y = pointOnPath[1] - 0.5 * currentElem._pos[j].width * Math.sin(pointOnPath[2]) + currentElem._pos[j].y * Math.cos(pointOnPath[2]);
                              currentElem._pos[j].rotate = pointOnPath[2] + currentElem._pos[j].rotate;
                              currentElem._pos[j].continuous = false;
                            }
                          }
                        } else {
                          for (var _j5 = 0; _j5 < currentElem._pos.length; _j5++) {
                            currentElem._pos[_j5].hidden = true;
                          }
                        }
                      }
                      recursive(textParentElem, null);
                      for (var i2 = 0; i2 < textPaths.length; i2++) {
                        textOnPath(textPaths[i2]);
                      }
                    })(this);
                    this.getTransformation = function() {
                      return this.get("transform");
                    };
                    this.drawInDocument = function(isClip, isMask) {
                      doc.save();
                      this.transform();
                      this.clip();
                      var masked = this.mask(), group;
                      if (masked) {
                        group = docBeginGroup(getPageBBox());
                      }
                      this.drawTextInDocument(isClip, isMask);
                      if (group) {
                        docEndGroup(group);
                        docInsertGroup(group);
                      }
                      doc.restore();
                    };
                  };
                  options = options || {};
                  var pxToPt = options.assumePt ? 1 : 72 / 96, viewportWidth = (options.width || doc.page.width) / pxToPt, viewportHeight = (options.height || doc.page.height) / pxToPt, preserveAspectRatio = options.preserveAspectRatio || null, useCSS = options.useCSS && typeof SVGElement !== "undefined" && svg instanceof SVGElement && typeof getComputedStyle === "function", warningCallback = options.warningCallback, fontCallback = options.fontCallback, imageCallback = options.imageCallback, colorCallback = options.colorCallback, documentCallback = options.documentCallback, precision = Math.ceil(Math.max(1, options.precision)) || 3, groupStack = [], documentCache = {}, links = [], styleRules = [];
                  if (typeof warningCallback !== "function") {
                    warningCallback = function warningCallback2(str) {
                      if (typeof console !== void 0 && typeof console.warn === "function") {
                        console.warn(str);
                      }
                    };
                  }
                  if (typeof fontCallback !== "function") {
                    fontCallback = function fontCallback2(family, bold, italic, fontOptions) {
                      if (bold && italic) {
                        if (doc._registeredFonts.hasOwnProperty(family + "-BoldItalic")) {
                          return family + "-BoldItalic";
                        } else if (doc._registeredFonts.hasOwnProperty(family + "-Italic")) {
                          fontOptions.fauxBold = true;
                          return family + "-Italic";
                        } else if (doc._registeredFonts.hasOwnProperty(family + "-Bold")) {
                          fontOptions.fauxItalic = true;
                          return family + "-Bold";
                        } else if (doc._registeredFonts.hasOwnProperty(family)) {
                          fontOptions.fauxBold = true;
                          fontOptions.fauxItalic = true;
                          return family;
                        }
                      }
                      if (bold && !italic) {
                        if (doc._registeredFonts.hasOwnProperty(family + "-Bold")) {
                          return family + "-Bold";
                        } else if (doc._registeredFonts.hasOwnProperty(family)) {
                          fontOptions.fauxBold = true;
                          return family;
                        }
                      }
                      if (!bold && italic) {
                        if (doc._registeredFonts.hasOwnProperty(family + "-Italic")) {
                          return family + "-Italic";
                        } else if (doc._registeredFonts.hasOwnProperty(family)) {
                          fontOptions.fauxItalic = true;
                          return family;
                        }
                      }
                      if (!bold && !italic) {
                        if (doc._registeredFonts.hasOwnProperty(family)) {
                          return family;
                        }
                      }
                      if (family.match(/(?:^|,)\s*serif\s*$/)) {
                        if (bold && italic) {
                          return "Times-BoldItalic";
                        }
                        if (bold && !italic) {
                          return "Times-Bold";
                        }
                        if (!bold && italic) {
                          return "Times-Italic";
                        }
                        if (!bold && !italic) {
                          return "Times-Roman";
                        }
                      } else if (family.match(/(?:^|,)\s*monospace\s*$/)) {
                        if (bold && italic) {
                          return "Courier-BoldOblique";
                        }
                        if (bold && !italic) {
                          return "Courier-Bold";
                        }
                        if (!bold && italic) {
                          return "Courier-Oblique";
                        }
                        if (!bold && !italic) {
                          return "Courier";
                        }
                      } else if (family.match(/(?:^|,)\s*sans-serif\s*$/) || true) {
                        if (bold && italic) {
                          return "Helvetica-BoldOblique";
                        }
                        if (bold && !italic) {
                          return "Helvetica-Bold";
                        }
                        if (!bold && italic) {
                          return "Helvetica-Oblique";
                        }
                        if (!bold && !italic) {
                          return "Helvetica";
                        }
                      }
                    };
                  }
                  if (typeof imageCallback !== "function") {
                    imageCallback = function imageCallback2(link) {
                      return link.replace(/\s+/g, "");
                    };
                  }
                  if (typeof colorCallback !== "function") {
                    colorCallback = null;
                  } else {
                    for (var color in DefaultColors) {
                      var newColor = colorCallback(DefaultColors[color]);
                      DefaultColors[color][0] = newColor[0];
                      DefaultColors[color][1] = newColor[1];
                    }
                  }
                  if (typeof documentCallback !== "function") {
                    documentCallback = null;
                  }
                  if (typeof svg === "string") {
                    svg = parseXml(svg);
                  }
                  if (svg) {
                    var styles = svg.getElementsByTagName("style");
                    for (var i = 0; i < styles.length; i++) {
                      styleRules = styleRules.concat(parseStyleSheet(styles[i].textContent));
                    }
                    var elem = createSVGElement(svg, null);
                    if (typeof elem.drawInDocument === "function") {
                      if (options.useCSS && !useCSS) {
                        warningCallback("SVGtoPDF: useCSS option can only be used for SVG *elements* in compatible browsers");
                      }
                      var savedFillColor = doc._fillColor;
                      doc.save().translate(x || 0, y || 0).scale(pxToPt);
                      elem.drawInDocument();
                      for (var _i8 = 0; _i8 < links.length; _i8++) {
                        doc.page.annotations.push(links[_i8]);
                      }
                      doc.restore();
                      doc._fillColor = savedFillColor;
                    } else {
                      warningCallback("SVGtoPDF: this element can't be rendered directly: " + svg.nodeName);
                    }
                  } else {
                    warningCallback("SVGtoPDF: the input does not look like a valid SVG");
                  }
                };
                if (module2 && typeof module2.exports !== "undefined") {
                  module2.exports = SVGtoPDF;
                }
              }
            ),
            /***/
            9742: (
              /***/
              function(__unused_webpack_module, exports2) {
                "use strict";
                exports2.byteLength = byteLength;
                exports2.toByteArray = toByteArray;
                exports2.fromByteArray = fromByteArray;
                var lookup = [];
                var revLookup = [];
                var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
                var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                for (var i = 0, len = code.length; i < len; ++i) {
                  lookup[i] = code[i];
                  revLookup[code.charCodeAt(i)] = i;
                }
                revLookup["-".charCodeAt(0)] = 62;
                revLookup["_".charCodeAt(0)] = 63;
                function getLens(b64) {
                  var len2 = b64.length;
                  if (len2 % 4 > 0) {
                    throw new Error("Invalid string. Length must be a multiple of 4");
                  }
                  var validLen = b64.indexOf("=");
                  if (validLen === -1)
                    validLen = len2;
                  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
                  return [validLen, placeHoldersLen];
                }
                function byteLength(b64) {
                  var lens = getLens(b64);
                  var validLen = lens[0];
                  var placeHoldersLen = lens[1];
                  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
                }
                function _byteLength(b64, validLen, placeHoldersLen) {
                  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
                }
                function toByteArray(b64) {
                  var tmp;
                  var lens = getLens(b64);
                  var validLen = lens[0];
                  var placeHoldersLen = lens[1];
                  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
                  var curByte = 0;
                  var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
                  var i2;
                  for (i2 = 0; i2 < len2; i2 += 4) {
                    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
                    arr[curByte++] = tmp >> 16 & 255;
                    arr[curByte++] = tmp >> 8 & 255;
                    arr[curByte++] = tmp & 255;
                  }
                  if (placeHoldersLen === 2) {
                    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
                    arr[curByte++] = tmp & 255;
                  }
                  if (placeHoldersLen === 1) {
                    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
                    arr[curByte++] = tmp >> 8 & 255;
                    arr[curByte++] = tmp & 255;
                  }
                  return arr;
                }
                function tripletToBase64(num) {
                  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
                }
                function encodeChunk(uint8, start, end) {
                  var tmp;
                  var output = [];
                  for (var i2 = start; i2 < end; i2 += 3) {
                    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
                    output.push(tripletToBase64(tmp));
                  }
                  return output.join("");
                }
                function fromByteArray(uint8) {
                  var tmp;
                  var len2 = uint8.length;
                  var extraBytes = len2 % 3;
                  var parts = [];
                  var maxChunkLength = 16383;
                  for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
                    parts.push(encodeChunk(
                      uint8,
                      i2,
                      i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength
                    ));
                  }
                  if (extraBytes === 1) {
                    tmp = uint8[len2 - 1];
                    parts.push(
                      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
                    );
                  } else if (extraBytes === 2) {
                    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
                    parts.push(
                      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
                    );
                  }
                  return parts.join("");
                }
              }
            ),
            /***/
            4181: (
              /***/
              function(module2) {
                var BROTLI_READ_SIZE = 4096;
                var BROTLI_IBUF_SIZE = 2 * BROTLI_READ_SIZE + 32;
                var BROTLI_IBUF_MASK = 2 * BROTLI_READ_SIZE - 1;
                var kBitMask = new Uint32Array([
                  0,
                  1,
                  3,
                  7,
                  15,
                  31,
                  63,
                  127,
                  255,
                  511,
                  1023,
                  2047,
                  4095,
                  8191,
                  16383,
                  32767,
                  65535,
                  131071,
                  262143,
                  524287,
                  1048575,
                  2097151,
                  4194303,
                  8388607,
                  16777215
                ]);
                function BrotliBitReader(input) {
                  this.buf_ = new Uint8Array(BROTLI_IBUF_SIZE);
                  this.input_ = input;
                  this.reset();
                }
                BrotliBitReader.READ_SIZE = BROTLI_READ_SIZE;
                BrotliBitReader.IBUF_MASK = BROTLI_IBUF_MASK;
                BrotliBitReader.prototype.reset = function() {
                  this.buf_ptr_ = 0;
                  this.val_ = 0;
                  this.pos_ = 0;
                  this.bit_pos_ = 0;
                  this.bit_end_pos_ = 0;
                  this.eos_ = 0;
                  this.readMoreInput();
                  for (var i = 0; i < 4; i++) {
                    this.val_ |= this.buf_[this.pos_] << 8 * i;
                    ++this.pos_;
                  }
                  return this.bit_end_pos_ > 0;
                };
                BrotliBitReader.prototype.readMoreInput = function() {
                  if (this.bit_end_pos_ > 256) {
                    return;
                  } else if (this.eos_) {
                    if (this.bit_pos_ > this.bit_end_pos_)
                      throw new Error("Unexpected end of input " + this.bit_pos_ + " " + this.bit_end_pos_);
                  } else {
                    var dst = this.buf_ptr_;
                    var bytes_read = this.input_.read(this.buf_, dst, BROTLI_READ_SIZE);
                    if (bytes_read < 0) {
                      throw new Error("Unexpected end of input");
                    }
                    if (bytes_read < BROTLI_READ_SIZE) {
                      this.eos_ = 1;
                      for (var p = 0; p < 32; p++)
                        this.buf_[dst + bytes_read + p] = 0;
                    }
                    if (dst === 0) {
                      for (var p = 0; p < 32; p++)
                        this.buf_[(BROTLI_READ_SIZE << 1) + p] = this.buf_[p];
                      this.buf_ptr_ = BROTLI_READ_SIZE;
                    } else {
                      this.buf_ptr_ = 0;
                    }
                    this.bit_end_pos_ += bytes_read << 3;
                  }
                };
                BrotliBitReader.prototype.fillBitWindow = function() {
                  while (this.bit_pos_ >= 8) {
                    this.val_ >>>= 8;
                    this.val_ |= this.buf_[this.pos_ & BROTLI_IBUF_MASK] << 24;
                    ++this.pos_;
                    this.bit_pos_ = this.bit_pos_ - 8 >>> 0;
                    this.bit_end_pos_ = this.bit_end_pos_ - 8 >>> 0;
                  }
                };
                BrotliBitReader.prototype.readBits = function(n_bits) {
                  if (32 - this.bit_pos_ < n_bits) {
                    this.fillBitWindow();
                  }
                  var val = this.val_ >>> this.bit_pos_ & kBitMask[n_bits];
                  this.bit_pos_ += n_bits;
                  return val;
                };
                module2.exports = BrotliBitReader;
              }
            ),
            /***/
            7080: (
              /***/
              function(__unused_webpack_module, exports2) {
                var CONTEXT_LSB6 = 0;
                var CONTEXT_MSB6 = 1;
                var CONTEXT_UTF8 = 2;
                var CONTEXT_SIGNED = 3;
                exports2.lookup = new Uint8Array([
                  /* CONTEXT_UTF8, last byte. */
                  /* ASCII range. */
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  4,
                  4,
                  0,
                  0,
                  4,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  8,
                  12,
                  16,
                  12,
                  12,
                  20,
                  12,
                  16,
                  24,
                  28,
                  12,
                  12,
                  32,
                  12,
                  36,
                  12,
                  44,
                  44,
                  44,
                  44,
                  44,
                  44,
                  44,
                  44,
                  44,
                  44,
                  32,
                  32,
                  24,
                  40,
                  28,
                  12,
                  12,
                  48,
                  52,
                  52,
                  52,
                  48,
                  52,
                  52,
                  52,
                  48,
                  52,
                  52,
                  52,
                  52,
                  52,
                  48,
                  52,
                  52,
                  52,
                  52,
                  52,
                  48,
                  52,
                  52,
                  52,
                  52,
                  52,
                  24,
                  12,
                  28,
                  12,
                  12,
                  12,
                  56,
                  60,
                  60,
                  60,
                  56,
                  60,
                  60,
                  60,
                  56,
                  60,
                  60,
                  60,
                  60,
                  60,
                  56,
                  60,
                  60,
                  60,
                  60,
                  60,
                  56,
                  60,
                  60,
                  60,
                  60,
                  60,
                  24,
                  12,
                  28,
                  12,
                  0,
                  /* UTF8 continuation byte range. */
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  0,
                  1,
                  /* UTF8 lead byte range. */
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  2,
                  3,
                  /* CONTEXT_UTF8 second last byte. */
                  /* ASCII range. */
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  1,
                  1,
                  1,
                  1,
                  0,
                  /* UTF8 continuation byte range. */
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  /* UTF8 lead byte range. */
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  /* CONTEXT_SIGNED, second last byte. */
                  0,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  1,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  4,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  5,
                  6,
                  6,
                  6,
                  6,
                  6,
                  6,
                  6,
                  6,
                  6,
                  6,
                  6,
                  6,
                  6,
                  6,
                  6,
                  7,
                  /* CONTEXT_SIGNED, last byte, same as the above values shifted by 3 bits. */
                  0,
                  8,
                  8,
                  8,
                  8,
                  8,
                  8,
                  8,
                  8,
                  8,
                  8,
                  8,
                  8,
                  8,
                  8,
                  8,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  24,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  32,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  40,
                  48,
                  48,
                  48,
                  48,
                  48,
                  48,
                  48,
                  48,
                  48,
                  48,
                  48,
                  48,
                  48,
                  48,
                  48,
                  56,
                  /* CONTEXT_LSB6, last byte. */
                  0,
                  1,
                  2,
                  3,
                  4,
                  5,
                  6,
                  7,
                  8,
                  9,
                  10,
                  11,
                  12,
                  13,
                  14,
                  15,
                  16,
                  17,
                  18,
                  19,
                  20,
                  21,
                  22,
                  23,
                  24,
                  25,
                  26,
                  27,
                  28,
                  29,
                  30,
                  31,
                  32,
                  33,
                  34,
                  35,
                  36,
                  37,
                  38,
                  39,
                  40,
                  41,
                  42,
                  43,
                  44,
                  45,
                  46,
                  47,
                  48,
                  49,
                  50,
                  51,
                  52,
                  53,
                  54,
                  55,
                  56,
                  57,
                  58,
                  59,
                  60,
                  61,
                  62,
                  63,
                  0,
                  1,
                  2,
                  3,
                  4,
                  5,
                  6,
                  7,
                  8,
                  9,
                  10,
                  11,
                  12,
                  13,
                  14,
                  15,
                  16,
                  17,
                  18,
                  19,
                  20,
                  21,
                  22,
                  23,
                  24,
                  25,
                  26,
                  27,
                  28,
                  29,
                  30,
                  31,
                  32,
                  33,
                  34,
                  35,
                  36,
                  37,
                  38,
                  39,
                  40,
                  41,
                  42,
                  43,
                  44,
                  45,
                  46,
                  47,
                  48,
                  49,
                  50,
                  51,
                  52,
                  53,
                  54,
                  55,
                  56,
                  57,
                  58,
                  59,
                  60,
                  61,
                  62,
                  63,
                  0,
                  1,
                  2,
                  3,
                  4,
                  5,
                  6,
                  7,
                  8,
                  9,
                  10,
                  11,
                  12,
                  13,
                  14,
                  15,
                  16,
                  17,
                  18,
                  19,
                  20,
                  21,
                  22,
                  23,
                  24,
                  25,
                  26,
                  27,
                  28,
                  29,
                  30,
                  31,
                  32,
                  33,
                  34,
                  35,
                  36,
                  37,
                  38,
                  39,
                  40,
                  41,
                  42,
                  43,
                  44,
                  45,
                  46,
                  47,
                  48,
                  49,
                  50,
                  51,
                  52,
                  53,
                  54,
                  55,
                  56,
                  57,
                  58,
                  59,
                  60,
                  61,
                  62,
                  63,
                  0,
                  1,
                  2,
                  3,
                  4,
                  5,
                  6,
                  7,
                  8,
                  9,
                  10,
                  11,
                  12,
                  13,
                  14,
                  15,
                  16,
                  17,
                  18,
                  19,
                  20,
                  21,
                  22,
                  23,
                  24,
                  25,
                  26,
                  27,
                  28,
                  29,
                  30,
                  31,
                  32,
                  33,
                  34,
                  35,
                  36,
                  37,
                  38,
                  39,
                  40,
                  41,
                  42,
                  43,
                  44,
                  45,
                  46,
                  47,
                  48,
                  49,
                  50,
                  51,
                  52,
                  53,
                  54,
                  55,
                  56,
                  57,
                  58,
                  59,
                  60,
                  61,
                  62,
                  63,
                  /* CONTEXT_MSB6, last byte. */
                  0,
                  0,
                  0,
                  0,
                  1,
                  1,
                  1,
                  1,
                  2,
                  2,
                  2,
                  2,
                  3,
                  3,
                  3,
                  3,
                  4,
                  4,
                  4,
                  4,
                  5,
                  5,
                  5,
                  5,
                  6,
                  6,
                  6,
                  6,
                  7,
                  7,
                  7,
                  7,
                  8,
                  8,
                  8,
                  8,
                  9,
                  9,
                  9,
                  9,
                  10,
                  10,
                  10,
                  10,
                  11,
                  11,
                  11,
                  11,
                  12,
                  12,
                  12,
                  12,
                  13,
                  13,
                  13,
                  13,
                  14,
                  14,
                  14,
                  14,
                  15,
                  15,
                  15,
                  15,
                  16,
                  16,
                  16,
                  16,
                  17,
                  17,
                  17,
                  17,
                  18,
                  18,
                  18,
                  18,
                  19,
                  19,
                  19,
                  19,
                  20,
                  20,
                  20,
                  20,
                  21,
                  21,
                  21,
                  21,
                  22,
                  22,
                  22,
                  22,
                  23,
                  23,
                  23,
                  23,
                  24,
                  24,
                  24,
                  24,
                  25,
                  25,
                  25,
                  25,
                  26,
                  26,
                  26,
                  26,
                  27,
                  27,
                  27,
                  27,
                  28,
                  28,
                  28,
                  28,
                  29,
                  29,
                  29,
                  29,
                  30,
                  30,
                  30,
                  30,
                  31,
                  31,
                  31,
                  31,
                  32,
                  32,
                  32,
                  32,
                  33,
                  33,
                  33,
                  33,
                  34,
                  34,
                  34,
                  34,
                  35,
                  35,
                  35,
                  35,
                  36,
                  36,
                  36,
                  36,
                  37,
                  37,
                  37,
                  37,
                  38,
                  38,
                  38,
                  38,
                  39,
                  39,
                  39,
                  39,
                  40,
                  40,
                  40,
                  40,
                  41,
                  41,
                  41,
                  41,
                  42,
                  42,
                  42,
                  42,
                  43,
                  43,
                  43,
                  43,
                  44,
                  44,
                  44,
                  44,
                  45,
                  45,
                  45,
                  45,
                  46,
                  46,
                  46,
                  46,
                  47,
                  47,
                  47,
                  47,
                  48,
                  48,
                  48,
                  48,
                  49,
                  49,
                  49,
                  49,
                  50,
                  50,
                  50,
                  50,
                  51,
                  51,
                  51,
                  51,
                  52,
                  52,
                  52,
                  52,
                  53,
                  53,
                  53,
                  53,
                  54,
                  54,
                  54,
                  54,
                  55,
                  55,
                  55,
                  55,
                  56,
                  56,
                  56,
                  56,
                  57,
                  57,
                  57,
                  57,
                  58,
                  58,
                  58,
                  58,
                  59,
                  59,
                  59,
                  59,
                  60,
                  60,
                  60,
                  60,
                  61,
                  61,
                  61,
                  61,
                  62,
                  62,
                  62,
                  62,
                  63,
                  63,
                  63,
                  63,
                  /* CONTEXT_{M,L}SB6, second last byte, */
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0
                ]);
                exports2.lookupOffsets = new Uint16Array([
                  /* CONTEXT_LSB6 */
                  1024,
                  1536,
                  /* CONTEXT_MSB6 */
                  1280,
                  1536,
                  /* CONTEXT_UTF8 */
                  0,
                  256,
                  /* CONTEXT_SIGNED */
                  768,
                  512
                ]);
              }
            ),
            /***/
            6450: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                var __webpack_unused_export__;
                var BrotliInput = __webpack_require__2(6154).g;
                var BrotliOutput = __webpack_require__2(6154).j;
                var BrotliBitReader = __webpack_require__2(4181);
                var BrotliDictionary = __webpack_require__2(5139);
                var HuffmanCode = __webpack_require__2(966).h;
                var BrotliBuildHuffmanTable = __webpack_require__2(966).g;
                var Context = __webpack_require__2(7080);
                var Prefix = __webpack_require__2(8435);
                var Transform = __webpack_require__2(2973);
                var kDefaultCodeLength = 8;
                var kCodeLengthRepeatCode = 16;
                var kNumLiteralCodes = 256;
                var kNumInsertAndCopyCodes = 704;
                var kNumBlockLengthCodes = 26;
                var kLiteralContextBits = 6;
                var kDistanceContextBits = 2;
                var HUFFMAN_TABLE_BITS = 8;
                var HUFFMAN_TABLE_MASK = 255;
                var HUFFMAN_MAX_TABLE_SIZE = 1080;
                var CODE_LENGTH_CODES = 18;
                var kCodeLengthCodeOrder = new Uint8Array([
                  1,
                  2,
                  3,
                  4,
                  0,
                  5,
                  17,
                  6,
                  16,
                  7,
                  8,
                  9,
                  10,
                  11,
                  12,
                  13,
                  14,
                  15
                ]);
                var NUM_DISTANCE_SHORT_CODES = 16;
                var kDistanceShortCodeIndexOffset = new Uint8Array([
                  3,
                  2,
                  1,
                  0,
                  3,
                  3,
                  3,
                  3,
                  3,
                  3,
                  2,
                  2,
                  2,
                  2,
                  2,
                  2
                ]);
                var kDistanceShortCodeValueOffset = new Int8Array([
                  0,
                  0,
                  0,
                  0,
                  -1,
                  1,
                  -2,
                  2,
                  -3,
                  3,
                  -1,
                  1,
                  -2,
                  2,
                  -3,
                  3
                ]);
                var kMaxHuffmanTableSize = new Uint16Array([
                  256,
                  402,
                  436,
                  468,
                  500,
                  534,
                  566,
                  598,
                  630,
                  662,
                  694,
                  726,
                  758,
                  790,
                  822,
                  854,
                  886,
                  920,
                  952,
                  984,
                  1016,
                  1048,
                  1080
                ]);
                function DecodeWindowBits(br) {
                  var n;
                  if (br.readBits(1) === 0) {
                    return 16;
                  }
                  n = br.readBits(3);
                  if (n > 0) {
                    return 17 + n;
                  }
                  n = br.readBits(3);
                  if (n > 0) {
                    return 8 + n;
                  }
                  return 17;
                }
                function DecodeVarLenUint8(br) {
                  if (br.readBits(1)) {
                    var nbits = br.readBits(3);
                    if (nbits === 0) {
                      return 1;
                    } else {
                      return br.readBits(nbits) + (1 << nbits);
                    }
                  }
                  return 0;
                }
                function MetaBlockLength() {
                  this.meta_block_length = 0;
                  this.input_end = 0;
                  this.is_uncompressed = 0;
                  this.is_metadata = false;
                }
                function DecodeMetaBlockLength(br) {
                  var out = new MetaBlockLength();
                  var size_nibbles;
                  var size_bytes;
                  var i;
                  out.input_end = br.readBits(1);
                  if (out.input_end && br.readBits(1)) {
                    return out;
                  }
                  size_nibbles = br.readBits(2) + 4;
                  if (size_nibbles === 7) {
                    out.is_metadata = true;
                    if (br.readBits(1) !== 0)
                      throw new Error("Invalid reserved bit");
                    size_bytes = br.readBits(2);
                    if (size_bytes === 0)
                      return out;
                    for (i = 0; i < size_bytes; i++) {
                      var next_byte = br.readBits(8);
                      if (i + 1 === size_bytes && size_bytes > 1 && next_byte === 0)
                        throw new Error("Invalid size byte");
                      out.meta_block_length |= next_byte << i * 8;
                    }
                  } else {
                    for (i = 0; i < size_nibbles; ++i) {
                      var next_nibble = br.readBits(4);
                      if (i + 1 === size_nibbles && size_nibbles > 4 && next_nibble === 0)
                        throw new Error("Invalid size nibble");
                      out.meta_block_length |= next_nibble << i * 4;
                    }
                  }
                  ++out.meta_block_length;
                  if (!out.input_end && !out.is_metadata) {
                    out.is_uncompressed = br.readBits(1);
                  }
                  return out;
                }
                function ReadSymbol(table, index, br) {
                  var start_index = index;
                  var nbits;
                  br.fillBitWindow();
                  index += br.val_ >>> br.bit_pos_ & HUFFMAN_TABLE_MASK;
                  nbits = table[index].bits - HUFFMAN_TABLE_BITS;
                  if (nbits > 0) {
                    br.bit_pos_ += HUFFMAN_TABLE_BITS;
                    index += table[index].value;
                    index += br.val_ >>> br.bit_pos_ & (1 << nbits) - 1;
                  }
                  br.bit_pos_ += table[index].bits;
                  return table[index].value;
                }
                function ReadHuffmanCodeLengths(code_length_code_lengths, num_symbols, code_lengths, br) {
                  var symbol = 0;
                  var prev_code_len = kDefaultCodeLength;
                  var repeat = 0;
                  var repeat_code_len = 0;
                  var space = 32768;
                  var table = [];
                  for (var i = 0; i < 32; i++)
                    table.push(new HuffmanCode(0, 0));
                  BrotliBuildHuffmanTable(table, 0, 5, code_length_code_lengths, CODE_LENGTH_CODES);
                  while (symbol < num_symbols && space > 0) {
                    var p = 0;
                    var code_len;
                    br.readMoreInput();
                    br.fillBitWindow();
                    p += br.val_ >>> br.bit_pos_ & 31;
                    br.bit_pos_ += table[p].bits;
                    code_len = table[p].value & 255;
                    if (code_len < kCodeLengthRepeatCode) {
                      repeat = 0;
                      code_lengths[symbol++] = code_len;
                      if (code_len !== 0) {
                        prev_code_len = code_len;
                        space -= 32768 >> code_len;
                      }
                    } else {
                      var extra_bits = code_len - 14;
                      var old_repeat;
                      var repeat_delta;
                      var new_len = 0;
                      if (code_len === kCodeLengthRepeatCode) {
                        new_len = prev_code_len;
                      }
                      if (repeat_code_len !== new_len) {
                        repeat = 0;
                        repeat_code_len = new_len;
                      }
                      old_repeat = repeat;
                      if (repeat > 0) {
                        repeat -= 2;
                        repeat <<= extra_bits;
                      }
                      repeat += br.readBits(extra_bits) + 3;
                      repeat_delta = repeat - old_repeat;
                      if (symbol + repeat_delta > num_symbols) {
                        throw new Error("[ReadHuffmanCodeLengths] symbol + repeat_delta > num_symbols");
                      }
                      for (var x = 0; x < repeat_delta; x++)
                        code_lengths[symbol + x] = repeat_code_len;
                      symbol += repeat_delta;
                      if (repeat_code_len !== 0) {
                        space -= repeat_delta << 15 - repeat_code_len;
                      }
                    }
                  }
                  if (space !== 0) {
                    throw new Error("[ReadHuffmanCodeLengths] space = " + space);
                  }
                  for (; symbol < num_symbols; symbol++)
                    code_lengths[symbol] = 0;
                }
                function ReadHuffmanCode(alphabet_size, tables, table, br) {
                  var table_size = 0;
                  var simple_code_or_skip;
                  var code_lengths = new Uint8Array(alphabet_size);
                  br.readMoreInput();
                  simple_code_or_skip = br.readBits(2);
                  if (simple_code_or_skip === 1) {
                    var i;
                    var max_bits_counter = alphabet_size - 1;
                    var max_bits = 0;
                    var symbols = new Int32Array(4);
                    var num_symbols = br.readBits(2) + 1;
                    while (max_bits_counter) {
                      max_bits_counter >>= 1;
                      ++max_bits;
                    }
                    for (i = 0; i < num_symbols; ++i) {
                      symbols[i] = br.readBits(max_bits) % alphabet_size;
                      code_lengths[symbols[i]] = 2;
                    }
                    code_lengths[symbols[0]] = 1;
                    switch (num_symbols) {
                      case 1:
                        break;
                      case 3:
                        if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[1] === symbols[2]) {
                          throw new Error("[ReadHuffmanCode] invalid symbols");
                        }
                        break;
                      case 2:
                        if (symbols[0] === symbols[1]) {
                          throw new Error("[ReadHuffmanCode] invalid symbols");
                        }
                        code_lengths[symbols[1]] = 1;
                        break;
                      case 4:
                        if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[0] === symbols[3] || symbols[1] === symbols[2] || symbols[1] === symbols[3] || symbols[2] === symbols[3]) {
                          throw new Error("[ReadHuffmanCode] invalid symbols");
                        }
                        if (br.readBits(1)) {
                          code_lengths[symbols[2]] = 3;
                          code_lengths[symbols[3]] = 3;
                        } else {
                          code_lengths[symbols[0]] = 2;
                        }
                        break;
                    }
                  } else {
                    var i;
                    var code_length_code_lengths = new Uint8Array(CODE_LENGTH_CODES);
                    var space = 32;
                    var num_codes = 0;
                    var huff = [
                      new HuffmanCode(2, 0),
                      new HuffmanCode(2, 4),
                      new HuffmanCode(2, 3),
                      new HuffmanCode(3, 2),
                      new HuffmanCode(2, 0),
                      new HuffmanCode(2, 4),
                      new HuffmanCode(2, 3),
                      new HuffmanCode(4, 1),
                      new HuffmanCode(2, 0),
                      new HuffmanCode(2, 4),
                      new HuffmanCode(2, 3),
                      new HuffmanCode(3, 2),
                      new HuffmanCode(2, 0),
                      new HuffmanCode(2, 4),
                      new HuffmanCode(2, 3),
                      new HuffmanCode(4, 5)
                    ];
                    for (i = simple_code_or_skip; i < CODE_LENGTH_CODES && space > 0; ++i) {
                      var code_len_idx = kCodeLengthCodeOrder[i];
                      var p = 0;
                      var v;
                      br.fillBitWindow();
                      p += br.val_ >>> br.bit_pos_ & 15;
                      br.bit_pos_ += huff[p].bits;
                      v = huff[p].value;
                      code_length_code_lengths[code_len_idx] = v;
                      if (v !== 0) {
                        space -= 32 >> v;
                        ++num_codes;
                      }
                    }
                    if (!(num_codes === 1 || space === 0))
                      throw new Error("[ReadHuffmanCode] invalid num_codes or space");
                    ReadHuffmanCodeLengths(code_length_code_lengths, alphabet_size, code_lengths, br);
                  }
                  table_size = BrotliBuildHuffmanTable(tables, table, HUFFMAN_TABLE_BITS, code_lengths, alphabet_size);
                  if (table_size === 0) {
                    throw new Error("[ReadHuffmanCode] BuildHuffmanTable failed: ");
                  }
                  return table_size;
                }
                function ReadBlockLength(table, index, br) {
                  var code;
                  var nbits;
                  code = ReadSymbol(table, index, br);
                  nbits = Prefix.kBlockLengthPrefixCode[code].nbits;
                  return Prefix.kBlockLengthPrefixCode[code].offset + br.readBits(nbits);
                }
                function TranslateShortCodes(code, ringbuffer, index) {
                  var val;
                  if (code < NUM_DISTANCE_SHORT_CODES) {
                    index += kDistanceShortCodeIndexOffset[code];
                    index &= 3;
                    val = ringbuffer[index] + kDistanceShortCodeValueOffset[code];
                  } else {
                    val = code - NUM_DISTANCE_SHORT_CODES + 1;
                  }
                  return val;
                }
                function MoveToFront(v, index) {
                  var value = v[index];
                  var i = index;
                  for (; i; --i)
                    v[i] = v[i - 1];
                  v[0] = value;
                }
                function InverseMoveToFrontTransform(v, v_len) {
                  var mtf = new Uint8Array(256);
                  var i;
                  for (i = 0; i < 256; ++i) {
                    mtf[i] = i;
                  }
                  for (i = 0; i < v_len; ++i) {
                    var index = v[i];
                    v[i] = mtf[index];
                    if (index)
                      MoveToFront(mtf, index);
                  }
                }
                function HuffmanTreeGroup(alphabet_size, num_htrees) {
                  this.alphabet_size = alphabet_size;
                  this.num_htrees = num_htrees;
                  this.codes = new Array(num_htrees + num_htrees * kMaxHuffmanTableSize[alphabet_size + 31 >>> 5]);
                  this.htrees = new Uint32Array(num_htrees);
                }
                HuffmanTreeGroup.prototype.decode = function(br) {
                  var i;
                  var table_size;
                  var next = 0;
                  for (i = 0; i < this.num_htrees; ++i) {
                    this.htrees[i] = next;
                    table_size = ReadHuffmanCode(this.alphabet_size, this.codes, next, br);
                    next += table_size;
                  }
                };
                function DecodeContextMap(context_map_size, br) {
                  var out = { num_htrees: null, context_map: null };
                  var use_rle_for_zeros;
                  var max_run_length_prefix = 0;
                  var table;
                  var i;
                  br.readMoreInput();
                  var num_htrees = out.num_htrees = DecodeVarLenUint8(br) + 1;
                  var context_map = out.context_map = new Uint8Array(context_map_size);
                  if (num_htrees <= 1) {
                    return out;
                  }
                  use_rle_for_zeros = br.readBits(1);
                  if (use_rle_for_zeros) {
                    max_run_length_prefix = br.readBits(4) + 1;
                  }
                  table = [];
                  for (i = 0; i < HUFFMAN_MAX_TABLE_SIZE; i++) {
                    table[i] = new HuffmanCode(0, 0);
                  }
                  ReadHuffmanCode(num_htrees + max_run_length_prefix, table, 0, br);
                  for (i = 0; i < context_map_size; ) {
                    var code;
                    br.readMoreInput();
                    code = ReadSymbol(table, 0, br);
                    if (code === 0) {
                      context_map[i] = 0;
                      ++i;
                    } else if (code <= max_run_length_prefix) {
                      var reps = 1 + (1 << code) + br.readBits(code);
                      while (--reps) {
                        if (i >= context_map_size) {
                          throw new Error("[DecodeContextMap] i >= context_map_size");
                        }
                        context_map[i] = 0;
                        ++i;
                      }
                    } else {
                      context_map[i] = code - max_run_length_prefix;
                      ++i;
                    }
                  }
                  if (br.readBits(1)) {
                    InverseMoveToFrontTransform(context_map, context_map_size);
                  }
                  return out;
                }
                function DecodeBlockType(max_block_type, trees, tree_type, block_types, ringbuffers, indexes, br) {
                  var ringbuffer = tree_type * 2;
                  var index = tree_type;
                  var type_code = ReadSymbol(trees, tree_type * HUFFMAN_MAX_TABLE_SIZE, br);
                  var block_type;
                  if (type_code === 0) {
                    block_type = ringbuffers[ringbuffer + (indexes[index] & 1)];
                  } else if (type_code === 1) {
                    block_type = ringbuffers[ringbuffer + (indexes[index] - 1 & 1)] + 1;
                  } else {
                    block_type = type_code - 2;
                  }
                  if (block_type >= max_block_type) {
                    block_type -= max_block_type;
                  }
                  block_types[tree_type] = block_type;
                  ringbuffers[ringbuffer + (indexes[index] & 1)] = block_type;
                  ++indexes[index];
                }
                function CopyUncompressedBlockToOutput(output, len, pos, ringbuffer, ringbuffer_mask, br) {
                  var rb_size = ringbuffer_mask + 1;
                  var rb_pos = pos & ringbuffer_mask;
                  var br_pos = br.pos_ & BrotliBitReader.IBUF_MASK;
                  var nbytes;
                  if (len < 8 || br.bit_pos_ + (len << 3) < br.bit_end_pos_) {
                    while (len-- > 0) {
                      br.readMoreInput();
                      ringbuffer[rb_pos++] = br.readBits(8);
                      if (rb_pos === rb_size) {
                        output.write(ringbuffer, rb_size);
                        rb_pos = 0;
                      }
                    }
                    return;
                  }
                  if (br.bit_end_pos_ < 32) {
                    throw new Error("[CopyUncompressedBlockToOutput] br.bit_end_pos_ < 32");
                  }
                  while (br.bit_pos_ < 32) {
                    ringbuffer[rb_pos] = br.val_ >>> br.bit_pos_;
                    br.bit_pos_ += 8;
                    ++rb_pos;
                    --len;
                  }
                  nbytes = br.bit_end_pos_ - br.bit_pos_ >> 3;
                  if (br_pos + nbytes > BrotliBitReader.IBUF_MASK) {
                    var tail = BrotliBitReader.IBUF_MASK + 1 - br_pos;
                    for (var x = 0; x < tail; x++)
                      ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
                    nbytes -= tail;
                    rb_pos += tail;
                    len -= tail;
                    br_pos = 0;
                  }
                  for (var x = 0; x < nbytes; x++)
                    ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
                  rb_pos += nbytes;
                  len -= nbytes;
                  if (rb_pos >= rb_size) {
                    output.write(ringbuffer, rb_size);
                    rb_pos -= rb_size;
                    for (var x = 0; x < rb_pos; x++)
                      ringbuffer[x] = ringbuffer[rb_size + x];
                  }
                  while (rb_pos + len >= rb_size) {
                    nbytes = rb_size - rb_pos;
                    if (br.input_.read(ringbuffer, rb_pos, nbytes) < nbytes) {
                      throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
                    }
                    output.write(ringbuffer, rb_size);
                    len -= nbytes;
                    rb_pos = 0;
                  }
                  if (br.input_.read(ringbuffer, rb_pos, len) < len) {
                    throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
                  }
                  br.reset();
                }
                function JumpToByteBoundary(br) {
                  var new_bit_pos = br.bit_pos_ + 7 & ~7;
                  var pad_bits = br.readBits(new_bit_pos - br.bit_pos_);
                  return pad_bits == 0;
                }
                function BrotliDecompressedSize(buffer) {
                  var input = new BrotliInput(buffer);
                  var br = new BrotliBitReader(input);
                  DecodeWindowBits(br);
                  var out = DecodeMetaBlockLength(br);
                  return out.meta_block_length;
                }
                __webpack_unused_export__ = BrotliDecompressedSize;
                function BrotliDecompressBuffer(buffer, output_size) {
                  var input = new BrotliInput(buffer);
                  if (output_size == null) {
                    output_size = BrotliDecompressedSize(buffer);
                  }
                  var output_buffer = new Uint8Array(output_size);
                  var output = new BrotliOutput(output_buffer);
                  BrotliDecompress(input, output);
                  if (output.pos < output.buffer.length) {
                    output.buffer = output.buffer.subarray(0, output.pos);
                  }
                  return output.buffer;
                }
                exports2.BrotliDecompressBuffer = BrotliDecompressBuffer;
                function BrotliDecompress(input, output) {
                  var i;
                  var pos = 0;
                  var input_end = 0;
                  var window_bits = 0;
                  var max_backward_distance;
                  var max_distance = 0;
                  var ringbuffer_size;
                  var ringbuffer_mask;
                  var ringbuffer;
                  var ringbuffer_end;
                  var dist_rb = [16, 15, 11, 4];
                  var dist_rb_idx = 0;
                  var prev_byte1 = 0;
                  var prev_byte2 = 0;
                  var hgroup = [new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0)];
                  var block_type_trees;
                  var block_len_trees;
                  var br;
                  var kRingBufferWriteAheadSlack = 128 + BrotliBitReader.READ_SIZE;
                  br = new BrotliBitReader(input);
                  window_bits = DecodeWindowBits(br);
                  max_backward_distance = (1 << window_bits) - 16;
                  ringbuffer_size = 1 << window_bits;
                  ringbuffer_mask = ringbuffer_size - 1;
                  ringbuffer = new Uint8Array(ringbuffer_size + kRingBufferWriteAheadSlack + BrotliDictionary.maxDictionaryWordLength);
                  ringbuffer_end = ringbuffer_size;
                  block_type_trees = [];
                  block_len_trees = [];
                  for (var x = 0; x < 3 * HUFFMAN_MAX_TABLE_SIZE; x++) {
                    block_type_trees[x] = new HuffmanCode(0, 0);
                    block_len_trees[x] = new HuffmanCode(0, 0);
                  }
                  while (!input_end) {
                    var meta_block_remaining_len = 0;
                    var is_uncompressed;
                    var block_length = [1 << 28, 1 << 28, 1 << 28];
                    var block_type = [0];
                    var num_block_types = [1, 1, 1];
                    var block_type_rb = [0, 1, 0, 1, 0, 1];
                    var block_type_rb_index = [0];
                    var distance_postfix_bits;
                    var num_direct_distance_codes;
                    var distance_postfix_mask;
                    var num_distance_codes;
                    var context_map = null;
                    var context_modes = null;
                    var num_literal_htrees;
                    var dist_context_map = null;
                    var num_dist_htrees;
                    var context_offset = 0;
                    var context_map_slice = null;
                    var literal_htree_index = 0;
                    var dist_context_offset = 0;
                    var dist_context_map_slice = null;
                    var dist_htree_index = 0;
                    var context_lookup_offset1 = 0;
                    var context_lookup_offset2 = 0;
                    var context_mode;
                    var htree_command;
                    for (i = 0; i < 3; ++i) {
                      hgroup[i].codes = null;
                      hgroup[i].htrees = null;
                    }
                    br.readMoreInput();
                    var _out = DecodeMetaBlockLength(br);
                    meta_block_remaining_len = _out.meta_block_length;
                    if (pos + meta_block_remaining_len > output.buffer.length) {
                      var tmp = new Uint8Array(pos + meta_block_remaining_len);
                      tmp.set(output.buffer);
                      output.buffer = tmp;
                    }
                    input_end = _out.input_end;
                    is_uncompressed = _out.is_uncompressed;
                    if (_out.is_metadata) {
                      JumpToByteBoundary(br);
                      for (; meta_block_remaining_len > 0; --meta_block_remaining_len) {
                        br.readMoreInput();
                        br.readBits(8);
                      }
                      continue;
                    }
                    if (meta_block_remaining_len === 0) {
                      continue;
                    }
                    if (is_uncompressed) {
                      br.bit_pos_ = br.bit_pos_ + 7 & ~7;
                      CopyUncompressedBlockToOutput(
                        output,
                        meta_block_remaining_len,
                        pos,
                        ringbuffer,
                        ringbuffer_mask,
                        br
                      );
                      pos += meta_block_remaining_len;
                      continue;
                    }
                    for (i = 0; i < 3; ++i) {
                      num_block_types[i] = DecodeVarLenUint8(br) + 1;
                      if (num_block_types[i] >= 2) {
                        ReadHuffmanCode(num_block_types[i] + 2, block_type_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
                        ReadHuffmanCode(kNumBlockLengthCodes, block_len_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
                        block_length[i] = ReadBlockLength(block_len_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
                        block_type_rb_index[i] = 1;
                      }
                    }
                    br.readMoreInput();
                    distance_postfix_bits = br.readBits(2);
                    num_direct_distance_codes = NUM_DISTANCE_SHORT_CODES + (br.readBits(4) << distance_postfix_bits);
                    distance_postfix_mask = (1 << distance_postfix_bits) - 1;
                    num_distance_codes = num_direct_distance_codes + (48 << distance_postfix_bits);
                    context_modes = new Uint8Array(num_block_types[0]);
                    for (i = 0; i < num_block_types[0]; ++i) {
                      br.readMoreInput();
                      context_modes[i] = br.readBits(2) << 1;
                    }
                    var _o1 = DecodeContextMap(num_block_types[0] << kLiteralContextBits, br);
                    num_literal_htrees = _o1.num_htrees;
                    context_map = _o1.context_map;
                    var _o2 = DecodeContextMap(num_block_types[2] << kDistanceContextBits, br);
                    num_dist_htrees = _o2.num_htrees;
                    dist_context_map = _o2.context_map;
                    hgroup[0] = new HuffmanTreeGroup(kNumLiteralCodes, num_literal_htrees);
                    hgroup[1] = new HuffmanTreeGroup(kNumInsertAndCopyCodes, num_block_types[1]);
                    hgroup[2] = new HuffmanTreeGroup(num_distance_codes, num_dist_htrees);
                    for (i = 0; i < 3; ++i) {
                      hgroup[i].decode(br);
                    }
                    context_map_slice = 0;
                    dist_context_map_slice = 0;
                    context_mode = context_modes[block_type[0]];
                    context_lookup_offset1 = Context.lookupOffsets[context_mode];
                    context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
                    htree_command = hgroup[1].htrees[0];
                    while (meta_block_remaining_len > 0) {
                      var cmd_code;
                      var range_idx;
                      var insert_code;
                      var copy_code;
                      var insert_length;
                      var copy_length;
                      var distance_code;
                      var distance;
                      var context;
                      var j;
                      var copy_dst;
                      br.readMoreInput();
                      if (block_length[1] === 0) {
                        DecodeBlockType(
                          num_block_types[1],
                          block_type_trees,
                          1,
                          block_type,
                          block_type_rb,
                          block_type_rb_index,
                          br
                        );
                        block_length[1] = ReadBlockLength(block_len_trees, HUFFMAN_MAX_TABLE_SIZE, br);
                        htree_command = hgroup[1].htrees[block_type[1]];
                      }
                      --block_length[1];
                      cmd_code = ReadSymbol(hgroup[1].codes, htree_command, br);
                      range_idx = cmd_code >> 6;
                      if (range_idx >= 2) {
                        range_idx -= 2;
                        distance_code = -1;
                      } else {
                        distance_code = 0;
                      }
                      insert_code = Prefix.kInsertRangeLut[range_idx] + (cmd_code >> 3 & 7);
                      copy_code = Prefix.kCopyRangeLut[range_idx] + (cmd_code & 7);
                      insert_length = Prefix.kInsertLengthPrefixCode[insert_code].offset + br.readBits(Prefix.kInsertLengthPrefixCode[insert_code].nbits);
                      copy_length = Prefix.kCopyLengthPrefixCode[copy_code].offset + br.readBits(Prefix.kCopyLengthPrefixCode[copy_code].nbits);
                      prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
                      prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
                      for (j = 0; j < insert_length; ++j) {
                        br.readMoreInput();
                        if (block_length[0] === 0) {
                          DecodeBlockType(
                            num_block_types[0],
                            block_type_trees,
                            0,
                            block_type,
                            block_type_rb,
                            block_type_rb_index,
                            br
                          );
                          block_length[0] = ReadBlockLength(block_len_trees, 0, br);
                          context_offset = block_type[0] << kLiteralContextBits;
                          context_map_slice = context_offset;
                          context_mode = context_modes[block_type[0]];
                          context_lookup_offset1 = Context.lookupOffsets[context_mode];
                          context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
                        }
                        context = Context.lookup[context_lookup_offset1 + prev_byte1] | Context.lookup[context_lookup_offset2 + prev_byte2];
                        literal_htree_index = context_map[context_map_slice + context];
                        --block_length[0];
                        prev_byte2 = prev_byte1;
                        prev_byte1 = ReadSymbol(hgroup[0].codes, hgroup[0].htrees[literal_htree_index], br);
                        ringbuffer[pos & ringbuffer_mask] = prev_byte1;
                        if ((pos & ringbuffer_mask) === ringbuffer_mask) {
                          output.write(ringbuffer, ringbuffer_size);
                        }
                        ++pos;
                      }
                      meta_block_remaining_len -= insert_length;
                      if (meta_block_remaining_len <= 0)
                        break;
                      if (distance_code < 0) {
                        var context;
                        br.readMoreInput();
                        if (block_length[2] === 0) {
                          DecodeBlockType(
                            num_block_types[2],
                            block_type_trees,
                            2,
                            block_type,
                            block_type_rb,
                            block_type_rb_index,
                            br
                          );
                          block_length[2] = ReadBlockLength(block_len_trees, 2 * HUFFMAN_MAX_TABLE_SIZE, br);
                          dist_context_offset = block_type[2] << kDistanceContextBits;
                          dist_context_map_slice = dist_context_offset;
                        }
                        --block_length[2];
                        context = (copy_length > 4 ? 3 : copy_length - 2) & 255;
                        dist_htree_index = dist_context_map[dist_context_map_slice + context];
                        distance_code = ReadSymbol(hgroup[2].codes, hgroup[2].htrees[dist_htree_index], br);
                        if (distance_code >= num_direct_distance_codes) {
                          var nbits;
                          var postfix;
                          var offset;
                          distance_code -= num_direct_distance_codes;
                          postfix = distance_code & distance_postfix_mask;
                          distance_code >>= distance_postfix_bits;
                          nbits = (distance_code >> 1) + 1;
                          offset = (2 + (distance_code & 1) << nbits) - 4;
                          distance_code = num_direct_distance_codes + (offset + br.readBits(nbits) << distance_postfix_bits) + postfix;
                        }
                      }
                      distance = TranslateShortCodes(distance_code, dist_rb, dist_rb_idx);
                      if (distance < 0) {
                        throw new Error("[BrotliDecompress] invalid distance");
                      }
                      if (pos < max_backward_distance && max_distance !== max_backward_distance) {
                        max_distance = pos;
                      } else {
                        max_distance = max_backward_distance;
                      }
                      copy_dst = pos & ringbuffer_mask;
                      if (distance > max_distance) {
                        if (copy_length >= BrotliDictionary.minDictionaryWordLength && copy_length <= BrotliDictionary.maxDictionaryWordLength) {
                          var offset = BrotliDictionary.offsetsByLength[copy_length];
                          var word_id = distance - max_distance - 1;
                          var shift = BrotliDictionary.sizeBitsByLength[copy_length];
                          var mask = (1 << shift) - 1;
                          var word_idx = word_id & mask;
                          var transform_idx = word_id >> shift;
                          offset += word_idx * copy_length;
                          if (transform_idx < Transform.kNumTransforms) {
                            var len = Transform.transformDictionaryWord(ringbuffer, copy_dst, offset, copy_length, transform_idx);
                            copy_dst += len;
                            pos += len;
                            meta_block_remaining_len -= len;
                            if (copy_dst >= ringbuffer_end) {
                              output.write(ringbuffer, ringbuffer_size);
                              for (var _x = 0; _x < copy_dst - ringbuffer_end; _x++)
                                ringbuffer[_x] = ringbuffer[ringbuffer_end + _x];
                            }
                          } else {
                            throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
                          }
                        } else {
                          throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
                        }
                      } else {
                        if (distance_code > 0) {
                          dist_rb[dist_rb_idx & 3] = distance;
                          ++dist_rb_idx;
                        }
                        if (copy_length > meta_block_remaining_len) {
                          throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
                        }
                        for (j = 0; j < copy_length; ++j) {
                          ringbuffer[pos & ringbuffer_mask] = ringbuffer[pos - distance & ringbuffer_mask];
                          if ((pos & ringbuffer_mask) === ringbuffer_mask) {
                            output.write(ringbuffer, ringbuffer_size);
                          }
                          ++pos;
                          --meta_block_remaining_len;
                        }
                      }
                      prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
                      prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
                    }
                    pos &= 1073741823;
                  }
                  output.write(ringbuffer, pos & ringbuffer_mask);
                }
                __webpack_unused_export__ = BrotliDecompress;
                BrotliDictionary.init();
              }
            ),
            /***/
            5340: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                var base64 = __webpack_require__2(9742);
                exports2.init = function() {
                  var BrotliDecompressBuffer = __webpack_require__2(6450).BrotliDecompressBuffer;
                  var compressed = base64.toByteArray(__webpack_require__2(2722));
                  return BrotliDecompressBuffer(compressed);
                };
              }
            ),
            /***/
            2722: (
              /***/
              function(module2) {
                module2.exports = "W5/fcQLn5gKf2XUbAiQ1XULX+TZz6ADToDsgqk6qVfeC0e4m6OO2wcQ1J76ZBVRV1fRkEsdu//62zQsFEZWSTCnMhcsQKlS2qOhuVYYMGCkV0fXWEoMFbESXrKEZ9wdUEsyw9g4bJlEt1Y6oVMxMRTEVbCIwZzJzboK5j8m4YH02qgXYhv1V+PM435sLVxyHJihaJREEhZGqL03txGFQLm76caGO/ovxKvzCby/3vMTtX/459f0igi7WutnKiMQ6wODSoRh/8Lx1V3Q99MvKtwB6bHdERYRY0hStJoMjNeTsNX7bn+Y7e4EQ3bf8xBc7L0BsyfFPK43dGSXpL6clYC/I328h54/VYrQ5i0648FgbGtl837svJ35L3Mot/+nPlNpWgKx1gGXQYqX6n+bbZ7wuyCHKcUok12Xjqub7NXZGzqBx0SD+uziNf87t7ve42jxSKQoW3nyxVrWIGlFShhCKxjpZZ5MeGna0+lBkk+kaN8F9qFBAFgEogyMBdcX/T1W/WnMOi/7ycWUQloEBKGeC48MkiwqJkJO+12eQiOFHMmck6q/IjWW3RZlany23TBm+cNr/84/oi5GGmGBZWrZ6j+zykVozz5fT/QH/Da6WTbZYYPynVNO7kxzuNN2kxKKWche5WveitPKAecB8YcAHz/+zXLjcLzkdDSktNIDwZE9J9X+tto43oJy65wApM3mDzYtCwX9lM+N5VR3kXYo0Z3t0TtXfgBFg7gU8oN0Dgl7fZlUbhNll+0uuohRVKjrEd8egrSndy5/Tgd2gqjA4CAVuC7ESUmL3DZoGnfhQV8uwnpi8EGvAVVsowNRxPudck7+oqAUDkwZopWqFnW1riss0t1z6iCISVKreYGNvQcXv+1L9+jbP8cd/dPUiqBso2q+7ZyFBvENCkkVr44iyPbtOoOoCecWsiuqMSML5lv+vN5MzUr+Dnh73G7Q1YnRYJVYXHRJaNAOByiaK6CusgFdBPE40r0rvqXV7tksKO2DrHYXBTv8P5ysqxEx8VDXUDDqkPH6NNOV/a2WH8zlkXRELSa8P+heNyJBBP7PgsG1EtWtNef6/i+lcayzQwQCsduidpbKfhWUDgAEmyhGu/zVTacI6RS0zTABrOYueemnVa19u9fT23N/Ta6RvTpof5DWygqreCqrDAgM4LID1+1T/taU6yTFVLqXOv+/MuQOFnaF8vLMKD7tKWDoBdALgxF33zQccCcdHx8fKIVdW69O7qHtXpeGr9jbbpFA+qRMWr5hp0s67FPc7HAiLV0g0/peZlW7hJPYEhZyhpSwahnf93/tZgfqZWXFdmdXBzqxGHLrQKxoAY6fRoBhgCRPmmGueYZ5JexTVDKUIXzkG/fqp/0U3hAgQdJ9zumutK6nqWbaqvm1pgu03IYR+G+8s0jDBBz8cApZFSBeuWasyqo2OMDKAZCozS+GWSvL/HsE9rHxooe17U3s/lTE+VZAk4j3dp6uIGaC0JMiqR5CUsabPyM0dOYDR7Ea7ip4USZlya38YfPtvrX/tBlhHilj55nZ1nfN24AOAi9BVtz/Mbn8AEDJCqJgsVUa6nQnSxv2Fs7l/NlCzpfYEjmPrNyib/+t0ei2eEMjvNhLkHCZlci4WhBe7ePZTmzYqlY9+1pxtS4GB+5lM1BHT9tS270EWUDYFq1I0yY/fNiAk4bk9yBgmef/f2k6AlYQZHsNFnW8wBQxCd68iWv7/35bXfz3JZmfGligWAKRjIs3IpzxQ27vAglHSiOzCYzJ9L9A1CdiyFvyR66ucA4jKifu5ehwER26yV7HjKqn5Mfozo7Coxxt8LWWPT47BeMxX8p0Pjb7hZn+6bw7z3Lw+7653j5sI8CLu5kThpMlj1m4c2ch3jGcP1FsT13vuK3qjecKTZk2kHcOZY40UX+qdaxstZqsqQqgXz+QGF99ZJLqr3VYu4aecl1Ab5GmqS8k/GV5b95zxQ5d4EfXUJ6kTS/CXF/aiqKDOT1T7Jz5z0PwDUcwr9clLN1OJGCiKfqvah+h3XzrBOiLOW8wvn8gW6qE8vPxi+Efv+UH55T7PQFVMh6cZ1pZQlzJpKZ7P7uWvwPGJ6DTlR6wbyj3Iv2HyefnRo/dv7dNx+qaa0N38iBsR++Uil7Wd4afwDNsrzDAK4fXZwvEY/jdKuIKXlfrQd2C39dW7ntnRbIp9OtGy9pPBn/V2ASoi/2UJZfS+xuGLH8bnLuPlzdTNS6zdyk8Dt/h6sfOW5myxh1f+zf3zZ3MX/mO9cQPp5pOx967ZA6/pqHvclNfnUFF+rq+Vd7alKr6KWPcIDhpn6v2K6NlUu6LrKo8b/pYpU/Gazfvtwhn7tEOUuXht5rUJdSf6sLjYf0VTYDgwJ81yaqKTUYej/tbHckSRb/HZicwGJqh1mAHB/IuNs9dc9yuvF3D5Xocm3elWFdq5oEy70dYFit79yaLiNjPj5UUcVmZUVhQEhW5V2Z6Cm4HVH/R8qlamRYwBileuh07CbEce3TXa2JmXWBf+ozt319psboobeZhVnwhMZzOeQJzhpTDbP71Tv8HuZxxUI/+ma3XW6DFDDs4+qmpERwHGBd2edxwUKlODRdUWZ/g0GOezrbzOZauFMai4QU6GVHV6aPNBiBndHSsV4IzpvUiiYyg6OyyrL4Dj5q/Lw3N5kAwftEVl9rNd7Jk5PDij2hTH6wIXnsyXkKePxbmHYgC8A6an5Fob/KH5GtC0l4eFso+VpxedtJHdHpNm+Bvy4C79yVOkrZsLrQ3OHCeB0Ra+kBIRldUGlDCEmq2RwXnfyh6Dz+alk6eftI2n6sastRrGwbwszBeDRS/Fa/KwRJkCzTsLr/JCs5hOPE/MPLYdZ1F1fv7D+VmysX6NpOC8aU9F4Qs6HvDyUy9PvFGDKZ/P5101TYHFl8pjj6wm/qyS75etZhhfg0UEL4OYmHk6m6dO192AzoIyPSV9QedDA4Ml23rRbqxMPMxf7FJnDc5FTElVS/PyqgePzmwVZ26NWhRDQ+oaT7ly7ell4s3DypS1s0g+tOr7XHrrkZj9+x/mJBttrLx98lFIaRZzHz4aC7r52/JQ4VjHahY2/YVXZn/QC2ztQb/sY3uRlyc5vQS8nLPGT/n27495i8HPA152z7Fh5aFpyn1GPJKHuPL8Iw94DuW3KjkURAWZXn4EQy89xiKEHN1mk/tkM4gYDBxwNoYvRfE6LFqsxWJtPrDGbsnLMap3Ka3MUoytW0cvieozOmdERmhcqzG+3HmZv2yZeiIeQTKGdRT4HHNxekm1tY+/n06rGmFleqLscSERzctTKM6G9P0Pc1RmVvrascIxaO1CQCiYPE15bD7c3xSeW7gXxYjgxcrUlcbIvO0r+Yplhx0kTt3qafDOmFyMjgGxXu73rddMHpV1wMubyAGcf/v5dLr5P72Ta9lBF+fzMJrMycwv+9vnU3ANIl1cH9tfW7af8u0/HG0vV47jNFXzFTtaha1xvze/s8KMtCYucXc1nzfd/MQydUXn/b72RBt5wO/3jRcMH9BdhC/yctKBIveRYPrNpDWqBsO8VMmP+WvRaOcA4zRMR1PvSoO92rS7pYEv+fZfEfTMzEdM+6X5tLlyxExhqLRkms5EuLovLfx66de5fL2/yX02H52FPVwahrPqmN/E0oVXnsCKhbi/yRxX83nRbUKWhzYceXOntfuXn51NszJ6MO73pQf5Pl4in3ec4JU8hF7ppV34+mm9r1LY0ee/i1O1wpd8+zfLztE0cqBxggiBi5Bu95v9l3r9r/U5hweLn+TbfxowrWDqdJauKd8+q/dH8sbPkc9ttuyO94f7/XK/nHX46MPFLEb5qQlNPvhJ50/59t9ft3LXu7uVaWaO2bDrDCnRSzZyWvFKxO1+vT8MwwunR3bX0CkfPjqb4K9O19tn5X50PvmYpEwHtiW9WtzuV/s76B1zvLLNkViNd8ySxIl/3orfqP90TyTGaf7/rx8jQzeHJXdmh/N6YDvbvmTBwCdxfEQ1NcL6wNMdSIXNq7b1EUzRy1/Axsyk5p22GMG1b+GxFgbHErZh92wuvco0AuOLXct9hvw2nw/LqIcDRRmJmmZzcgUa7JpM/WV/S9IUfbF56TL2orzqwebdRD8nIYNJ41D/hz37Fo11p2Y21wzPcn713qVGhqtevStYfGH4n69OEJtPvbbLYWvscDqc3Hgnu166+tAyLnxrX0Y5zoYjV++1sI7t5kMr02KT/+uwtkc+rZLOf/qn/s3nYCf13Dg8/sB2diJgjGqjQ+TLhxbzyue2Ob7X6/9lUwW7a+lbznHzOYy8LKW1C/uRPbQY3KW/0gO9LXunHLvPL97afba9bFtc9hmz7GAttjVYlCvQAiOwAk/gC5+hkLEs6tr3AZKxLJtOEwk2dLxTYWsIB/j/ToWtIWzo906FrSG8iaqqqqqqiIiIiAgzMzMzNz+AyK+01/zi8n8S+Y1MjoRaQ80WU/G8MBlO+53VPXANrWm4wzGUVZUjjBJZVdhpcfkjsmcWaO+UEldXi1e+zq+HOsCpknYshuh8pOLISJun7TN0EIGW2xTnlOImeecnoGW4raxe2G1T3HEvfYUYMhG+gAFOAwh5nK8mZhwJMmN7r224QVsNFvZ87Z0qatvknklyPDK3Hy45PgVKXji52Wen4d4PlFVVYGnNap+fSpFbK90rYnhUc6n91Q3AY9E0tJOFrcfZtm/491XbcG/jsViUPPX76qmeuiz+qY1Hk7/1VPM405zWVuoheLUimpWYdVzCmUdKHebMdzgrYrb8mL2eeLSnRWHdonfZa8RsOU9F37w+591l5FLYHiOqWeHtE/lWrBHcRKp3uhtr8yXm8LU/5ms+NM6ZKsqu90cFZ4o58+k4rdrtB97NADFbwmEG7lXqvirhOTOqU14xuUF2myIjURcPHrPOQ4lmM3PeMg7bUuk0nnZi67bXsU6H8lhqIo8TaOrEafCO1ARK9PjC0QOoq2BxmMdgYB9G/lIb9++fqNJ2s7BHGFyBNmZAR8J3KCo012ikaSP8BCrf6VI0X5xdnbhHIO+B5rbOyB54zXkzfObyJ4ecwxfqBJMLFc7m59rNcw7hoHnFZ0b00zee+gTqvjm61Pb4xn0kcDX4jvHM0rBXZypG3DCKnD/Waa/ZtHmtFPgO5eETx+k7RrVg3aSwm2YoNXnCs3XPQDhNn+Fia6IlOOuIG6VJH7TP6ava26ehKHQa2T4N0tcZ9dPCGo3ZdnNltsHQbeYt5vPnJezV/cAeNypdml1vCHI8M81nSRP5Qi2+mI8v/sxiZru9187nRtp3f/42NemcONa+4eVC3PCZzc88aZh851CqSsshe70uPxeN/dmYwlwb3trwMrN1Gq8jbnApcVDx/yDPeYs5/7r62tsQ6lLg+DiFXTEhzR9dHqv0iT4tgj825W+H3XiRUNUZT2kR9Ri0+lp+UM3iQtS8uOE23Ly4KYtvqH13jghUntJRAewuzNLDXp8RxdcaA3cMY6TO2IeSFRXezeWIjCqyhsUdMYuCgYTZSKpBype1zRfq8FshvfBPc6BAQWl7/QxIDp3VGo1J3vn42OEs3qznws+YLRXbymyB19a9XBx6n/owcyxlEYyFWCi+kG9F+EyD/4yn80+agaZ9P7ay2Dny99aK2o91FkfEOY8hBwyfi5uwx2y5SaHmG+oq/zl1FX/8irOf8Y3vAcX/6uLP6A6nvMO24edSGPjQc827Rw2atX+z2bKq0CmW9mOtYnr5/AfDa1ZfPaXnKtlWborup7QYx+Or2uWb+N3N//2+yDcXMqIJdf55xl7/vsj4WoPPlxLxtVrkJ4w/tTe3mLdATOOYwxcq52w5Wxz5MbPdVs5O8/lhfE7dPj0bIiPQ3QV0iqm4m3YX8hRfc6jQ3fWepevMqUDJd86Z4vwM40CWHnn+WphsGHfieF02D3tmZvpWD+kBpNCFcLnZhcmmrhpGzzbdA+sQ1ar18OJD87IOKOFoRNznaHPNHUfUNhvY1iU+uhvEvpKHaUn3qK3exVVyX4joipp3um7FmYJWmA+WbIDshRpbVRx5/nqstCgy87FGbfVB8yDGCqS+2qCsnRwnSAN6zgzxfdB2nBT/vZ4/6uxb6oH8b4VBRxiIB93wLa47hG3w2SL/2Z27yOXJFwZpSJaBYyvajA7vRRYNKqljXKpt/CFD/tSMr18DKKbwB0xggBePatl1nki0yvqW5zchlyZmJ0OTxJ3D+fsYJs/mxYN5+Le5oagtcl+YsVvy8kSjI2YGvGjvmpkRS9W2dtXqWnVuxUhURm1lKtou/hdEq19VBp9OjGvHEQSmrpuf2R24mXGheil8KeiANY8fW1VERUfBImb64j12caBZmRViZHbeVMjCrPDg9A90IXrtnsYCuZtRQ0PyrKDjBNOsPfKsg1pA02gHlVr0OXiFhtp6nJqXVzcbfM0KnzC3ggOENPE9VBdmHKN6LYaijb4wXxJn5A0FSDF5j+h1ooZx885Jt3ZKzO5n7Z5WfNEOtyyPqQEnn7WLv5Fis3PdgMshjF1FRydbNyeBbyKI1oN1TRVrVK7kgsb/zjX4NDPIRMctVeaxVB38Vh1x5KbeJbU138AM5KzmZu3uny0ErygxiJF7GVXUrPzFxrlx1uFdAaZFDN9cvIb74qD9tzBMo7L7WIEYK+sla1DVMHpF0F7b3+Y6S+zjvLeDMCpapmJo1weBWuxKF3rOocih1gun4BoJh1kWnV/Jmiq6uOhK3VfKxEHEkafjLgK3oujaPzY6SXg8phhL4TNR1xvJd1Wa0aYFfPUMLrNBDCh4AuGRTbtKMc6Z1Udj8evY/ZpCuMAUefdo69DZUngoqE1P9A3PJfOf7WixCEj+Y6t7fYeHbbxUAoFV3M89cCKfma3fc1+jKRe7MFWEbQqEfyzO2x/wrO2VYH7iYdQ9BkPyI8/3kXBpLaCpU7eC0Yv/am/tEDu7HZpqg0EvHo0nf/R/gRzUWy33/HXMJQeu1GylKmOkXzlCfGFruAcPPhaGqZOtu19zsJ1SO2Jz4Ztth5cBX6mRQwWmDwryG9FUMlZzNckMdK+IoMJv1rOWnBamS2w2KHiaPMPLC15hCZm4KTpoZyj4E2TqC/P6r7/EhnDMhKicZZ1ZwxuC7DPzDGs53q8gXaI9kFTK+2LTq7bhwsTbrMV8Rsfua5lMS0FwbTitUVnVa1yTb5IX51mmYnUcP9wPr8Ji1tiYJeJV9GZTrQhF7vvdU2OTU42ogJ9FDwhmycI2LIg++03C6scYhUyUuMV5tkw6kGUoL+mjNC38+wMdWNljn6tGPpRES7veqrSn5TRuv+dh6JVL/iDHU1db4c9WK3++OrH3PqziF916UMUKn8G67nN60GfWiHrXYhUG3yVWmyYak59NHj8t1smG4UDiWz2rPHNrKnN4Zo1LBbr2/eF9YZ0n0blx2nG4X+EKFxvS3W28JESD+FWk61VCD3z/URGHiJl++7TdBwkCj6tGOH3qDb0QqcOF9Kzpj0HUb/KyFW3Yhj2VMKJqGZleFBH7vqvf7WqLC3XMuHV8q8a4sTFuxUtkD/6JIBvKaVjv96ndgruKZ1k/BHzqf2K9fLk7HGXANyLDd1vxkK/i055pnzl+zw6zLnwXlVYVtfmacJgEpRP1hbGgrYPVN6v2lG+idQNGmwcKXu/8xEj/P6qe/sB2WmwNp6pp8jaISMkwdleFXYK55NHWLTTbutSUqjBfDGWo/Yg918qQ+8BRZSAHZbfuNZz2O0sov1Ue4CWlVg3rFhM3Kljj9ksGd/NUhk4nH+a5UN2+1i8+NM3vRNp7uQ6sqexSCukEVlVZriHNqFi5rLm9TMWa4qm3idJqppQACol2l4VSuvWLfta4JcXy3bROPNbXOgdOhG47LC0CwW/dMlSx4Jf17aEU3yA1x9p+Yc0jupXgcMuYNku64iYOkGToVDuJvlbEKlJqsmiHbvNrIVZEH+yFdF8DbleZ6iNiWwMqvtMp/mSpwx5KxRrT9p3MAPTHGtMbfvdFhyj9vhaKcn3At8Lc16Ai+vBcSp1ztXi7rCJZx/ql7TXcclq6Q76UeKWDy9boS0WHIjUuWhPG8LBmW5y2rhuTpM5vsLt+HOLh1Yf0DqXa9tsfC+kaKt2htA0ai/L2i7RKoNjEwztkmRU0GfgW1TxUvPFhg0V7DdfWJk5gfrccpYv+MA9M0dkGTLECeYwUixRzjRFdmjG7zdZIl3XKB9YliNKI31lfa7i2JG5C8Ss+rHe0D7Z696/V3DEAOWHnQ9yNahMUl5kENWS6pHKKp2D1BaSrrHdE1w2qNxIztpXgUIrF0bm15YML4b6V1k+GpNysTahKMVrrS85lTVo9OGJ96I47eAy5rYWpRf/mIzeoYU1DKaQCTUVwrhHeyNoDqHel+lLxr9WKzhSYw7vrR6+V5q0pfi2k3L1zqkubY6rrd9ZLvSuWNf0uqnkY+FpTvFzSW9Fp0b9l8JA7THV9eCi/PY/SCZIUYx3BU2alj7Cm3VV6eYpios4b6WuNOJdYXUK3zTqj5CVG2FqYM4Z7CuIU0qO05XR0d71FHM0YhZmJmTRfLlXEumN82BGtzdX0S19t1e+bUieK8zRmqpa4Qc5TSjifmaQsY2ETLjhI36gMR1+7qpjdXXHiceUekfBaucHShAOiFXmv3sNmGQyU5iVgnoocuonQXEPTFwslHtS8R+A47StI9wj0iSrtbi5rMysczFiImsQ+bdFClnFjjpXXwMy6O7qfjOr8Fb0a7ODItisjnn3EQO16+ypd1cwyaAW5Yzxz5QknfMO7643fXW/I9y3U2xH27Oapqr56Z/tEzglj6IbT6HEHjopiXqeRbe5mQQvxtcbDOVverN0ZgMdzqRYRjaXtMRd56Q4cZSmdPvZJdSrhJ1D9zNXPqAEqPIavPdfubt5oke2kmv0dztIszSv2VYuoyf1UuopbsYb+uX9h6WpwjpgtZ6fNNawNJ4q8O3CFoSbioAaOSZMx2GYaPYB+rEb6qjQiNRFQ76TvwNFVKD+BhH9VhcKGsXzmMI7BptU/CNWolM7YzROvpFAntsiWJp6eR2d3GarcYShVYSUqhmYOWj5E96NK2WvmYNTeY7Zs4RUEdv9h9QT4EseKt6LzLrqEOs3hxAY1MaNWpSa6zZx8F3YOVeCYMS88W+CYHDuWe4yoc6YK+djDuEOrBR5lvh0r+Q9uM88lrjx9x9AtgpQVNE8r+3O6Gvw59D+kBF/UMXyhliYUtPjmvXGY6Dk3x+kEOW+GtdMVC4EZTqoS/jmR0P0LS75DOc/w2vnri97M4SdbZ8qeU7gg8DVbERkU5geaMQO3mYrSYyAngeUQqrN0C0/vsFmcgWNXNeidsTAj7/4MncJR0caaBUpbLK1yBCBNRjEv6KvuVSdpPnEMJdsRRtqJ+U8tN1gXA4ePHc6ZT0eviI73UOJF0fEZ8YaneAQqQdGphNvwM4nIqPnXxV0xA0fnCT+oAhJuyw/q8jO0y8CjSteZExwBpIN6SvNp6A5G/abi6egeND/1GTguhuNjaUbbnSbGd4L8937Ezm34Eyi6n1maeOBxh3PI0jzJDf5mh/BsLD7F2GOKvlA/5gtvxI3/eV4sLfKW5Wy+oio+es/u6T8UU+nsofy57Icb/JlZHPFtCgd/x+bwt3ZT+xXTtTtTrGAb4QehC6X9G+8YT+ozcLxDsdCjsuOqwPFnrdLYaFc92Ui0m4fr39lYmlCaqTit7G6O/3kWDkgtXjNH4BiEm/+jegQnihOtfffn33WxsFjhfMd48HT+f6o6X65j7XR8WLSHMFkxbvOYsrRsF1bowDuSQ18Mkxk4qz2zoGPL5fu9h2Hqmt1asl3Q3Yu3szOc+spiCmX4AETBM3pLoTYSp3sVxahyhL8eC4mPN9k2x3o0xkiixIzM3CZFzf5oR4mecQ5+ax2wCah3/crmnHoqR0+KMaOPxRif1oEFRFOO/kTPPmtww+NfMXxEK6gn6iU32U6fFruIz8Q4WgljtnaCVTBgWx7diUdshC9ZEa5yKpRBBeW12r/iNc/+EgNqmhswNB8SBoihHXeDF7rrWDLcmt3V8GYYN7pXRy4DZjj4DJuUBL5iC3DQAaoo4vkftqVTYRGLS3mHZ7gdmdTTqbgNN/PTdTCOTgXolc88MhXAEUMdX0iy1JMuk5wLsgeu0QUYlz2S4skTWwJz6pOm/8ihrmgGfFgri+ZWUK2gAPHgbWa8jaocdSuM4FJYoKicYX/ZSENkg9Q1ZzJfwScfVnR2DegOGwCvmogaWJCLQepv9WNlU6QgsmOwICquU28Mlk3d9W5E81lU/5Ez0LcX6lwKMWDNluNKfBDUy/phJgBcMnfkh9iRxrdOzgs08JdPB85Lwo+GUSb4t3nC+0byqMZtO2fQJ4U2zGIr49t/28qmmGv2RanDD7a3FEcdtutkW8twwwlUSpb8QalodddbBfNHKDQ828BdE7OBgFdiKYohLawFYqpybQoxATZrheLhdI7+0Zlu9Q1myRcd15r9UIm8K2LGJxqTegntqNVMKnf1a8zQiyUR1rxoqjiFxeHxqFcYUTHfDu7rhbWng6qOxOsI+5A1p9mRyEPdVkTlE24vY54W7bWc6jMgZvNXdfC9/9q7408KDsbdL7Utz7QFSDetz2picArzrdpL8OaCHC9V26RroemtDZ5yNM/KGkWMyTmfnInEvwtSD23UcFcjhaE3VKzkoaEMKGBft4XbIO6forTY1lmGQwVmKicBCiArDzE+1oIxE08fWeviIOD5TznqH+OoHadvoOP20drMPe5Irg3XBQziW2XDuHYzjqQQ4wySssjXUs5H+t3FWYMHppUnBHMx/nYIT5d7OmjDbgD9F6na3m4l7KdkeSO3kTEPXafiWinogag7b52taiZhL1TSvBFmEZafFq2H8khQaZXuitCewT5FBgVtPK0j4xUHPfUz3Q28eac1Z139DAP23dgki94EC8vbDPTQC97HPPSWjUNG5tWKMsaxAEMKC0665Xvo1Ntd07wCLNf8Q56mrEPVpCxlIMVlQlWRxM3oAfpgIc+8KC3rEXUog5g06vt7zgXY8grH7hhwVSaeuvC06YYRAwpbyk/Unzj9hLEZNs2oxPQB9yc+GnL6zTgq7rI++KDJwX2SP8Sd6YzTuw5lV/kU6eQxRD12omfQAW6caTR4LikYkBB1CMOrvgRr/VY75+NSB40Cni6bADAtaK+vyxVWpf9NeKJxN2KYQ8Q2xPB3K1s7fuhvWbr2XpgW044VD6DRs0qXoqKf1NFsaGvKJc47leUV3pppP/5VTKFhaGuol4Esfjf5zyCyUHmHthChcYh4hYLQF+AFWsuq4t0wJyWgdwQVOZiV0efRHPoK5+E1vjz9wTJmVkITC9oEstAsyZSgE/dbicwKr89YUxKZI+owD205Tm5lnnmDRuP/JnzxX3gMtlrcX0UesZdxyQqYQuEW4R51vmQ5xOZteUd8SJruMlTUzhtVw/Nq7eUBcqN2/HVotgfngif60yKEtoUx3WYOZlVJuJOh8u59fzSDPFYtQgqDUAGyGhQOAvKroXMcOYY0qjnStJR/G3aP+Jt1sLVlGV8POwr/6OGsqetnyF3TmTqZjENfnXh51oxe9qVUw2M78EzAJ+IM8lZ1MBPQ9ZWSVc4J3mWSrLKrMHReA5qdGoz0ODRsaA+vwxXA2cAM4qlfzBJA6581m4hzxItQw5dxrrBL3Y6kCbUcFxo1S8jyV44q//+7ASNNudZ6xeaNOSIUffqMn4A9lIjFctYn2gpEPAb3f7p3iIBN8H14FUGQ9ct2hPsL+cEsTgUrR47uJVN4n4wt/wgfwwHuOnLd4yobkofy8JvxSQTA7rMpDIc608SlZFJfZYcmbT0tAHpPE8MrtQ42siTUNWxqvWZOmvu9f0JPoQmg+6l7sZWwyfi6PXkxJnwBraUG0MYG4zYHQz3igy/XsFkx5tNQxw43qvI9dU3f0DdhOUlHKjmi1VAr2Kiy0HZwD8VeEbhh0OiDdMYspolQsYdSwjCcjeowIXNZVUPmL2wwIkYhmXKhGozdCJ4lRKbsf4NBh/XnQoS92NJEWOVOFs2YhN8c5QZFeK0pRdAG40hqvLbmoSA8xQmzOOEc7wLcme9JOsjPCEgpCwUs9E2DohMHRhUeyGIN6TFvrbny8nDuilsDpzrH5mS76APoIEJmItS67sQJ+nfwddzmjPxcBEBBCw0kWDwd0EZCkNeOD7NNQhtBm7KHL9mRxj6U1yWU2puzlIDtpYxdH4ZPeXBJkTGAJfUr/oTCz/iypY6uXaR2V1doPxJYlrw2ghH0D5gbrhFcIxzYwi4a/4hqVdf2DdxBp6vGYDjavxMAAoy+1+3aiO6S3W/QAKNVXagDtvsNtx7Ks+HKgo6U21B+QSZgIogV5Bt+BnXisdVfy9VyXV+2P5fMuvdpAjM1o/K9Z+XnE4EOCrue+kcdYHqAQ0/Y/OmNlQ6OI33jH/uD1RalPaHpJAm2av0/xtpqdXVKNDrc9F2izo23Wu7firgbURFDNX9eGGeYBhiypyXZft2j3hTvzE6PMWKsod//rEILDkzBXfi7xh0eFkfb3/1zzPK/PI5Nk3FbZyTl4mq5BfBoVoqiPHO4Q4QKZAlrQ3MdNfi3oxIjvsM3kAFv3fdufurqYR3PSwX/mpGy/GFI/B2MNPiNdOppWVbs/gjF3YH+QA9jMhlAbhvasAHstB0IJew09iAkmXHl1/TEj+jvHOpOGrPRQXbPADM+Ig2/OEcUcpgPTItMtW4DdqgfYVI/+4hAFWYjUGpOP/UwNuB7+BbKOcALbjobdgzeBQfjgNSp2GOpxzGLj70Vvq5cw2AoYENwKLUtJUX8sGRox4dVa/TN4xKwaKcl9XawQR/uNus700Hf17pyNnezrUgaY9e4MADhEDBpsJT6y1gDJs1q6wlwGhuUzGR7C8kgpjPyHWwsvrf3yn1zJEIRa5eSxoLAZOCR9xbuztxFRJW9ZmMYfCFJ0evm9F2fVnuje92Rc4Pl6A8bluN8MZyyJGZ0+sNSb//DvAFxC2BqlEsFwccWeAl6CyBcQV1bx4mQMBP1Jxqk1EUADNLeieS2dUFbQ/c/kvwItbZ7tx0st16viqd53WsRmPTKv2AD8CUnhtPWg5aUegNpsYgasaw2+EVooeNKmrW3MFtj76bYHJm5K9gpAXZXsE5U8DM8XmVOSJ1F1WnLy6nQup+jx52bAb+rCq6y9WXl2B2oZDhfDkW7H3oYfT/4xx5VncBuxMXP2lNfhUVQjSSzSRbuZFE4vFawlzveXxaYKVs8LpvAb8IRYF3ZHiRnm0ADeNPWocwxSzNseG7NrSEVZoHdKWqaGEBz1N8Pt7kFbqh3LYmAbm9i1IChIpLpM5AS6mr6OAPHMwwznVy61YpBYX8xZDN/a+lt7n+x5j4bNOVteZ8lj3hpAHSx1VR8vZHec4AHO9XFCdjZ9eRkSV65ljMmZVzaej2qFn/qt1lvWzNZEfHxK3qOJrHL6crr0CRzMox5f2e8ALBB4UGFZKA3tN6F6IXd32GTJXGQ7DTi9j/dNcLF9jCbDcWGKxoKTYblIwbLDReL00LRcDPMcQuXLMh5YzgtfjkFK1DP1iDzzYYVZz5M/kWYRlRpig1htVRjVCknm+h1M5LiEDXOyHREhvzCGpFZjHS0RsK27o2avgdilrJkalWqPW3D9gmwV37HKmfM3F8YZj2ar+vHFvf3B8CRoH4kDHIK9mrAg+owiEwNjjd9V+FsQKYR8czJrUkf7Qoi2YaW6EVDZp5zYlqiYtuXOTHk4fAcZ7qBbdLDiJq0WNV1l2+Hntk1mMWvxrYmc8kIx8G3rW36J6Ra4lLrTOCgiOihmow+YnzUT19jbV2B3RWqSHyxkhmgsBqMYWvOcUom1jDQ436+fcbu3xf2bbeqU/ca+C4DOKE+e3qvmeMqW3AxejfzBRFVcwVYPq4L0APSWWoJu+5UYX4qg5U6YTioqQGPG9XrnuZ/BkxuYpe6Li87+18EskyQW/uA+uk2rpHpr6hut2TlVbKgWkFpx+AZffweiw2+VittkEyf/ifinS/0ItRL2Jq3tQOcxPaWO2xrG68GdFoUpZgFXaP2wYVtRc6xYCfI1CaBqyWpg4bx8OHBQwsV4XWMibZZ0LYjWEy2IxQ1mZrf1/UNbYCJplWu3nZ4WpodIGVA05d+RWSS+ET9tH3RfGGmNI1cIY7evZZq7o+a0bjjygpmR3mVfalkT/SZGT27Q8QGalwGlDOS9VHCyFAIL0a1Q7JiW3saz9gqY8lqKynFrPCzxkU4SIfLc9VfCI5edgRhDXs0edO992nhTKHriREP1NJC6SROMgQ0xO5kNNZOhMOIT99AUElbxqeZF8A3xrfDJsWtDnUenAHdYWSwAbYjFqQZ+D5gi3hNK8CSxU9i6f6ClL9IGlj1OPMQAsr84YG6ijsJpCaGWj75c3yOZKBB9mNpQNPUKkK0D6wgLH8MGoyRxTX6Y05Q4AnYNXMZwXM4eij/9WpsM/9CoRnFQXGR6MEaY+FXvXEO3RO0JaStk6OXuHVATHJE+1W+TU3bSZ2ksMtqjO0zfSJCdBv7y2d8DMx6TfVme3q0ZpTKMMu4YL/t7ciTNtdDkwPogh3Cnjx7qk08SHwf+dksZ7M2vCOlfsF0hQ6J4ehPCaHTNrM/zBSOqD83dBEBCW/F/LEmeh0nOHd7oVl3/Qo/9GUDkkbj7yz+9cvvu+dDAtx8NzCDTP4iKdZvk9MWiizvtILLepysflSvTLFBZ37RLwiriqyRxYv/zrgFd/9XVHh/OmzBvDX4mitMR/lUavs2Vx6cR94lzAkplm3IRNy4TFfu47tuYs9EQPIPVta4P64tV+sZ7n3ued3cgEx2YK+QL5+xms6osk8qQbTyuKVGdaX9FQqk6qfDnT5ykxk0VK7KZ62b6DNDUfQlqGHxSMKv1P0XN5BqMeKG1P4Wp5QfZDUCEldppoX0U6ss2jIko2XpURKCIhfaOqLPfShdtS37ZrT+jFRSH2xYVV1rmT/MBtRQhxiO4MQ3iAGlaZi+9PWBEIXOVnu9jN1f921lWLZky9bqbM3J2MAAI9jmuAx3gyoEUa6P2ivs0EeNv/OR+AX6q5SW6l5HaoFuS6jr6yg9limu+P0KYKzfMXWcQSfTXzpOzKEKpwI3YGXZpSSy2LTlMgfmFA3CF6R5c9xWEtRuCg2ZPUQ2Nb6dRFTNd4TfGHrnEWSKHPuRyiJSDAZ+KX0VxmSHjGPbQTLVpqixia2uyhQ394gBMt7C3ZAmxn/DJS+l1fBsAo2Eir/C0jG9csd4+/tp12pPc/BVJGaK9mfvr7M/CeztrmCO5qY06Edi4xAGtiEhnWAbzLy2VEyazE1J5nPmgU4RpW4Sa0TnOT6w5lgt3/tMpROigHHmexBGAMY0mdcDbDxWIz41NgdD6oxgHsJRgr5RnT6wZAkTOcStU4NMOQNemSO7gxGahdEsC+NRVGxMUhQmmM0llWRbbmFGHzEqLM4Iw0H7577Kyo+Zf+2cUFIOw93gEY171vQaM0HLwpjpdRR6Jz7V0ckE7XzYJ0TmY9znLdzkva0vNrAGGT5SUZ5uaHDkcGvI0ySpwkasEgZPMseYcu85w8HPdSNi+4T6A83iAwDbxgeFcB1ZM2iGXzFcEOUlYVrEckaOyodfvaYSQ7GuB4ISE0nYJc15X/1ciDTPbPCgYJK55VkEor4LvzL9S2WDy4xj+6FOqVyTAC2ZNowheeeSI5hA/02l8UYkv4nk9iaVn+kCVEUstgk5Hyq+gJm6R9vG3rhuM904he/hFmNQaUIATB1y3vw+OmxP4X5Yi6A5I5jJufHCjF9+AGNwnEllZjUco6XhsO5T5+R3yxz5yLVOnAn0zuS+6zdj0nTJbEZCbXJdtpfYZfCeCOqJHoE2vPPFS6eRLjIJlG69X93nfR0mxSFXzp1Zc0lt/VafDaImhUMtbnqWVb9M4nGNQLN68BHP7AR8Il9dkcxzmBv8PCZlw9guY0lurbBsmNYlwJZsA/B15/HfkbjbwPddaVecls/elmDHNW2r4crAx43feNkfRwsaNq/yyJ0d/p5hZ6AZajz7DBfUok0ZU62gCzz7x8eVfJTKA8IWn45vINLSM1q+HF9CV9qF3zP6Ml21kPPL3CXzkuYUlnSqT+Ij4tI/od5KwIs+tDajDs64owN7tOAd6eucGz+KfO26iNcBFpbWA5732bBNWO4kHNpr9D955L61bvHCF/mwSrz6eQaDjfDEANqGMkFc+NGxpKZzCD2sj/JrHd+zlPQ8Iz7Q+2JVIiVCuCKoK/hlAEHzvk/Piq3mRL1rT/fEh9hoT5GJmeYswg1otiKydizJ/fS2SeKHVu6Z3JEHjiW8NaTQgP5xdBli8nC57XiN9hrquBu99hn9zqwo92+PM2JXtpeVZS0PdqR5mDyDreMMtEws+CpwaRyyzoYtfcvt9PJIW0fJVNNi/FFyRsea7peLvJrL+5b4GOXJ8tAr+ATk9f8KmiIsRhqRy0vFzwRV3Z5dZ3QqIU8JQ/uQpkJbjMUMFj2F9sCFeaBjI4+fL/oN3+LQgjI4zuAfQ+3IPIPFQBccf0clJpsfpnBxD84atwtupkGqKvrH7cGNl/QcWcSi6wcVDML6ljOgYbo+2BOAWNNjlUBPiyitUAwbnhFvLbnqw42kR3Yp2kv2dMeDdcGOX5kT4S6M44KHEB/SpCfl7xgsUvs+JNY9G3O2X/6FEt9FyAn57lrbiu+tl83sCymSvq9eZbe9mchL7MTf/Ta78e80zSf0hYY5eUU7+ff14jv7Xy8qjzfzzzvaJnrIdvFb5BLWKcWGy5/w7+vV2cvIfwHqdTB+RuJK5oj9mbt0Hy94AmjMjjwYNZlNS6uiyxNnwNyt3gdreLb64p/3+08nXkb92LTkkRgFOwk1oGEVllcOj5lv1hfAZywDows0944U8vUFw+A/nuVq/UCygsrmWIBnHyU01d0XJPwriEOvx/ISK6Pk4y2w0gmojZs7lU8TtakBAdne4v/aNxmMpK4VcGMp7si0yqsiolXRuOi1Z1P7SqD3Zmp0CWcyK4Ubmp2SXiXuI5nGLCieFHKHNRIlcY3Pys2dwMTYCaqlyWSITwr2oGXvyU3h1Pf8eQ3w1bnD7ilocVjYDkcXR3Oo1BXgMLTUjNw2xMVwjtp99NhSVc5aIWrDQT5DHPKtCtheBP4zHcw4dz2eRdTMamhlHhtfgqJJHI7NGDUw1XL8vsSeSHyKqDtqoAmrQqsYwvwi7HW3ojWyhIa5oz5xJTaq14NAzFLjVLR12rRNUQ6xohDnrWFb5bG9yf8aCD8d5phoackcNJp+Dw3Due3RM+5Rid7EuIgsnwgpX0rUWh/nqPtByMhMZZ69NpgvRTKZ62ViZ+Q7Dp5r4K0d7EfJuiy06KuIYauRh5Ecrhdt2QpTS1k1AscEHvapNbU3HL1F2TFyR33Wxb5MvH5iZsrn3SDcsxlnnshO8PLwmdGN+paWnQuORtZGX37uhFT64SeuPsx8UOokY6ON85WdQ1dki5zErsJGazcBOddWJEKqNPiJpsMD1GrVLrVY+AOdPWQneTyyP1hRX/lMM4ZogGGOhYuAdr7F/DOiAoc++cn5vlf0zkMUJ40Z1rlgv9BelPqVOpxKeOpzKdF8maK+1Vv23MO9k/8+qpLoxrIGH2EDQlnGmH8CD31G8QqlyQIcpmR5bwmSVw9/Ns6IHgulCRehvZ/+VrM60Cu/r3AontFfrljew74skYe2uyn7JKQtFQBQRJ9ryGic/zQOsbS4scUBctA8cPToQ3x6ZBQu6DPu5m1bnCtP8TllLYA0UTQNVqza5nfew3Mopy1GPUwG5jsl0OVXniPmAcmLqO5HG8Hv3nSLecE9oOjPDXcsTxoCBxYyzBdj4wmnyEV4kvFDunipS8SSkvdaMnTBN9brHUR8xdmmEAp/Pdqk9uextp1t+JrtXwpN/MG2w/qhRMpSNxQ1uhg/kKO30eQ/FyHUDkWHT8V6gGRU4DhDMxZu7xXij9Ui6jlpWmQCqJg3FkOTq3WKneCRYZxBXMNAVLQgHXSCGSqNdjebY94oyIpVjMYehAiFx/tqzBXFHZaL5PeeD74rW5OysFoUXY8sebUZleFTUa/+zBKVTFDopTReXNuZq47QjkWnxjirCommO4L/GrFtVV21EpMyw8wyThL5Y59d88xtlx1g1ttSICDwnof6lt/6zliPzgVUL8jWBjC0o2D6Kg+jNuThkAlaDJsq/AG2aKA//A76avw2KNqtv223P+Wq3StRDDNKFFgtsFukYt1GFDWooFVXitaNhb3RCyJi4cMeNjROiPEDb4k+G3+hD8tsg+5hhmSc/8t2JTSwYoCzAI75doq8QTHe+E/Tw0RQSUDlU+6uBeNN3h6jJGX/mH8oj0i3caCNsjvTnoh73BtyZpsflHLq6AfwJNCDX4S98h4+pCOhGKDhV3rtkKHMa3EG4J9y8zFWI4UsfNzC/Rl5midNn7gwoN9j23HGCQQ+OAZpTTPMdiVow740gIyuEtd0qVxMyNXhHcnuXRKdw5wDUSL358ktjMXmAkvIB73BLa1vfF9BAUZInPYJiwxqFWQQBVk7gQH4ojfUQ/KEjn+A/WR6EEe4CtbpoLe1mzHkajgTIoE0SLDHVauKhrq12zrAXBGbPPWKCt4DGedq3JyGRbmPFW32bE7T20+73BatV/qQhhBWfWBFHfhYWXjALts38FemnoT+9bn1jDBMcUMmYgSc0e7GQjv2MUBwLU8ionCpgV+Qrhg7iUIfUY6JFxR0Y+ZTCPM+rVuq0GNLyJXX6nrUTt8HzFBRY1E/FIm2EeVA9NcXrj7S6YYIChVQCWr/m2fYUjC4j0XLkzZ8GCSLfmkW3PB/xq+nlXsKVBOj7vTvqKCOMq7Ztqr3cQ+N8gBnPaAps+oGwWOkbuxnRYj/x/WjiDclVrs22xMK4qArE1Ztk1456kiJriw6abkNeRHogaPRBgbgF9Z8i/tbzWELN4CvbqtrqV9TtGSnmPS2F9kqOIBaazHYaJ9bi3AoDBvlZasMluxt0BDXfhp02Jn411aVt6S4TUB8ZgFDkI6TP6gwPY85w+oUQSsjIeXVminrwIdK2ZAawb8Se6XOJbOaliQxHSrnAeONDLuCnFejIbp4YDtBcQCwMsYiRZfHefuEJqJcwKTTJ8sx5hjHmJI1sPFHOr6W9AhZ2NAod38mnLQk1gOz2LCAohoQbgMbUK9RMEA3LkiF7Sr9tLZp6lkciIGhE2V546w3Mam53VtVkGbB9w0Yk2XiRnCmbpxmHr2k4eSC0RuNbjNsUfDIfc8DZvRvgUDe1IlKdZTzcT4ZGEb53dp8VtsoZlyXzLHOdAbsp1LPTVaHvLA0GYDFMbAW/WUBfUAdHwqLFAV+3uHvYWrCfhUOR2i89qvCBoOb48usAGdcF2M4aKn79k/43WzBZ+xR1L0uZfia70XP9soQReeuhZiUnXFDG1T8/OXNmssTSnYO+3kVLAgeiY719uDwL9FQycgLPessNihMZbAKG7qwPZyG11G1+ZA3jAX2yddpYfmaKBlmfcK/V0mwIRUDC0nJSOPUl2KB8h13F4dlVZiRhdGY5farwN+f9hEb1cRi41ZcGDn6Xe9MMSTOY81ULJyXIHSWFIQHstVYLiJEiUjktlHiGjntN5/btB8Fu+vp28zl2fZXN+dJDyN6EXhS+0yzqpl/LSJNEUVxmu7BsNdjAY0jVsAhkNuuY0E1G48ej25mSt+00yPbQ4SRCVkIwb6ISvYtmJRPz9Zt5dk76blf+lJwAPH5KDF+vHAmACLoCdG2Adii6dOHnNJnTmZtoOGO8Q1jy1veMw6gbLFToQmfJa7nT7Al89mRbRkZZQxJTKgK5Kc9INzmTJFp0tpAPzNmyL/F08bX3nhCumM/cR/2RPn9emZ3VljokttZD1zVWXlUIqEU7SLk5I0lFRU0AcENXBYazNaVzsVHA/sD3o9hm42wbHIRb/BBQTKzAi8s3+bMtpOOZgLdQzCYPfX3UUxKd1WYVkGH7lh/RBBgMZZwXzU9+GYxdBqlGs0LP+DZ5g2BWNh6FAcR944B+K/JTWI3t9YyVyRhlP4CCoUk/mmF7+r2pilVBjxXBHFaBfBtr9hbVn2zDuI0kEOG3kBx8CGdPOjX1ph1POOZJUO1JEGG0jzUy2tK4X0CgVNYhmkqqQysRNtKuPdCJqK3WW57kaV17vXgiyPrl4KEEWgiGF1euI4QkSFHFf0TDroQiLNKJiLbdhH0YBhriRNCHPxSqJmNNoketaioohqMglh6wLtEGWSM1EZbQg72h0UJAIPVFCAJOThpQGGdKfFovcwEeiBuZHN2Ob4uVM7+gwZLz1D9E7ta4RmMZ24OBBAg7Eh6dLXGofZ4U2TFOCQMKjwhVckjrydRS+YaqCw1kYt6UexuzbNEDyYLTZnrY1PzsHZJT4U+awO2xlqTSYu6n/U29O2wPXgGOEKDMSq+zTUtyc8+6iLp0ivav4FKx+xxVy4FxhIF/pucVDqpsVe2jFOfdZhTzLz2QjtzvsTCvDPU7bzDH2eXVKUV9TZ+qFtaSSxnYgYdXKwVreIgvWhT9eGDB2OvnWyPLfIIIfNnfIxU8nW7MbcH05nhlsYtaW9EZRsxWcKdEqInq1DiZPKCz7iGmAU9/ccnnQud2pNgIGFYOTAWjhIrd63aPDgfj8/sdlD4l+UTlcxTI9jbaMqqN0gQxSHs60IAcW3cH4p3V1aSciTKB29L1tz2eUQhRiTgTvmqc+sGtBNh4ky0mQJGsdycBREP+fAaSs1EREDVo5gvgi5+aCN7NECw30owbCc1mSpjiahyNVwJd1jiGgzSwfTpzf2c5XJvG/g1n0fH88KHNnf+u7ZiRMlXueSIsloJBUtW9ezvsx9grfsX/FNxnbxU1Lvg0hLxixypHKGFAaPu0xCD8oDTeFSyfRT6s8109GMUZL8m2xXp8X2dpPCWWdX84iga4BrTlOfqox4shqEgh/Ht4qRst52cA1xOIUuOxgfUivp6v5f8IVyaryEdpVk72ERAwdT4aoY1usBgmP+0m06Q216H/nubtNYxHaOIYjcach3A8Ez/zc0KcShhel0HCYjFsA0FjYqyJ5ZUH1aZw3+zWC0hLpM6GDfcAdn9fq2orPmZbW6XXrf+Krc9RtvII5jeD3dFoT1KwZJwxfUMvc5KLfn8rROW23Jw89sJ2a5dpB3qWDUBWF2iX8OCuKprHosJ2mflBR+Wqs86VvgI/XMnsqb97+VlKdPVysczPj8Jhzf+WCvGBHijAqYlavbF60soMWlHbvKT+ScvhprgeTln51xX0sF+Eadc/l2s2a5BgkVbHYyz0E85p0LstqH+gEGiR84nBRRFIn8hLSZrGwqjZ3E29cuGi+5Z5bp7EM8MWFa9ssS/vy4VrDfECSv7DSU84DaP0sXI3Ap4lWznQ65nQoTKRWU30gd7Nn8ZowUvGIx4aqyXGwmA/PB4qN8msJUODezUHEl0VP9uo+cZ8vPFodSIB4C7lQYjEFj8yu49C2KIV3qxMFYTevG8KqAr0TPlkbzHHnTpDpvpzziAiNFh8xiT7C/TiyH0EguUw4vxAgpnE27WIypV+uFN2zW7xniF/n75trs9IJ5amB1zXXZ1LFkJ6GbS/dFokzl4cc2mamVwhL4XU0Av5gDWAl+aEWhAP7t2VIwU+EpvfOPDcLASX7H7lZpXA2XQfbSlD4qU18NffNPoAKMNSccBfO9YVVgmlW4RydBqfHAV7+hrZ84WJGho6bNT0YMhxxLdOx/dwGj0oyak9aAkNJ8lRJzUuA8sR+fPyiyTgUHio5+Pp+YaKlHrhR41jY5NESPS3x+zTMe0S2HnLOKCOQPpdxKyviBvdHrCDRqO+l96HhhNBLXWv4yEMuEUYo8kXnYJM8oIgVM4XJ+xXOev4YbWeqsvgq0lmw4/PiYr9sYLt+W5EAuYSFnJEan8CwJwbtASBfLBBpJZiRPor/aCJBZsM+MhvS7ZepyHvU8m5WSmaZnxuLts8ojl6KkS8oSAHkq5GWlCB/NgJ5W3rO2Cj1MK7ahxsCrbTT3a0V/QQH+sErxV4XUWDHx0kkFy25bPmBMBQ6BU3HoHhhYcJB9JhP6NXUWKxnE0raXHB6U9KHpWdQCQI72qevp5fMzcm+AvC85rsynVQhruDA9fp9COe7N56cg1UKGSas89vrN+WlGLYTwi5W+0xYdKEGtGCeNJwXKDU0XqU5uQYnWsMwTENLGtbQMvoGjIFIEMzCRal4rnBAg7D/CSn8MsCvS+FDJJAzoiioJEhZJgAp9n2+1Yznr7H+6eT4YkJ9Mpj60ImcW4i4iHDLn9RydB8dx3QYm3rsX6n4VRrZDsYK6DCGwkwd5n3/INFEpk16fYpP6JtMQpqEMzcOfQGAHXBTEGzuLJ03GYQL9bmV2/7ExDlRf+Uvf1sM2frRtCWmal12pMgtonvSCtR4n1CLUZRdTHDHP1Otwqd+rcdlavnKjUB/OYXQHUJzpNyFoKpQK+2OgrEKpGyIgIBgn2y9QHnTJihZOpEvOKIoHAMGAXHmj21Lym39Mbiow4IF+77xNuewziNVBxr6KD5e+9HzZSBIlUa/AmsDFJFXeyrQakR3FwowTGcADJHcEfhGkXYNGSYo4dh4bxwLM+28xjiqkdn0/3R4UEkvcBrBfn/SzBc1XhKM2VPlJgKSorjDac96V2UnQYXl1/yZPT4DVelgO+soMjexXwYO58VLl5xInQUZI8jc3H2CPnCNb9X05nOxIy4MlecasTqGK6s2az4RjpF2cQP2G28R+7wDPsZDZC/kWtjdoHC7SpdPmqQrUAhMwKVuxCmYTiD9q/O7GHtZvPSN0CAUQN/rymXZNniYLlJDE70bsk6Xxsh4kDOdxe7A2wo7P9F5YvqqRDI6brf79yPCSp4I0jVoO4YnLYtX5nzspR5WB4AKOYtR1ujXbOQpPyYDvfRE3FN5zw0i7reehdi7yV0YDRKRllGCGRk5Yz+Uv1fYl2ZwrnGsqsjgAVo0xEUba8ohjaNMJNwTwZA/wBDWFSCpg1eUH8MYL2zdioxRTqgGQrDZxQyNzyBJPXZF0+oxITJAbj7oNC5JwgDMUJaM5GqlGCWc//KCIrI+aclEe4IA0uzv7cuj6GCdaJONpi13O544vbtIHBF+A+JeDFUQNy61Gki3rtyQ4aUywn6ru314/dkGiP8Iwjo0J/2Txs49ZkwEl4mx+iYUUO55I6pJzU4P+7RRs+DXZkyKUYZqVWrPF4I94m4Wx1tXeE74o9GuX977yvJ/jkdak8+AmoHVjI15V+WwBdARFV2IPirJgVMdsg1Pez2VNHqa7EHWdTkl3XTcyjG9BiueWFvQfXI8aWSkuuRmqi/HUuzqyvLJfNfs0txMqldYYflWB1BS31WkuPJGGwXUCpjiQSktkuBMWwHjSkQxeehqw1Kgz0Trzm7QbtgxiEPDVmWCNCAeCfROTphd1ZNOhzLy6XfJyG6Xgd5MCAZw4xie0Sj5AnY1/akDgNS9YFl3Y06vd6FAsg2gVQJtzG7LVq1OH2frbXNHWH/NY89NNZ4QUSJqL2yEcGADbT38X0bGdukqYlSoliKOcsSTuqhcaemUeYLLoI8+MZor2RxXTRThF1LrHfqf/5LcLAjdl4EERgUysYS2geE+yFdasU91UgUDsc2cSQ1ZoT9+uLOwdgAmifwQqF028INc2IQEDfTmUw3eZxvz7Ud1z3xc1PQfeCvfKsB9jOhRj7rFyb9XcDWLcYj0bByosychMezMLVkFiYcdBBQtvI6K0KRuOZQH2kBsYHJaXTkup8F0eIhO1/GcIwWKpr2mouB7g5TUDJNvORXPXa/mU8bh27TAZYBe2sKx4NSv5OjnHIWD2RuysCzBlUfeNXhDd2jxnHoUlheJ3jBApzURy0fwm2FwwsSU0caQGl0Kv8hopRQE211NnvtLRsmCNrhhpEDoNiZEzD2QdJWKbRRWnaFedXHAELSN0t0bfsCsMf0ktfBoXBoNA+nZN9+pSlmuzspFevmsqqcMllzzvkyXrzoA+Ryo1ePXpdGOoJvhyru+EBRsmOp7MXZ0vNUMUqHLUoKglg1p73sWeZmPc+KAw0pE2zIsFFE5H4192KwDvDxdxEYoDBDNZjbg2bmADTeUKK57IPD4fTYF4c6EnXx/teYMORBDtIhPJneiZny7Nv/zG+YmekIKCoxr6kauE2bZtBLufetNG0BtBY7f+/ImUypMBvdWu/Q7vTMRzw5aQGZWuc1V0HEsItFYMIBnoKGZ0xcarba/TYZq50kCaflFysYjA4EDKHqGdpYWdKYmm+a7TADmW35yfnOYpZYrkpVEtiqF0EujI00aeplNs2k+qyFZNeE3CDPL9P6b4PQ/kataHkVpLSEVGK7EX6rAa7IVNrvZtFvOA6okKvBgMtFDAGZOx88MeBcJ8AR3AgUUeIznAN6tjCUipGDZONm1FjWJp4A3QIzSaIOmZ7DvF/ysYYbM/fFDOV0jntAjRdapxJxL0eThpEhKOjCDDq2ks+3GrwxqIFKLe1WdOzII8XIOPGnwy6LKXVfpSDOTEfaRsGujhpS4hBIsMOqHbl16PJxc4EkaVu9wpEYlF/84NSv5Zum4drMfp9yXbzzAOJqqS4YkI4cBrFrC7bMPiCfgI3nNZAqkk3QOZqR+yyqx+nDQKBBBZ7QKrfGMCL+XpqFaBJU0wpkBdAhbR4hJsmT5aynlvkouoxm/NjD5oe6BzVIO9uktM+/5dEC5P7vZvarmuO/lKXz4sBabVPIATuKTrwbJP8XUkdM6uEctHKXICUJGjaZIWRbZp8czquQYfY6ynBUCfIU+gG6wqSIBmYIm9pZpXdaL121V7q0VjDjmQnXvMe7ysoEZnZL15B0SpxS1jjd83uNIOKZwu5MPzg2NhOx3xMOPYwEn2CUzbSrwAs5OAtrz3GAaUkJOU74XwjaYUmGJdZBS1NJVkGYrToINLKDjxcuIlyfVsKQSG/G4DyiO2SlQvJ0d0Ot1uOG5IFSAkq+PRVMgVMDvOIJMdqjeCFKUGRWBW9wigYvcbU7CQL/7meF2KZAaWl+4y9uhowAX7elogAvItAAxo2+SFxGRsHGEW9BnhlTuWigYxRcnVUBRQHV41LV+Fr5CJYV7sHfeywswx4XMtUx6EkBhR+q8AXXUA8uPJ73Pb49i9KG9fOljvXeyFj9ixgbo6CcbAJ7WHWqKHy/h+YjBwp6VcN7M89FGzQ04qbrQtgrOFybg3gQRTYG5xn73ArkfQWjCJROwy3J38Dx/D7jOa6BBNsitEw1wGq780EEioOeD+ZGp2J66ADiVGMayiHYucMk8nTK2zzT9CnEraAk95kQjy4k0GRElLL5YAKLQErJ5rp1eay9O4Fb6yJGm9U4FaMwPGxtKD6odIIHKoWnhKo1U8KIpFC+MVn59ZXmc7ZTBZfsg6FQ8W10YfTr4u0nYrpHZbZ1jXiLmooF0cOm0+mPnJBXQtepc7n0BqOipNCqI6yyloTeRShNKH04FIo0gcMk0H/xThyN4pPAWjDDkEp3lNNPRNVfpMI44CWRlRgViP64eK0JSRp0WUvCWYumlW/c58Vcz/yMwVcW5oYb9+26TEhwvbxiNg48hl1VI1UXTU//Eta+BMKnGUivctfL5wINDD0giQL1ipt6U7C9cd4+lgqY2lMUZ02Uv6Prs+ZEZer7ZfWBXVghlfOOrClwsoOFKzWEfz6RZu1eCs+K8fLvkts5+BX0gyrFYve0C3qHrn5U/Oh6D/CihmWIrY7HUZRhJaxde+tldu6adYJ+LeXupQw0XExC36RETdNFxcq9glMu4cNQSX9cqR/GQYp+IxUkIcNGWVU7ZtGa6P3XAyodRt0XeS3Tp01AnCh0ZbUh4VrSZeV9RWfSoWyxnY3hzcZ30G/InDq4wxRrEejreBxnhIQbkxenxkaxl+k7eLUQkUR6vKJ2iDFNGX3WmVA1yaOH+mvhBd+sE6vacQzFobwY5BqEAFmejwW5ne7HtVNolOUgJc8CsUxmc/LBi8N5mu9VsIA5HyErnS6zeCz7VLI9+n/hbT6hTokMXTVyXJRKSG2hd2labXTbtmK4fNH3IZBPreSA4FMeVouVN3zG5x9CiGpLw/3pceo4qGqp+rVp+z+7yQ98oEf+nyH4F3+J9IheDBa94Wi63zJbLBCIZm7P0asHGpIJt3PzE3m0S4YIWyXBCVXGikj8MudDPB/6Nm2v4IxJ5gU0ii0guy5SUHqGUYzTP0jIJU5E82RHUXtX4lDdrihBLdP1YaG1AGUC12rQKuIaGvCpMjZC9bWSCYnjDlvpWbkdXMTNeBHLKiuoozMGIvkczmP0aRJSJ8PYnLCVNhKHXBNckH79e8Z8Kc2wUej4sQZoH8qDRGkg86maW/ZQWGNnLcXmq3FlXM6ssR/3P6E/bHMvm6HLrv1yRixit25JsH3/IOr2UV4BWJhxXW5BJ6Xdr07n9kF3ZNAk6/Xpc5MSFmYJ2R7bdL8Kk7q1OU9Elg/tCxJ8giT27wSTySF0GOxg4PbYJdi/Nyia9Nn89CGDulfJemm1aiEr/eleGSN+5MRrVJ4K6lgyTTIW3i9cQ0dAi6FHt0YMbH3wDSAtGLSAccezzxHitt1QdhW36CQgPcA8vIIBh3/JNjf/Obmc2yzpk8edSlS4lVdwgW5vzbYEyFoF4GCBBby1keVNueHAH+evi+H7oOVfS3XuPQSNTXOONAbzJeSb5stwdQHl1ZjrGoE49I8+A9j3t+ahhQj74FCSWpZrj7wRSFJJnnwi1T9HL5qrCFW/JZq6P62XkMWTb+u4lGpKfmmwiJWx178GOG7KbrZGqyWwmuyKWPkNswkZ1q8uptUlviIi+AXh2bOOTOLsrtNkfqbQJeh24reebkINLkjut5r4d9GR/r8CBa9SU0UQhsnZp5cP+RqWCixRm7i4YRFbtZ4EAkhtNa6jHb6gPYQv7MKqkPLRmX3dFsK8XsRLVZ6IEVrCbmNDc8o5mqsogjAQfoC9Bc7R6gfw03m+lQpv6kTfhxscDIX6s0w+fBxtkhjXAXr10UouWCx3C/p/FYwJRS/AXRKkjOb5CLmK4XRe0+xeDDwVkJPZau52bzLEDHCqV0f44pPgKOkYKgTZJ33fmk3Tu8SdxJ02SHM8Fem5SMsWqRyi2F1ynfRJszcFKykdWlNqgDA/L9lKYBmc7Zu/q9ii1FPF47VJkqhirUob53zoiJtVVRVwMR34gV9iqcBaHbRu9kkvqk3yMpfRFG49pKKjIiq7h/VpRwPGTHoY4cg05X5028iHsLvUW/uz+kjPyIEhhcKUwCkJAwbR9pIEGOn8z6svAO8i89sJ3dL5qDWFYbS+HGPRMxYwJItFQN86YESeJQhn2urGiLRffQeLptDl8dAgb+Tp47UQPxWOw17OeChLN1WnzlkPL1T5O+O3Menpn4C3IY5LEepHpnPeZHbvuWfeVtPlkH4LZjPbBrkJT3NoRJzBt86CO0Xq59oQ+8dsm0ymRcmQyn8w71mhmcuEI5byuF+C88VPYly2sEzjlzAQ3vdn/1+Hzguw6qFNNbqenhZGbdiG6RwZaTG7jTA2X9RdXjDN9yj1uQpyO4Lx8KRAcZcbZMafp4wPOd5MdXoFY52V1A8M9hi3sso93+uprE0qYNMjkE22CvK4HuUxqN7oIz5pWuETq1lQAjqlSlqdD2Rnr/ggp/TVkQYjn9lMfYelk2sH5HPdopYo7MHwlV1or9Bxf+QCyLzm92vzG2wjiIjC/ZHEJzeroJl6bdFPTpZho5MV2U86fLQqxNlGIMqCGy+9WYhJ8ob1r0+Whxde9L2PdysETv97O+xVw+VNN1TZSQN5I6l9m5Ip6pLIqLm4a1B1ffH6gHyqT9p82NOjntRWGIofO3bJz5GhkvSWbsXueTAMaJDou99kGLqDlhwBZNEQ4mKPuDvVwSK4WmLluHyhA97pZiVe8g+JxmnJF8IkV/tCs4Jq/HgOoAEGR9tCDsDbDmi3OviUQpG5D8XmKcSAUaFLRXb2lmJTNYdhtYyfjBYZQmN5qT5CNuaD3BVnlkCk7bsMW3AtXkNMMTuW4HjUERSJnVQ0vsBGa1wo3Qh7115XGeTF3NTz8w0440AgU7c3bSXO/KMINaIWXd0oLpoq/0/QJxCQSJ9XnYy1W7TYLBJpHsVWD1ahsA7FjNvRd6mxCiHsm8g6Z0pnzqIpF1dHUtP2ITU5Z1hZHbu+L3BEEStBbL9XYvGfEakv1bmf+bOZGnoiuHEdlBnaChxYKNzB23b8sw8YyT7Ajxfk49eJIAvdbVkdFCe2J0gMefhQ0bIZxhx3fzMIysQNiN8PgOUKxOMur10LduigREDRMZyP4oGWrP1GFY4t6groASsZ421os48wAdnrbovNhLt7ScNULkwZ5AIZJTrbaKYTLjA1oJ3sIuN/aYocm/9uoQHEIlacF1s/TM1fLcPTL38O9fOsjMEIwoPKfvt7opuI9G2Hf/PR4aCLDQ7wNmIdEuXJ/QNL72k5q4NejAldPfe3UVVqzkys8YZ/jYOGOp6c+YzRCrCuq0M11y7TiN6qk7YXRMn/gukxrEimbMQjr3jwRM6dKVZ4RUfWQr8noPXLJq6yh5R3EH1IVOHESst/LItbG2D2vRsZRkAObzvQAAD3mb3/G4NzopI0FAiHfbpq0X72adg6SRj+8OHMShtFxxLZlf/nLgRLbClwl5WmaYSs+yEjkq48tY7Z2bE0N91mJwt+ua0NlRJIDh0HikF4UvSVorFj2YVu9YeS5tfvlVjPSoNu/Zu6dEUfBOT555hahBdN3Sa5Xuj2Rvau1lQNIaC944y0RWj9UiNDskAK1WoL+EfXcC6IbBXFRyVfX/WKXxPAwUyIAGW8ggZ08hcijKTt1YKnUO6QPvcrmDVAb0FCLIXn5id4fD/Jx4tw/gbXs7WF9b2RgXtPhLBG9vF5FEkdHAKrQHZAJC/HWvk7nvzzDzIXZlfFTJoC3JpGgLPBY7SQTjGlUvG577yNutZ1hTfs9/1nkSXK9zzKLRZ3VODeKUovJe0WCq1zVMYxCJMenmNzPIU2S8TA4E7wWmbNkxq9rI2dd6v0VpcAPVMxnDsvWTWFayyqvKZO7Z08a62i/oH2/jxf8rpmfO64in3FLiL1GX8IGtVE9M23yGsIqJbxDTy+LtaMWDaPqkymb5VrQdzOvqldeU0SUi6IirG8UZ3jcpRbwHa1C0Dww9G/SFX3gPvTJQE+kyz+g1BeMILKKO+olcHzctOWgzxYHnOD7dpCRtuZEXACjgqesZMasoPgnuDC4nUviAAxDc5pngjoAITIkvhKwg5d608pdrZcA+qn5TMT6Uo/QzBaOxBCLTJX3Mgk85rMfsnWx86oLxf7p2PX5ONqieTa/qM3tPw4ZXvlAp83NSD8F7+ZgctK1TpoYwtiU2h02HCGioH5tkVCqNVTMH5p00sRy2JU1qyDBP2CII/Dg4WDsIl+zgeX7589srx6YORRQMBfKbodbB743Tl4WLKOEnwWUVBsm94SOlCracU72MSyj068wdpYjyz1FwC2bjQnxnB6Mp/pZ+yyZXtguEaYB+kqhjQ6UUmwSFazOb+rhYjLaoiM+aN9/8KKn0zaCTFpN9eKwWy7/u4EHzO46TdFSNjMfn2iPSJwDPCFHc0I1+vjdAZw5ZjqR/uzi9Zn20oAa5JnLEk/EA3VRWE7J/XrupfFJPtCUuqHPpnlL7ISJtRpSVcB8qsZCm2QEkWoROtCKKxUh3yEcMbWYJwk6DlEBG0bZP6eg06FL3v6RPb7odGuwm7FN8fG4woqtB8e7M5klPpo97GoObNwt+ludTAmxyC5hmcFx+dIvEZKI6igFKHqLH01iY1o7903VzG9QGetyVx5RNmBYUU+zIuSva/yIcECUi4pRmE3VkF2avqulQEUY4yZ/wmNboBzPmAPey3+dSYtBZUjeWWT0pPwCz4Vozxp9xeClIU60qvEFMQCaPvPaA70WlOP9f/ey39macvpGCVa+zfa8gO44wbxpJUlC8GN/pRMTQtzY8Z8/hiNrU+Zq64ZfFGIkdj7m7abcK1EBtws1X4J/hnqvasPvvDSDYWN+QcQVGMqXalkDtTad5rYY0TIR1Eqox3czwPMjKPvF5sFv17Thujr1IZ1Ytl4VX1J0vjXKmLY4lmXipRAro0qVGEcXxEVMMEl54jQMd4J7RjgomU0j1ptjyxY+cLiSyXPfiEcIS2lWDK3ISAy6UZ3Hb5vnPncA94411jcy75ay6B6DSTzK6UTCZR9uDANtPBrvIDgjsfarMiwoax2OlLxaSoYn4iRgkpEGqEkwox5tyI8aKkLlfZ12lO11TxsqRMY89j5JaO55XfPJPDL1LGSnC88Re9Ai+Nu5bZjtwRrvFITUFHPR4ZmxGslQMecgbZO7nHk32qHxYkdvWpup07ojcMCaVrpFAyFZJJbNvBpZfdf39Hdo2kPtT7v0/f8R/B5Nz4f1t9/3zNM/7n6SUHfcWk5dfQFJvcJMgPolGCpOFb/WC0FGWU2asuQyT+rm88ZKZ78Cei/CAh939CH0JYbpZIPtxc2ufXqjS3pHH9lnWK4iJ7OjR/EESpCo2R3MYKyE7rHfhTvWho4cL1QdN4jFTyR6syMwFm124TVDDRXMNveI1Dp/ntwdz8k8kxw7iFSx6+Yx6O+1LzMVrN0BBzziZi9kneZSzgollBnVwBh6oSOPHXrglrOj+QmR/AESrhDpKrWT+8/AiMDxS/5wwRNuGQPLlJ9ovomhJWn8sMLVItQ8N/7IXvtD8kdOoHaw+vBSbFImQsv/OCAIui99E+YSIOMlMvBXkAt+NAZK8wB9Jf8CPtB+TOUOR+z71d/AFXpPBT6+A5FLjxMjLIEoJzrQfquvxEIi+WoUzGR1IzQFNvbYOnxb2PyQ0kGdyXKzW2axQL8lNAXPk6NEjqrRD1oZtKLlFoofrXw0dCNWASHzy+7PSzOUJ3XtaPZsxLDjr+o41fKuKWNmjiZtfkOzItvlV2MDGSheGF0ma04qE3TUEfqJMrXFm7DpK+27DSvCUVf7rbNoljPhha5W7KBqVq0ShUSTbRmuqPtQreVWH4JET5yMhuqMoSd4r/N8sDmeQiQQvi1tcZv7Moc7dT5X5AtCD6kNEGZOzVcNYlpX4AbTsLgSYYliiPyVoniuYYySxsBy5cgb3pD+EK0Gpb0wJg031dPgaL8JZt6sIvzNPEHfVPOjXmaXj4bd4voXzpZ5GApMhILgMbCEWZ2zwgdeQgjNHLbPIt+KqxRwWPLTN6HwZ0Ouijj4UF+Sg0Au8XuIKW0WxlexdrFrDcZJ8Shauat3X0XmHygqgL1nAu2hrJFb4wZXkcS+i36KMyU1yFvYv23bQUJi/3yQpqr/naUOoiEWOxckyq/gq43dFou1DVDaYMZK9tho7+IXXokBCs5GRfOcBK7g3A+jXQ39K4YA8PBRW4m5+yR0ZAxWJncjRVbITvIAPHYRt1EJ3YLiUbqIvoKHtzHKtUy1ddRUQ0AUO41vonZDUOW+mrszw+SW/6Q/IUgNpcXFjkM7F4CSSQ2ExZg85otsMs7kqsQD4OxYeBNDcSpifjMoLb7GEbGWTwasVObmB/bfPcUlq0wYhXCYEDWRW02TP5bBrYsKTGWjnWDDJ1F7zWai0zW/2XsCuvBQjPFcTYaQX3tSXRSm8hsAoDdjArK/OFp6vcWYOE7lizP0Yc+8p16i7/NiXIiiQTp7c7Xus925VEtlKAjUdFhyaiLT7VxDagprMFwix4wZ05u0qj7cDWFd0W9OYHIu3JbJKMXRJ1aYNovugg+QqRN7fNHSi26VSgBpn+JfMuPo3aeqPWik/wI5Rz3BWarPQX4i5+dM0npwVOsX+KsOhC7vDg+OJsz4Q5zlnIeflUWL6QYMbf9WDfLmosLF4Qev3mJiOuHjoor/dMeBpA9iKDkMjYBNbRo414HCxjsHrB4EXNbHzNMDHCLuNBG6Sf+J4MZ/ElVsDSLxjIiGsTPhw8BPjxbfQtskj+dyNMKOOcUYIRBEIqbazz3lmjlRQhplxq673VklMMY6597vu+d89ec/zq7Mi4gQvh87ehYbpOuZEXj5g/Q7S7BFDAAB9DzG35SC853xtWVcnZQoH54jeOqYLR9NDuwxsVthTV7V99n/B7HSbAytbEyVTz/5NhJ8gGIjG0E5j3griULUd5Rg7tQR+90hJgNQKQH2btbSfPcaTOfIexc1db1BxUOhM1vWCpLaYuKr3FdNTt/T3PWCpEUWDKEtzYrjpzlL/wri3MITKsFvtF8QVV/NhVo97aKIBgdliNc10dWdXVDpVtsNn+2UIolrgqdWA4EY8so0YvB4a+aLzMXiMAuOHQrXY0tr+CL10JbvZzgjJJuB1cRkdT7DUqTvnswVUp5kkUSFVtIIFYK05+tQxT6992HHNWVhWxUsD1PkceIrlXuUVRogwmfdhyrf6zzaL8+c0L7GXMZOteAhAVQVwdJh+7nrX7x4LaIIfz2F2v7Dg/uDfz2Fa+4gFm2zHAor8UqimJG3VTJtZEoFXhnDYXvxMJFc6ku2bhbCxzij2z5UNuK0jmp1mnvkVNUfR+SEmj1Lr94Lym75PO7Fs0MIr3GdsWXRXSfgLTVY0FLqba97u1In8NAcY7IC6TjWLigwKEIm43NxTdaVTv9mcKkzuzBkKd8x/xt1p/9BbP7Wyb4bpo1K1gnOpbLvKz58pWl3B55RJ/Z5mRDLPtNQg14jdOEs9+h/V5UVpwrAI8kGbX8KPVPDIMfIqKDjJD9UyDOPhjZ3vFAyecwyq4akUE9mDOtJEK1hpDyi6Ae87sWAClXGTiwPwN7PXWwjxaR79ArHRIPeYKTunVW24sPr/3HPz2IwH8oKH4OlWEmt4BLM6W5g4kMcYbLwj2usodD1088stZA7VOsUSpEVl4w7NMb1EUHMRxAxLF0CIV+0L3iZb+ekB1vSDSFjAZ3hfLJf7gFaXrOKn+mhR+rWw/eTXIcAgl4HvFuBg1LOmOAwJH3eoVEjjwheKA4icbrQCmvAtpQ0mXG0agYp5mj4Rb6mdQ+RV4QBPbxMqh9C7o8nP0Wko2ocnCHeRGhN1XVyT2b9ACsL+6ylUy+yC3QEnaKRIJK91YtaoSrcWZMMwxuM0E9J68Z+YyjA0g8p1PfHAAIROy6Sa04VXOuT6A351FOWhKfTGsFJ3RTJGWYPoLk5FVK4OaYR9hkJvezwF9vQN1126r6isMGXWTqFW+3HL3I/jurlIdDWIVvYY+s6yq7lrFSPAGRdnU7PVwY/SvWbZGpXzy3BQ2LmAJlrONUsZs4oGkly0V267xbD5KMY8woNNsmWG1VVgLCra8aQBBcI4DP2BlNwxhiCtHlaz6OWFoCW0vMR3ErrG7JyMjTSCnvRcsEHgmPnwA6iNpJ2DrFb4gLlhKJyZGaWkA97H6FFdwEcLT6DRQQL++fOkVC4cYGW1TG/3iK5dShRSuiBulmihqgjR45Vi03o2RbQbP3sxt90VxQ6vzdlGfkXmmKmjOi080JSHkLntjvsBJnv7gKscOaTOkEaRQqAnCA4HWtB4XnMtOhpRmH2FH8tTXrIjAGNWEmudQLCkcVlGTQ965Kh0H6ixXbgImQP6b42B49sO5C8pc7iRlgyvSYvcnH9FgQ3azLbQG2cUW96SDojTQStxkOJyOuDGTHAnnWkz29aEwN9FT8EJ4yhXOg+jLTrCPKeEoJ9a7lDXOjEr8AgX4BmnMQ668oW0zYPyQiVMPxKRHtpfnEEyaKhdzNVThlxxDQNdrHeZiUFb6NoY2KwvSb7BnRcpJy+/g/zAYx3fYSN5QEaVD2Y1VsNWxB0BSO12MRsRY8JLfAezRMz5lURuLUnG1ToKk6Q30FughqWN6gBNcFxP/nY/iv+iaUQOa+2Nuym46wtI/DvSfzSp1jEi4SdYBE7YhTiVV5cX9gwboVDMVgZp5YBQlHOQvaDNfcCoCJuYhf5kz5kwiIKPjzgpcRJHPbOhJajeoeRL53cuMahhV8Z7IRr6M4hW0JzT7mzaMUzQpm866zwM7Cs07fJYXuWvjAMkbe5O6V4bu71sOG6JQ4oL8zIeXHheFVavzxmlIyBkgc9IZlEDplMPr8xlcyss4pVUdwK1e7CK2kTsSdq7g5SHRAl3pYUB9Ko4fsh4qleOyJv1z3KFSTSvwEcRO/Ew8ozEDYZSqpfoVW9uhJfYrNAXR0Z3VmeoAD+rVWtwP/13sE/3ICX3HhDG3CMc476dEEC0K3umSAD4j+ZQLVdFOsWL2C1TH5+4KiSWH+lMibo+B55hR3Gq40G1n25sGcN0mEcoU2wN9FCVyQLBhYOu9aHVLWjEKx2JIUZi5ySoHUAI9b8hGzaLMxCZDMLhv8MkcpTqEwz9KFDpCpqQhVmsGQN8m24wyB82FAKNmjgfKRsXRmsSESovAwXjBIoMKSG51p6Um8b3i7GISs7kjTq/PZoioCfJzfKdJTN0Q45kQEQuh9H88M3yEs3DbtRTKALraM0YC8laiMiOOe6ADmTcCiREeAWZelBaEXRaSuj2lx0xHaRYqF65O0Lo5OCFU18A8cMDE4MLYm9w2QSr9NgQAIcRxZsNpA7UJR0e71JL+VU+ISWFk5I97lra8uGg7GlQYhGd4Gc6rxsLFRiIeGO4abP4S4ekQ1fiqDCy87GZHd52fn5aaDGuvOmIofrzpVwMvtbreZ/855OaXTRcNiNE0wzGZSxbjg26v8ko8L537v/XCCWP2MFaArJpvnkep0pA+O86MWjRAZPQRfznZiSIaTppy6m3p6HrNSsY7fDtz7Cl4V/DJAjQDoyiL2uwf1UHVd2AIrzBUSlJaTj4k6NL97a/GqhWKU9RUmjnYKpm2r+JYUcrkCuZKvcYvrg8pDoUKQywY9GDWg03DUFSirlUXBS5SWn/KAntnf0IdHGL/7mwXqDG+LZYjbEdQmqUqq4y54TNmWUP7IgcAw5816YBzwiNIJiE9M4lPCzeI/FGBeYy3p6IAmH4AjXXmvQ4Iy0Y82NTobcAggT2Cdqz6Mx4TdGoq9fn2etrWKUNFyatAHydQTVUQ2S5OWVUlugcNvoUrlA8cJJz9MqOa/W3iVno4zDHfE7zhoY5f5lRTVZDhrQbR8LS4eRLz8iPMyBL6o4PiLlp89FjdokQLaSBmKHUwWp0na5fE3v9zny2YcDXG/jfI9sctulHRbdkI5a4GOPJx4oAJQzVZ/yYAado8KNZUdEFs9ZPiBsausotXMNebEgr0dyopuqfScFJ3ODNPHgclACPdccwv0YJGQdsN2lhoV4HVGBxcEUeUX/alr4nqpcc1CCR3vR7g40zteQg/JvWmFlUE4mAiTpHlYGrB7w+U2KdSwQz2QJKBe/5eiixWipmfP15AFWrK8Sh1GBBYLgzki1wTMhGQmagXqJ2+FuqJ8f0XzXCVJFHQdMAw8xco11HhM347alrAu+wmX3pDFABOvkC+WPX0Uhg1Z5MVHKNROxaR84YV3s12UcM+70cJ460SzEaKLyh472vOMD3XnaK7zxZcXlWqenEvcjmgGNR2OKbI1s8U+iwiW+HotHalp3e1MGDy6BMVIvajnAzkFHbeVsgjmJUkrP9OAwnEHYXVBqYx3q7LvXjoVR0mY8h+ZaOnh053pdsGkmbqhyryN01eVHySr+CkDYkSMeZ1xjPNVM+gVLTDKu2VGsMUJqWO4TwPDP0VOg2/8ITbAUaMGb4LjL7L+Pi11lEVMXTYIlAZ/QHmTENjyx3kDkBdfcvvQt6tKk6jYFM4EG5UXDTaF5+1ZjRz6W7MdJPC+wTkbDUim4p5QQH3b9kGk2Bkilyeur8Bc20wm5uJSBO95GfYDI1EZipoRaH7uVveneqz43tlTZGRQ4a7CNmMHgXyOQQOL6WQkgMUTQDT8vh21aSdz7ERiZT1jK9F+v6wgFvuEmGngSvIUR2CJkc5tx1QygfZnAruONobB1idCLB1FCfO7N1ZdRocT8/Wye+EnDiO9pzqIpnLDl4bkaRKW+ekBVwHn46Shw1X0tclt/0ROijuUB4kIInrVJU4buWf4YITJtjOJ6iKdr1u+flgQeFH70GxKjhdgt/MrwfB4K/sXczQ+9zYcrD4dhY6qZhZ010rrxggWA8JaZyg2pYij8ieYEg1aZJkZK9O1Re7sB0iouf60rK0Gd+AYlp7soqCBCDGwfKeUQhCBn0E0o0GS6PdmjLi0TtCYZeqazqwN+yNINIA8Lk3iPDnWUiIPLGNcHmZDxfeK0iAdxm/T7LnN+gemRL61hHIc0NCAZaiYJR+OHnLWSe8sLrK905B5eEJHNlWq4RmEXIaFTmo49f8w61+NwfEUyuJAwVqZCLFcyHBKAcIVj3sNzfEOXzVKIndxHw+AR93owhbCxUZf6Gs8cz6/1VdrFEPrv330+9s6BtMVPJ3zl/Uf9rUi0Z/opexfdL3ykF76e999GPfVv8fJv/Y/+/5hEMon1tqNFyVRevV9y9/uIvsG3dbB8GRRrgaEXfhx+2xeOFt+cEn3RZanNxdEe2+B6MHpNbrRE53PlDifPvFcp4kO78ILR0T4xyW/WGPyBsqGdoA7zJJCu1TKbGfhnqgnRbxbB2B3UZoeQ2bz2sTVnUwokTcTU21RxN1PYPS3Sar7T0eRIsyCNowr9amwoMU/od9s2APtiKNL6ENOlyKADstAEWKA+sdKDhrJ6BOhRJmZ+QJbAaZ3/5Fq0/lumCgEzGEbu3yi0Y4I4EgVAjqxh4HbuQn0GrRhOWyAfsglQJAVL1y/6yezS2k8RE2MstJLh92NOB3GCYgFXznF4d25qiP4ZCyI4RYGesut6FXK6GwPpKK8WHEkhYui0AyEmr5Ml3uBFtPFdnioI8RiCooa7Z1G1WuyIi3nSNglutc+xY8BkeW3JJXPK6jd2VIMpaSxpVtFq+R+ySK9J6WG5Qvt+C+QH1hyYUOVK7857nFmyDBYgZ/o+AnibzNVqyYCJQvyDXDTK+iXdkA71bY7TL3bvuLxLBQ8kbTvTEY9aqkQ3+MiLWbEgjLzOH+lXgco1ERgzd80rDCymlpaRQbOYnKG/ODoFl46lzT0cjM5FYVvv0qLUbD5lyJtMUaC1pFlTkNONx6lliaX9o0i/1vws5bNKn5OuENQEKmLlcP4o2ZmJjD4zzd3Fk32uQ4uRWkPSUqb4LBe3EXHdORNB2BWsws5daRnMfNVX7isPSb1hMQdAJi1/qmDMfRUlCU74pmnzjbXfL8PVG8NsW6IQM2Ne23iCPIpryJjYbVnm5hCvKpMa7HLViNiNc+xTfDIaKm3jctViD8A1M9YPJNk003VVr4Zo2MuGW8vil8SLaGpPXqG7I4DLdtl8a4Rbx1Lt4w5Huqaa1XzZBtj208EJVGcmKYEuaeN27zT9EE6a09JerXdEbpaNgNqYJdhP1NdqiPKsbDRUi86XvvNC7rME5mrSQtrzAZVndtSjCMqd8BmaeGR4l4YFULGRBeXIV9Y4yxLFdyoUNpiy2IhePSWzBofYPP0eIa2q5JP4j9G8at/AqoSsLAUuRXtvgsqX/zYwsE+of6oSDbUOo4RMJw+DOUTJq+hnqwKim9Yy/napyZNTc2rCq6V9jHtJbxGPDwlzWj/Sk3zF/BHOlT/fSjSq7FqlPI1q6J+ru8Aku008SFINXZfOfnZNOvGPMtEmn2gLPt+H4QLA+/SYe4j398auzhKIp2Pok3mPC5q1IN1HgR+mnEfc4NeeHYwd2/kpszR3cBn7ni9NbIqhtSWFW8xbUJuUPVOeeXu3j0IGZmFNiwaNZ6rH4/zQ2ODz6tFxRLsUYZu1bfd1uIvfQDt4YD/efKYv8VF8bHGDgK22w2Wqwpi43vNCOXFJZCGMqWiPbL8mil6tsmOTXAWCyMCw73e2rADZj2IK6rqksM3EXF2cbLb4vjB14wa/yXK5vwU+05MzERJ5nXsXsW21o7M+gO0js2OyKciP5uF2iXyb2DiptwQeHeqygkrNsqVCSlldxBMpwHi1vfc8RKpP/4L3Lmpq6DZcvhDDfxTCE3splacTcOtXdK2g303dIWBVe2wD/Gvja1cClFQ67gw0t1ZUttsUgQ1Veky8oOpS6ksYEc4bqseCbZy766SvL3FodmnahlWJRgVCNjPxhL/fk2wyvlKhITH/VQCipOI0dNcRa5B1M5HmOBjTLeZQJy237e2mobwmDyJNHePhdDmiknvLKaDbShL+Is1XTCJuLQd2wmdJL7+mKvs294whXQD+vtd88KKk0DXP8B1Xu9J+xo69VOuFgexgTrcvI6SyltuLix9OPuE6/iRJYoBMEXxU4shQMf4Fjqwf1PtnJ/wWSZd29rhZjRmTGgiGTAUQqRz+nCdjeMfYhsBD5Lv60KILWEvNEHfmsDs2L0A252351eUoYxAysVaCJVLdH9QFWAmqJDCODUcdoo12+gd6bW2boY0pBVHWL6LQDK5bYWh1V8vFvi0cRpfwv7cJiMX3AZNJuTddHehTIdU0YQ/sQ1dLoF2xQPcCuHKiuCWOY30DHe1OwcClLAhqAKyqlnIbH/8u9ScJpcS4kgp6HKDUdiOgRaRGSiUCRBjzI5gSksMZKqy7Sd51aeg0tgJ+x0TH9YH2Mgsap9N7ENZdEB0bey2DMTrBA1hn56SErNHf3tKtqyL9b6yXEP97/rc+jgD2N1LNUH6RM9AzP3kSipr06RkKOolR7HO768jjWiH1X92jA7dkg7gcNcjqsZCgfqWw0tPXdLg20cF6vnQypg7gLtkazrHAodyYfENPQZsdfnjMZiNu4nJO97D1/sQE+3vNFzrSDOKw+keLECYf7RJwVHeP/j79833oZ0egonYB2FlFE5qj02B/LVOMJQlsB8uNg3Leg4qtZwntsOSNidR0abbZmAK4sCzvt8Yiuz2yrNCJoH5O8XvX/vLeR/BBYTWj0sOPYM/jyxRd5+/JziKAABaPcw/34UA3aj/gLZxZgRCWN6m4m3demanNgsx0P237/Q+Ew5VYnJPkyCY0cIVHoFn2Ay/e7U4P19APbPFXEHX94N6KhEMPG7iwB3+I+O1jd5n6VSgHegxgaSawO6iQCYFgDsPSMsNOcUj4q3sF6KzGaH/0u5PQoAj/8zq6Uc9MoNrGqhYeb2jQo0WlGlXjxtanZLS24/OIN5Gx/2g684BPDQpwlqnkFcxpmP/osnOXrFuu4PqifouQH0eF5qCkvITQbJw/Zvy5mAHWC9oU+cTiYhJmSfKsCyt1cGVxisKu+NymEQIAyaCgud/V09qT3nk/9s/SWsYtha7yNpzBIMM40rCSGaJ9u6lEkl00vXBiEt7p9P5IBCiavynEOv7FgLqPdeqxRiCwuFVMolSIUBcoyfUC2e2FJSAUgYdVGFf0b0Kn2EZlK97yyxrT2MVgvtRikfdaAW8RwEEfN+B7/eK8bBdp7URpbqn1xcrC6d2UjdsKbzCjBFqkKkoZt7Mrhg6YagE7spkqj0jOrWM+UGQ0MUlG2evP1uE1p2xSv4dMK0dna6ENcNUF+xkaJ7B764NdxLCpuvhblltVRAf7vK5qPttJ/9RYFUUSGcLdibnz6mf7WkPO3MkUUhR2mAOuGv8IWw5XG1ZvoVMnjSAZe6T7WYA99GENxoHkMiKxHlCuK5Gd0INrISImHQrQmv6F4mqU/TTQ8nHMDzCRivKySQ8dqkpQgnUMnwIkaAuc6/FGq1hw3b2Sba398BhUwUZSAIO8XZvnuLdY2n6hOXws+gq9BHUKcKFA6kz6FDnpxLPICa3qGhnc97bo1FT/XJk48LrkHJ2CAtBv0RtN97N21plfpXHvZ8gMJb7Zc4cfI6MbPwsW7AilCSXMFIEUEmir8XLEklA0ztYbGpTTGqttp5hpFTTIqUyaAIqvMT9A/x+Ji5ejA4Bhxb/cl1pUdOD6epd3yilIdO6j297xInoiBPuEDW2/UfslDyhGkQs7Wy253bVnlT+SWg89zYIK/9KXFl5fe+jow2rd5FXv8zDPrmfMXiUPt9QBO/iK4QGbX5j/7Rx1c1vzsY8ONbP3lVIaPrhL4+1QrECTN3nyKavGG0gBBtHvTKhGoBHgMXHStFowN+HKrPriYu+OZ05Frn8okQrPaaxoKP1ULCS/cmKFN3gcH7HQlVjraCeQmtjg1pSQxeuqXiSKgLpxc/1OiZsU4+n4lz4hpahGyWBURLi4642n1gn9qz9bIsaCeEPJ0uJmenMWp2tJmIwLQ6VSgDYErOeBCfSj9P4G/vI7oIF+l/n5fp956QgxGvur77ynawAu3G9MdFbJbu49NZnWnnFcQHjxRuhUYvg1U/e84N4JTecciDAKb/KYIFXzloyuE1eYXf54MmhjTq7B/yBToDzzpx3tJCTo3HCmVPYfmtBRe3mPYEE/6RlTIxbf4fSOcaKFGk4gbaUWe44hVk9SZzhW80yfW5QWBHxmtUzvMhfVQli4gZTktIOZd9mjJ5hsbmzttaHQB29Am3dZkmx3g/qvYocyhZ2PXAWsNQiIaf+Q8W/MWPIK7/TjvCx5q2XRp4lVWydMc2wIQkhadDB0xsnw/kSEyGjLKjI4coVIwtubTF3E7MJ6LS6UOsJKj82XVAVPJJcepfewbzE91ivXZvOvYfsmMevwtPpfMzGmC7WJlyW2j0jh7AF1JLmwEJSKYwIvu6DHc3YnyLH9ZdIBnQ+nOVDRiP+REpqv++typYHIvoJyICGA40d8bR7HR2k7do6UQTHF4oriYeIQbxKe4Th6+/l1BjUtS9hqORh3MbgvYrStXTfSwaBOmAVQZzpYNqsAmQyjY56MUqty3c/xH6GuhNvNaG9vGbG6cPtBM8UA3e8r51D0AR9kozKuGGSMgLz3nAHxDNnc7GTwpLj7/6HeWp1iksDeTjwCLpxejuMtpMnGJgsiku1sOACwQ9ukzESiDRN77YNESxR5LphOlcASXA5uIts1LnBIcn1J7BLWs49DMALSnuz95gdOrTZr0u1SeYHinno/pE58xYoXbVO/S+FEMMs5qyWkMnp8Q3ClyTlZP52Y9nq7b8fITPuVXUk9ohG5EFHw4gAEcjFxfKb3xuAsEjx2z1wxNbSZMcgS9GKyW3R6KwJONgtA64LTyxWm8Bvudp0M1FdJPEGopM4Fvg7G/hsptkhCfHFegv4ENwxPeXmYhxwZy7js+BeM27t9ODBMynVCLJ7RWcBMteZJtvjOYHb5lOnCLYWNEMKC59BA7covu1cANa2PXL05iGdufOzkgFqqHBOrgQVUmLEc+Mkz4Rq8O6WkNr7atNkH4M8d+SD1t/tSzt3oFql+neVs+AwEI5JaBJaxARtY2Z4mKoUqxds4UpZ0sv3zIbNoo0J4fihldQTX3XNcuNcZmcrB5LTWMdzeRuAtBk3cZHYQF6gTi3PNuDJ0nmR+4LPLoHvxQIxRgJ9iNNXqf2SYJhcvCtJiVWo85TsyFOuq7EyBPJrAdhEgE0cTq16FQXhYPJFqSfiVn0IQnPOy0LbU4BeG94QjdYNB0CiQ3QaxQqD2ebSMiNjaVaw8WaM4Z5WnzcVDsr4eGweSLa2DE3BWViaxhZFIcSTjgxNCAfelg+hznVOYoe5VqTYs1g7WtfTm3e4/WduC6p+qqAM8H4ZyrJCGpewThTDPe6H7CzX/zQ8Tm+r65HeZn+MsmxUciEWPlAVaK/VBaQBWfoG/aRL/jSZIQfep/89GjasWmbaWzeEZ2R1FOjvyJT37O9B8046SRSKVEnXWlBqbkb5XCS3qFeuE9xb9+frEknxWB5h1D/hruz2iVDEAS7+qkEz5Ot5agHJc7WCdY94Ws61sURcX5nG8UELGBAHZ3i+3VulAyT0nKNNz4K2LBHBWJcTBX1wzf+//u/j/9+//v87+9/l9Lbh/L/uyNYiTsWV2LwsjaA6MxTuzFMqmxW8Jw/+IppdX8t/Clgi1rI1SN0UC/r6tX/4lUc2VV1OQReSeCsjUpKZchw4XUcjHfw6ryCV3R8s6VXm67vp4n+lcPV9gJwmbKQEsmrJi9c2vkwrm8HFbVYNTaRGq8D91t9n5+U+aD/hNtN3HjC/nC/vUoGFSCkXP+NlRcmLUqLbiUBl4LYf1U/CCvwtd3ryCH8gUmGITAxiH1O5rnGTz7y1LuFjmnFGQ1UWuM7HwfXtWl2fPFKklYwNUpF2IL/TmaRETjQiM5SJacI+3Gv5MBU8lP5Io6gWkawpyzNEVGqOdx4YlO1dCvjbWFZWbCmeiFKPSlMKtKcMFLs/KQxtgAHi7NZNCQ32bBAW2mbHflVZ8wXKi1JKVHkW20bnYnl3dKWJeWJOiX3oKPBD6Zbi0ZvSIuWktUHB8qDR8DMMh1ZfkBL9FS9x5r0hBGLJ8pUCJv3NYH+Ae8p40mZWd5m5fhobFjQeQvqTT4VKWIYfRL0tfaXKiVl75hHReuTJEcqVlug+eOIIc4bdIydtn2K0iNZPsYWQvQio2qbO3OqAlPHDDOB7DfjGEfVF51FqqNacd6QmgFKJpMfLp5DHTv4wXlONKVXF9zTJpDV4m1sYZqJPhotcsliZM8yksKkCkzpiXt+EcRQvSQqmBS9WdWkxMTJXPSw94jqI3varCjQxTazjlMH8jTS8ilaW8014/vwA/LNa+YiFoyyx3s/KswP3O8QW1jtq45yTM/DX9a8M4voTVaO2ebvw1EooDw/yg6Y1faY+WwrdVs5Yt0hQ5EwRfYXSFxray1YvSM+kYmlpLG2/9mm1MfmbKHXr44Ih8nVKb1M537ZANUkCtdsPZ80JVKVKabVHCadaLXg+IV8i5GSwpZti0h6diTaKs9sdpUKEpd7jDUpYmHtiX33SKiO3tuydkaxA7pEc9XIQEOfWJlszj5YpL5bKeQyT7aZSBOamvSHl8xsWvgo26IP/bqk+0EJUz+gkkcvlUlyPp2kdKFtt7y5aCdks9ZJJcFp5ZWeaWKgtnXMN3ORwGLBE0PtkEIek5FY2aVssUZHtsWIvnljMVJtuVIjpZup/5VL1yPOHWWHkOMc6YySWMckczD5jUj2mlLVquFaMU8leGVaqeXis+aRRL8zm4WuBk6cyWfGMxgtr8useQEx7k/PvRoZyd9nde1GUCV84gMX8Ogu/BWezYPSR27llzQnA97oo0pYyxobYUJfsj+ysTm9zJ+S4pk0TGo9VTG0KjqYhTmALfoDZVKla2b5yhv241PxFaLJs3i05K0AAIdcGxCJZmT3ZdT7CliR7q+kur7WdQjygYtOWRL9B8E4s4LI8KpAj7bE0dg7DLOaX+MGeAi0hMMSSWZEz+RudXbZCsGYS0QqiXjH9XQbd8sCB+nIVTq7/T/FDS+zWY9q7Z2fdq1tdLb6v3hKKVDAw5gjj6o9r1wHFROdHc18MJp4SJ2Ucvu+iQ9EgkekW8VCM+psM6y+/2SBy8tNN4a3L1MzP+OLsyvESo5gS7IQOnIqMmviJBVc6zbVG1n8eXiA3j46kmvvtJlewwNDrxk4SbJOtP/TV/lIVK9ueShNbbMHfwnLTLLhbZuO79ec5XvfgRwLFK+w1r5ZWW15rVFZrE+wKqNRv5KqsLNfpGgnoUU6Y71NxEmN7MyqwqAQqoIULOw/LbuUB2+uE75gJt+kq1qY4LoxV+qR/zalupea3D5+WMeaRIn0sAI6DDWDh158fqUb4YhAxhREbUN0qyyJYkBU4V2KARXDT65gW3gRsiv7xSPYEKLwzgriWcWgPr0sbZnv7m1XHNFW6xPdGNZUdxFiUYlmXNjDVWuu7LCkX/nVkrXaJhiYktBISC2xgBXQnNEP+cptWl1eG62a7CPXrnrkTQ5BQASbEqUZWMDiZUisKyHDeLFOaJILUo5f6iDt4ZO8MlqaKLto0AmTHVVbkGuyPa1R/ywZsWRoRDoRdNMMHwYTsklMVnlAd2S0282bgMI8fiJpDh69OSL6K3qbo20KfpNMurnYGQSr/stFqZ7hYsxKlLnKAKhsmB8AIpEQ4bd/NrTLTXefsE6ChRmKWjXKVgpGoPs8GAicgKVw4K0qgDgy1A6hFq1WRat3fHF+FkU+b6H4NWpOU3KXTxrIb2qSHAb+qhm8hiSROi/9ofapjxhyKxxntPpge6KL5Z4+WBMYkAcE6+0Hd3Yh2zBsK2MV3iW0Y6cvOCroXlRb2MMJtdWx+3dkFzGh2Pe3DZ9QpSqpaR/rE1ImOrHqYYyccpiLC22amJIjRWVAherTfpQLmo6/K2pna85GrDuQPlH1Tsar8isAJbXLafSwOof4gg9RkAGm/oYpBQQiPUoyDk2BCQ1k+KILq48ErFo4WSRhHLq/y7mgw3+L85PpP6xWr6cgp9sOjYjKagOrxF148uhuaWtjet953fh1IQiEzgC+d2IgBCcUZqgTAICm2bR8oCjDLBsmg+ThyhfD+zBalsKBY1Ce54Y/t9cwfbLu9SFwEgphfopNA3yNxgyDafUM3mYTovZNgPGdd4ZFFOj1vtfFW3u7N+iHEN1HkeesDMXKPyoCDCGVMo4GCCD6PBhQ3dRZIHy0Y/3MaE5zU9mTCrwwnZojtE+qNpMSkJSpmGe0EzLyFelMJqhfFQ7a50uXxZ8pCc2wxtAKWgHoeamR2O7R+bq7IbPYItO0esdRgoTaY38hZLJ5y02oIVwoPokGIzxAMDuanQ1vn2WDQ00Rh6o5QOaCRu99fwDbQcN0XAuqkFpxT/cfz3slGRVokrNU0iqiMAJFEbKScZdmSkTUznC0U+MfwFOGdLgsewRyPKwBZYSmy6U325iUhBQNxbAC3FLKDV9VSOuQpOOukJ/GAmu/tyEbX9DgEp6dv1zoU0IqzpG6gssSjIYRVPGgU1QAQYRgIT8gEV0EXr1sqeh2I6rXjtmoCYyEDCe/PkFEi/Q48FuT29p557iN+LCwk5CK/CZ2WdAdfQZh2Z9QGrzPLSNRj5igUWzl9Vi0rCqH8G1Kp4QMLkuwMCAypdviDXyOIk0AHTM8HBYKh3b0/F+DxoNj4ZdoZfCpQVdnZarqoMaHWnMLNVcyevytGsrXQEoIbubqWYNo7NRHzdc0zvT21fWVirj7g36iy6pxogfvgHp1xH1Turbz8QyyHnXeBJicpYUctbzApwzZ1HT+FPEXMAgUZetgeGMwt4G+DHiDT2Lu+PT21fjJCAfV16a/Wu1PqOkUHSTKYhWW6PhhHUlNtWzFnA7MbY+r64vkwdpfNB2JfWgWXAvkzd42K4lN9x7Wrg4kIKgXCb4mcW595MCPJ/cTfPAMQMFWwnqwde4w8HZYJFpQwcSMhjVz4B8p6ncSCN1X4klxoIH4BN2J6taBMj6lHkAOs8JJAmXq5xsQtrPIPIIp/HG6i21xMGcFgqDXSRF0xQg14d2uy6HgKE13LSvQe52oShF5Jx1R6avyL4thhXQZHfC94oZzuPUBKFYf1VvDaxIrtV6dNGSx7DO0i1p6CzBkuAmEqyWceQY7F9+U0ObYDzoa1iKao/cOD/v6Q9gHrrr1uCeOk8fST9MG23Ul0KmM3r+Wn6Hi6WAcL7gEeaykicvgjzkjSwFsAXIR81Zx4QJ6oosVyJkCcT+4xAldCcihqvTf94HHUPXYp3REIaR4dhpQF6+FK1H0i9i7Pvh8owu3lO4PT1iuqu+DkL2Bj9+kdfGAg2TXw03iNHyobxofLE2ibjsYDPgeEQlRMR7afXbSGQcnPjI2D+sdtmuQ771dbASUsDndU7t58jrrNGRzISvwioAlHs5FA+cBE5Ccznkd8NMV6BR6ksnKLPZnMUawRDU1MZ/ib3xCdkTblHKu4blNiylH5n213yM0zubEie0o4JhzcfAy3H5qh2l17uLooBNLaO+gzonTH2uF8PQu9EyH+pjGsACTMy4cHzsPdymUSXYJOMP3yTkXqvO/lpvt0cX5ekDEu9PUfBeZODkFuAjXCaGdi6ew4qxJ8PmFfwmPpkgQjQlWqomFY6UkjmcnAtJG75EVR+NpzGpP1Ef5qUUbfowrC3zcSLX3BxgWEgEx/v9cP8H8u1Mvt9/rMDYf6sjwU1xSOPBgzFEeJLMRVFtKo5QHsUYT8ZRLCah27599EuqoC9PYjYO6aoAMHB8X1OHwEAYouHfHB3nyb2B+SnZxM/vw/bCtORjLMSy5aZoEpvgdGvlJfNPFUu/p7Z4VVK1hiI0/UTuB3ZPq4ohEbm7Mntgc1evEtknaosgZSwnDC2BdMmibpeg48X8Ixl+/8+xXdbshQXUPPvx8jT3fkELivHSmqbhblfNFShWAyQnJ3WBU6SMYSIpTDmHjdLVAdlADdz9gCplZw6mTiHqDwIsxbm9ErGusiVpg2w8Q3khKV/R9Oj8PFeF43hmW/nSd99nZzhyjCX3QOZkkB6BsH4H866WGyv9E0hVAzPYah2tkRfQZMmP2rinfOeQalge0ovhduBjJs9a1GBwReerceify49ctOh5/65ATYuMsAkVltmvTLBk4oHpdl6i+p8DoNj4Fb2vhdFYer2JSEilEwPd5n5zNoGBXEjreg/wh2NFnNRaIUHSOXa4eJRwygZoX6vnWnqVdCRT1ARxeFrNBJ+tsdooMwqnYhE7zIxnD8pZH+P0Nu1wWxCPTADfNWmqx626IBJJq6NeapcGeOmbtXvl0TeWG0Y7OGGV4+EHTtNBIT5Wd0Bujl7inXgZgfXTM5efD3qDTJ54O9v3Bkv+tdIRlq1kXcVD0BEMirmFxglNPt5pedb1AnxuCYMChUykwsTIWqT23XDpvTiKEru1cTcEMeniB+HQDehxPXNmkotFdwUPnilB/u4Nx5Xc6l8J9jH1EgKZUUt8t8cyoZleDBEt8oibDmJRAoMKJ5Oe9CSWS5ZMEJvacsGVdXDWjp/Ype5x0p9PXB2PAwt2LRD3d+ftNgpuyvxlP8pB84oB1i73vAVpwyrmXW72hfW6Dzn9Jkj4++0VQ4d0KSx1AsDA4OtXXDo63/w+GD+zC7w5SJaxsmnlYRQ4dgdjA7tTl2KNLnpJ+mvkoDxtt1a4oPaX3EVqj96o9sRKBQqU7ZOiupeAIyLMD+Y3YwHx30XWHB5CQiw7q3mj1EDlP2eBsZbz79ayUMbyHQ7s8gu4Lgip1LiGJj7NQj905/+rgUYKAA5qdrlHKIknWmqfuR+PB8RdBkDg/NgnlT89G72h2NvySnj7UyBwD+mi/IWs1xWbxuVwUIVXun5cMqBtFbrccI+DILjsVQg6eeq0itiRfedn89CvyFtpkxaauEvSANuZmB1p8FGPbU94J9medwsZ9HkUYjmI7OH5HuxendLbxTaYrPuIfE2ffXFKhoNBUp33HsFAXmCV/Vxpq5AYgFoRr5Ay93ZLRlgaIPjhZjXZZChT+aE5iWAXMX0oSFQEtwjiuhQQItTQX5IYrKfKB+queTNplR1Hoflo5/I6aPPmACwQCE2jTOYo5Dz1cs7Sod0KTG/3kEDGk3kUaUCON19xSJCab3kNpWZhSWkO8l+SpW70Wn3g0ciOIJO5JXma6dbos6jyisuxXwUUhj2+1uGhcvuliKtWwsUTw4gi1c/diEEpZHoKoxTBeMDmhPhKTx7TXWRakV8imJR355DcIHkR9IREHxohP4TbyR5LtFU24umRPRmEYHbpe1LghyxPx7YgUHjNbbQFRQhh4KeU1EabXx8FS3JAxp2rwRDoeWkJgWRUSKw6gGP5U2PuO9V4ZuiKXGGzFQuRuf+tkSSsbBtRJKhCi3ENuLlXhPbjTKD4djXVnfXFds6Zb+1XiUrRfyayGxJq1+SYBEfbKlgjiSmk0orgTqzSS+DZ5rTqsJbttiNtp+KMqGE2AHGFw6jQqM5vD6vMptmXV9OAjq49Uf/Lx9Opam+Hn5O9p8qoBBAQixzQZ4eNVkO9sPzJAMyR1y4/RCQQ1s0pV5KAU5sKLw3tkcFbI/JqrjCsK4Mw+W8aod4lioYuawUiCyVWBE/qPaFi5bnkgpfu/ae47174rI1fqQoTbW0HrU6FAejq7ByM0V4zkZTg02/YJK2N7hUQRCeZ4BIgSEqgD8XsjzG6LIsSbuHoIdz/LhFzbNn1clci1NHWJ0/6/O8HJMdIpEZbqi1RrrFfoo/rI/7ufm2MPG5lUI0IYJ4MAiHRTSOFJ2oTverFHYXThkYFIoyFx6rMYFgaOKM4xNWdlOnIcKb/suptptgTOTdVIf4YgdaAjJnIAm4qNNHNQqqAzvi53GkyRCEoseUBrHohZsjUbkR8gfKtc/+Oa72lwxJ8Mq6HDfDATbfbJhzeIuFQJSiw1uZprHlzUf90WgqG76zO0eCB1WdPv1IT6sNxxh91GEL2YpgC97ikFHyoaH92ndwduqZ6IYjkg20DX33MWdoZk7QkcKUCgisIYslOaaLyvIIqRKWQj16jE1DlQWJJaPopWTJjXfixEjRJJo8g4++wuQjbq+WVYjsqCuNIQW3YjnxKe2M5ZKEqq+cX7ZVgnkbsU3RWIyXA1rxv4kGersYJjD//auldXGmcEbcfTeF16Y1708FB1HIfmWv6dSFi6oD4E+RIjCsEZ+kY7dKnwReJJw3xCjKvi3kGN42rvyhUlIz0Bp+fNSV5xwFiuBzG296e5s/oHoFtUyUplmPulIPl+e1CQIQVtjlzLzzzbV+D/OVQtYzo5ixtMi5BmHuG4N/uKfJk5UIREp7+12oZlKtPBomXSzAY0KgtbPzzZoHQxujnREUgBU+O/jKKhgxVhRPtbqyHiUaRwRpHv7pgRPyUrnE7fYkVblGmfTY28tFCvlILC04Tz3ivkNWVazA+OsYrxvRM/hiNn8Fc4bQBeUZABGx5S/xFf9Lbbmk298X7iFg2yeimvsQqqJ+hYbt6uq+Zf9jC+Jcwiccd61NKQtFvGWrgJiHB5lwi6fR8KzYS7EaEHf/ka9EC7H8D+WEa3TEACHBkNSj/cXxFeq4RllC+fUFm2xtstYLL2nos1DfzsC9vqDDdRVcPA3Ho95aEQHvExVThXPqym65llkKlfRXbPTRiDepdylHjmV9YTWAEjlD9DdQnCem7Aj/ml58On366392214B5zrmQz/9ySG2mFqEwjq5sFl5tYJPw5hNz8lyZPUTsr5E0F2C9VMPnZckWP7+mbwp/BiN7f4kf7vtGnZF2JGvjK/sDX1RtcFY5oPQnE4lIAYV49U3C9SP0LCY/9i/WIFK9ORjzM9kG/KGrAuwFmgdEpdLaiqQNpCTGZVuAO65afkY1h33hrqyLjZy92JK3/twdj9pafFcwfXONmPQWldPlMe7jlP24Js0v9m8bIJ9TgS2IuRvE9ZVRaCwSJYOtAfL5H/YS4FfzKWKbek+GFulheyKtDNlBtrdmr+KU+ibHTdalzFUmMfxw3f36x+3cQbJLItSilW9cuvZEMjKw987jykZRlsH/UI+HlKfo2tLwemBEeBFtmxF2xmItA/dAIfQ+rXnm88dqvXa+GapOYVt/2waFimXFx3TC2MUiOi5/Ml+3rj/YU6Ihx2hXgiDXFsUeQkRAD6wF3SCPi2flk7XwKAA4zboqynuELD312EJ88lmDEVOMa1W/K/a8tGylZRMrMoILyoMQzzbDJHNZrhH77L9qSC42HVmKiZ5S0016UTp83gOhCwz9XItK9fgXfK3F5d7nZCBUekoLxrutQaPHa16Rjsa0gTrzyjqTnmcIcrxg6X6dkKiucudc0DD5W4pJPf0vuDW8r5/uw24YfMuxFRpD2ovT2mFX79xH6Jf+MVdv2TYqR6/955QgVPe3JCD/WjAYcLA9tpXgFiEjge2J5ljeI/iUzg91KQuHkII4mmHZxC3XQORLAC6G7uFn5LOmlnXkjFdoO976moNTxElS8HdxWoPAkjjocDR136m2l+f5t6xaaNgdodOvTu0rievnhNAB79WNrVs6EsPgkgfahF9gSFzzAd+rJSraw5Mllit7vUP5YxA843lUpu6/5jAR0RvH4rRXkSg3nE+O5GFyfe+L0s5r3k05FyghSFnKo4TTgs07qj4nTLqOYj6qaW9knJTDkF5OFMYbmCP+8H16Ty482OjvERV6OFyw043L9w3hoJi408sR+SGo1WviXUu8d7qS+ehKjpKwxeCthsm2LBFSFeetx0x4AaKPxtp3CxdWqCsLrB1s/j5TAhc1jNZsXWl6tjo/WDoewxzg8T8NnhZ1niUwL/nhfygLanCnRwaFGDyLw+sfZhyZ1UtYTp8TYB6dE7R3VsKKH95CUxJ8u8N+9u2/9HUNKHW3x3w5GQrfOPafk2w5qZq8MaHT0ebeY3wIsp3rN9lrpIsW9c1ws3VNV+JwNz0Lo9+V7zZr6GD56We6gWVIvtmam5GPPkVAbr74r6SwhuL+TRXtW/0pgyX16VNl4/EAD50TnUPuwrW6OcUO2VlWXS0inq872kk7GUlW6o/ozFKq+Sip6LcTtSDfDrPTcCHhx75H8BeRon+KG2wRwzfDgWhALmiWOMO6h3pm1UCZEPEjScyk7tdLx6WrdA2N1QTPENvNnhCQjW6kl057/qv7IwRryHrZBCwVSbLLnFRiHdTwk8mlYixFt1slEcPD7FVht13HyqVeyD55HOXrh2ElAxJyinGeoFzwKA91zfrdLvDxJSjzmImfvTisreI25EDcVfGsmxLVbfU8PGe/7NmWWKjXcdTJ11jAlVIY/Bv/mcxg/Q10vCHwKG1GW/XbJq5nxDhyLqiorn7Wd7VEVL8UgVzpHMjQ+Z8DUgSukiVwWAKkeTlVVeZ7t1DGnCgJVIdBPZAEK5f8CDyDNo7tK4/5DBjdD5MPV86TaEhGsLVFPQSI68KlBYy84FievdU9gWh6XZrugvtCZmi9vfd6db6V7FmoEcRHnG36VZH8N4aZaldq9zZawt1uBFgxYYx+Gs/qW1jwANeFy+LCoymyM6zgG7j8bGzUyLhvrbJkTYAEdICEb4kMKusKT9V3eIwMLsjdUdgijMc+7iKrr+TxrVWG0U+W95SGrxnxGrE4eaJFfgvAjUM4SAy8UaRwE9j6ZQH5qYAWGtXByvDiLSDfOD0yFA3UCMKSyQ30fyy1mIRg4ZcgZHLNHWl+c9SeijOvbOJxoQy7lTN2r3Y8p6ovxvUY74aOYbuVezryqXA6U+fcp6wSV9X5/OZKP18tB56Ua0gMyxJI7XyNT7IrqN8GsB9rL/kP5KMrjXxgqKLDa+V5OCH6a5hmOWemMUsea9vQl9t5Oce76PrTyTv50ExOqngE3PHPfSL//AItPdB7kGnyTRhVUUFNdJJ2z7RtktZwgmQzhBG/G7QsjZmJfCE7k75EmdIKH7xlnmDrNM/XbTT6FzldcH/rcRGxlPrv4qDScqE7JSmQABJWqRT/TUcJSwoQM+1jvDigvrjjH8oeK2in1S+/yO1j8xAws/T5u0VnIvAPqaE1atNuN0cuRliLcH2j0nTL4JpcR7w9Qya0JoaHgsOiALLCCzRkl1UUESz+ze/gIXHGtDwgYrK6pCFKJ1webSDog4zTlPkgXZqxlQDiYMjhDpwTtBW2WxthWbov9dt2X9XFLFmcF+eEc1UaQ74gqZiZsdj63pH1qcv3Vy8JYciogIVKsJ8Yy3J9w/GhjWVSQAmrS0BPOWK+RKV+0lWqXgYMnIFwpcZVD7zPSp547i9HlflB8gVnSTGmmq1ClO081OW/UH11pEQMfkEdDFzjLC1Cdo/BdL3s7cXb8J++Hzz1rhOUVZFIPehRiZ8VYu6+7Er7j5PSZu9g/GBdmNzJmyCD9wiswj9BZw+T3iBrg81re36ihMLjoVLoWc+62a1U/7qVX5CpvTVF7rocSAKwv4cBVqZm7lLDS/qoXs4fMs/VQi6BtVbNA3uSzKpQfjH1o3x4LrvkOn40zhm6hjduDglzJUwA0POabgdXIndp9fzhOo23Pe+Rk9GSLX0d71Poqry8NQDTzNlsa+JTNG9+UrEf+ngxCjGEsDCc0bz+udVRyHQI1jmEO3S+IOQycEq7XwB6z3wfMfa73m8PVRp+iOgtZfeSBl01xn03vMaQJkyj7vnhGCklsCWVRUl4y+5oNUzQ63B2dbjDF3vikd/3RUMifPYnX5Glfuk2FsV/7RqjI9yKTbE8wJY+74p7qXO8+dIYgjtLD/N8TJtRh04N9tXJA4H59IkMmLElgvr0Q5OCeVfdAt+5hkh4pQgfRMHpL74XatLQpPiOyHRs/OdmHtBf8nOZcxVKzdGclIN16lE7kJ+pVMjspOI+5+TqLRO6m0ZpNXJoZRv9MPDRcAfJUtNZHyig/s2wwReakFgPPJwCQmu1I30/tcBbji+Na53i1W1N+BqoY7Zxo+U/M9XyJ4Ok2SSkBtoOrwuhAY3a03Eu6l8wFdIG1cN+e8hopTkiKF093KuH/BcB39rMiGDLn6XVhGKEaaT/vqb/lufuAdpGExevF1+J9itkFhCfymWr9vGb3BTK4j598zRH7+e+MU9maruZqb0pkGxRDRE1CD4Z8LV4vhgPidk5w2Bq816g3nHw1//j3JStz7NR9HIWELO8TMn3QrP/zZp//+Dv9p429/ogv+GATR+n/UdF+ns9xNkXZQJXY4t9jMkJNUFygAtzndXwjss+yWH9HAnLQQfhAskdZS2l01HLWv7L7us5uTH409pqitvfSOQg/c+Zt7k879P3K9+WV68n7+3cZfuRd/dDPP/03rn+d+/nBvWfgDlt8+LzjqJ/vx3CnNOwiXhho778C96iD+1TBvRZYeP+EH81LE0vVwOOrmCLB3iKzI1x+vJEsrPH4uF0UB4TJ4X3uDfOCo3PYpYe0MF4bouh0DQ/l43fxUF7Y+dpWuvTSffB0yO2UQUETI/LwCZE3BvnevJ7c9zUlY3H58xzke6DNFDQG8n0WtDN4LAYN4nogKav1ezOfK/z+t6tsCTp+dhx4ymjWuCJk1dEUifDP+HyS4iP/Vg9B2jTo9L4NbiBuDS4nuuHW6H+JDQn2JtqRKGkEQPEYE7uzazXIkcxIAqUq1esasZBETlEZY7y7Jo+RoV/IsjY9eIMkUvr42Hc0xqtsavZvhz1OLwSxMOTuqzlhb0WbdOwBH9EYiyBjatz40bUxTHbiWxqJ0uma19qhPruvcWJlbiSSH48OLDDpaHPszvyct41ZfTu10+vjox6kOqK6v0K/gEPphEvMl/vwSv+A4Hhm36JSP9IXTyCZDm4kKsqD5ay8b1Sad/vaiyO5N/sDfEV6Z4q95E+yfjxpqBoBETW2C7xl4pIO2bDODDFurUPwE7EWC2Uplq+AHmBHvir2PSgkR12/Ry65O0aZtQPeXi9mTlF/Wj5GQ+vFkYyhXsLTjrBSP9hwk4GPqDP5rBn5/l8b0mLRAvRSzXHc293bs3s8EsdE3m2exxidWVB4joHR+S+dz5/W+v00K3TqN14CDBth8eWcsTbiwXPsygHdGid0PEdy6HHm2v/IUuV5RVapYmzGsX90mpnIdNGcOOq64Dbc5GUbYpD9M7S+6cLY//QmjxFLP5cuTFRm3vA5rkFZroFnO3bjHF35uU3s8mvL7Tp9nyTc4mymTJ5sLIp7umSnGkO23faehtz3mmTS7fbVx5rP7x3HXIjRNeq/A3xCs9JNB08c9S9BF2O3bOur0ItslFxXgRPdaapBIi4dRpKGxVz7ir69t/bc9qTxjvtOyGOfiLGDhR4fYywHv1WdOplxIV87TpLBy3Wc0QP0P9s4G7FBNOdITS/tep3o3h1TEa5XDDii7fWtqRzUEReP2fbxz7bHWWJdbIOxOUJZtItNZpTFRfj6vm9sYjRxQVO+WTdiOhdPeTJ+8YirPvoeL88l5iLYOHd3b/Imkq+1ZN1El3UikhftuteEYxf1Wujof8Pr4ICTu5ezZyZ4tHQMxlzUHLYO2VMOoNMGL/20S5i2o2obfk+8qqdR7xzbRDbgU0lnuIgz4LelQ5XS7xbLuSQtNS95v3ZUOdaUx/Qd8qxCt6xf2E62yb/HukLO6RyorV8KgYl5YNc75y+KvefrxY+lc/64y9kvWP0a0bDz/rojq+RWjO06WeruWqNFU7r3HPIcLWRql8ICZsz2Ls/qOm/CLn6++X+Qf7mGspYCrZod/lpl6Rw4xN/yuq8gqV4B6aHk1hVE1SfILxWu5gvXqbfARYQpspcxKp1F/c8XOPzkZvmoSw+vEqBLdrq1fr3wAPv5NnM9i8F+jdAuxkP5Z71c6uhK3enlnGymr7UsWZKC12qgUiG8XXGQ9mxnqz4GSIlybF9eXmbqj2sHX+a1jf0gRoONHRdRSrIq03Ty89eQ1GbV/Bk+du4+V15zls+vvERvZ4E7ZbnxWTVjDjb4o/k8jlw44pTIrUGxxuJvBeO+heuhOjpFsO6lVJ/aXnJDa/bM0Ql1cLbXE/Pbv3EZ3vj3iVrB5irjupZTzlnv677NrI9UNYNqbPgp/HZXS+lJmk87wec+7YOxTDo2aw2l3NfDr34VNlvqWJBknuK7oSlZ6/T10zuOoPZOeoIk81N+sL843WJ2Q4Z0fZ3scsqC/JV2fuhWi1jGURSKZV637lf53Xnnx16/vKEXY89aVJ0fv91jGdfG+G4+sniwHes4hS+udOr4RfhFhG/F5gUG35QaU+McuLmclb5ZWmR+sG5V6nf+PxYzlrnFGxpZaK8eqqVo0NfmAWoGfXDiT/FnUbWvzGDOTr8aktOZWg4BYvz5YH12ZbfCcGtNk+dDAZNGWvHov+PIOnY9Prjg8h/wLRrT69suaMVZ5bNuK00lSVpnqSX1NON/81FoP92rYndionwgOiA8WMf4vc8l15KqEEG4yAm2+WAN5Brfu1sq9suWYqgoajgOYt/JCk1gC8wPkK+XKCtRX6TAtgvrnuBgNRmn6I8lVDipOVB9kX6Oxkp4ZKyd1M6Gj8/v2U7k+YQBL95Kb9PQENucJb0JlW3b5tObN7m/Z1j1ev388d7o15zgXsI9CikAGAViR6lkJv7nb4Ak40M2G8TJ447kN+pvfHiOFjSUSP6PM+QfbAywKJCBaxSVxpizHseZUyUBhq59vFwrkyGoRiHbo0apweEZeSLuNiQ+HAekOnarFg00dZNXaPeoHPTRR0FmEyqYExOVaaaO8c0uFUh7U4e/UxdBmthlBDgg257Q33j1hA7HTxSeTTSuVnPZbgW1nodwmG16aKBDKxEetv7D9OjO0JhrbJTnoe+kcGoDJazFSO8/fUN9Jy/g4XK5PUkw2dgPDGpJqBfhe7GA+cjzfE/EGsMM+FV9nj9IAhrSfT/J3QE5TEIYyk5UjsI6ZZcCPr6A8FZUF4g9nnpVmjX90MLSQysIPD0nFzqwCcSJmIb5mYv2Cmk+C1MDFkZQyCBq4c/Yai9LJ6xYkGS/x2s5/frIW2vmG2Wrv0APpCdgCA9snFvfpe8uc0OwdRs4G9973PGEBnQB5qKrCQ6m6X/H7NInZ7y/1674/ZXOVp7OeuCRk8JFS516VHrnH1HkIUIlTIljjHaQtEtkJtosYul77cVwjk3gW1Ajaa6zWeyHGLlpk3VHE2VFzT2yI/EvlGUSz2H9zYE1s4nsKMtMqNyKNtL/59CpFJki5Fou6VXGm8vWATEPwrUVOLvoA8jLuwOzVBCgHB2Cr5V6OwEWtJEKokJkfc87h+sNHTvMb0KVTp5284QTPupoWvQVUwUeogZR3kBMESYo0mfukewRVPKh5+rzLQb7HKjFFIgWhj1w3yN/qCNoPI8XFiUgBNT1hCHBsAz8L7Oyt8wQWUFj92ONn/APyJFg8hzueqoJdNj57ROrFbffuS/XxrSXLTRgj5uxZjpgQYceeMc2wJrahReSKpm3QjHfqExTLAB2ipVumE8pqcZv8LYXQiPHHsgb5BMW8zM5pvQit+mQx8XGaVDcfVbLyMTlY8xcfmm/RSAT/H09UQol5gIz7rESDmnrQ4bURIB4iRXMDQwxgex1GgtDxKp2HayIkR+E/aDmCttNm2C6lytWdfOVzD6X2SpDWjQDlMRvAp1symWv4my1bPCD+E1EmGnMGWhNwmycJnDV2WrQNxO45ukEb08AAffizYKVULp15I4vbNK5DzWwCSUADfmKhfGSUqii1L2UsE8rB7mLuHuUJZOx4+WiizHBJ/hwboaBzhpNOVvgFTf5cJsHef7L1HCI9dOUUbb+YxUJWn6dYOLz+THi91kzY5dtO5c+grX7v0jEbsuoOGnoIreDIg/sFMyG+TyCLIcAWd1IZ1UNFxE8Uie13ucm40U2fcxC0u3WLvLOxwu+F7MWUsHsdtFQZ7W+nlfCASiAKyh8rnP3EyDByvtJb6Kax6/HkLzT9SyEyTMVM1zPtM0MJY14DmsWh4MgD15Ea9Hd00AdkTZ0EiG5NAGuIBzQJJ0JR0na+OB7lQA6UKxMfihIQ7GCCnVz694QvykWXTxpS2soDu+smru1UdIxSvAszBFD1c8c6ZOobA8bJiJIvuycgIXBQIXWwhyTgZDQxJTRXgEwRNAawGSXO0a1DKjdihLVNp/taE/xYhsgwe+VpKEEB4LlraQyE84gEihxCnbfoyOuJIEXy2FIYw+JjRusybKlU2g/vhTSGTydvCvXhYBdtAXtS2v7LkHtmXh/8fly1do8FI/D0f8UbzVb5h+KRhMGSAmR2mhi0YG/uj7wgxcfzCrMvdjitUIpXDX8ae2JcF/36qUWIMwN6JsjaRGNj+jEteGDcFyTUb8X/NHSucKMJp7pduxtD6KuxVlyxxwaeiC1FbGBESO84lbyrAugYxdl+2N8/6AgWpo/IeoAOcsG35IA/b3AuSyoa55L7llBLlaWlEWvuCFd8f8NfcTUgzJv6CbB+6ohWwodlk9nGWFpBAOaz5uEW5xBvmjnHFeDsb0mXwayj3mdYq5gxxNf3H3/tnCgHwjSrpSgVxLmiTtuszdRUFIsn6LiMPjL808vL1uQhDbM7aA43mISXReqjSskynIRcHCJ9qeFopJfx9tqyUoGbSwJex/0aDE3plBPGtNBYgWbdLom3+Q/bjdizR2/AS/c/dH/d3G7pyl1qDXgtOFtEqidwLqxPYtrNEveasWq3vPUUtqTeu8gpov4bdOQRI2kneFvRNMrShyVeEupK1PoLDPMSfWMIJcs267mGB8X9CehQCF0gIyhpP10mbyM7lwW1e6TGvHBV1sg/UyTghHPGRqMyaebC6pbB1WKNCQtlai1GGvmq9zUKaUzLaXsXEBYtHxmFbEZ2kJhR164LhWW2Tlp1dhsGE7ZgIWRBOx3Zcu2DxgH+G83WTPceKG0TgQKKiiNNOlWgvqNEbnrk6fVD+AqRam2OguZb0YWSTX88N+i/ELSxbaUUpPx4vJUzYg/WonSeA8xUK6u7DPHgpqWpEe6D4cXg5uK9FIYVba47V/nb+wyOtk+zG8RrS4EA0ouwa04iByRLSvoJA2FzaobbZtXnq8GdbfqEp5I2dpfpj59TCVif6+E75p665faiX8gS213RqBxTZqfHP46nF6NSenOneuT+vgbLUbdTH2/t0REFXZJOEB6DHvx6N6g9956CYrY/AYcm9gELJXYkrSi+0F0geKDZgOCIYkLU/+GOW5aGj8mvLFgtFH5+XC8hvAE3CvHRfl4ofM/Qwk4x2A+R+nyc9gNu/9Tem7XW4XRnyRymf52z09cTOdr+PG6+P/Vb4QiXlwauc5WB1z3o+IJjlbxI8MyWtSzT+k4sKVbhF3xa+vDts3NxXa87iiu+xRH9cAprnOL2h6vV54iQRXuOAj1s8nLFK8gZ70ThIQcWdF19/2xaJmT0efrkNDkWbpAQPdo92Z8+Hn/aLjbOzB9AI/k12fPs9HhUNDJ1u6ax2VxD3R6PywN7BrLJ26z6s3QoMp76qzzwetrDABKSGkfW5PwS1GvYNUbK6uRqxfyVGNyFB0E+OugMM8kKwmJmupuRWO8XkXXXQECyRVw9UyIrtCtcc4oNqXqr7AURBmKn6Khz3eBN96LwIJrAGP9mr/59uTOSx631suyT+QujDd4beUFpZ0kJEEnjlP+X/Kr2kCKhnENTg4BsMTOmMqlj2WMFLRUlVG0fzdCBgUta9odrJfpVdFomTi6ak0tFjXTcdqqvWBAzjY6hVrH9sbt3Z9gn+AVDpTcQImefbB4edirjzrsNievve4ZT4EUZWV3TxEsIW+9MT/RJoKfZZYSRGfC1CwPG/9rdMOM8qR/LUYvw5f/emUSoD7YSFuOoqchdUg2UePd1eCtFSKgxLSZ764oy4lvRCIH6bowPxZWwxNFctksLeil47pfevcBipkkBIc4ngZG+kxGZ71a72KQ7VaZ6MZOZkQJZXM6kb/Ac0/XkJx8dvyfJcWbI3zONEaEPIW8GbkYjsZcwy+eMoKrYjDmvEEixHzkCSCRPRzhOfJZuLdcbx19EL23MA8rnjTZZ787FGMnkqnpuzB5/90w1gtUSRaWcb0eta8198VEeZMUSfIhyuc4/nywFQ9uqn7jdqXh+5wwv+RK9XouNPbYdoEelNGo34KyySwigsrfCe0v/PlWPvQvQg8R0KgHO18mTVThhQrlbEQ0Kp/JxPdjHyR7E1QPw/ut0r+HDDG7BwZFm9IqEUZRpv2WpzlMkOemeLcAt5CsrzskLGaVOAxyySzZV/D2EY7ydNZMf8e8VhHcKGHAWNszf1EOq8fNstijMY4JXyATwTdncFFqcNDfDo+mWFvxJJpc4sEZtjXyBdoFcxbUmniCoKq5jydUHNjYJxMqN1KzYV62MugcELVhS3Bnd+TLLOh7dws/zSXWzxEb4Nj4aFun5x4kDWLK5TUF/yCXB/cZYvI9kPgVsG2jShtXkxfgT+xzjJofXqPEnIXIQ1lnIdmVzBOM90EXvJUW6a0nZ/7XjJGl8ToO3H/fdxnxmTNKBZxnkpXLVgLXCZywGT3YyS75w/PAH5I/jMuRspej8xZObU9kREbRA+kqjmKRFaKGWAmFQspC+QLbKPf0RaK3OXvBSWqo46p70ws/eZpu6jCtZUgQy6r4tHMPUdAgWGGUYNbuv/1a6K+MVFsd3T183+T8capSo6m0+Sh57fEeG/95dykGJBQMj09DSW2bY0mUonDy9a8trLnnL5B5LW3Nl8rJZNysO8Zb+80zXxqUGFpud3Qzwb7bf+8mq6x0TAnJU9pDQR9YQmZhlna2xuxJt0aCO/f1SU8gblOrbIyMsxTlVUW69VJPzYU2HlRXcqE2lLLxnObZuz2tT9CivfTAUYfmzJlt/lOPgsR6VN64/xQd4Jlk/RV7UKVv2Gx/AWsmTAuCWKhdwC+4HmKEKYZh2Xis4KsUR1BeObs1c13wqFRnocdmuheaTV30gvVXZcouzHKK5zwrN52jXJEuX6dGx3BCpV/++4f3hyaW/cQJLFKqasjsMuO3B3WlMq2gyYfdK1e7L2pO/tRye2mwzwZPfdUMrl5wdLqdd2Kv/wVtnpyWYhd49L6rsOV+8HXPrWH2Kup89l2tz6bf80iYSd+V4LROSOHeamvexR524q4r43rTmtFzQvArpvWfLYFZrbFspBsXNUqqenjxNNsFXatZvlIhk7teUPfK+YL32F8McTnjv0BZNppb+vshoCrtLXjIWq3EJXpVXIlG6ZNL0dh6qEm2WMwDjD3LfOfkGh1/czYc/0qhiD2ozNnH4882MVVt3JbVFkbwowNCO3KL5IoYW5wlVeGCViOuv1svZx7FbzxKzA4zGqBlRRaRWCobXaVq4yYCWbZf8eiJwt3OY+MFiSJengcFP2t0JMfzOiJ7cECvpx7neg1Rc5x+7myPJOXt2FohVRyXtD+/rDoTOyGYInJelZMjolecVHUhUNqvdZWg2J2t0jPmiLFeRD/8fOT4o+NGILb+TufCo9ceBBm3JLVn+MO2675n7qiEX/6W+188cYg3Zn5NSTjgOKfWFSAANa6raCxSoVU851oJLY11WIoYK0du0ec5E4tCnAPoKh71riTsjVIp3gKvBbEYQiNYrmH22oLQWA2AdwMnID6PX9b58dR2QKo4qag1D1Z+L/FwEKTR7osOZPWECPJIHQqPUsM5i/CH5YupVPfFA5pHUBcsesh8eO5YhyWnaVRPZn/BmdXVumZWPxMP5e28zm2uqHgFoT9CymHYNNrzrrjlXZM06HnzDxYNlI5b/QosxLmmrqDFqmogQdqk0WLkUceoAvQxHgkIyvWU69BPFr24VB6+lx75Rna6dGtrmOxDnvBojvi1/4dHjVeg8owofPe1cOnxU1ioh016s/Vudv9mhV9f35At+Sh28h1bpp8xhr09+vf47Elx3Ms6hyp6QvB3t0vnLbOhwo660cp7K0vvepabK7YJfxEWWfrC2YzJfYOjygPwfwd/1amTqa0hZ5ueebhWYVMubRTwIjj+0Oq0ohU3zfRfuL8gt59XsHdwKtxTQQ4Y2qz6gisxnm2UdlmpEkgOsZz7iEk6QOt8BuPwr+NR01LTqXmJo1C76o1N274twJvl+I069TiLpenK/miRxhyY8jvYV6W1WuSwhH9q7kuwnJMtm7IWcqs7HsnyHSqWXLSpYtZGaR1V3t0gauninFPZGtWskF65rtti48UV9uV9KM8kfDYs0pgB00S+TlzTXV6P8mxq15b9En8sz3jWSszcifZa/NuufPNnNTb031pptt0+sRSH/7UG8pzbsgtt3OG3ut7B9JzDMt2mTZuyRNIV8D54TuTrpNcHtgmMlYJeiY9XS83NYJicjRjtJSf9BZLsQv629QdDsKQhTK5CnXhpk7vMNkHzPhm0ExW/VCGApHfPyBagtZQTQmPHx7g5IXXsrQDPzIVhv2LB6Ih138iSDww1JNHrDvzUxvp73MsQBVhW8EbrReaVUcLB1R3PUXyaYG4HpJUcLVxMgDxcPkVRQpL7VTAGabDzbKcvg12t5P8TSGQkrj/gOrpnbiDHwluA73xbXts/L7u468cRWSWRtgTwlQnA47EKg0OiZDgFxAKQQUcsbGomITgeXUAAyKe03eA7Mp4gnyKQmm0LXJtEk6ddksMJCuxDmmHzmVhO+XaN2A54MIh3niw5CF7PwiXFZrnA8wOdeHLvvhdoqIDG9PDI7UnWWHq526T8y6ixJPhkuVKZnoUruOpUgOOp3iIKBjk+yi1vHo5cItHXb1PIKzGaZlRS0g5d3MV2pD8FQdGYLZ73aae/eEIUePMc4NFz8pIUfLCrrF4jVWH5gQneN3S8vANBmUXrEcKGn6hIUN95y1vpsvLwbGpzV9L0ZKTan6TDXM05236uLJcIEMKVAxKNT0K8WljuwNny3BNQRfzovA85beI9zr1AGNYnYCVkR1aGngWURUrgqR+gRrQhxW81l3CHevjvGEPzPMTxdsIfB9dfGRbZU0cg/1mcubtECX4tvaedmNAvTxCJtc2QaoUalGfENCGK7IS/O8CRpdOVca8EWCRwv2sSWE8CJPW5PCugjCXPd3h6U60cPD+bdhtXZuYB6stcoveE7Sm5MM2yvfUHXFSW7KzLmi7/EeEWL0wqcOH9MOSKjhCHHmw+JGLcYE/7SBZQCRggox0ZZTAxrlzNNXYXL5fNIjkdT4YMqVUz6p8YDt049v4OXGdg3qTrtLBUXOZf7ahPlZAY/O+7Sp0bvGSHdyQ8B1LOsplqMb9Se8VAE7gIdSZvxbRSrfl+Lk5Qaqi5QJceqjitdErcHXg/3MryljPSIAMaaloFm1cVwBJ8DNmkDqoGROSHFetrgjQ5CahuKkdH5pRPigMrgTtlFI8ufJPJSUlGgTjbBSvpRc0zypiUn6U5KZqcRoyrtzhmJ7/caeZkmVRwJQeLOG8LY6vP5ChpKhc8Js0El+n6FXqbx9ItdtLtYP92kKfaTLtCi8StLZdENJa9Ex1nOoz1kQ7qxoiZFKRyLf4O4CHRT0T/0W9F8epNKVoeyxUXhy3sQMMsJjQJEyMOjmOhMFgOmmlscV4eFi1CldU92yjwleirEKPW3bPAuEhRZV7JsKV3Lr5cETAiFuX5Nw5UlF7d2HZ96Bh0sgFIL5KGaKSoVYVlvdKpZJVP5+NZ7xDEkQhmDgsDKciazJCXJ6ZN2B3FY2f6VZyGl/t4aunGIAk/BHaS+i+SpdRfnB/OktOvyjinWNfM9Ksr6WwtCa1hCmeRI6icpFM4o8quCLsikU0tMoZI/9EqXRMpKGaWzofl4nQuVQm17d5fU5qXCQeCDqVaL9XJ9qJ08n3G3EFZS28SHEb3cdRBdtO0YcTzil3QknNKEe/smQ1fTb0XbpyNB5xAeuIlf+5KWlEY0DqJbsnzJlQxJPOVyHiKMx5Xu9FcEv1Fbg6Fhm4t+Jyy5JC1W3YO8dYLsO0PXPbxodBgttTbH3rt9Cp1lJIk2r3O1Zqu94eRbnIz2f50lWolYzuKsj4PMok4abHLO8NAC884hiXx5Fy5pWKO0bWL7uEGXaJCtznhP67SlQ4xjWIfgq6EpZ28QMtuZK7JC0RGbl9nA4XtFLug/NLMoH1pGt9IonAJqcEDLyH6TDROcbsmGPaGIxMo41IUAnQVPMPGByp4mOmh9ZQMkBAcksUK55LsZj7E5z5XuZoyWCKu6nHmDq22xI/9Z8YdxJy4kWpD16jLVrpwGLWfyOD0Wd+cBzFBxVaGv7S5k9qwh/5t/LQEXsRqI3Q9Rm3QIoaZW9GlsDaKOUyykyWuhNOprSEi0s1G4rgoiX1V743EELti+pJu5og6X0g6oTynUqlhH9k6ezyRi05NGZHz0nvp3HOJr7ebrAUFrDjbkFBObEvdQWkkUbL0pEvMU46X58vF9j9F3j6kpyetNUBItrEubW9ZvMPM4qNqLlsSBJqOH3XbNwv/cXDXNxN8iFLzUhteisYY+RlHYOuP29/Cb+L+xv+35Rv7xudnZ6ohK4cMPfCG8KI7dNmjNk/H4e84pOxn/sZHK9psfvj8ncA8qJz7O8xqbxESDivGJOZzF7o5PJLQ7g34qAWoyuA+x3btU98LT6ZyGyceIXjrqob2CAVql4VOTQPUQYvHV/g4zAuCZGvYQBtf0wmd5lilrvuEn1BXLny01B4h4SMDlYsnNpm9d7m9h578ufpef9Z4WplqWQvqo52fyUA7J24eZD5av6SyGIV9kpmHNqyvdfzcpEMw97BvknV2fq+MFHun9BT3Lsf8pbzvisWiIQvYkng+8Vxk1V+dli1u56kY50LRjaPdotvT5BwqtwyF+emo/z9J3yVUVGfKrxQtJMOAQWoQii/4dp9wgybSa5mkucmRLtEQZ/pz0tL/NVcgWAd95nEQ3Tg6tNbuyn3Iepz65L3huMUUBntllWuu4DbtOFSMSbpILV4fy6wlM0SOvi6CpLh81c1LreIvKd61uEWBcDw1lUBUW1I0Z+m/PaRlX+PQ/oxg0Ye6KUiIiTF4ADNk59Ydpt5/rkxmq9tV5Kcp/eQLUVVmBzQNVuytQCP6Ezd0G8eLxWyHpmZWJ3bAzkWTtg4lZlw42SQezEmiUPaJUuR/qklVA/87S4ArFCpALdY3QRdUw3G3XbWUp6aq9z0zUizcPa7351p9JXOZyfdZBFnqt90VzQndXB/mwf8LC9STj5kenVpNuqOQQP3mIRJj7eV21FxG8VAxKrEn3c+XfmZ800EPb9/5lIlijscUbB6da0RQaMook0zug1G0tKi/JBC4rw7/D3m4ARzAkzMcVrDcT2SyFtUdWAsFlsPDFqV3N+EjyXaoEePwroaZCiLqEzb8MW+PNE9TmTC01EzWli51PzZvUqkmyuROU+V6ik+Le/9qT6nwzUzf9tP68tYei0YaDGx6kAd7jn1cKqOCuYbiELH9zYqcc4MnRJjkeGiqaGwLImhyeKs+xKJMBlOJ05ow9gGCKZ1VpnMKoSCTbMS+X+23y042zOb5MtcY/6oBeAo1Vy89OTyhpavFP78jXCcFH0t7Gx24hMEOm2gsEfGabVpQgvFqbQKMsknFRRmuPHcZu0Su/WMFphZvB2r/EGbG72rpGGho3h+Msz0uGzJ7hNK2uqQiE1qmn0zgacKYYZBCqsxV+sjbpoVdSilW/b94n2xNb648VmNIoizqEWhBnsen+d0kbCPmRItfWqSBeOd9Wne3c6bcd6uvXOJ6WdiSsuXq0ndhqrQ4QoWUjCjYtZ0EAhnSOP1m44xkf0O7jXghrzSJWxP4a/t72jU29Vu2rvu4n7HfHkkmQOMGSS+NPeLGO5I73mC2B7+lMiBQQZRM9/9liLIfowupUFAbPBbR+lxDM6M8Ptgh1paJq5Rvs7yEuLQv/7d1oU2woFSb3FMPWQOKMuCuJ7pDDjpIclus5TeEoMBy2YdVB4fxmesaCeMNsEgTHKS5WDSGyNUOoEpcC2OFWtIRf0w27ck34/DjxRTVIcc9+kqZE6iMSiVDsiKdP/Xz5XfEhm/sBhO50p1rvJDlkyyxuJ9SPgs7YeUJBjXdeAkE+P9OQJm6SZnn1svcduI78dYmbkE2mtziPrcjVisXG78spLvbZaSFx/Rks9zP4LKn0Cdz/3JsetkT06A8f/yCgMO6Mb1Hme0JJ7b2wZz1qleqTuKBGokhPVUZ0dVu+tnQYNEY1fmkZSz6+EGZ5EzL7657mreZGR3jUfaEk458PDniBzsSmBKhDRzfXameryJv9/D5m6HIqZ0R+ouCE54Dzp4IJuuD1e4Dc5i+PpSORJfG23uVgqixAMDvchMR0nZdH5brclYwRoJRWv/rlxGRI5ffD5NPGmIDt7vDE1434pYdVZIFh89Bs94HGGJbTwrN8T6lh1HZFTOB4lWzWj6EVqxSMvC0/ljWBQ3F2kc/mO2b6tWonT2JEqEwFts8rz2h+oWNds9ceR2cb7zZvJTDppHaEhK5avWqsseWa2Dt5BBhabdWSktS80oMQrL4TvAM9b5HMmyDnO+OkkbMXfUJG7eXqTIG6lqSOEbqVR+qYdP7uWb57WEJqzyh411GAVsDinPs7KvUeXItlcMdOUWzXBH6zscymV1LLVCtc8IePojzXHF9m5b5zGwBRdzcyUJkiu938ApmAayRdJrX1PmVguWUvt2ThQ62czItTyWJMW2An/hdDfMK7SiFQlGIdAbltHz3ycoh7j9V7GxNWBpbtcSdqm4XxRwTawc3cbZ+xfSv9qQfEkDKfZTwCkqWGI/ur250ItXlMlh6vUNWEYIg9A3GzbgmbqvTN8js2YMo87CU5y6nZ4dbJLDQJj9fc7yM7tZzJDZFtqOcU8+mZjYlq4VmifI23iHb1ZoT9E+kT2dolnP1AfiOkt7PQCSykBiXy5mv637IegWSKj9IKrYZf4Lu9+I7ub+mkRdlvYzehh/jaJ9n7HUH5b2IbgeNdkY7wx1yVzxS7pbvky6+nmVUtRllEFfweUQ0/nG017WoUYSxs+j2B4FV/F62EtHlMWZXYrjGHpthnNb1x66LKZ0Qe92INWHdfR/vqp02wMS8r1G4dJqHok8KmQ7947G13a4YXbsGgHcBvRuVu1eAi4/A5+ZixmdSXM73LupB/LH7O9yxLTVXJTyBbI1S49TIROrfVCOb/czZ9pM4JsZx8kUz8dQGv7gUWKxXvTH7QM/3J2OuXXgciUhqY+cgtaOliQQVOYthBLV3xpESZT3rmfEYNZxmpBbb24CRao86prn+i9TNOh8VxRJGXJfXHATJHs1T5txgc/opYrY8XjlGQQbRcoxIBcnVsMjmU1ymmIUL4dviJXndMAJ0Yet+c7O52/p98ytlmAsGBaTAmMhimAnvp1TWNGM9BpuitGj+t810CU2UhorrjPKGtThVC8WaXw04WFnT5fTjqmPyrQ0tN3CkLsctVy2xr0ZWgiWVZ1OrlFjjxJYsOiZv2cAoOvE+7sY0I/TwWcZqMoyIKNOftwP7w++Rfg67ljfovKYa50if3fzE/8aPYVey/Nq35+nH2sLPh/fP5TsylSKGOZ4k69d2PnH43+kq++sRXHQqGArWdwhx+hpwQC6JgT2uxehYU4Zbw7oNb6/HLikPyJROGK2ouyr+vzseESp9G50T4AyFrSqOQ0rroCYP4sMDFBrHn342EyZTMlSyk47rHSq89Y9/nI3zG5lX16Z5lxphguLOcZUndL8wNcrkyjH82jqg8Bo8OYkynrxZvbFno5lUS3OPr8Ko3mX9NoRPdYOKKjD07bvgFgpZ/RF+YzkWvJ/Hs/tUbfeGzGWLxNAjfDzHHMVSDwB5SabQLsIZHiBp43FjGkaienYoDd18hu2BGwOK7U3o70K/WY/kuuKdmdrykIBUdG2mvE91L1JtTbh20mOLbk1vCAamu7utlXeGU2ooVikbU/actcgmsC1FKk2qmj3GWeIWbj4tGIxE7BLcBWUvvcnd/lYxsMV4F917fWeFB/XbINN3qGvIyTpCalz1lVewdIGqeAS/gB8Mi+sA+BqDiX3VGD2eUunTRbSY+AuDy4E3Qx3hAhwnSXX+B0zuj3eQ1miS8Vux2z/l6/BkWtjKGU72aJkOCWhGcSf3+kFkkB15vGOsQrSdFr6qTj0gBYiOlnBO41170gOWHSUoBVRU2JjwppYdhIFDfu7tIRHccSNM5KZOFDPz0TGMAjzzEpeLwTWp+kn201kU6NjbiMQJx83+LX1e1tZ10kuChJZ/XBUQ1dwaBHjTDJDqOympEk8X2M3VtVw21JksChA8w1tTefO3RJ1FMbqZ01bHHkudDB/OhLfe7P5GOHaI28ZXKTMuqo0hLWQ4HabBsGG7NbP1RiXtETz074er6w/OerJWEqjmkq2y51q1BVI+JUudnVa3ogBpzdhFE7fC7kybrAt2Z6RqDjATAUEYeYK45WMupBKQRtQlU+uNsjnzj6ZmGrezA+ASrWxQ6LMkHRXqXwNq7ftv28dUx/ZSJciDXP2SWJsWaN0FjPX9Yko6LobZ7aYW/IdUktI9apTLyHS8DyWPyuoZyxN1TK/vtfxk3HwWh6JczZC8Ftn0bIJay2g+n5wd7lm9rEsKO+svqVmi+c1j88hSCxbzrg4+HEP0Nt1/B6YW1XVm09T1CpAKjc9n18hjqsaFGdfyva1ZG0Xu3ip6N6JGpyTSqY5h4BOlpLPaOnyw45PdXTN+DtAKg7DLrLFTnWusoSBHk3s0d7YouJHq85/R09Tfc37ENXZF48eAYLnq9GLioNcwDZrC6FW6godB8JnqYUPvn0pWLfQz0lM0Yy8Mybgn84Ds3Q9bDP10bLyOV+qzxa4Rd9Dhu7cju8mMaONXK3UqmBQ9qIg7etIwEqM/kECk/Dzja4Bs1xR+Q/tCbc8IKrSGsTdJJ0vge7IG20W687uVmK6icWQ6cD3lwFzgNMGtFvO5qyJeKflGLAAcQZOrkxVwy3cWvqlGpvjmf9Qe6Ap20MPbV92DPV0OhFM4kz8Yr0ffC2zLWSQ1kqY6QdQrttR3kh1YLtQd1kCEv5hVoPIRWl5ERcUTttBIrWp6Xs5Ehh5OUUwI5aEBvuiDmUoENmnVw1FohCrbRp1A1E+XSlWVOTi7ADW+5Ohb9z1vK4qx5R5lPdGCPBJZ00mC+Ssp8VUbgpGAvXWMuWQQRbCqI6Rr2jtxZxtfP7W/8onz+yz0Gs76LaT5HX9ecyiZCB/ZR/gFtMxPsDwohoeCRtiuLxE1GM1vUEUgBv86+eehL58/P56QFGQ/MqOe/vC76L63jzmeax4exd/OKTUvkXg+fOJUHych9xt/9goJMrapSgvXrj8+8vk/N80f22Sewj6cyGqt1B6mztoeklVHHraouhvHJaG/OuBz6DHKMpFmQULU1bRWlyYE0RPXYYkUycIemN7TLtgNCJX6BqdyxDKkegO7nJK5xQ7OVYDZTMf9bVHidtk6DQX9Et+V9M7esgbsYBdEeUpsB0Xvw2kd9+rI7V+m47u+O/tq7mw7262HU1WlS9uFzsV6JxIHNmUCy0QS9e077JGRFbG65z3/dOKB/Zk+yDdKpUmdXjn/aS3N5nv4fK7bMHHmPlHd4E2+iTbV5rpzScRnxk6KARuDTJ8Q1LpK2mP8gj1EbuJ9RIyY+EWK4hCiIDBAS1Tm2IEXAFfgKPgdL9O6mAa06wjCcUAL6EsxPQWO9VNegBPm/0GgkZbDxCynxujX/92vmGcjZRMAY45puak2sFLCLSwXpEsyy5fnF0jGJBhm+fNSHKKUUfy+276A7/feLOFxxUuHRNJI2Osenxyvf8DAGObT60pfTTlhEg9u/KKkhJqm5U1/+BEcSkpFDA5XeCqxwXmPac1jcuZ3JWQ+p0NdWzb/5v1ZvF8GtMTFFEdQjpLO0bwPb0BHNWnip3liDXI2fXf05jjvfJ0NpjLCUgfTh9CMFYVFKEd4Z/OG/2C+N435mnK+9t1gvCiVcaaH7rK4+PjCvpVNiz+t2QyqH1O8x3JKZVl6Q+Lp/XK8wMjVMslOq9FdSw5FtUs/CptXH9PW+wbWHgrV17R5jTVOtGtKFu3nb80T+E0tv9QkzW3J2dbaw/8ddAKZ0pxIaEqLjlPrji3VgJ3GvdFvlqD8075woxh4fVt0JZE0KVFsAvqhe0dqN9b35jtSpnYMXkU+vZq+IAHad3IHc2s/LYrnD1anfG46IFiMIr9oNbZDWvwthqYNqOigaKd/XlLU4XHfk/PXIjPsLy/9/kAtQ+/wKH+hI/IROWj5FPvTZAT9f7j4ZXQyG4M0TujMAFXYkKvEHv1xhySekgXGGqNxWeWKlf8dDAlLuB1cb/qOD+rk7cmwt+1yKpk9cudqBanTi6zTbXRtV8qylNtjyOVKy1HTz0GW9rjt6sSjAZcT5R+KdtyYb0zyqG9pSLuCw5WBwAn7fjBjKLLoxLXMI+52L9cLwIR2B6OllJZLHJ8vDxmWdtF+QJnmt1rsHPIWY20lftk8fYePkAIg6Hgn532QoIpegMxiWgAOfe5/U44APR8Ac0NeZrVh3gEhs12W+tVSiWiUQekf/YBECUy5fdYbA08dd7VzPAP9aiVcIB9k6tY7WdJ1wNV+bHeydNtmC6G5ICtFC1ZwmJU/j8hf0I8TRVKSiz5oYIa93EpUI78X8GYIAZabx47/n8LDAAJ0nNtP1rpROprqKMBRecShca6qXuTSI3jZBLOB3Vp381B5rCGhjSvh/NSVkYp2qIdP/Bg=";
              }
            ),
            /***/
            5139: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                var data = __webpack_require__2(5340);
                exports2.init = function() {
                  exports2.dictionary = data.init();
                };
                exports2.offsetsByLength = new Uint32Array([
                  0,
                  0,
                  0,
                  0,
                  0,
                  4096,
                  9216,
                  21504,
                  35840,
                  44032,
                  53248,
                  63488,
                  74752,
                  87040,
                  93696,
                  100864,
                  104704,
                  106752,
                  108928,
                  113536,
                  115968,
                  118528,
                  119872,
                  121280,
                  122016
                ]);
                exports2.sizeBitsByLength = new Uint8Array([
                  0,
                  0,
                  0,
                  0,
                  10,
                  10,
                  11,
                  11,
                  10,
                  10,
                  10,
                  10,
                  10,
                  9,
                  9,
                  8,
                  7,
                  7,
                  8,
                  7,
                  7,
                  6,
                  6,
                  5,
                  5
                ]);
                exports2.minDictionaryWordLength = 4;
                exports2.maxDictionaryWordLength = 24;
              }
            ),
            /***/
            966: (
              /***/
              function(__unused_webpack_module, exports2) {
                function HuffmanCode(bits, value) {
                  this.bits = bits;
                  this.value = value;
                }
                exports2.h = HuffmanCode;
                var MAX_LENGTH = 15;
                function GetNextKey(key, len) {
                  var step = 1 << len - 1;
                  while (key & step) {
                    step >>= 1;
                  }
                  return (key & step - 1) + step;
                }
                function ReplicateValue(table, i, step, end, code) {
                  do {
                    end -= step;
                    table[i + end] = new HuffmanCode(code.bits, code.value);
                  } while (end > 0);
                }
                function NextTableBitSize(count, len, root_bits) {
                  var left = 1 << len - root_bits;
                  while (len < MAX_LENGTH) {
                    left -= count[len];
                    if (left <= 0)
                      break;
                    ++len;
                    left <<= 1;
                  }
                  return len - root_bits;
                }
                exports2.g = function(root_table, table, root_bits, code_lengths, code_lengths_size) {
                  var start_table = table;
                  var code;
                  var len;
                  var symbol;
                  var key;
                  var step;
                  var low;
                  var mask;
                  var table_bits;
                  var table_size;
                  var total_size;
                  var sorted;
                  var count = new Int32Array(MAX_LENGTH + 1);
                  var offset = new Int32Array(MAX_LENGTH + 1);
                  sorted = new Int32Array(code_lengths_size);
                  for (symbol = 0; symbol < code_lengths_size; symbol++) {
                    count[code_lengths[symbol]]++;
                  }
                  offset[1] = 0;
                  for (len = 1; len < MAX_LENGTH; len++) {
                    offset[len + 1] = offset[len] + count[len];
                  }
                  for (symbol = 0; symbol < code_lengths_size; symbol++) {
                    if (code_lengths[symbol] !== 0) {
                      sorted[offset[code_lengths[symbol]]++] = symbol;
                    }
                  }
                  table_bits = root_bits;
                  table_size = 1 << table_bits;
                  total_size = table_size;
                  if (offset[MAX_LENGTH] === 1) {
                    for (key = 0; key < total_size; ++key) {
                      root_table[table + key] = new HuffmanCode(0, sorted[0] & 65535);
                    }
                    return total_size;
                  }
                  key = 0;
                  symbol = 0;
                  for (len = 1, step = 2; len <= root_bits; ++len, step <<= 1) {
                    for (; count[len] > 0; --count[len]) {
                      code = new HuffmanCode(len & 255, sorted[symbol++] & 65535);
                      ReplicateValue(root_table, table + key, step, table_size, code);
                      key = GetNextKey(key, len);
                    }
                  }
                  mask = total_size - 1;
                  low = -1;
                  for (len = root_bits + 1, step = 2; len <= MAX_LENGTH; ++len, step <<= 1) {
                    for (; count[len] > 0; --count[len]) {
                      if ((key & mask) !== low) {
                        table += table_size;
                        table_bits = NextTableBitSize(count, len, root_bits);
                        table_size = 1 << table_bits;
                        total_size += table_size;
                        low = key & mask;
                        root_table[start_table + low] = new HuffmanCode(table_bits + root_bits & 255, table - start_table - low & 65535);
                      }
                      code = new HuffmanCode(len - root_bits & 255, sorted[symbol++] & 65535);
                      ReplicateValue(root_table, table + (key >> root_bits), step, table_size, code);
                      key = GetNextKey(key, len);
                    }
                  }
                  return total_size;
                };
              }
            ),
            /***/
            8435: (
              /***/
              function(__unused_webpack_module, exports2) {
                function PrefixCodeRange(offset, nbits) {
                  this.offset = offset;
                  this.nbits = nbits;
                }
                exports2.kBlockLengthPrefixCode = [
                  new PrefixCodeRange(1, 2),
                  new PrefixCodeRange(5, 2),
                  new PrefixCodeRange(9, 2),
                  new PrefixCodeRange(13, 2),
                  new PrefixCodeRange(17, 3),
                  new PrefixCodeRange(25, 3),
                  new PrefixCodeRange(33, 3),
                  new PrefixCodeRange(41, 3),
                  new PrefixCodeRange(49, 4),
                  new PrefixCodeRange(65, 4),
                  new PrefixCodeRange(81, 4),
                  new PrefixCodeRange(97, 4),
                  new PrefixCodeRange(113, 5),
                  new PrefixCodeRange(145, 5),
                  new PrefixCodeRange(177, 5),
                  new PrefixCodeRange(209, 5),
                  new PrefixCodeRange(241, 6),
                  new PrefixCodeRange(305, 6),
                  new PrefixCodeRange(369, 7),
                  new PrefixCodeRange(497, 8),
                  new PrefixCodeRange(753, 9),
                  new PrefixCodeRange(1265, 10),
                  new PrefixCodeRange(2289, 11),
                  new PrefixCodeRange(4337, 12),
                  new PrefixCodeRange(8433, 13),
                  new PrefixCodeRange(16625, 24)
                ];
                exports2.kInsertLengthPrefixCode = [
                  new PrefixCodeRange(0, 0),
                  new PrefixCodeRange(1, 0),
                  new PrefixCodeRange(2, 0),
                  new PrefixCodeRange(3, 0),
                  new PrefixCodeRange(4, 0),
                  new PrefixCodeRange(5, 0),
                  new PrefixCodeRange(6, 1),
                  new PrefixCodeRange(8, 1),
                  new PrefixCodeRange(10, 2),
                  new PrefixCodeRange(14, 2),
                  new PrefixCodeRange(18, 3),
                  new PrefixCodeRange(26, 3),
                  new PrefixCodeRange(34, 4),
                  new PrefixCodeRange(50, 4),
                  new PrefixCodeRange(66, 5),
                  new PrefixCodeRange(98, 5),
                  new PrefixCodeRange(130, 6),
                  new PrefixCodeRange(194, 7),
                  new PrefixCodeRange(322, 8),
                  new PrefixCodeRange(578, 9),
                  new PrefixCodeRange(1090, 10),
                  new PrefixCodeRange(2114, 12),
                  new PrefixCodeRange(6210, 14),
                  new PrefixCodeRange(22594, 24)
                ];
                exports2.kCopyLengthPrefixCode = [
                  new PrefixCodeRange(2, 0),
                  new PrefixCodeRange(3, 0),
                  new PrefixCodeRange(4, 0),
                  new PrefixCodeRange(5, 0),
                  new PrefixCodeRange(6, 0),
                  new PrefixCodeRange(7, 0),
                  new PrefixCodeRange(8, 0),
                  new PrefixCodeRange(9, 0),
                  new PrefixCodeRange(10, 1),
                  new PrefixCodeRange(12, 1),
                  new PrefixCodeRange(14, 2),
                  new PrefixCodeRange(18, 2),
                  new PrefixCodeRange(22, 3),
                  new PrefixCodeRange(30, 3),
                  new PrefixCodeRange(38, 4),
                  new PrefixCodeRange(54, 4),
                  new PrefixCodeRange(70, 5),
                  new PrefixCodeRange(102, 5),
                  new PrefixCodeRange(134, 6),
                  new PrefixCodeRange(198, 7),
                  new PrefixCodeRange(326, 8),
                  new PrefixCodeRange(582, 9),
                  new PrefixCodeRange(1094, 10),
                  new PrefixCodeRange(2118, 24)
                ];
                exports2.kInsertRangeLut = [
                  0,
                  0,
                  8,
                  8,
                  0,
                  16,
                  8,
                  16,
                  16
                ];
                exports2.kCopyRangeLut = [
                  0,
                  8,
                  0,
                  8,
                  16,
                  0,
                  16,
                  8,
                  16
                ];
              }
            ),
            /***/
            6154: (
              /***/
              function(__unused_webpack_module, exports2) {
                function BrotliInput(buffer) {
                  this.buffer = buffer;
                  this.pos = 0;
                }
                BrotliInput.prototype.read = function(buf, i, count) {
                  if (this.pos + count > this.buffer.length) {
                    count = this.buffer.length - this.pos;
                  }
                  for (var p = 0; p < count; p++)
                    buf[i + p] = this.buffer[this.pos + p];
                  this.pos += count;
                  return count;
                };
                exports2.g = BrotliInput;
                function BrotliOutput(buf) {
                  this.buffer = buf;
                  this.pos = 0;
                }
                BrotliOutput.prototype.write = function(buf, count) {
                  if (this.pos + count > this.buffer.length)
                    throw new Error("Output buffer is not large enough");
                  this.buffer.set(buf.subarray(0, count), this.pos);
                  this.pos += count;
                  return count;
                };
                exports2.j = BrotliOutput;
              }
            ),
            /***/
            2973: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                var BrotliDictionary = __webpack_require__2(5139);
                var kIdentity = 0;
                var kOmitLast1 = 1;
                var kOmitLast2 = 2;
                var kOmitLast3 = 3;
                var kOmitLast4 = 4;
                var kOmitLast5 = 5;
                var kOmitLast6 = 6;
                var kOmitLast7 = 7;
                var kOmitLast8 = 8;
                var kOmitLast9 = 9;
                var kUppercaseFirst = 10;
                var kUppercaseAll = 11;
                var kOmitFirst1 = 12;
                var kOmitFirst2 = 13;
                var kOmitFirst3 = 14;
                var kOmitFirst4 = 15;
                var kOmitFirst5 = 16;
                var kOmitFirst6 = 17;
                var kOmitFirst7 = 18;
                var kOmitFirst8 = 19;
                var kOmitFirst9 = 20;
                function Transform(prefix, transform, suffix) {
                  this.prefix = new Uint8Array(prefix.length);
                  this.transform = transform;
                  this.suffix = new Uint8Array(suffix.length);
                  for (var i = 0; i < prefix.length; i++)
                    this.prefix[i] = prefix.charCodeAt(i);
                  for (var i = 0; i < suffix.length; i++)
                    this.suffix[i] = suffix.charCodeAt(i);
                }
                var kTransforms = [
                  new Transform("", kIdentity, ""),
                  new Transform("", kIdentity, " "),
                  new Transform(" ", kIdentity, " "),
                  new Transform("", kOmitFirst1, ""),
                  new Transform("", kUppercaseFirst, " "),
                  new Transform("", kIdentity, " the "),
                  new Transform(" ", kIdentity, ""),
                  new Transform("s ", kIdentity, " "),
                  new Transform("", kIdentity, " of "),
                  new Transform("", kUppercaseFirst, ""),
                  new Transform("", kIdentity, " and "),
                  new Transform("", kOmitFirst2, ""),
                  new Transform("", kOmitLast1, ""),
                  new Transform(", ", kIdentity, " "),
                  new Transform("", kIdentity, ", "),
                  new Transform(" ", kUppercaseFirst, " "),
                  new Transform("", kIdentity, " in "),
                  new Transform("", kIdentity, " to "),
                  new Transform("e ", kIdentity, " "),
                  new Transform("", kIdentity, '"'),
                  new Transform("", kIdentity, "."),
                  new Transform("", kIdentity, '">'),
                  new Transform("", kIdentity, "\n"),
                  new Transform("", kOmitLast3, ""),
                  new Transform("", kIdentity, "]"),
                  new Transform("", kIdentity, " for "),
                  new Transform("", kOmitFirst3, ""),
                  new Transform("", kOmitLast2, ""),
                  new Transform("", kIdentity, " a "),
                  new Transform("", kIdentity, " that "),
                  new Transform(" ", kUppercaseFirst, ""),
                  new Transform("", kIdentity, ". "),
                  new Transform(".", kIdentity, ""),
                  new Transform(" ", kIdentity, ", "),
                  new Transform("", kOmitFirst4, ""),
                  new Transform("", kIdentity, " with "),
                  new Transform("", kIdentity, "'"),
                  new Transform("", kIdentity, " from "),
                  new Transform("", kIdentity, " by "),
                  new Transform("", kOmitFirst5, ""),
                  new Transform("", kOmitFirst6, ""),
                  new Transform(" the ", kIdentity, ""),
                  new Transform("", kOmitLast4, ""),
                  new Transform("", kIdentity, ". The "),
                  new Transform("", kUppercaseAll, ""),
                  new Transform("", kIdentity, " on "),
                  new Transform("", kIdentity, " as "),
                  new Transform("", kIdentity, " is "),
                  new Transform("", kOmitLast7, ""),
                  new Transform("", kOmitLast1, "ing "),
                  new Transform("", kIdentity, "\n	"),
                  new Transform("", kIdentity, ":"),
                  new Transform(" ", kIdentity, ". "),
                  new Transform("", kIdentity, "ed "),
                  new Transform("", kOmitFirst9, ""),
                  new Transform("", kOmitFirst7, ""),
                  new Transform("", kOmitLast6, ""),
                  new Transform("", kIdentity, "("),
                  new Transform("", kUppercaseFirst, ", "),
                  new Transform("", kOmitLast8, ""),
                  new Transform("", kIdentity, " at "),
                  new Transform("", kIdentity, "ly "),
                  new Transform(" the ", kIdentity, " of "),
                  new Transform("", kOmitLast5, ""),
                  new Transform("", kOmitLast9, ""),
                  new Transform(" ", kUppercaseFirst, ", "),
                  new Transform("", kUppercaseFirst, '"'),
                  new Transform(".", kIdentity, "("),
                  new Transform("", kUppercaseAll, " "),
                  new Transform("", kUppercaseFirst, '">'),
                  new Transform("", kIdentity, '="'),
                  new Transform(" ", kIdentity, "."),
                  new Transform(".com/", kIdentity, ""),
                  new Transform(" the ", kIdentity, " of the "),
                  new Transform("", kUppercaseFirst, "'"),
                  new Transform("", kIdentity, ". This "),
                  new Transform("", kIdentity, ","),
                  new Transform(".", kIdentity, " "),
                  new Transform("", kUppercaseFirst, "("),
                  new Transform("", kUppercaseFirst, "."),
                  new Transform("", kIdentity, " not "),
                  new Transform(" ", kIdentity, '="'),
                  new Transform("", kIdentity, "er "),
                  new Transform(" ", kUppercaseAll, " "),
                  new Transform("", kIdentity, "al "),
                  new Transform(" ", kUppercaseAll, ""),
                  new Transform("", kIdentity, "='"),
                  new Transform("", kUppercaseAll, '"'),
                  new Transform("", kUppercaseFirst, ". "),
                  new Transform(" ", kIdentity, "("),
                  new Transform("", kIdentity, "ful "),
                  new Transform(" ", kUppercaseFirst, ". "),
                  new Transform("", kIdentity, "ive "),
                  new Transform("", kIdentity, "less "),
                  new Transform("", kUppercaseAll, "'"),
                  new Transform("", kIdentity, "est "),
                  new Transform(" ", kUppercaseFirst, "."),
                  new Transform("", kUppercaseAll, '">'),
                  new Transform(" ", kIdentity, "='"),
                  new Transform("", kUppercaseFirst, ","),
                  new Transform("", kIdentity, "ize "),
                  new Transform("", kUppercaseAll, "."),
                  new Transform("", kIdentity, ""),
                  new Transform(" ", kIdentity, ","),
                  new Transform("", kUppercaseFirst, '="'),
                  new Transform("", kUppercaseAll, '="'),
                  new Transform("", kIdentity, "ous "),
                  new Transform("", kUppercaseAll, ", "),
                  new Transform("", kUppercaseFirst, "='"),
                  new Transform(" ", kUppercaseFirst, ","),
                  new Transform(" ", kUppercaseAll, '="'),
                  new Transform(" ", kUppercaseAll, ", "),
                  new Transform("", kUppercaseAll, ","),
                  new Transform("", kUppercaseAll, "("),
                  new Transform("", kUppercaseAll, ". "),
                  new Transform(" ", kUppercaseAll, "."),
                  new Transform("", kUppercaseAll, "='"),
                  new Transform(" ", kUppercaseAll, ". "),
                  new Transform(" ", kUppercaseFirst, '="'),
                  new Transform(" ", kUppercaseAll, "='"),
                  new Transform(" ", kUppercaseFirst, "='")
                ];
                exports2.kTransforms = kTransforms;
                exports2.kNumTransforms = kTransforms.length;
                function ToUpperCase(p, i) {
                  if (p[i] < 192) {
                    if (p[i] >= 97 && p[i] <= 122) {
                      p[i] ^= 32;
                    }
                    return 1;
                  }
                  if (p[i] < 224) {
                    p[i + 1] ^= 32;
                    return 2;
                  }
                  p[i + 2] ^= 5;
                  return 3;
                }
                exports2.transformDictionaryWord = function(dst, idx, word, len, transform) {
                  var prefix = kTransforms[transform].prefix;
                  var suffix = kTransforms[transform].suffix;
                  var t = kTransforms[transform].transform;
                  var skip = t < kOmitFirst1 ? 0 : t - (kOmitFirst1 - 1);
                  var i = 0;
                  var start_idx = idx;
                  var uppercase;
                  if (skip > len) {
                    skip = len;
                  }
                  var prefix_pos = 0;
                  while (prefix_pos < prefix.length) {
                    dst[idx++] = prefix[prefix_pos++];
                  }
                  word += skip;
                  len -= skip;
                  if (t <= kOmitLast9) {
                    len -= t;
                  }
                  for (i = 0; i < len; i++) {
                    dst[idx++] = BrotliDictionary.dictionary[word + i];
                  }
                  uppercase = idx - len;
                  if (t === kUppercaseFirst) {
                    ToUpperCase(dst, uppercase);
                  } else if (t === kUppercaseAll) {
                    while (len > 0) {
                      var step = ToUpperCase(dst, uppercase);
                      uppercase += step;
                      len -= step;
                    }
                  }
                  var suffix_pos = 0;
                  while (suffix_pos < suffix.length) {
                    dst[idx++] = suffix[suffix_pos++];
                  }
                  return idx - start_idx;
                };
              }
            ),
            /***/
            7709: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                module2.exports = __webpack_require__2(6450).BrotliDecompressBuffer;
              }
            ),
            /***/
            4505: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var Buffer = __webpack_require__2(8823)["Buffer"];
                var process = __webpack_require__2(4155);
                var assert = __webpack_require__2(9282);
                var Zstream = __webpack_require__2(2292);
                var zlib_deflate = __webpack_require__2(405);
                var zlib_inflate = __webpack_require__2(7948);
                var constants = __webpack_require__2(1619);
                for (var key in constants) {
                  exports2[key] = constants[key];
                }
                exports2.NONE = 0;
                exports2.DEFLATE = 1;
                exports2.INFLATE = 2;
                exports2.GZIP = 3;
                exports2.GUNZIP = 4;
                exports2.DEFLATERAW = 5;
                exports2.INFLATERAW = 6;
                exports2.UNZIP = 7;
                var GZIP_HEADER_ID1 = 31;
                var GZIP_HEADER_ID2 = 139;
                function Zlib(mode) {
                  if (typeof mode !== "number" || mode < exports2.DEFLATE || mode > exports2.UNZIP) {
                    throw new TypeError("Bad argument");
                  }
                  this.dictionary = null;
                  this.err = 0;
                  this.flush = 0;
                  this.init_done = false;
                  this.level = 0;
                  this.memLevel = 0;
                  this.mode = mode;
                  this.strategy = 0;
                  this.windowBits = 0;
                  this.write_in_progress = false;
                  this.pending_close = false;
                  this.gzip_id_bytes_read = 0;
                }
                Zlib.prototype.close = function() {
                  if (this.write_in_progress) {
                    this.pending_close = true;
                    return;
                  }
                  this.pending_close = false;
                  assert(this.init_done, "close before init");
                  assert(this.mode <= exports2.UNZIP);
                  if (this.mode === exports2.DEFLATE || this.mode === exports2.GZIP || this.mode === exports2.DEFLATERAW) {
                    zlib_deflate.deflateEnd(this.strm);
                  } else if (this.mode === exports2.INFLATE || this.mode === exports2.GUNZIP || this.mode === exports2.INFLATERAW || this.mode === exports2.UNZIP) {
                    zlib_inflate.inflateEnd(this.strm);
                  }
                  this.mode = exports2.NONE;
                  this.dictionary = null;
                };
                Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
                  return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
                };
                Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
                  return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
                };
                Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
                  assert.equal(arguments.length, 8);
                  assert(this.init_done, "write before init");
                  assert(this.mode !== exports2.NONE, "already finalized");
                  assert.equal(false, this.write_in_progress, "write already in progress");
                  assert.equal(false, this.pending_close, "close is pending");
                  this.write_in_progress = true;
                  assert.equal(false, flush === void 0, "must provide flush value");
                  this.write_in_progress = true;
                  if (flush !== exports2.Z_NO_FLUSH && flush !== exports2.Z_PARTIAL_FLUSH && flush !== exports2.Z_SYNC_FLUSH && flush !== exports2.Z_FULL_FLUSH && flush !== exports2.Z_FINISH && flush !== exports2.Z_BLOCK) {
                    throw new Error("Invalid flush value");
                  }
                  if (input == null) {
                    input = Buffer.alloc(0);
                    in_len = 0;
                    in_off = 0;
                  }
                  this.strm.avail_in = in_len;
                  this.strm.input = input;
                  this.strm.next_in = in_off;
                  this.strm.avail_out = out_len;
                  this.strm.output = out;
                  this.strm.next_out = out_off;
                  this.flush = flush;
                  if (!async) {
                    this._process();
                    if (this._checkError()) {
                      return this._afterSync();
                    }
                    return;
                  }
                  var self2 = this;
                  process.nextTick(function() {
                    self2._process();
                    self2._after();
                  });
                  return this;
                };
                Zlib.prototype._afterSync = function() {
                  var avail_out = this.strm.avail_out;
                  var avail_in = this.strm.avail_in;
                  this.write_in_progress = false;
                  return [avail_in, avail_out];
                };
                Zlib.prototype._process = function() {
                  var next_expected_header_byte = null;
                  switch (this.mode) {
                    case exports2.DEFLATE:
                    case exports2.GZIP:
                    case exports2.DEFLATERAW:
                      this.err = zlib_deflate.deflate(this.strm, this.flush);
                      break;
                    case exports2.UNZIP:
                      if (this.strm.avail_in > 0) {
                        next_expected_header_byte = this.strm.next_in;
                      }
                      switch (this.gzip_id_bytes_read) {
                        case 0:
                          if (next_expected_header_byte === null) {
                            break;
                          }
                          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
                            this.gzip_id_bytes_read = 1;
                            next_expected_header_byte++;
                            if (this.strm.avail_in === 1) {
                              break;
                            }
                          } else {
                            this.mode = exports2.INFLATE;
                            break;
                          }
                        case 1:
                          if (next_expected_header_byte === null) {
                            break;
                          }
                          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
                            this.gzip_id_bytes_read = 2;
                            this.mode = exports2.GUNZIP;
                          } else {
                            this.mode = exports2.INFLATE;
                          }
                          break;
                        default:
                          throw new Error("invalid number of gzip magic number bytes read");
                      }
                    case exports2.INFLATE:
                    case exports2.GUNZIP:
                    case exports2.INFLATERAW:
                      this.err = zlib_inflate.inflate(
                        this.strm,
                        this.flush
                        // If data was encoded with dictionary
                      );
                      if (this.err === exports2.Z_NEED_DICT && this.dictionary) {
                        this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
                        if (this.err === exports2.Z_OK) {
                          this.err = zlib_inflate.inflate(this.strm, this.flush);
                        } else if (this.err === exports2.Z_DATA_ERROR) {
                          this.err = exports2.Z_NEED_DICT;
                        }
                      }
                      while (this.strm.avail_in > 0 && this.mode === exports2.GUNZIP && this.err === exports2.Z_STREAM_END && this.strm.next_in[0] !== 0) {
                        this.reset();
                        this.err = zlib_inflate.inflate(this.strm, this.flush);
                      }
                      break;
                    default:
                      throw new Error("Unknown mode " + this.mode);
                  }
                };
                Zlib.prototype._checkError = function() {
                  switch (this.err) {
                    case exports2.Z_OK:
                    case exports2.Z_BUF_ERROR:
                      if (this.strm.avail_out !== 0 && this.flush === exports2.Z_FINISH) {
                        this._error("unexpected end of file");
                        return false;
                      }
                      break;
                    case exports2.Z_STREAM_END:
                      break;
                    case exports2.Z_NEED_DICT:
                      if (this.dictionary == null) {
                        this._error("Missing dictionary");
                      } else {
                        this._error("Bad dictionary");
                      }
                      return false;
                    default:
                      this._error("Zlib error");
                      return false;
                  }
                  return true;
                };
                Zlib.prototype._after = function() {
                  if (!this._checkError()) {
                    return;
                  }
                  var avail_out = this.strm.avail_out;
                  var avail_in = this.strm.avail_in;
                  this.write_in_progress = false;
                  this.callback(avail_in, avail_out);
                  if (this.pending_close) {
                    this.close();
                  }
                };
                Zlib.prototype._error = function(message) {
                  if (this.strm.msg) {
                    message = this.strm.msg;
                  }
                  this.onerror(
                    message,
                    this.err
                    // no hope of rescue.
                  );
                  this.write_in_progress = false;
                  if (this.pending_close) {
                    this.close();
                  }
                };
                Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
                  assert(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
                  assert(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
                  assert(level >= -1 && level <= 9, "invalid compression level");
                  assert(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
                  assert(strategy === exports2.Z_FILTERED || strategy === exports2.Z_HUFFMAN_ONLY || strategy === exports2.Z_RLE || strategy === exports2.Z_FIXED || strategy === exports2.Z_DEFAULT_STRATEGY, "invalid strategy");
                  this._init(level, windowBits, memLevel, strategy, dictionary);
                  this._setDictionary();
                };
                Zlib.prototype.params = function() {
                  throw new Error("deflateParams Not supported");
                };
                Zlib.prototype.reset = function() {
                  this._reset();
                  this._setDictionary();
                };
                Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
                  this.level = level;
                  this.windowBits = windowBits;
                  this.memLevel = memLevel;
                  this.strategy = strategy;
                  this.flush = exports2.Z_NO_FLUSH;
                  this.err = exports2.Z_OK;
                  if (this.mode === exports2.GZIP || this.mode === exports2.GUNZIP) {
                    this.windowBits += 16;
                  }
                  if (this.mode === exports2.UNZIP) {
                    this.windowBits += 32;
                  }
                  if (this.mode === exports2.DEFLATERAW || this.mode === exports2.INFLATERAW) {
                    this.windowBits = -1 * this.windowBits;
                  }
                  this.strm = new Zstream();
                  switch (this.mode) {
                    case exports2.DEFLATE:
                    case exports2.GZIP:
                    case exports2.DEFLATERAW:
                      this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports2.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
                      break;
                    case exports2.INFLATE:
                    case exports2.GUNZIP:
                    case exports2.INFLATERAW:
                    case exports2.UNZIP:
                      this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
                      break;
                    default:
                      throw new Error("Unknown mode " + this.mode);
                  }
                  if (this.err !== exports2.Z_OK) {
                    this._error("Init error");
                  }
                  this.dictionary = dictionary;
                  this.write_in_progress = false;
                  this.init_done = true;
                };
                Zlib.prototype._setDictionary = function() {
                  if (this.dictionary == null) {
                    return;
                  }
                  this.err = exports2.Z_OK;
                  switch (this.mode) {
                    case exports2.DEFLATE:
                    case exports2.DEFLATERAW:
                      this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
                      break;
                    default:
                      break;
                  }
                  if (this.err !== exports2.Z_OK) {
                    this._error("Failed to set dictionary");
                  }
                };
                Zlib.prototype._reset = function() {
                  this.err = exports2.Z_OK;
                  switch (this.mode) {
                    case exports2.DEFLATE:
                    case exports2.DEFLATERAW:
                    case exports2.GZIP:
                      this.err = zlib_deflate.deflateReset(this.strm);
                      break;
                    case exports2.INFLATE:
                    case exports2.INFLATERAW:
                    case exports2.GUNZIP:
                      this.err = zlib_inflate.inflateReset(this.strm);
                      break;
                    default:
                      break;
                  }
                  if (this.err !== exports2.Z_OK) {
                    this._error("Failed to reset stream");
                  }
                };
                exports2.Zlib = Zlib;
              }
            ),
            /***/
            2635: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var process = __webpack_require__2(4155);
                var Buffer = __webpack_require__2(8823).Buffer;
                var Transform = __webpack_require__2(2830).Transform;
                var binding = __webpack_require__2(4505);
                var util = __webpack_require__2(9539);
                var assert = __webpack_require__2(9282).ok;
                var kMaxLength = __webpack_require__2(8823).kMaxLength;
                var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes";
                binding.Z_MIN_WINDOWBITS = 8;
                binding.Z_MAX_WINDOWBITS = 15;
                binding.Z_DEFAULT_WINDOWBITS = 15;
                binding.Z_MIN_CHUNK = 64;
                binding.Z_MAX_CHUNK = Infinity;
                binding.Z_DEFAULT_CHUNK = 16 * 1024;
                binding.Z_MIN_MEMLEVEL = 1;
                binding.Z_MAX_MEMLEVEL = 9;
                binding.Z_DEFAULT_MEMLEVEL = 8;
                binding.Z_MIN_LEVEL = -1;
                binding.Z_MAX_LEVEL = 9;
                binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;
                var bkeys = Object.keys(binding);
                for (var bk = 0; bk < bkeys.length; bk++) {
                  var bkey = bkeys[bk];
                  if (bkey.match(/^Z/)) {
                    Object.defineProperty(exports2, bkey, {
                      enumerable: true,
                      value: binding[bkey],
                      writable: false
                    });
                  }
                }
                var codes = {
                  Z_OK: binding.Z_OK,
                  Z_STREAM_END: binding.Z_STREAM_END,
                  Z_NEED_DICT: binding.Z_NEED_DICT,
                  Z_ERRNO: binding.Z_ERRNO,
                  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
                  Z_DATA_ERROR: binding.Z_DATA_ERROR,
                  Z_MEM_ERROR: binding.Z_MEM_ERROR,
                  Z_BUF_ERROR: binding.Z_BUF_ERROR,
                  Z_VERSION_ERROR: binding.Z_VERSION_ERROR
                };
                var ckeys = Object.keys(codes);
                for (var ck = 0; ck < ckeys.length; ck++) {
                  var ckey = ckeys[ck];
                  codes[codes[ckey]] = ckey;
                }
                Object.defineProperty(exports2, "codes", {
                  enumerable: true,
                  value: Object.freeze(codes),
                  writable: false
                });
                exports2.Deflate = Deflate;
                exports2.Inflate = Inflate;
                exports2.Gzip = Gzip;
                exports2.Gunzip = Gunzip;
                exports2.DeflateRaw = DeflateRaw;
                exports2.InflateRaw = InflateRaw;
                exports2.Unzip = Unzip;
                exports2.createDeflate = function(o) {
                  return new Deflate(o);
                };
                exports2.createInflate = function(o) {
                  return new Inflate(o);
                };
                exports2.createDeflateRaw = function(o) {
                  return new DeflateRaw(o);
                };
                exports2.createInflateRaw = function(o) {
                  return new InflateRaw(o);
                };
                exports2.createGzip = function(o) {
                  return new Gzip(o);
                };
                exports2.createGunzip = function(o) {
                  return new Gunzip(o);
                };
                exports2.createUnzip = function(o) {
                  return new Unzip(o);
                };
                exports2.deflate = function(buffer, opts, callback) {
                  if (typeof opts === "function") {
                    callback = opts;
                    opts = {};
                  }
                  return zlibBuffer(new Deflate(opts), buffer, callback);
                };
                exports2.deflateSync = function(buffer, opts) {
                  return zlibBufferSync(new Deflate(opts), buffer);
                };
                exports2.gzip = function(buffer, opts, callback) {
                  if (typeof opts === "function") {
                    callback = opts;
                    opts = {};
                  }
                  return zlibBuffer(new Gzip(opts), buffer, callback);
                };
                exports2.gzipSync = function(buffer, opts) {
                  return zlibBufferSync(new Gzip(opts), buffer);
                };
                exports2.deflateRaw = function(buffer, opts, callback) {
                  if (typeof opts === "function") {
                    callback = opts;
                    opts = {};
                  }
                  return zlibBuffer(new DeflateRaw(opts), buffer, callback);
                };
                exports2.deflateRawSync = function(buffer, opts) {
                  return zlibBufferSync(new DeflateRaw(opts), buffer);
                };
                exports2.unzip = function(buffer, opts, callback) {
                  if (typeof opts === "function") {
                    callback = opts;
                    opts = {};
                  }
                  return zlibBuffer(new Unzip(opts), buffer, callback);
                };
                exports2.unzipSync = function(buffer, opts) {
                  return zlibBufferSync(new Unzip(opts), buffer);
                };
                exports2.inflate = function(buffer, opts, callback) {
                  if (typeof opts === "function") {
                    callback = opts;
                    opts = {};
                  }
                  return zlibBuffer(new Inflate(opts), buffer, callback);
                };
                exports2.inflateSync = function(buffer, opts) {
                  return zlibBufferSync(new Inflate(opts), buffer);
                };
                exports2.gunzip = function(buffer, opts, callback) {
                  if (typeof opts === "function") {
                    callback = opts;
                    opts = {};
                  }
                  return zlibBuffer(new Gunzip(opts), buffer, callback);
                };
                exports2.gunzipSync = function(buffer, opts) {
                  return zlibBufferSync(new Gunzip(opts), buffer);
                };
                exports2.inflateRaw = function(buffer, opts, callback) {
                  if (typeof opts === "function") {
                    callback = opts;
                    opts = {};
                  }
                  return zlibBuffer(new InflateRaw(opts), buffer, callback);
                };
                exports2.inflateRawSync = function(buffer, opts) {
                  return zlibBufferSync(new InflateRaw(opts), buffer);
                };
                function zlibBuffer(engine, buffer, callback) {
                  var buffers = [];
                  var nread = 0;
                  engine.on("error", onError);
                  engine.on("end", onEnd);
                  engine.end(buffer);
                  flow();
                  function flow() {
                    var chunk;
                    while (null !== (chunk = engine.read())) {
                      buffers.push(chunk);
                      nread += chunk.length;
                    }
                    engine.once("readable", flow);
                  }
                  function onError(err) {
                    engine.removeListener("end", onEnd);
                    engine.removeListener("readable", flow);
                    callback(err);
                  }
                  function onEnd() {
                    var buf;
                    var err = null;
                    if (nread >= kMaxLength) {
                      err = new RangeError(kRangeErrorMessage);
                    } else {
                      buf = Buffer.concat(buffers, nread);
                    }
                    buffers = [];
                    engine.close();
                    callback(err, buf);
                  }
                }
                function zlibBufferSync(engine, buffer) {
                  if (typeof buffer === "string")
                    buffer = Buffer.from(buffer);
                  if (!Buffer.isBuffer(buffer))
                    throw new TypeError("Not a string or buffer");
                  var flushFlag = engine._finishFlushFlag;
                  return engine._processChunk(buffer, flushFlag);
                }
                function Deflate(opts) {
                  if (!(this instanceof Deflate))
                    return new Deflate(opts);
                  Zlib.call(this, opts, binding.DEFLATE);
                }
                function Inflate(opts) {
                  if (!(this instanceof Inflate))
                    return new Inflate(opts);
                  Zlib.call(this, opts, binding.INFLATE);
                }
                function Gzip(opts) {
                  if (!(this instanceof Gzip))
                    return new Gzip(opts);
                  Zlib.call(this, opts, binding.GZIP);
                }
                function Gunzip(opts) {
                  if (!(this instanceof Gunzip))
                    return new Gunzip(opts);
                  Zlib.call(this, opts, binding.GUNZIP);
                }
                function DeflateRaw(opts) {
                  if (!(this instanceof DeflateRaw))
                    return new DeflateRaw(opts);
                  Zlib.call(this, opts, binding.DEFLATERAW);
                }
                function InflateRaw(opts) {
                  if (!(this instanceof InflateRaw))
                    return new InflateRaw(opts);
                  Zlib.call(this, opts, binding.INFLATERAW);
                }
                function Unzip(opts) {
                  if (!(this instanceof Unzip))
                    return new Unzip(opts);
                  Zlib.call(this, opts, binding.UNZIP);
                }
                function isValidFlushFlag(flag) {
                  return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;
                }
                function Zlib(opts, mode) {
                  var _this = this;
                  this._opts = opts = opts || {};
                  this._chunkSize = opts.chunkSize || exports2.Z_DEFAULT_CHUNK;
                  Transform.call(this, opts);
                  if (opts.flush && !isValidFlushFlag(opts.flush)) {
                    throw new Error("Invalid flush flag: " + opts.flush);
                  }
                  if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
                    throw new Error("Invalid flush flag: " + opts.finishFlush);
                  }
                  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
                  this._finishFlushFlag = typeof opts.finishFlush !== "undefined" ? opts.finishFlush : binding.Z_FINISH;
                  if (opts.chunkSize) {
                    if (opts.chunkSize < exports2.Z_MIN_CHUNK || opts.chunkSize > exports2.Z_MAX_CHUNK) {
                      throw new Error("Invalid chunk size: " + opts.chunkSize);
                    }
                  }
                  if (opts.windowBits) {
                    if (opts.windowBits < exports2.Z_MIN_WINDOWBITS || opts.windowBits > exports2.Z_MAX_WINDOWBITS) {
                      throw new Error("Invalid windowBits: " + opts.windowBits);
                    }
                  }
                  if (opts.level) {
                    if (opts.level < exports2.Z_MIN_LEVEL || opts.level > exports2.Z_MAX_LEVEL) {
                      throw new Error("Invalid compression level: " + opts.level);
                    }
                  }
                  if (opts.memLevel) {
                    if (opts.memLevel < exports2.Z_MIN_MEMLEVEL || opts.memLevel > exports2.Z_MAX_MEMLEVEL) {
                      throw new Error("Invalid memLevel: " + opts.memLevel);
                    }
                  }
                  if (opts.strategy) {
                    if (opts.strategy != exports2.Z_FILTERED && opts.strategy != exports2.Z_HUFFMAN_ONLY && opts.strategy != exports2.Z_RLE && opts.strategy != exports2.Z_FIXED && opts.strategy != exports2.Z_DEFAULT_STRATEGY) {
                      throw new Error("Invalid strategy: " + opts.strategy);
                    }
                  }
                  if (opts.dictionary) {
                    if (!Buffer.isBuffer(opts.dictionary)) {
                      throw new Error("Invalid dictionary: it should be a Buffer instance");
                    }
                  }
                  this._handle = new binding.Zlib(mode);
                  var self2 = this;
                  this._hadError = false;
                  this._handle.onerror = function(message, errno) {
                    _close(self2);
                    self2._hadError = true;
                    var error = new Error(message);
                    error.errno = errno;
                    error.code = exports2.codes[errno];
                    self2.emit("error", error);
                  };
                  var level = exports2.Z_DEFAULT_COMPRESSION;
                  if (typeof opts.level === "number")
                    level = opts.level;
                  var strategy = exports2.Z_DEFAULT_STRATEGY;
                  if (typeof opts.strategy === "number")
                    strategy = opts.strategy;
                  this._handle.init(opts.windowBits || exports2.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports2.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
                  this._buffer = Buffer.allocUnsafe(this._chunkSize);
                  this._offset = 0;
                  this._level = level;
                  this._strategy = strategy;
                  this.once("end", this.close);
                  Object.defineProperty(this, "_closed", {
                    get: function() {
                      return !_this._handle;
                    },
                    configurable: true,
                    enumerable: true
                  });
                }
                util.inherits(Zlib, Transform);
                Zlib.prototype.params = function(level, strategy, callback) {
                  if (level < exports2.Z_MIN_LEVEL || level > exports2.Z_MAX_LEVEL) {
                    throw new RangeError("Invalid compression level: " + level);
                  }
                  if (strategy != exports2.Z_FILTERED && strategy != exports2.Z_HUFFMAN_ONLY && strategy != exports2.Z_RLE && strategy != exports2.Z_FIXED && strategy != exports2.Z_DEFAULT_STRATEGY) {
                    throw new TypeError("Invalid strategy: " + strategy);
                  }
                  if (this._level !== level || this._strategy !== strategy) {
                    var self2 = this;
                    this.flush(binding.Z_SYNC_FLUSH, function() {
                      assert(self2._handle, "zlib binding closed");
                      self2._handle.params(level, strategy);
                      if (!self2._hadError) {
                        self2._level = level;
                        self2._strategy = strategy;
                        if (callback)
                          callback();
                      }
                    });
                  } else {
                    process.nextTick(callback);
                  }
                };
                Zlib.prototype.reset = function() {
                  assert(this._handle, "zlib binding closed");
                  return this._handle.reset();
                };
                Zlib.prototype._flush = function(callback) {
                  this._transform(Buffer.alloc(0), "", callback);
                };
                Zlib.prototype.flush = function(kind, callback) {
                  var _this2 = this;
                  var ws = this._writableState;
                  if (typeof kind === "function" || kind === void 0 && !callback) {
                    callback = kind;
                    kind = binding.Z_FULL_FLUSH;
                  }
                  if (ws.ended) {
                    if (callback)
                      process.nextTick(callback);
                  } else if (ws.ending) {
                    if (callback)
                      this.once("end", callback);
                  } else if (ws.needDrain) {
                    if (callback) {
                      this.once("drain", function() {
                        return _this2.flush(kind, callback);
                      });
                    }
                  } else {
                    this._flushFlag = kind;
                    this.write(Buffer.alloc(0), "", callback);
                  }
                };
                Zlib.prototype.close = function(callback) {
                  _close(this, callback);
                  process.nextTick(emitCloseNT, this);
                };
                function _close(engine, callback) {
                  if (callback)
                    process.nextTick(callback);
                  if (!engine._handle)
                    return;
                  engine._handle.close();
                  engine._handle = null;
                }
                function emitCloseNT(self2) {
                  self2.emit("close");
                }
                Zlib.prototype._transform = function(chunk, encoding, cb) {
                  var flushFlag;
                  var ws = this._writableState;
                  var ending = ws.ending || ws.ended;
                  var last = ending && (!chunk || ws.length === chunk.length);
                  if (chunk !== null && !Buffer.isBuffer(chunk))
                    return cb(new Error("invalid input"));
                  if (!this._handle)
                    return cb(new Error("zlib binding closed"));
                  if (last)
                    flushFlag = this._finishFlushFlag;
                  else {
                    flushFlag = this._flushFlag;
                    if (chunk.length >= ws.length) {
                      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
                    }
                  }
                  this._processChunk(chunk, flushFlag, cb);
                };
                Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
                  var availInBefore = chunk && chunk.length;
                  var availOutBefore = this._chunkSize - this._offset;
                  var inOff = 0;
                  var self2 = this;
                  var async = typeof cb === "function";
                  if (!async) {
                    var buffers = [];
                    var nread = 0;
                    var error;
                    this.on("error", function(er) {
                      error = er;
                    });
                    assert(this._handle, "zlib binding closed");
                    do {
                      var res = this._handle.writeSync(
                        flushFlag,
                        chunk,
                        // in
                        inOff,
                        // in_off
                        availInBefore,
                        // in_len
                        this._buffer,
                        // out
                        this._offset,
                        //out_off
                        availOutBefore
                      );
                    } while (!this._hadError && callback(res[0], res[1]));
                    if (this._hadError) {
                      throw error;
                    }
                    if (nread >= kMaxLength) {
                      _close(this);
                      throw new RangeError(kRangeErrorMessage);
                    }
                    var buf = Buffer.concat(buffers, nread);
                    _close(this);
                    return buf;
                  }
                  assert(this._handle, "zlib binding closed");
                  var req = this._handle.write(
                    flushFlag,
                    chunk,
                    // in
                    inOff,
                    // in_off
                    availInBefore,
                    // in_len
                    this._buffer,
                    // out
                    this._offset,
                    //out_off
                    availOutBefore
                  );
                  req.buffer = chunk;
                  req.callback = callback;
                  function callback(availInAfter, availOutAfter) {
                    if (this) {
                      this.buffer = null;
                      this.callback = null;
                    }
                    if (self2._hadError)
                      return;
                    var have = availOutBefore - availOutAfter;
                    assert(have >= 0, "have should not go down");
                    if (have > 0) {
                      var out = self2._buffer.slice(self2._offset, self2._offset + have);
                      self2._offset += have;
                      if (async) {
                        self2.push(out);
                      } else {
                        buffers.push(out);
                        nread += out.length;
                      }
                    }
                    if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
                      availOutBefore = self2._chunkSize;
                      self2._offset = 0;
                      self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
                    }
                    if (availOutAfter === 0) {
                      inOff += availInBefore - availInAfter;
                      availInBefore = availInAfter;
                      if (!async)
                        return true;
                      var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
                      newReq.callback = callback;
                      newReq.buffer = chunk;
                      return;
                    }
                    if (!async)
                      return false;
                    cb();
                  }
                };
                util.inherits(Deflate, Zlib);
                util.inherits(Inflate, Zlib);
                util.inherits(Gzip, Zlib);
                util.inherits(Gunzip, Zlib);
                util.inherits(DeflateRaw, Zlib);
                util.inherits(InflateRaw, Zlib);
                util.inherits(Unzip, Zlib);
              }
            ),
            /***/
            1924: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var GetIntrinsic = __webpack_require__2(210);
                var callBind = __webpack_require__2(5559);
                var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
                module2.exports = function callBoundIntrinsic(name, allowMissing) {
                  var intrinsic = GetIntrinsic(name, !!allowMissing);
                  if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
                    return callBind(intrinsic);
                  }
                  return intrinsic;
                };
              }
            ),
            /***/
            5559: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var bind = __webpack_require__2(8612);
                var GetIntrinsic = __webpack_require__2(210);
                var $apply = GetIntrinsic("%Function.prototype.apply%");
                var $call = GetIntrinsic("%Function.prototype.call%");
                var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
                var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
                var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
                var $max = GetIntrinsic("%Math.max%");
                if ($defineProperty) {
                  try {
                    $defineProperty({}, "a", { value: 1 });
                  } catch (e) {
                    $defineProperty = null;
                  }
                }
                module2.exports = function callBind(originalFunction) {
                  var func = $reflectApply(bind, $call, arguments);
                  if ($gOPD && $defineProperty) {
                    var desc = $gOPD(func, "length");
                    if (desc.configurable) {
                      $defineProperty(
                        func,
                        "length",
                        { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
                      );
                    }
                  }
                  return func;
                };
                var applyBind = function applyBind2() {
                  return $reflectApply(bind, $apply, arguments);
                };
                if ($defineProperty) {
                  $defineProperty(module2.exports, "apply", { value: applyBind });
                } else {
                  module2.exports.apply = applyBind;
                }
              }
            ),
            /***/
            6313: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var Buffer = __webpack_require__2(8823)["Buffer"];
                var clone = function() {
                  "use strict";
                  function clone2(parent, circular, depth, prototype) {
                    var filter;
                    if (typeof circular === "object") {
                      depth = circular.depth;
                      prototype = circular.prototype;
                      filter = circular.filter;
                      circular = circular.circular;
                    }
                    var allParents = [];
                    var allChildren = [];
                    var useBuffer = typeof Buffer != "undefined";
                    if (typeof circular == "undefined")
                      circular = true;
                    if (typeof depth == "undefined")
                      depth = Infinity;
                    function _clone(parent2, depth2) {
                      if (parent2 === null)
                        return null;
                      if (depth2 == 0)
                        return parent2;
                      var child;
                      var proto;
                      if (typeof parent2 != "object") {
                        return parent2;
                      }
                      if (clone2.__isArray(parent2)) {
                        child = [];
                      } else if (clone2.__isRegExp(parent2)) {
                        child = new RegExp(parent2.source, __getRegExpFlags(parent2));
                        if (parent2.lastIndex)
                          child.lastIndex = parent2.lastIndex;
                      } else if (clone2.__isDate(parent2)) {
                        child = new Date(parent2.getTime());
                      } else if (useBuffer && Buffer.isBuffer(parent2)) {
                        if (Buffer.allocUnsafe) {
                          child = Buffer.allocUnsafe(parent2.length);
                        } else {
                          child = new Buffer(parent2.length);
                        }
                        parent2.copy(child);
                        return child;
                      } else {
                        if (typeof prototype == "undefined") {
                          proto = Object.getPrototypeOf(parent2);
                          child = Object.create(proto);
                        } else {
                          child = Object.create(prototype);
                          proto = prototype;
                        }
                      }
                      if (circular) {
                        var index = allParents.indexOf(parent2);
                        if (index != -1) {
                          return allChildren[index];
                        }
                        allParents.push(parent2);
                        allChildren.push(child);
                      }
                      for (var i in parent2) {
                        var attrs;
                        if (proto) {
                          attrs = Object.getOwnPropertyDescriptor(proto, i);
                        }
                        if (attrs && attrs.set == null) {
                          continue;
                        }
                        child[i] = _clone(parent2[i], depth2 - 1);
                      }
                      return child;
                    }
                    return _clone(parent, depth);
                  }
                  clone2.clonePrototype = function clonePrototype(parent) {
                    if (parent === null)
                      return null;
                    var c = function() {
                    };
                    c.prototype = parent;
                    return new c();
                  };
                  function __objToStr(o) {
                    return Object.prototype.toString.call(o);
                  }
                  ;
                  clone2.__objToStr = __objToStr;
                  function __isDate(o) {
                    return typeof o === "object" && __objToStr(o) === "[object Date]";
                  }
                  ;
                  clone2.__isDate = __isDate;
                  function __isArray(o) {
                    return typeof o === "object" && __objToStr(o) === "[object Array]";
                  }
                  ;
                  clone2.__isArray = __isArray;
                  function __isRegExp(o) {
                    return typeof o === "object" && __objToStr(o) === "[object RegExp]";
                  }
                  ;
                  clone2.__isRegExp = __isRegExp;
                  function __getRegExpFlags(re) {
                    var flags = "";
                    if (re.global)
                      flags += "g";
                    if (re.ignoreCase)
                      flags += "i";
                    if (re.multiline)
                      flags += "m";
                    return flags;
                  }
                  ;
                  clone2.__getRegExpFlags = __getRegExpFlags;
                  return clone2;
                }();
                if (module2.exports) {
                  module2.exports = clone;
                }
              }
            ),
            /***/
            4667: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                __webpack_require__2(2479);
                var path = __webpack_require__2(857);
                module2.exports = path.Object.values;
              }
            ),
            /***/
            7633: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                __webpack_require__2(9170);
                __webpack_require__2(6992);
                __webpack_require__2(1539);
                __webpack_require__2(8674);
                __webpack_require__2(7922);
                __webpack_require__2(4668);
                __webpack_require__2(7727);
                __webpack_require__2(8783);
                var path = __webpack_require__2(857);
                module2.exports = path.Promise;
              }
            ),
            /***/
            3867: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var parent = __webpack_require__2(1150);
                __webpack_require__2(8628);
                __webpack_require__2(7314);
                __webpack_require__2(7479);
                __webpack_require__2(6290);
                module2.exports = parent;
              }
            ),
            /***/
            9662: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var isCallable = __webpack_require__2(614);
                var tryToString = __webpack_require__2(6330);
                var TypeError2 = global.TypeError;
                module2.exports = function(argument) {
                  if (isCallable(argument))
                    return argument;
                  throw TypeError2(tryToString(argument) + " is not a function");
                };
              }
            ),
            /***/
            9483: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var isConstructor = __webpack_require__2(4411);
                var tryToString = __webpack_require__2(6330);
                var TypeError2 = global.TypeError;
                module2.exports = function(argument) {
                  if (isConstructor(argument))
                    return argument;
                  throw TypeError2(tryToString(argument) + " is not a constructor");
                };
              }
            ),
            /***/
            6077: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var isCallable = __webpack_require__2(614);
                var String2 = global.String;
                var TypeError2 = global.TypeError;
                module2.exports = function(argument) {
                  if (typeof argument == "object" || isCallable(argument))
                    return argument;
                  throw TypeError2("Can't set " + String2(argument) + " as a prototype");
                };
              }
            ),
            /***/
            1223: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var wellKnownSymbol = __webpack_require__2(5112);
                var create = __webpack_require__2(30);
                var definePropertyModule = __webpack_require__2(3070);
                var UNSCOPABLES = wellKnownSymbol("unscopables");
                var ArrayPrototype = Array.prototype;
                if (ArrayPrototype[UNSCOPABLES] == void 0) {
                  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
                    configurable: true,
                    value: create(null)
                  });
                }
                module2.exports = function(key) {
                  ArrayPrototype[UNSCOPABLES][key] = true;
                };
              }
            ),
            /***/
            1530: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var charAt = __webpack_require__2(8710).charAt;
                module2.exports = function(S, index, unicode) {
                  return index + (unicode ? charAt(S, index).length : 1);
                };
              }
            ),
            /***/
            5787: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var isPrototypeOf = __webpack_require__2(7976);
                var TypeError2 = global.TypeError;
                module2.exports = function(it, Prototype) {
                  if (isPrototypeOf(Prototype, it))
                    return it;
                  throw TypeError2("Incorrect invocation");
                };
              }
            ),
            /***/
            9670: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var isObject = __webpack_require__2(111);
                var String2 = global.String;
                var TypeError2 = global.TypeError;
                module2.exports = function(argument) {
                  if (isObject(argument))
                    return argument;
                  throw TypeError2(String2(argument) + " is not an object");
                };
              }
            ),
            /***/
            1048: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var toObject = __webpack_require__2(7908);
                var toAbsoluteIndex = __webpack_require__2(1400);
                var lengthOfArrayLike = __webpack_require__2(6244);
                var min = Math.min;
                module2.exports = [].copyWithin || function copyWithin(target, start) {
                  var O = toObject(this);
                  var len = lengthOfArrayLike(O);
                  var to = toAbsoluteIndex(target, len);
                  var from = toAbsoluteIndex(start, len);
                  var end = arguments.length > 2 ? arguments[2] : void 0;
                  var count = min((end === void 0 ? len : toAbsoluteIndex(end, len)) - from, len - to);
                  var inc = 1;
                  if (from < to && to < from + count) {
                    inc = -1;
                    from += count - 1;
                    to += count - 1;
                  }
                  while (count-- > 0) {
                    if (from in O)
                      O[to] = O[from];
                    else
                      delete O[to];
                    to += inc;
                    from += inc;
                  }
                  return O;
                };
              }
            ),
            /***/
            1285: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var toObject = __webpack_require__2(7908);
                var toAbsoluteIndex = __webpack_require__2(1400);
                var lengthOfArrayLike = __webpack_require__2(6244);
                module2.exports = function fill(value) {
                  var O = toObject(this);
                  var length = lengthOfArrayLike(O);
                  var argumentsLength = arguments.length;
                  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : void 0, length);
                  var end = argumentsLength > 2 ? arguments[2] : void 0;
                  var endPos = end === void 0 ? length : toAbsoluteIndex(end, length);
                  while (endPos > index)
                    O[index++] = value;
                  return O;
                };
              }
            ),
            /***/
            8533: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $forEach = __webpack_require__2(2092).forEach;
                var arrayMethodIsStrict = __webpack_require__2(9341);
                var STRICT_METHOD = arrayMethodIsStrict("forEach");
                module2.exports = !STRICT_METHOD ? function forEach(callbackfn) {
                  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                } : [].forEach;
              }
            ),
            /***/
            7745: (
              /***/
              function(module2) {
                module2.exports = function(Constructor, list) {
                  var index = 0;
                  var length = list.length;
                  var result = new Constructor(length);
                  while (length > index)
                    result[index] = list[index++];
                  return result;
                };
              }
            ),
            /***/
            8457: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var global = __webpack_require__2(7854);
                var bind = __webpack_require__2(9974);
                var call = __webpack_require__2(6916);
                var toObject = __webpack_require__2(7908);
                var callWithSafeIterationClosing = __webpack_require__2(3411);
                var isArrayIteratorMethod = __webpack_require__2(7659);
                var isConstructor = __webpack_require__2(4411);
                var lengthOfArrayLike = __webpack_require__2(6244);
                var createProperty = __webpack_require__2(6135);
                var getIterator = __webpack_require__2(8554);
                var getIteratorMethod = __webpack_require__2(1246);
                var Array2 = global.Array;
                module2.exports = function from(arrayLike) {
                  var O = toObject(arrayLike);
                  var IS_CONSTRUCTOR = isConstructor(this);
                  var argumentsLength = arguments.length;
                  var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
                  var mapping = mapfn !== void 0;
                  if (mapping)
                    mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : void 0);
                  var iteratorMethod = getIteratorMethod(O);
                  var index = 0;
                  var length, result, step, iterator, next, value;
                  if (iteratorMethod && !(this == Array2 && isArrayIteratorMethod(iteratorMethod))) {
                    iterator = getIterator(O, iteratorMethod);
                    next = iterator.next;
                    result = IS_CONSTRUCTOR ? new this() : [];
                    for (; !(step = call(next, iterator)).done; index++) {
                      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
                      createProperty(result, index, value);
                    }
                  } else {
                    length = lengthOfArrayLike(O);
                    result = IS_CONSTRUCTOR ? new this(length) : Array2(length);
                    for (; length > index; index++) {
                      value = mapping ? mapfn(O[index], index) : O[index];
                      createProperty(result, index, value);
                    }
                  }
                  result.length = index;
                  return result;
                };
              }
            ),
            /***/
            1318: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var toIndexedObject = __webpack_require__2(5656);
                var toAbsoluteIndex = __webpack_require__2(1400);
                var lengthOfArrayLike = __webpack_require__2(6244);
                var createMethod = function(IS_INCLUDES) {
                  return function($this, el, fromIndex) {
                    var O = toIndexedObject($this);
                    var length = lengthOfArrayLike(O);
                    var index = toAbsoluteIndex(fromIndex, length);
                    var value;
                    if (IS_INCLUDES && el != el)
                      while (length > index) {
                        value = O[index++];
                        if (value != value)
                          return true;
                      }
                    else
                      for (; length > index; index++) {
                        if ((IS_INCLUDES || index in O) && O[index] === el)
                          return IS_INCLUDES || index || 0;
                      }
                    return !IS_INCLUDES && -1;
                  };
                };
                module2.exports = {
                  // `Array.prototype.includes` method
                  // https://tc39.es/ecma262/#sec-array.prototype.includes
                  includes: createMethod(true),
                  // `Array.prototype.indexOf` method
                  // https://tc39.es/ecma262/#sec-array.prototype.indexof
                  indexOf: createMethod(false)
                };
              }
            ),
            /***/
            2092: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var bind = __webpack_require__2(9974);
                var uncurryThis = __webpack_require__2(1702);
                var IndexedObject = __webpack_require__2(8361);
                var toObject = __webpack_require__2(7908);
                var lengthOfArrayLike = __webpack_require__2(6244);
                var arraySpeciesCreate = __webpack_require__2(5417);
                var push = uncurryThis([].push);
                var createMethod = function(TYPE) {
                  var IS_MAP = TYPE == 1;
                  var IS_FILTER = TYPE == 2;
                  var IS_SOME = TYPE == 3;
                  var IS_EVERY = TYPE == 4;
                  var IS_FIND_INDEX = TYPE == 6;
                  var IS_FILTER_REJECT = TYPE == 7;
                  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
                  return function($this, callbackfn, that, specificCreate) {
                    var O = toObject($this);
                    var self2 = IndexedObject(O);
                    var boundFunction = bind(callbackfn, that);
                    var length = lengthOfArrayLike(self2);
                    var index = 0;
                    var create = specificCreate || arraySpeciesCreate;
                    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : void 0;
                    var value, result;
                    for (; length > index; index++)
                      if (NO_HOLES || index in self2) {
                        value = self2[index];
                        result = boundFunction(value, index, O);
                        if (TYPE) {
                          if (IS_MAP)
                            target[index] = result;
                          else if (result)
                            switch (TYPE) {
                              case 3:
                                return true;
                              case 5:
                                return value;
                              case 6:
                                return index;
                              case 2:
                                push(target, value);
                            }
                          else
                            switch (TYPE) {
                              case 4:
                                return false;
                              case 7:
                                push(target, value);
                            }
                        }
                      }
                    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
                  };
                };
                module2.exports = {
                  // `Array.prototype.forEach` method
                  // https://tc39.es/ecma262/#sec-array.prototype.foreach
                  forEach: createMethod(0),
                  // `Array.prototype.map` method
                  // https://tc39.es/ecma262/#sec-array.prototype.map
                  map: createMethod(1),
                  // `Array.prototype.filter` method
                  // https://tc39.es/ecma262/#sec-array.prototype.filter
                  filter: createMethod(2),
                  // `Array.prototype.some` method
                  // https://tc39.es/ecma262/#sec-array.prototype.some
                  some: createMethod(3),
                  // `Array.prototype.every` method
                  // https://tc39.es/ecma262/#sec-array.prototype.every
                  every: createMethod(4),
                  // `Array.prototype.find` method
                  // https://tc39.es/ecma262/#sec-array.prototype.find
                  find: createMethod(5),
                  // `Array.prototype.findIndex` method
                  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
                  findIndex: createMethod(6),
                  // `Array.prototype.filterReject` method
                  // https://github.com/tc39/proposal-array-filtering
                  filterReject: createMethod(7)
                };
              }
            ),
            /***/
            6583: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var apply = __webpack_require__2(2104);
                var toIndexedObject = __webpack_require__2(5656);
                var toIntegerOrInfinity = __webpack_require__2(9303);
                var lengthOfArrayLike = __webpack_require__2(6244);
                var arrayMethodIsStrict = __webpack_require__2(9341);
                var min = Math.min;
                var $lastIndexOf = [].lastIndexOf;
                var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
                var STRICT_METHOD = arrayMethodIsStrict("lastIndexOf");
                var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;
                module2.exports = FORCED ? function lastIndexOf(searchElement) {
                  if (NEGATIVE_ZERO)
                    return apply($lastIndexOf, this, arguments) || 0;
                  var O = toIndexedObject(this);
                  var length = lengthOfArrayLike(O);
                  var index = length - 1;
                  if (arguments.length > 1)
                    index = min(index, toIntegerOrInfinity(arguments[1]));
                  if (index < 0)
                    index = length + index;
                  for (; index >= 0; index--)
                    if (index in O && O[index] === searchElement)
                      return index || 0;
                  return -1;
                } : $lastIndexOf;
              }
            ),
            /***/
            1194: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var fails = __webpack_require__2(7293);
                var wellKnownSymbol = __webpack_require__2(5112);
                var V8_VERSION = __webpack_require__2(7392);
                var SPECIES = wellKnownSymbol("species");
                module2.exports = function(METHOD_NAME) {
                  return V8_VERSION >= 51 || !fails(function() {
                    var array = [];
                    var constructor = array.constructor = {};
                    constructor[SPECIES] = function() {
                      return { foo: 1 };
                    };
                    return array[METHOD_NAME](Boolean).foo !== 1;
                  });
                };
              }
            ),
            /***/
            9341: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var fails = __webpack_require__2(7293);
                module2.exports = function(METHOD_NAME, argument) {
                  var method = [][METHOD_NAME];
                  return !!method && fails(function() {
                    method.call(null, argument || function() {
                      throw 1;
                    }, 1);
                  });
                };
              }
            ),
            /***/
            3671: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var aCallable = __webpack_require__2(9662);
                var toObject = __webpack_require__2(7908);
                var IndexedObject = __webpack_require__2(8361);
                var lengthOfArrayLike = __webpack_require__2(6244);
                var TypeError2 = global.TypeError;
                var createMethod = function(IS_RIGHT) {
                  return function(that, callbackfn, argumentsLength, memo) {
                    aCallable(callbackfn);
                    var O = toObject(that);
                    var self2 = IndexedObject(O);
                    var length = lengthOfArrayLike(O);
                    var index = IS_RIGHT ? length - 1 : 0;
                    var i = IS_RIGHT ? -1 : 1;
                    if (argumentsLength < 2)
                      while (true) {
                        if (index in self2) {
                          memo = self2[index];
                          index += i;
                          break;
                        }
                        index += i;
                        if (IS_RIGHT ? index < 0 : length <= index) {
                          throw TypeError2("Reduce of empty array with no initial value");
                        }
                      }
                    for (; IS_RIGHT ? index >= 0 : length > index; index += i)
                      if (index in self2) {
                        memo = callbackfn(memo, self2[index], index, O);
                      }
                    return memo;
                  };
                };
                module2.exports = {
                  // `Array.prototype.reduce` method
                  // https://tc39.es/ecma262/#sec-array.prototype.reduce
                  left: createMethod(false),
                  // `Array.prototype.reduceRight` method
                  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
                  right: createMethod(true)
                };
              }
            ),
            /***/
            206: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var uncurryThis = __webpack_require__2(1702);
                module2.exports = uncurryThis([].slice);
              }
            ),
            /***/
            4362: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var arraySlice = __webpack_require__2(206);
                var floor = Math.floor;
                var mergeSort = function(array, comparefn) {
                  var length = array.length;
                  var middle = floor(length / 2);
                  return length < 8 ? insertionSort(array, comparefn) : merge(
                    array,
                    mergeSort(arraySlice(array, 0, middle), comparefn),
                    mergeSort(arraySlice(array, middle), comparefn),
                    comparefn
                  );
                };
                var insertionSort = function(array, comparefn) {
                  var length = array.length;
                  var i = 1;
                  var element, j;
                  while (i < length) {
                    j = i;
                    element = array[i];
                    while (j && comparefn(array[j - 1], element) > 0) {
                      array[j] = array[--j];
                    }
                    if (j !== i++)
                      array[j] = element;
                  }
                  return array;
                };
                var merge = function(array, left, right, comparefn) {
                  var llength = left.length;
                  var rlength = right.length;
                  var lindex = 0;
                  var rindex = 0;
                  while (lindex < llength || rindex < rlength) {
                    array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
                  }
                  return array;
                };
                module2.exports = mergeSort;
              }
            ),
            /***/
            7475: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var isArray = __webpack_require__2(3157);
                var isConstructor = __webpack_require__2(4411);
                var isObject = __webpack_require__2(111);
                var wellKnownSymbol = __webpack_require__2(5112);
                var SPECIES = wellKnownSymbol("species");
                var Array2 = global.Array;
                module2.exports = function(originalArray) {
                  var C;
                  if (isArray(originalArray)) {
                    C = originalArray.constructor;
                    if (isConstructor(C) && (C === Array2 || isArray(C.prototype)))
                      C = void 0;
                    else if (isObject(C)) {
                      C = C[SPECIES];
                      if (C === null)
                        C = void 0;
                    }
                  }
                  return C === void 0 ? Array2 : C;
                };
              }
            ),
            /***/
            5417: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var arraySpeciesConstructor = __webpack_require__2(7475);
                module2.exports = function(originalArray, length) {
                  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
                };
              }
            ),
            /***/
            3411: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var anObject = __webpack_require__2(9670);
                var iteratorClose = __webpack_require__2(9212);
                module2.exports = function(iterator, fn, value, ENTRIES) {
                  try {
                    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
                  } catch (error) {
                    iteratorClose(iterator, "throw", error);
                  }
                };
              }
            ),
            /***/
            7072: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var wellKnownSymbol = __webpack_require__2(5112);
                var ITERATOR = wellKnownSymbol("iterator");
                var SAFE_CLOSING = false;
                try {
                  var called = 0;
                  var iteratorWithReturn = {
                    next: function() {
                      return { done: !!called++ };
                    },
                    "return": function() {
                      SAFE_CLOSING = true;
                    }
                  };
                  iteratorWithReturn[ITERATOR] = function() {
                    return this;
                  };
                  Array.from(iteratorWithReturn, function() {
                    throw 2;
                  });
                } catch (error) {
                }
                module2.exports = function(exec, SKIP_CLOSING) {
                  if (!SKIP_CLOSING && !SAFE_CLOSING)
                    return false;
                  var ITERATION_SUPPORT = false;
                  try {
                    var object = {};
                    object[ITERATOR] = function() {
                      return {
                        next: function() {
                          return { done: ITERATION_SUPPORT = true };
                        }
                      };
                    };
                    exec(object);
                  } catch (error) {
                  }
                  return ITERATION_SUPPORT;
                };
              }
            ),
            /***/
            4326: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var uncurryThis = __webpack_require__2(1702);
                var toString = uncurryThis({}.toString);
                var stringSlice = uncurryThis("".slice);
                module2.exports = function(it) {
                  return stringSlice(toString(it), 8, -1);
                };
              }
            ),
            /***/
            648: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var TO_STRING_TAG_SUPPORT = __webpack_require__2(1694);
                var isCallable = __webpack_require__2(614);
                var classofRaw = __webpack_require__2(4326);
                var wellKnownSymbol = __webpack_require__2(5112);
                var TO_STRING_TAG = wellKnownSymbol("toStringTag");
                var Object2 = global.Object;
                var CORRECT_ARGUMENTS = classofRaw(function() {
                  return arguments;
                }()) == "Arguments";
                var tryGet = function(it, key) {
                  try {
                    return it[key];
                  } catch (error) {
                  }
                };
                module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
                  var O, tag, result;
                  return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object2(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && isCallable(O.callee) ? "Arguments" : result;
                };
              }
            ),
            /***/
            7741: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var uncurryThis = __webpack_require__2(1702);
                var arraySlice = __webpack_require__2(206);
                var replace = uncurryThis("".replace);
                var split = uncurryThis("".split);
                var join = uncurryThis([].join);
                var TEST = function(arg) {
                  return String(Error(arg).stack);
                }("zxcasd");
                var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
                var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
                var IS_FIREFOX_OR_SAFARI_STACK = /@[^\n]*\n/.test(TEST) && !/zxcasd/.test(TEST);
                module2.exports = function(stack, dropEntries) {
                  if (typeof stack != "string")
                    return stack;
                  if (IS_V8_OR_CHAKRA_STACK) {
                    while (dropEntries--)
                      stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, "");
                  } else if (IS_FIREFOX_OR_SAFARI_STACK) {
                    return join(arraySlice(split(stack, "\n"), dropEntries), "\n");
                  }
                  return stack;
                };
              }
            ),
            /***/
            5631: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var defineProperty = __webpack_require__2(3070).f;
                var create = __webpack_require__2(30);
                var redefineAll = __webpack_require__2(2248);
                var bind = __webpack_require__2(9974);
                var anInstance = __webpack_require__2(5787);
                var iterate = __webpack_require__2(408);
                var defineIterator = __webpack_require__2(654);
                var setSpecies = __webpack_require__2(6340);
                var DESCRIPTORS = __webpack_require__2(9781);
                var fastKey = __webpack_require__2(2423).fastKey;
                var InternalStateModule = __webpack_require__2(9909);
                var setInternalState = InternalStateModule.set;
                var internalStateGetterFor = InternalStateModule.getterFor;
                module2.exports = {
                  getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
                    var Constructor = wrapper(function(that, iterable) {
                      anInstance(that, Prototype);
                      setInternalState(that, {
                        type: CONSTRUCTOR_NAME,
                        index: create(null),
                        first: void 0,
                        last: void 0,
                        size: 0
                      });
                      if (!DESCRIPTORS)
                        that.size = 0;
                      if (iterable != void 0)
                        iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
                    });
                    var Prototype = Constructor.prototype;
                    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
                    var define2 = function(that, key, value) {
                      var state = getInternalState(that);
                      var entry = getEntry(that, key);
                      var previous, index;
                      if (entry) {
                        entry.value = value;
                      } else {
                        state.last = entry = {
                          index: index = fastKey(key, true),
                          key,
                          value,
                          previous: previous = state.last,
                          next: void 0,
                          removed: false
                        };
                        if (!state.first)
                          state.first = entry;
                        if (previous)
                          previous.next = entry;
                        if (DESCRIPTORS)
                          state.size++;
                        else
                          that.size++;
                        if (index !== "F")
                          state.index[index] = entry;
                      }
                      return that;
                    };
                    var getEntry = function(that, key) {
                      var state = getInternalState(that);
                      var index = fastKey(key);
                      var entry;
                      if (index !== "F")
                        return state.index[index];
                      for (entry = state.first; entry; entry = entry.next) {
                        if (entry.key == key)
                          return entry;
                      }
                    };
                    redefineAll(Prototype, {
                      // `{ Map, Set }.prototype.clear()` methods
                      // https://tc39.es/ecma262/#sec-map.prototype.clear
                      // https://tc39.es/ecma262/#sec-set.prototype.clear
                      clear: function clear() {
                        var that = this;
                        var state = getInternalState(that);
                        var data = state.index;
                        var entry = state.first;
                        while (entry) {
                          entry.removed = true;
                          if (entry.previous)
                            entry.previous = entry.previous.next = void 0;
                          delete data[entry.index];
                          entry = entry.next;
                        }
                        state.first = state.last = void 0;
                        if (DESCRIPTORS)
                          state.size = 0;
                        else
                          that.size = 0;
                      },
                      // `{ Map, Set }.prototype.delete(key)` methods
                      // https://tc39.es/ecma262/#sec-map.prototype.delete
                      // https://tc39.es/ecma262/#sec-set.prototype.delete
                      "delete": function(key) {
                        var that = this;
                        var state = getInternalState(that);
                        var entry = getEntry(that, key);
                        if (entry) {
                          var next = entry.next;
                          var prev = entry.previous;
                          delete state.index[entry.index];
                          entry.removed = true;
                          if (prev)
                            prev.next = next;
                          if (next)
                            next.previous = prev;
                          if (state.first == entry)
                            state.first = next;
                          if (state.last == entry)
                            state.last = prev;
                          if (DESCRIPTORS)
                            state.size--;
                          else
                            that.size--;
                        }
                        return !!entry;
                      },
                      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
                      // https://tc39.es/ecma262/#sec-map.prototype.foreach
                      // https://tc39.es/ecma262/#sec-set.prototype.foreach
                      forEach: function forEach(callbackfn) {
                        var state = getInternalState(this);
                        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                        var entry;
                        while (entry = entry ? entry.next : state.first) {
                          boundFunction(entry.value, entry.key, this);
                          while (entry && entry.removed)
                            entry = entry.previous;
                        }
                      },
                      // `{ Map, Set}.prototype.has(key)` methods
                      // https://tc39.es/ecma262/#sec-map.prototype.has
                      // https://tc39.es/ecma262/#sec-set.prototype.has
                      has: function has(key) {
                        return !!getEntry(this, key);
                      }
                    });
                    redefineAll(Prototype, IS_MAP ? {
                      // `Map.prototype.get(key)` method
                      // https://tc39.es/ecma262/#sec-map.prototype.get
                      get: function get(key) {
                        var entry = getEntry(this, key);
                        return entry && entry.value;
                      },
                      // `Map.prototype.set(key, value)` method
                      // https://tc39.es/ecma262/#sec-map.prototype.set
                      set: function set(key, value) {
                        return define2(this, key === 0 ? 0 : key, value);
                      }
                    } : {
                      // `Set.prototype.add(value)` method
                      // https://tc39.es/ecma262/#sec-set.prototype.add
                      add: function add(value) {
                        return define2(this, value = value === 0 ? 0 : value, value);
                      }
                    });
                    if (DESCRIPTORS)
                      defineProperty(Prototype, "size", {
                        get: function() {
                          return getInternalState(this).size;
                        }
                      });
                    return Constructor;
                  },
                  setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
                    var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
                    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
                    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
                    defineIterator(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {
                      setInternalState(this, {
                        type: ITERATOR_NAME,
                        target: iterated,
                        state: getInternalCollectionState(iterated),
                        kind,
                        last: void 0
                      });
                    }, function() {
                      var state = getInternalIteratorState(this);
                      var kind = state.kind;
                      var entry = state.last;
                      while (entry && entry.removed)
                        entry = entry.previous;
                      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
                        state.target = void 0;
                        return { value: void 0, done: true };
                      }
                      if (kind == "keys")
                        return { value: entry.key, done: false };
                      if (kind == "values")
                        return { value: entry.value, done: false };
                      return { value: [entry.key, entry.value], done: false };
                    }, IS_MAP ? "entries" : "values", !IS_MAP, true);
                    setSpecies(CONSTRUCTOR_NAME);
                  }
                };
              }
            ),
            /***/
            7710: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var global = __webpack_require__2(7854);
                var uncurryThis = __webpack_require__2(1702);
                var isForced = __webpack_require__2(4705);
                var redefine = __webpack_require__2(1320);
                var InternalMetadataModule = __webpack_require__2(2423);
                var iterate = __webpack_require__2(408);
                var anInstance = __webpack_require__2(5787);
                var isCallable = __webpack_require__2(614);
                var isObject = __webpack_require__2(111);
                var fails = __webpack_require__2(7293);
                var checkCorrectnessOfIteration = __webpack_require__2(7072);
                var setToStringTag = __webpack_require__2(8003);
                var inheritIfRequired = __webpack_require__2(9587);
                module2.exports = function(CONSTRUCTOR_NAME, wrapper, common) {
                  var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
                  var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
                  var ADDER = IS_MAP ? "set" : "add";
                  var NativeConstructor = global[CONSTRUCTOR_NAME];
                  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
                  var Constructor = NativeConstructor;
                  var exported = {};
                  var fixMethod = function(KEY) {
                    var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
                    redefine(
                      NativePrototype,
                      KEY,
                      KEY == "add" ? function add(value) {
                        uncurriedNativeMethod(this, value === 0 ? 0 : value);
                        return this;
                      } : KEY == "delete" ? function(key) {
                        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
                      } : KEY == "get" ? function get(key) {
                        return IS_WEAK && !isObject(key) ? void 0 : uncurriedNativeMethod(this, key === 0 ? 0 : key);
                      } : KEY == "has" ? function has(key) {
                        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
                      } : function set(key, value) {
                        uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
                        return this;
                      }
                    );
                  };
                  var REPLACE = isForced(
                    CONSTRUCTOR_NAME,
                    !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function() {
                      new NativeConstructor().entries().next();
                    }))
                  );
                  if (REPLACE) {
                    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
                    InternalMetadataModule.enable();
                  } else if (isForced(CONSTRUCTOR_NAME, true)) {
                    var instance = new Constructor();
                    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
                    var THROWS_ON_PRIMITIVES = fails(function() {
                      instance.has(1);
                    });
                    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(iterable) {
                      new NativeConstructor(iterable);
                    });
                    var BUGGY_ZERO = !IS_WEAK && fails(function() {
                      var $instance = new NativeConstructor();
                      var index = 5;
                      while (index--)
                        $instance[ADDER](index, index);
                      return !$instance.has(-0);
                    });
                    if (!ACCEPT_ITERABLES) {
                      Constructor = wrapper(function(dummy, iterable) {
                        anInstance(dummy, NativePrototype);
                        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
                        if (iterable != void 0)
                          iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
                        return that;
                      });
                      Constructor.prototype = NativePrototype;
                      NativePrototype.constructor = Constructor;
                    }
                    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
                      fixMethod("delete");
                      fixMethod("has");
                      IS_MAP && fixMethod("get");
                    }
                    if (BUGGY_ZERO || HASNT_CHAINING)
                      fixMethod(ADDER);
                    if (IS_WEAK && NativePrototype.clear)
                      delete NativePrototype.clear;
                  }
                  exported[CONSTRUCTOR_NAME] = Constructor;
                  $({ global: true, forced: Constructor != NativeConstructor }, exported);
                  setToStringTag(Constructor, CONSTRUCTOR_NAME);
                  if (!IS_WEAK)
                    common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
                  return Constructor;
                };
              }
            ),
            /***/
            9920: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var hasOwn = __webpack_require__2(2597);
                var ownKeys = __webpack_require__2(3887);
                var getOwnPropertyDescriptorModule = __webpack_require__2(1236);
                var definePropertyModule = __webpack_require__2(3070);
                module2.exports = function(target, source) {
                  var keys = ownKeys(source);
                  var defineProperty = definePropertyModule.f;
                  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                  for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    if (!hasOwn(target, key))
                      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
                  }
                };
              }
            ),
            /***/
            4964: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var wellKnownSymbol = __webpack_require__2(5112);
                var MATCH = wellKnownSymbol("match");
                module2.exports = function(METHOD_NAME) {
                  var regexp = /./;
                  try {
                    "/./"[METHOD_NAME](regexp);
                  } catch (error1) {
                    try {
                      regexp[MATCH] = false;
                      return "/./"[METHOD_NAME](regexp);
                    } catch (error2) {
                    }
                  }
                  return false;
                };
              }
            ),
            /***/
            8544: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var fails = __webpack_require__2(7293);
                module2.exports = !fails(function() {
                  function F() {
                  }
                  F.prototype.constructor = null;
                  return Object.getPrototypeOf(new F()) !== F.prototype;
                });
              }
            ),
            /***/
            4230: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var uncurryThis = __webpack_require__2(1702);
                var requireObjectCoercible = __webpack_require__2(4488);
                var toString = __webpack_require__2(1340);
                var quot = /"/g;
                var replace = uncurryThis("".replace);
                module2.exports = function(string, tag, attribute, value) {
                  var S = toString(requireObjectCoercible(string));
                  var p1 = "<" + tag;
                  if (attribute !== "")
                    p1 += " " + attribute + '="' + replace(toString(value), quot, "&quot;") + '"';
                  return p1 + ">" + S + "</" + tag + ">";
                };
              }
            ),
            /***/
            4994: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var IteratorPrototype = __webpack_require__2(3383).IteratorPrototype;
                var create = __webpack_require__2(30);
                var createPropertyDescriptor = __webpack_require__2(9114);
                var setToStringTag = __webpack_require__2(8003);
                var Iterators = __webpack_require__2(7497);
                var returnThis = function() {
                  return this;
                };
                module2.exports = function(IteratorConstructor, NAME, next) {
                  var TO_STRING_TAG = NAME + " Iterator";
                  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
                  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
                  Iterators[TO_STRING_TAG] = returnThis;
                  return IteratorConstructor;
                };
              }
            ),
            /***/
            8880: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var DESCRIPTORS = __webpack_require__2(9781);
                var definePropertyModule = __webpack_require__2(3070);
                var createPropertyDescriptor = __webpack_require__2(9114);
                module2.exports = DESCRIPTORS ? function(object, key, value) {
                  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
                } : function(object, key, value) {
                  object[key] = value;
                  return object;
                };
              }
            ),
            /***/
            9114: (
              /***/
              function(module2) {
                module2.exports = function(bitmap, value) {
                  return {
                    enumerable: !(bitmap & 1),
                    configurable: !(bitmap & 2),
                    writable: !(bitmap & 4),
                    value
                  };
                };
              }
            ),
            /***/
            6135: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var toPropertyKey = __webpack_require__2(4948);
                var definePropertyModule = __webpack_require__2(3070);
                var createPropertyDescriptor = __webpack_require__2(9114);
                module2.exports = function(object, key, value) {
                  var propertyKey = toPropertyKey(key);
                  if (propertyKey in object)
                    definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
                  else
                    object[propertyKey] = value;
                };
              }
            ),
            /***/
            8709: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var global = __webpack_require__2(7854);
                var anObject = __webpack_require__2(9670);
                var ordinaryToPrimitive = __webpack_require__2(2140);
                var TypeError2 = global.TypeError;
                module2.exports = function(hint) {
                  anObject(this);
                  if (hint === "string" || hint === "default")
                    hint = "string";
                  else if (hint !== "number")
                    throw TypeError2("Incorrect hint");
                  return ordinaryToPrimitive(this, hint);
                };
              }
            ),
            /***/
            654: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var call = __webpack_require__2(6916);
                var IS_PURE = __webpack_require__2(1913);
                var FunctionName = __webpack_require__2(6530);
                var isCallable = __webpack_require__2(614);
                var createIteratorConstructor = __webpack_require__2(4994);
                var getPrototypeOf = __webpack_require__2(9518);
                var setPrototypeOf = __webpack_require__2(7674);
                var setToStringTag = __webpack_require__2(8003);
                var createNonEnumerableProperty = __webpack_require__2(8880);
                var redefine = __webpack_require__2(1320);
                var wellKnownSymbol = __webpack_require__2(5112);
                var Iterators = __webpack_require__2(7497);
                var IteratorsCore = __webpack_require__2(3383);
                var PROPER_FUNCTION_NAME = FunctionName.PROPER;
                var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
                var IteratorPrototype = IteratorsCore.IteratorPrototype;
                var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
                var ITERATOR = wellKnownSymbol("iterator");
                var KEYS = "keys";
                var VALUES = "values";
                var ENTRIES = "entries";
                var returnThis = function() {
                  return this;
                };
                module2.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
                  createIteratorConstructor(IteratorConstructor, NAME, next);
                  var getIterationMethod = function(KIND) {
                    if (KIND === DEFAULT && defaultIterator)
                      return defaultIterator;
                    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
                      return IterablePrototype[KIND];
                    switch (KIND) {
                      case KEYS:
                        return function keys() {
                          return new IteratorConstructor(this, KIND);
                        };
                      case VALUES:
                        return function values() {
                          return new IteratorConstructor(this, KIND);
                        };
                      case ENTRIES:
                        return function entries() {
                          return new IteratorConstructor(this, KIND);
                        };
                    }
                    return function() {
                      return new IteratorConstructor(this);
                    };
                  };
                  var TO_STRING_TAG = NAME + " Iterator";
                  var INCORRECT_VALUES_NAME = false;
                  var IterablePrototype = Iterable.prototype;
                  var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
                  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
                  var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
                  var CurrentIteratorPrototype, methods, KEY;
                  if (anyNativeIterator) {
                    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
                    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
                      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                        if (setPrototypeOf) {
                          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
                          redefine(CurrentIteratorPrototype, ITERATOR, returnThis);
                        }
                      }
                      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
                      if (IS_PURE)
                        Iterators[TO_STRING_TAG] = returnThis;
                    }
                  }
                  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
                    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
                      createNonEnumerableProperty(IterablePrototype, "name", VALUES);
                    } else {
                      INCORRECT_VALUES_NAME = true;
                      defaultIterator = function values() {
                        return call(nativeIterator, this);
                      };
                    }
                  }
                  if (DEFAULT) {
                    methods = {
                      values: getIterationMethod(VALUES),
                      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                      entries: getIterationMethod(ENTRIES)
                    };
                    if (FORCED)
                      for (KEY in methods) {
                        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                          redefine(IterablePrototype, KEY, methods[KEY]);
                        }
                      }
                    else
                      $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
                  }
                  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
                    redefine(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
                  }
                  Iterators[NAME] = defaultIterator;
                  return methods;
                };
              }
            ),
            /***/
            7235: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var path = __webpack_require__2(857);
                var hasOwn = __webpack_require__2(2597);
                var wrappedWellKnownSymbolModule = __webpack_require__2(6061);
                var defineProperty = __webpack_require__2(3070).f;
                module2.exports = function(NAME) {
                  var Symbol2 = path.Symbol || (path.Symbol = {});
                  if (!hasOwn(Symbol2, NAME))
                    defineProperty(Symbol2, NAME, {
                      value: wrappedWellKnownSymbolModule.f(NAME)
                    });
                };
              }
            ),
            /***/
            9781: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var fails = __webpack_require__2(7293);
                module2.exports = !fails(function() {
                  return Object.defineProperty({}, 1, { get: function() {
                    return 7;
                  } })[1] != 7;
                });
              }
            ),
            /***/
            317: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var isObject = __webpack_require__2(111);
                var document2 = global.document;
                var EXISTS = isObject(document2) && isObject(document2.createElement);
                module2.exports = function(it) {
                  return EXISTS ? document2.createElement(it) : {};
                };
              }
            ),
            /***/
            8324: (
              /***/
              function(module2) {
                module2.exports = {
                  CSSRuleList: 0,
                  CSSStyleDeclaration: 0,
                  CSSValueList: 0,
                  ClientRectList: 0,
                  DOMRectList: 0,
                  DOMStringList: 0,
                  DOMTokenList: 1,
                  DataTransferItemList: 0,
                  FileList: 0,
                  HTMLAllCollection: 0,
                  HTMLCollection: 0,
                  HTMLFormElement: 0,
                  HTMLSelectElement: 0,
                  MediaList: 0,
                  MimeTypeArray: 0,
                  NamedNodeMap: 0,
                  NodeList: 1,
                  PaintRequestList: 0,
                  Plugin: 0,
                  PluginArray: 0,
                  SVGLengthList: 0,
                  SVGNumberList: 0,
                  SVGPathSegList: 0,
                  SVGPointList: 0,
                  SVGStringList: 0,
                  SVGTransformList: 0,
                  SourceBufferList: 0,
                  StyleSheetList: 0,
                  TextTrackCueList: 0,
                  TextTrackList: 0,
                  TouchList: 0
                };
              }
            ),
            /***/
            8509: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var documentCreateElement = __webpack_require__2(317);
                var classList = documentCreateElement("span").classList;
                var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
                module2.exports = DOMTokenListPrototype === Object.prototype ? void 0 : DOMTokenListPrototype;
              }
            ),
            /***/
            8886: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var userAgent = __webpack_require__2(8113);
                var firefox = userAgent.match(/firefox\/(\d+)/i);
                module2.exports = !!firefox && +firefox[1];
              }
            ),
            /***/
            7871: (
              /***/
              function(module2) {
                module2.exports = typeof window == "object";
              }
            ),
            /***/
            256: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var UA = __webpack_require__2(8113);
                module2.exports = /MSIE|Trident/.test(UA);
              }
            ),
            /***/
            1528: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var userAgent = __webpack_require__2(8113);
                var global = __webpack_require__2(7854);
                module2.exports = /ipad|iphone|ipod/i.test(userAgent) && global.Pebble !== void 0;
              }
            ),
            /***/
            6833: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var userAgent = __webpack_require__2(8113);
                module2.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
              }
            ),
            /***/
            5268: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var classof = __webpack_require__2(4326);
                var global = __webpack_require__2(7854);
                module2.exports = classof(global.process) == "process";
              }
            ),
            /***/
            1036: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var userAgent = __webpack_require__2(8113);
                module2.exports = /web0s(?!.*chrome)/i.test(userAgent);
              }
            ),
            /***/
            8113: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var getBuiltIn = __webpack_require__2(5005);
                module2.exports = getBuiltIn("navigator", "userAgent") || "";
              }
            ),
            /***/
            7392: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var userAgent = __webpack_require__2(8113);
                var process = global.process;
                var Deno = global.Deno;
                var versions = process && process.versions || Deno && Deno.version;
                var v8 = versions && versions.v8;
                var match, version;
                if (v8) {
                  match = v8.split(".");
                  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
                }
                if (!version && userAgent) {
                  match = userAgent.match(/Edge\/(\d+)/);
                  if (!match || match[1] >= 74) {
                    match = userAgent.match(/Chrome\/(\d+)/);
                    if (match)
                      version = +match[1];
                  }
                }
                module2.exports = version;
              }
            ),
            /***/
            8008: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var userAgent = __webpack_require__2(8113);
                var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
                module2.exports = !!webkit && +webkit[1];
              }
            ),
            /***/
            748: (
              /***/
              function(module2) {
                module2.exports = [
                  "constructor",
                  "hasOwnProperty",
                  "isPrototypeOf",
                  "propertyIsEnumerable",
                  "toLocaleString",
                  "toString",
                  "valueOf"
                ];
              }
            ),
            /***/
            2914: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var fails = __webpack_require__2(7293);
                var createPropertyDescriptor = __webpack_require__2(9114);
                module2.exports = !fails(function() {
                  var error = Error("a");
                  if (!("stack" in error))
                    return true;
                  Object.defineProperty(error, "stack", createPropertyDescriptor(1, 7));
                  return error.stack !== 7;
                });
              }
            ),
            /***/
            2109: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var getOwnPropertyDescriptor = __webpack_require__2(1236).f;
                var createNonEnumerableProperty = __webpack_require__2(8880);
                var redefine = __webpack_require__2(1320);
                var setGlobal = __webpack_require__2(3505);
                var copyConstructorProperties = __webpack_require__2(9920);
                var isForced = __webpack_require__2(4705);
                module2.exports = function(options, source) {
                  var TARGET = options.target;
                  var GLOBAL = options.global;
                  var STATIC = options.stat;
                  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
                  if (GLOBAL) {
                    target = global;
                  } else if (STATIC) {
                    target = global[TARGET] || setGlobal(TARGET, {});
                  } else {
                    target = (global[TARGET] || {}).prototype;
                  }
                  if (target)
                    for (key in source) {
                      sourceProperty = source[key];
                      if (options.noTargetGet) {
                        descriptor = getOwnPropertyDescriptor(target, key);
                        targetProperty = descriptor && descriptor.value;
                      } else
                        targetProperty = target[key];
                      FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
                      if (!FORCED && targetProperty !== void 0) {
                        if (typeof sourceProperty == typeof targetProperty)
                          continue;
                        copyConstructorProperties(sourceProperty, targetProperty);
                      }
                      if (options.sham || targetProperty && targetProperty.sham) {
                        createNonEnumerableProperty(sourceProperty, "sham", true);
                      }
                      redefine(target, key, sourceProperty, options);
                    }
                };
              }
            ),
            /***/
            7293: (
              /***/
              function(module2) {
                module2.exports = function(exec) {
                  try {
                    return !!exec();
                  } catch (error) {
                    return true;
                  }
                };
              }
            ),
            /***/
            7007: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                __webpack_require__2(4916);
                var uncurryThis = __webpack_require__2(1702);
                var redefine = __webpack_require__2(1320);
                var regexpExec = __webpack_require__2(2261);
                var fails = __webpack_require__2(7293);
                var wellKnownSymbol = __webpack_require__2(5112);
                var createNonEnumerableProperty = __webpack_require__2(8880);
                var SPECIES = wellKnownSymbol("species");
                var RegExpPrototype = RegExp.prototype;
                module2.exports = function(KEY, exec, FORCED, SHAM) {
                  var SYMBOL = wellKnownSymbol(KEY);
                  var DELEGATES_TO_SYMBOL = !fails(function() {
                    var O = {};
                    O[SYMBOL] = function() {
                      return 7;
                    };
                    return ""[KEY](O) != 7;
                  });
                  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
                    var execCalled = false;
                    var re = /a/;
                    if (KEY === "split") {
                      re = {};
                      re.constructor = {};
                      re.constructor[SPECIES] = function() {
                        return re;
                      };
                      re.flags = "";
                      re[SYMBOL] = /./[SYMBOL];
                    }
                    re.exec = function() {
                      execCalled = true;
                      return null;
                    };
                    re[SYMBOL]("");
                    return !execCalled;
                  });
                  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
                    var uncurriedNativeRegExpMethod = uncurryThis(/./[SYMBOL]);
                    var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
                      var uncurriedNativeMethod = uncurryThis(nativeMethod);
                      var $exec = regexp.exec;
                      if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
                        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
                        }
                        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
                      }
                      return { done: false };
                    });
                    redefine(String.prototype, KEY, methods[0]);
                    redefine(RegExpPrototype, SYMBOL, methods[1]);
                  }
                  if (SHAM)
                    createNonEnumerableProperty(RegExpPrototype[SYMBOL], "sham", true);
                };
              }
            ),
            /***/
            6677: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var fails = __webpack_require__2(7293);
                module2.exports = !fails(function() {
                  return Object.isExtensible(Object.preventExtensions({}));
                });
              }
            ),
            /***/
            2104: (
              /***/
              function(module2) {
                var FunctionPrototype = Function.prototype;
                var apply = FunctionPrototype.apply;
                var bind = FunctionPrototype.bind;
                var call = FunctionPrototype.call;
                module2.exports = typeof Reflect == "object" && Reflect.apply || (bind ? call.bind(apply) : function() {
                  return call.apply(apply, arguments);
                });
              }
            ),
            /***/
            9974: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var uncurryThis = __webpack_require__2(1702);
                var aCallable = __webpack_require__2(9662);
                var bind = uncurryThis(uncurryThis.bind);
                module2.exports = function(fn, that) {
                  aCallable(fn);
                  return that === void 0 ? fn : bind ? bind(fn, that) : function() {
                    return fn.apply(that, arguments);
                  };
                };
              }
            ),
            /***/
            7065: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var global = __webpack_require__2(7854);
                var uncurryThis = __webpack_require__2(1702);
                var aCallable = __webpack_require__2(9662);
                var isObject = __webpack_require__2(111);
                var hasOwn = __webpack_require__2(2597);
                var arraySlice = __webpack_require__2(206);
                var Function2 = global.Function;
                var concat = uncurryThis([].concat);
                var join = uncurryThis([].join);
                var factories = {};
                var construct = function(C, argsLength, args) {
                  if (!hasOwn(factories, argsLength)) {
                    for (var list = [], i = 0; i < argsLength; i++)
                      list[i] = "a[" + i + "]";
                    factories[argsLength] = Function2("C,a", "return new C(" + join(list, ",") + ")");
                  }
                  return factories[argsLength](C, args);
                };
                module2.exports = Function2.bind || function bind(that) {
                  var F = aCallable(this);
                  var Prototype = F.prototype;
                  var partArgs = arraySlice(arguments, 1);
                  var boundFunction = function bound() {
                    var args = concat(partArgs, arraySlice(arguments));
                    return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
                  };
                  if (isObject(Prototype))
                    boundFunction.prototype = Prototype;
                  return boundFunction;
                };
              }
            ),
            /***/
            6916: (
              /***/
              function(module2) {
                var call = Function.prototype.call;
                module2.exports = call.bind ? call.bind(call) : function() {
                  return call.apply(call, arguments);
                };
              }
            ),
            /***/
            6530: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var DESCRIPTORS = __webpack_require__2(9781);
                var hasOwn = __webpack_require__2(2597);
                var FunctionPrototype = Function.prototype;
                var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
                var EXISTS = hasOwn(FunctionPrototype, "name");
                var PROPER = EXISTS && function something() {
                }.name === "something";
                var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
                module2.exports = {
                  EXISTS,
                  PROPER,
                  CONFIGURABLE
                };
              }
            ),
            /***/
            1702: (
              /***/
              function(module2) {
                var FunctionPrototype = Function.prototype;
                var bind = FunctionPrototype.bind;
                var call = FunctionPrototype.call;
                var callBind = bind && bind.bind(call);
                module2.exports = bind ? function(fn) {
                  return fn && callBind(call, fn);
                } : function(fn) {
                  return fn && function() {
                    return call.apply(fn, arguments);
                  };
                };
              }
            ),
            /***/
            5005: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var isCallable = __webpack_require__2(614);
                var aFunction = function(argument) {
                  return isCallable(argument) ? argument : void 0;
                };
                module2.exports = function(namespace, method) {
                  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
                };
              }
            ),
            /***/
            1246: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var classof = __webpack_require__2(648);
                var getMethod = __webpack_require__2(8173);
                var Iterators = __webpack_require__2(7497);
                var wellKnownSymbol = __webpack_require__2(5112);
                var ITERATOR = wellKnownSymbol("iterator");
                module2.exports = function(it) {
                  if (it != void 0)
                    return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
                };
              }
            ),
            /***/
            8554: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var call = __webpack_require__2(6916);
                var aCallable = __webpack_require__2(9662);
                var anObject = __webpack_require__2(9670);
                var tryToString = __webpack_require__2(6330);
                var getIteratorMethod = __webpack_require__2(1246);
                var TypeError2 = global.TypeError;
                module2.exports = function(argument, usingIterator) {
                  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
                  if (aCallable(iteratorMethod))
                    return anObject(call(iteratorMethod, argument));
                  throw TypeError2(tryToString(argument) + " is not iterable");
                };
              }
            ),
            /***/
            8173: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var aCallable = __webpack_require__2(9662);
                module2.exports = function(V, P) {
                  var func = V[P];
                  return func == null ? void 0 : aCallable(func);
                };
              }
            ),
            /***/
            647: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var uncurryThis = __webpack_require__2(1702);
                var toObject = __webpack_require__2(7908);
                var floor = Math.floor;
                var charAt = uncurryThis("".charAt);
                var replace = uncurryThis("".replace);
                var stringSlice = uncurryThis("".slice);
                var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
                var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
                module2.exports = function(matched, str, position, captures, namedCaptures, replacement) {
                  var tailPos = position + matched.length;
                  var m = captures.length;
                  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
                  if (namedCaptures !== void 0) {
                    namedCaptures = toObject(namedCaptures);
                    symbols = SUBSTITUTION_SYMBOLS;
                  }
                  return replace(replacement, symbols, function(match, ch) {
                    var capture;
                    switch (charAt(ch, 0)) {
                      case "$":
                        return "$";
                      case "&":
                        return matched;
                      case "`":
                        return stringSlice(str, 0, position);
                      case "'":
                        return stringSlice(str, tailPos);
                      case "<":
                        capture = namedCaptures[stringSlice(ch, 1, -1)];
                        break;
                      default:
                        var n = +ch;
                        if (n === 0)
                          return match;
                        if (n > m) {
                          var f = floor(n / 10);
                          if (f === 0)
                            return match;
                          if (f <= m)
                            return captures[f - 1] === void 0 ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
                          return match;
                        }
                        capture = captures[n - 1];
                    }
                    return capture === void 0 ? "" : capture;
                  });
                };
              }
            ),
            /***/
            7854: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var check = function(it) {
                  return it && it.Math == Math && it;
                };
                module2.exports = // eslint-disable-next-line es/no-global-this -- safe
                check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
                check(typeof self == "object" && self) || check(typeof __webpack_require__2.g == "object" && __webpack_require__2.g) || // eslint-disable-next-line no-new-func -- fallback
                function() {
                  return this;
                }() || Function("return this")();
              }
            ),
            /***/
            2597: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var uncurryThis = __webpack_require__2(1702);
                var toObject = __webpack_require__2(7908);
                var hasOwnProperty = uncurryThis({}.hasOwnProperty);
                module2.exports = Object.hasOwn || function hasOwn(it, key) {
                  return hasOwnProperty(toObject(it), key);
                };
              }
            ),
            /***/
            3501: (
              /***/
              function(module2) {
                module2.exports = {};
              }
            ),
            /***/
            842: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                module2.exports = function(a, b) {
                  var console2 = global.console;
                  if (console2 && console2.error) {
                    arguments.length == 1 ? console2.error(a) : console2.error(a, b);
                  }
                };
              }
            ),
            /***/
            490: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var getBuiltIn = __webpack_require__2(5005);
                module2.exports = getBuiltIn("document", "documentElement");
              }
            ),
            /***/
            4664: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var DESCRIPTORS = __webpack_require__2(9781);
                var fails = __webpack_require__2(7293);
                var createElement = __webpack_require__2(317);
                module2.exports = !DESCRIPTORS && !fails(function() {
                  return Object.defineProperty(createElement("div"), "a", {
                    get: function() {
                      return 7;
                    }
                  }).a != 7;
                });
              }
            ),
            /***/
            1179: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var Array2 = global.Array;
                var abs = Math.abs;
                var pow = Math.pow;
                var floor = Math.floor;
                var log = Math.log;
                var LN2 = Math.LN2;
                var pack = function(number, mantissaLength, bytes) {
                  var buffer = Array2(bytes);
                  var exponentLength = bytes * 8 - mantissaLength - 1;
                  var eMax = (1 << exponentLength) - 1;
                  var eBias = eMax >> 1;
                  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
                  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
                  var index = 0;
                  var exponent, mantissa, c;
                  number = abs(number);
                  if (number != number || number === Infinity) {
                    mantissa = number != number ? 1 : 0;
                    exponent = eMax;
                  } else {
                    exponent = floor(log(number) / LN2);
                    if (number * (c = pow(2, -exponent)) < 1) {
                      exponent--;
                      c *= 2;
                    }
                    if (exponent + eBias >= 1) {
                      number += rt / c;
                    } else {
                      number += rt * pow(2, 1 - eBias);
                    }
                    if (number * c >= 2) {
                      exponent++;
                      c /= 2;
                    }
                    if (exponent + eBias >= eMax) {
                      mantissa = 0;
                      exponent = eMax;
                    } else if (exponent + eBias >= 1) {
                      mantissa = (number * c - 1) * pow(2, mantissaLength);
                      exponent = exponent + eBias;
                    } else {
                      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
                      exponent = 0;
                    }
                  }
                  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8)
                    ;
                  exponent = exponent << mantissaLength | mantissa;
                  exponentLength += mantissaLength;
                  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8)
                    ;
                  buffer[--index] |= sign * 128;
                  return buffer;
                };
                var unpack = function(buffer, mantissaLength) {
                  var bytes = buffer.length;
                  var exponentLength = bytes * 8 - mantissaLength - 1;
                  var eMax = (1 << exponentLength) - 1;
                  var eBias = eMax >> 1;
                  var nBits = exponentLength - 7;
                  var index = bytes - 1;
                  var sign = buffer[index--];
                  var exponent = sign & 127;
                  var mantissa;
                  sign >>= 7;
                  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8)
                    ;
                  mantissa = exponent & (1 << -nBits) - 1;
                  exponent >>= -nBits;
                  nBits += mantissaLength;
                  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8)
                    ;
                  if (exponent === 0) {
                    exponent = 1 - eBias;
                  } else if (exponent === eMax) {
                    return mantissa ? NaN : sign ? -Infinity : Infinity;
                  } else {
                    mantissa = mantissa + pow(2, mantissaLength);
                    exponent = exponent - eBias;
                  }
                  return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
                };
                module2.exports = {
                  pack,
                  unpack
                };
              }
            ),
            /***/
            8361: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var uncurryThis = __webpack_require__2(1702);
                var fails = __webpack_require__2(7293);
                var classof = __webpack_require__2(4326);
                var Object2 = global.Object;
                var split = uncurryThis("".split);
                module2.exports = fails(function() {
                  return !Object2("z").propertyIsEnumerable(0);
                }) ? function(it) {
                  return classof(it) == "String" ? split(it, "") : Object2(it);
                } : Object2;
              }
            ),
            /***/
            9587: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var isCallable = __webpack_require__2(614);
                var isObject = __webpack_require__2(111);
                var setPrototypeOf = __webpack_require__2(7674);
                module2.exports = function($this, dummy, Wrapper) {
                  var NewTarget, NewTargetPrototype;
                  if (
                    // it can work only with native `setPrototypeOf`
                    setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
                    isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
                  )
                    setPrototypeOf($this, NewTargetPrototype);
                  return $this;
                };
              }
            ),
            /***/
            2788: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var uncurryThis = __webpack_require__2(1702);
                var isCallable = __webpack_require__2(614);
                var store = __webpack_require__2(5465);
                var functionToString = uncurryThis(Function.toString);
                if (!isCallable(store.inspectSource)) {
                  store.inspectSource = function(it) {
                    return functionToString(it);
                  };
                }
                module2.exports = store.inspectSource;
              }
            ),
            /***/
            8340: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var isObject = __webpack_require__2(111);
                var createNonEnumerableProperty = __webpack_require__2(8880);
                module2.exports = function(O, options) {
                  if (isObject(options) && "cause" in options) {
                    createNonEnumerableProperty(O, "cause", options.cause);
                  }
                };
              }
            ),
            /***/
            2423: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(2109);
                var uncurryThis = __webpack_require__2(1702);
                var hiddenKeys = __webpack_require__2(3501);
                var isObject = __webpack_require__2(111);
                var hasOwn = __webpack_require__2(2597);
                var defineProperty = __webpack_require__2(3070).f;
                var getOwnPropertyNamesModule = __webpack_require__2(8006);
                var getOwnPropertyNamesExternalModule = __webpack_require__2(1156);
                var uid = __webpack_require__2(9711);
                var FREEZING = __webpack_require__2(6677);
                var REQUIRED = false;
                var METADATA = uid("meta");
                var id = 0;
                var isExtensible = Object.isExtensible || function() {
                  return true;
                };
                var setMetadata = function(it) {
                  defineProperty(it, METADATA, { value: {
                    objectID: "O" + id++,
                    // object ID
                    weakData: {}
                    // weak collections IDs
                  } });
                };
                var fastKey = function(it, create) {
                  if (!isObject(it))
                    return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
                  if (!hasOwn(it, METADATA)) {
                    if (!isExtensible(it))
                      return "F";
                    if (!create)
                      return "E";
                    setMetadata(it);
                  }
                  return it[METADATA].objectID;
                };
                var getWeakData = function(it, create) {
                  if (!hasOwn(it, METADATA)) {
                    if (!isExtensible(it))
                      return true;
                    if (!create)
                      return false;
                    setMetadata(it);
                  }
                  return it[METADATA].weakData;
                };
                var onFreeze = function(it) {
                  if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA))
                    setMetadata(it);
                  return it;
                };
                var enable = function() {
                  meta.enable = function() {
                  };
                  REQUIRED = true;
                  var getOwnPropertyNames = getOwnPropertyNamesModule.f;
                  var splice = uncurryThis([].splice);
                  var test = {};
                  test[METADATA] = 1;
                  if (getOwnPropertyNames(test).length) {
                    getOwnPropertyNamesModule.f = function(it) {
                      var result = getOwnPropertyNames(it);
                      for (var i = 0, length = result.length; i < length; i++) {
                        if (result[i] === METADATA) {
                          splice(result, i, 1);
                          break;
                        }
                      }
                      return result;
                    };
                    $({ target: "Object", stat: true, forced: true }, {
                      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
                    });
                  }
                };
                var meta = module2.exports = {
                  enable,
                  fastKey,
                  getWeakData,
                  onFreeze
                };
                hiddenKeys[METADATA] = true;
              }
            ),
            /***/
            9909: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var NATIVE_WEAK_MAP = __webpack_require__2(8536);
                var global = __webpack_require__2(7854);
                var uncurryThis = __webpack_require__2(1702);
                var isObject = __webpack_require__2(111);
                var createNonEnumerableProperty = __webpack_require__2(8880);
                var hasOwn = __webpack_require__2(2597);
                var shared = __webpack_require__2(5465);
                var sharedKey = __webpack_require__2(6200);
                var hiddenKeys = __webpack_require__2(3501);
                var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
                var TypeError2 = global.TypeError;
                var WeakMap2 = global.WeakMap;
                var set, get, has;
                var enforce = function(it) {
                  return has(it) ? get(it) : set(it, {});
                };
                var getterFor = function(TYPE) {
                  return function(it) {
                    var state;
                    if (!isObject(it) || (state = get(it)).type !== TYPE) {
                      throw TypeError2("Incompatible receiver, " + TYPE + " required");
                    }
                    return state;
                  };
                };
                if (NATIVE_WEAK_MAP || shared.state) {
                  var store = shared.state || (shared.state = new WeakMap2());
                  var wmget = uncurryThis(store.get);
                  var wmhas = uncurryThis(store.has);
                  var wmset = uncurryThis(store.set);
                  set = function(it, metadata) {
                    if (wmhas(store, it))
                      throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
                    metadata.facade = it;
                    wmset(store, it, metadata);
                    return metadata;
                  };
                  get = function(it) {
                    return wmget(store, it) || {};
                  };
                  has = function(it) {
                    return wmhas(store, it);
                  };
                } else {
                  var STATE = sharedKey("state");
                  hiddenKeys[STATE] = true;
                  set = function(it, metadata) {
                    if (hasOwn(it, STATE))
                      throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
                    metadata.facade = it;
                    createNonEnumerableProperty(it, STATE, metadata);
                    return metadata;
                  };
                  get = function(it) {
                    return hasOwn(it, STATE) ? it[STATE] : {};
                  };
                  has = function(it) {
                    return hasOwn(it, STATE);
                  };
                }
                module2.exports = {
                  set,
                  get,
                  has,
                  enforce,
                  getterFor
                };
              }
            ),
            /***/
            7659: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var wellKnownSymbol = __webpack_require__2(5112);
                var Iterators = __webpack_require__2(7497);
                var ITERATOR = wellKnownSymbol("iterator");
                var ArrayPrototype = Array.prototype;
                module2.exports = function(it) {
                  return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
                };
              }
            ),
            /***/
            3157: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var classof = __webpack_require__2(4326);
                module2.exports = Array.isArray || function isArray(argument) {
                  return classof(argument) == "Array";
                };
              }
            ),
            /***/
            614: (
              /***/
              function(module2) {
                module2.exports = function(argument) {
                  return typeof argument == "function";
                };
              }
            ),
            /***/
            4411: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var uncurryThis = __webpack_require__2(1702);
                var fails = __webpack_require__2(7293);
                var isCallable = __webpack_require__2(614);
                var classof = __webpack_require__2(648);
                var getBuiltIn = __webpack_require__2(5005);
                var inspectSource = __webpack_require__2(2788);
                var noop = function() {
                };
                var empty = [];
                var construct = getBuiltIn("Reflect", "construct");
                var constructorRegExp = /^\s*(?:class|function)\b/;
                var exec = uncurryThis(constructorRegExp.exec);
                var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);
                var isConstructorModern = function(argument) {
                  if (!isCallable(argument))
                    return false;
                  try {
                    construct(noop, empty, argument);
                    return true;
                  } catch (error) {
                    return false;
                  }
                };
                var isConstructorLegacy = function(argument) {
                  if (!isCallable(argument))
                    return false;
                  switch (classof(argument)) {
                    case "AsyncFunction":
                    case "GeneratorFunction":
                    case "AsyncGeneratorFunction":
                      return false;
                  }
                  return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
                };
                module2.exports = !construct || fails(function() {
                  var called;
                  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
                    called = true;
                  }) || called;
                }) ? isConstructorLegacy : isConstructorModern;
              }
            ),
            /***/
            4705: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var fails = __webpack_require__2(7293);
                var isCallable = __webpack_require__2(614);
                var replacement = /#|\.prototype\./;
                var isForced = function(feature, detection) {
                  var value = data[normalize(feature)];
                  return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
                };
                var normalize = isForced.normalize = function(string) {
                  return String(string).replace(replacement, ".").toLowerCase();
                };
                var data = isForced.data = {};
                var NATIVE = isForced.NATIVE = "N";
                var POLYFILL = isForced.POLYFILL = "P";
                module2.exports = isForced;
              }
            ),
            /***/
            5988: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var isObject = __webpack_require__2(111);
                var floor = Math.floor;
                module2.exports = Number.isInteger || function isInteger(it) {
                  return !isObject(it) && isFinite(it) && floor(it) === it;
                };
              }
            ),
            /***/
            111: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var isCallable = __webpack_require__2(614);
                module2.exports = function(it) {
                  return typeof it == "object" ? it !== null : isCallable(it);
                };
              }
            ),
            /***/
            1913: (
              /***/
              function(module2) {
                module2.exports = false;
              }
            ),
            /***/
            7850: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var isObject = __webpack_require__2(111);
                var classof = __webpack_require__2(4326);
                var wellKnownSymbol = __webpack_require__2(5112);
                var MATCH = wellKnownSymbol("match");
                module2.exports = function(it) {
                  var isRegExp;
                  return isObject(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : classof(it) == "RegExp");
                };
              }
            ),
            /***/
            2190: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var getBuiltIn = __webpack_require__2(5005);
                var isCallable = __webpack_require__2(614);
                var isPrototypeOf = __webpack_require__2(7976);
                var USE_SYMBOL_AS_UID = __webpack_require__2(3307);
                var Object2 = global.Object;
                module2.exports = USE_SYMBOL_AS_UID ? function(it) {
                  return typeof it == "symbol";
                } : function(it) {
                  var $Symbol = getBuiltIn("Symbol");
                  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, Object2(it));
                };
              }
            ),
            /***/
            408: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var bind = __webpack_require__2(9974);
                var call = __webpack_require__2(6916);
                var anObject = __webpack_require__2(9670);
                var tryToString = __webpack_require__2(6330);
                var isArrayIteratorMethod = __webpack_require__2(7659);
                var lengthOfArrayLike = __webpack_require__2(6244);
                var isPrototypeOf = __webpack_require__2(7976);
                var getIterator = __webpack_require__2(8554);
                var getIteratorMethod = __webpack_require__2(1246);
                var iteratorClose = __webpack_require__2(9212);
                var TypeError2 = global.TypeError;
                var Result = function(stopped, result) {
                  this.stopped = stopped;
                  this.result = result;
                };
                var ResultPrototype = Result.prototype;
                module2.exports = function(iterable, unboundFunction, options) {
                  var that = options && options.that;
                  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
                  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
                  var INTERRUPTED = !!(options && options.INTERRUPTED);
                  var fn = bind(unboundFunction, that);
                  var iterator, iterFn, index, length, result, next, step;
                  var stop = function(condition) {
                    if (iterator)
                      iteratorClose(iterator, "normal", condition);
                    return new Result(true, condition);
                  };
                  var callFn = function(value) {
                    if (AS_ENTRIES) {
                      anObject(value);
                      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
                    }
                    return INTERRUPTED ? fn(value, stop) : fn(value);
                  };
                  if (IS_ITERATOR) {
                    iterator = iterable;
                  } else {
                    iterFn = getIteratorMethod(iterable);
                    if (!iterFn)
                      throw TypeError2(tryToString(iterable) + " is not iterable");
                    if (isArrayIteratorMethod(iterFn)) {
                      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
                        result = callFn(iterable[index]);
                        if (result && isPrototypeOf(ResultPrototype, result))
                          return result;
                      }
                      return new Result(false);
                    }
                    iterator = getIterator(iterable, iterFn);
                  }
                  next = iterator.next;
                  while (!(step = call(next, iterator)).done) {
                    try {
                      result = callFn(step.value);
                    } catch (error) {
                      iteratorClose(iterator, "throw", error);
                    }
                    if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result))
                      return result;
                  }
                  return new Result(false);
                };
              }
            ),
            /***/
            9212: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var call = __webpack_require__2(6916);
                var anObject = __webpack_require__2(9670);
                var getMethod = __webpack_require__2(8173);
                module2.exports = function(iterator, kind, value) {
                  var innerResult, innerError;
                  anObject(iterator);
                  try {
                    innerResult = getMethod(iterator, "return");
                    if (!innerResult) {
                      if (kind === "throw")
                        throw value;
                      return value;
                    }
                    innerResult = call(innerResult, iterator);
                  } catch (error) {
                    innerError = true;
                    innerResult = error;
                  }
                  if (kind === "throw")
                    throw value;
                  if (innerError)
                    throw innerResult;
                  anObject(innerResult);
                  return value;
                };
              }
            ),
            /***/
            3383: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var fails = __webpack_require__2(7293);
                var isCallable = __webpack_require__2(614);
                var create = __webpack_require__2(30);
                var getPrototypeOf = __webpack_require__2(9518);
                var redefine = __webpack_require__2(1320);
                var wellKnownSymbol = __webpack_require__2(5112);
                var IS_PURE = __webpack_require__2(1913);
                var ITERATOR = wellKnownSymbol("iterator");
                var BUGGY_SAFARI_ITERATORS = false;
                var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
                if ([].keys) {
                  arrayIterator = [].keys();
                  if (!("next" in arrayIterator))
                    BUGGY_SAFARI_ITERATORS = true;
                  else {
                    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
                    if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
                      IteratorPrototype = PrototypeOfArrayIteratorPrototype;
                  }
                }
                var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == void 0 || fails(function() {
                  var test = {};
                  return IteratorPrototype[ITERATOR].call(test) !== test;
                });
                if (NEW_ITERATOR_PROTOTYPE)
                  IteratorPrototype = {};
                else if (IS_PURE)
                  IteratorPrototype = create(IteratorPrototype);
                if (!isCallable(IteratorPrototype[ITERATOR])) {
                  redefine(IteratorPrototype, ITERATOR, function() {
                    return this;
                  });
                }
                module2.exports = {
                  IteratorPrototype,
                  BUGGY_SAFARI_ITERATORS
                };
              }
            ),
            /***/
            7497: (
              /***/
              function(module2) {
                module2.exports = {};
              }
            ),
            /***/
            6244: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var toLength = __webpack_require__2(7466);
                module2.exports = function(obj) {
                  return toLength(obj.length);
                };
              }
            ),
            /***/
            5948: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var bind = __webpack_require__2(9974);
                var getOwnPropertyDescriptor = __webpack_require__2(1236).f;
                var macrotask = __webpack_require__2(261).set;
                var IS_IOS = __webpack_require__2(6833);
                var IS_IOS_PEBBLE = __webpack_require__2(1528);
                var IS_WEBOS_WEBKIT = __webpack_require__2(1036);
                var IS_NODE = __webpack_require__2(5268);
                var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
                var document2 = global.document;
                var process = global.process;
                var Promise2 = global.Promise;
                var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, "queueMicrotask");
                var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
                var flush, head, last, notify, toggle, node, promise, then;
                if (!queueMicrotask) {
                  flush = function() {
                    var parent, fn;
                    if (IS_NODE && (parent = process.domain))
                      parent.exit();
                    while (head) {
                      fn = head.fn;
                      head = head.next;
                      try {
                        fn();
                      } catch (error) {
                        if (head)
                          notify();
                        else
                          last = void 0;
                        throw error;
                      }
                    }
                    last = void 0;
                    if (parent)
                      parent.enter();
                  };
                  if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document2) {
                    toggle = true;
                    node = document2.createTextNode("");
                    new MutationObserver(flush).observe(node, { characterData: true });
                    notify = function() {
                      node.data = toggle = !toggle;
                    };
                  } else if (!IS_IOS_PEBBLE && Promise2 && Promise2.resolve) {
                    promise = Promise2.resolve(void 0);
                    promise.constructor = Promise2;
                    then = bind(promise.then, promise);
                    notify = function() {
                      then(flush);
                    };
                  } else if (IS_NODE) {
                    notify = function() {
                      process.nextTick(flush);
                    };
                  } else {
                    macrotask = bind(macrotask, global);
                    notify = function() {
                      macrotask(flush);
                    };
                  }
                }
                module2.exports = queueMicrotask || function(fn) {
                  var task = { fn, next: void 0 };
                  if (last)
                    last.next = task;
                  if (!head) {
                    head = task;
                    notify();
                  }
                  last = task;
                };
              }
            ),
            /***/
            3366: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                module2.exports = global.Promise;
              }
            ),
            /***/
            133: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var V8_VERSION = __webpack_require__2(7392);
                var fails = __webpack_require__2(7293);
                module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
                  var symbol = Symbol();
                  return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
                  !Symbol.sham && V8_VERSION && V8_VERSION < 41;
                });
              }
            ),
            /***/
            8536: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var isCallable = __webpack_require__2(614);
                var inspectSource = __webpack_require__2(2788);
                var WeakMap2 = global.WeakMap;
                module2.exports = isCallable(WeakMap2) && /native code/.test(inspectSource(WeakMap2));
              }
            ),
            /***/
            8523: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var aCallable = __webpack_require__2(9662);
                var PromiseCapability = function(C) {
                  var resolve, reject;
                  this.promise = new C(function($$resolve, $$reject) {
                    if (resolve !== void 0 || reject !== void 0)
                      throw TypeError("Bad Promise constructor");
                    resolve = $$resolve;
                    reject = $$reject;
                  });
                  this.resolve = aCallable(resolve);
                  this.reject = aCallable(reject);
                };
                module2.exports.f = function(C) {
                  return new PromiseCapability(C);
                };
              }
            ),
            /***/
            6277: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var toString = __webpack_require__2(1340);
                module2.exports = function(argument, $default) {
                  return argument === void 0 ? arguments.length < 2 ? "" : $default : toString(argument);
                };
              }
            ),
            /***/
            3929: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var isRegExp = __webpack_require__2(7850);
                var TypeError2 = global.TypeError;
                module2.exports = function(it) {
                  if (isRegExp(it)) {
                    throw TypeError2("The method doesn't accept regular expressions");
                  }
                  return it;
                };
              }
            ),
            /***/
            7023: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var globalIsFinite = global.isFinite;
                module2.exports = Number.isFinite || function isFinite2(it) {
                  return typeof it == "number" && globalIsFinite(it);
                };
              }
            ),
            /***/
            1574: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var DESCRIPTORS = __webpack_require__2(9781);
                var uncurryThis = __webpack_require__2(1702);
                var call = __webpack_require__2(6916);
                var fails = __webpack_require__2(7293);
                var objectKeys = __webpack_require__2(1956);
                var getOwnPropertySymbolsModule = __webpack_require__2(5181);
                var propertyIsEnumerableModule = __webpack_require__2(5296);
                var toObject = __webpack_require__2(7908);
                var IndexedObject = __webpack_require__2(8361);
                var $assign = Object.assign;
                var defineProperty = Object.defineProperty;
                var concat = uncurryThis([].concat);
                module2.exports = !$assign || fails(function() {
                  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, "a", {
                    enumerable: true,
                    get: function() {
                      defineProperty(this, "b", {
                        value: 3,
                        enumerable: false
                      });
                    }
                  }), { b: 2 })).b !== 1)
                    return true;
                  var A = {};
                  var B = {};
                  var symbol = Symbol();
                  var alphabet = "abcdefghijklmnopqrst";
                  A[symbol] = 7;
                  alphabet.split("").forEach(function(chr) {
                    B[chr] = chr;
                  });
                  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join("") != alphabet;
                }) ? function assign(target, source) {
                  var T = toObject(target);
                  var argumentsLength = arguments.length;
                  var index = 1;
                  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
                  var propertyIsEnumerable = propertyIsEnumerableModule.f;
                  while (argumentsLength > index) {
                    var S = IndexedObject(arguments[index++]);
                    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
                    var length = keys.length;
                    var j = 0;
                    var key;
                    while (length > j) {
                      key = keys[j++];
                      if (!DESCRIPTORS || call(propertyIsEnumerable, S, key))
                        T[key] = S[key];
                    }
                  }
                  return T;
                } : $assign;
              }
            ),
            /***/
            30: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var anObject = __webpack_require__2(9670);
                var defineProperties = __webpack_require__2(6048);
                var enumBugKeys = __webpack_require__2(748);
                var hiddenKeys = __webpack_require__2(3501);
                var html = __webpack_require__2(490);
                var documentCreateElement = __webpack_require__2(317);
                var sharedKey = __webpack_require__2(6200);
                var GT = ">";
                var LT = "<";
                var PROTOTYPE = "prototype";
                var SCRIPT = "script";
                var IE_PROTO = sharedKey("IE_PROTO");
                var EmptyConstructor = function() {
                };
                var scriptTag = function(content) {
                  return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
                };
                var NullProtoObjectViaActiveX = function(activeXDocument2) {
                  activeXDocument2.write(scriptTag(""));
                  activeXDocument2.close();
                  var temp = activeXDocument2.parentWindow.Object;
                  activeXDocument2 = null;
                  return temp;
                };
                var NullProtoObjectViaIFrame = function() {
                  var iframe = documentCreateElement("iframe");
                  var JS = "java" + SCRIPT + ":";
                  var iframeDocument;
                  iframe.style.display = "none";
                  html.appendChild(iframe);
                  iframe.src = String(JS);
                  iframeDocument = iframe.contentWindow.document;
                  iframeDocument.open();
                  iframeDocument.write(scriptTag("document.F=Object"));
                  iframeDocument.close();
                  return iframeDocument.F;
                };
                var activeXDocument;
                var NullProtoObject = function() {
                  try {
                    activeXDocument = new ActiveXObject("htmlfile");
                  } catch (error) {
                  }
                  NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
                  var length = enumBugKeys.length;
                  while (length--)
                    delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
                  return NullProtoObject();
                };
                hiddenKeys[IE_PROTO] = true;
                module2.exports = Object.create || function create(O, Properties) {
                  var result;
                  if (O !== null) {
                    EmptyConstructor[PROTOTYPE] = anObject(O);
                    result = new EmptyConstructor();
                    EmptyConstructor[PROTOTYPE] = null;
                    result[IE_PROTO] = O;
                  } else
                    result = NullProtoObject();
                  return Properties === void 0 ? result : defineProperties(result, Properties);
                };
              }
            ),
            /***/
            6048: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var DESCRIPTORS = __webpack_require__2(9781);
                var definePropertyModule = __webpack_require__2(3070);
                var anObject = __webpack_require__2(9670);
                var toIndexedObject = __webpack_require__2(5656);
                var objectKeys = __webpack_require__2(1956);
                module2.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
                  anObject(O);
                  var props = toIndexedObject(Properties);
                  var keys = objectKeys(Properties);
                  var length = keys.length;
                  var index = 0;
                  var key;
                  while (length > index)
                    definePropertyModule.f(O, key = keys[index++], props[key]);
                  return O;
                };
              }
            ),
            /***/
            3070: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var DESCRIPTORS = __webpack_require__2(9781);
                var IE8_DOM_DEFINE = __webpack_require__2(4664);
                var anObject = __webpack_require__2(9670);
                var toPropertyKey = __webpack_require__2(4948);
                var TypeError2 = global.TypeError;
                var $defineProperty = Object.defineProperty;
                exports2.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {
                  anObject(O);
                  P = toPropertyKey(P);
                  anObject(Attributes);
                  if (IE8_DOM_DEFINE)
                    try {
                      return $defineProperty(O, P, Attributes);
                    } catch (error) {
                    }
                  if ("get" in Attributes || "set" in Attributes)
                    throw TypeError2("Accessors not supported");
                  if ("value" in Attributes)
                    O[P] = Attributes.value;
                  return O;
                };
              }
            ),
            /***/
            1236: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                var DESCRIPTORS = __webpack_require__2(9781);
                var call = __webpack_require__2(6916);
                var propertyIsEnumerableModule = __webpack_require__2(5296);
                var createPropertyDescriptor = __webpack_require__2(9114);
                var toIndexedObject = __webpack_require__2(5656);
                var toPropertyKey = __webpack_require__2(4948);
                var hasOwn = __webpack_require__2(2597);
                var IE8_DOM_DEFINE = __webpack_require__2(4664);
                var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
                exports2.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
                  O = toIndexedObject(O);
                  P = toPropertyKey(P);
                  if (IE8_DOM_DEFINE)
                    try {
                      return $getOwnPropertyDescriptor(O, P);
                    } catch (error) {
                    }
                  if (hasOwn(O, P))
                    return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
                };
              }
            ),
            /***/
            1156: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var classof = __webpack_require__2(4326);
                var toIndexedObject = __webpack_require__2(5656);
                var $getOwnPropertyNames = __webpack_require__2(8006).f;
                var arraySlice = __webpack_require__2(206);
                var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
                var getWindowNames = function(it) {
                  try {
                    return $getOwnPropertyNames(it);
                  } catch (error) {
                    return arraySlice(windowNames);
                  }
                };
                module2.exports.f = function getOwnPropertyNames(it) {
                  return windowNames && classof(it) == "Window" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
                };
              }
            ),
            /***/
            8006: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                var internalObjectKeys = __webpack_require__2(6324);
                var enumBugKeys = __webpack_require__2(748);
                var hiddenKeys = enumBugKeys.concat("length", "prototype");
                exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
                  return internalObjectKeys(O, hiddenKeys);
                };
              }
            ),
            /***/
            5181: (
              /***/
              function(__unused_webpack_module, exports2) {
                exports2.f = Object.getOwnPropertySymbols;
              }
            ),
            /***/
            9518: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var hasOwn = __webpack_require__2(2597);
                var isCallable = __webpack_require__2(614);
                var toObject = __webpack_require__2(7908);
                var sharedKey = __webpack_require__2(6200);
                var CORRECT_PROTOTYPE_GETTER = __webpack_require__2(8544);
                var IE_PROTO = sharedKey("IE_PROTO");
                var Object2 = global.Object;
                var ObjectPrototype = Object2.prototype;
                module2.exports = CORRECT_PROTOTYPE_GETTER ? Object2.getPrototypeOf : function(O) {
                  var object = toObject(O);
                  if (hasOwn(object, IE_PROTO))
                    return object[IE_PROTO];
                  var constructor = object.constructor;
                  if (isCallable(constructor) && object instanceof constructor) {
                    return constructor.prototype;
                  }
                  return object instanceof Object2 ? ObjectPrototype : null;
                };
              }
            ),
            /***/
            7976: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var uncurryThis = __webpack_require__2(1702);
                module2.exports = uncurryThis({}.isPrototypeOf);
              }
            ),
            /***/
            6324: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var uncurryThis = __webpack_require__2(1702);
                var hasOwn = __webpack_require__2(2597);
                var toIndexedObject = __webpack_require__2(5656);
                var indexOf = __webpack_require__2(1318).indexOf;
                var hiddenKeys = __webpack_require__2(3501);
                var push = uncurryThis([].push);
                module2.exports = function(object, names) {
                  var O = toIndexedObject(object);
                  var i = 0;
                  var result = [];
                  var key;
                  for (key in O)
                    !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
                  while (names.length > i)
                    if (hasOwn(O, key = names[i++])) {
                      ~indexOf(result, key) || push(result, key);
                    }
                  return result;
                };
              }
            ),
            /***/
            1956: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var internalObjectKeys = __webpack_require__2(6324);
                var enumBugKeys = __webpack_require__2(748);
                module2.exports = Object.keys || function keys(O) {
                  return internalObjectKeys(O, enumBugKeys);
                };
              }
            ),
            /***/
            5296: (
              /***/
              function(__unused_webpack_module, exports2) {
                "use strict";
                var $propertyIsEnumerable = {}.propertyIsEnumerable;
                var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
                var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
                exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
                  var descriptor = getOwnPropertyDescriptor(this, V);
                  return !!descriptor && descriptor.enumerable;
                } : $propertyIsEnumerable;
              }
            ),
            /***/
            7674: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var uncurryThis = __webpack_require__2(1702);
                var anObject = __webpack_require__2(9670);
                var aPossiblePrototype = __webpack_require__2(6077);
                module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
                  var CORRECT_SETTER = false;
                  var test = {};
                  var setter;
                  try {
                    setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set);
                    setter(test, []);
                    CORRECT_SETTER = test instanceof Array;
                  } catch (error) {
                  }
                  return function setPrototypeOf(O, proto) {
                    anObject(O);
                    aPossiblePrototype(proto);
                    if (CORRECT_SETTER)
                      setter(O, proto);
                    else
                      O.__proto__ = proto;
                    return O;
                  };
                }() : void 0);
              }
            ),
            /***/
            4699: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var DESCRIPTORS = __webpack_require__2(9781);
                var uncurryThis = __webpack_require__2(1702);
                var objectKeys = __webpack_require__2(1956);
                var toIndexedObject = __webpack_require__2(5656);
                var $propertyIsEnumerable = __webpack_require__2(5296).f;
                var propertyIsEnumerable = uncurryThis($propertyIsEnumerable);
                var push = uncurryThis([].push);
                var createMethod = function(TO_ENTRIES) {
                  return function(it) {
                    var O = toIndexedObject(it);
                    var keys = objectKeys(O);
                    var length = keys.length;
                    var i = 0;
                    var result = [];
                    var key;
                    while (length > i) {
                      key = keys[i++];
                      if (!DESCRIPTORS || propertyIsEnumerable(O, key)) {
                        push(result, TO_ENTRIES ? [key, O[key]] : O[key]);
                      }
                    }
                    return result;
                  };
                };
                module2.exports = {
                  // `Object.entries` method
                  // https://tc39.es/ecma262/#sec-object.entries
                  entries: createMethod(true),
                  // `Object.values` method
                  // https://tc39.es/ecma262/#sec-object.values
                  values: createMethod(false)
                };
              }
            ),
            /***/
            288: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var TO_STRING_TAG_SUPPORT = __webpack_require__2(1694);
                var classof = __webpack_require__2(648);
                module2.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
                  return "[object " + classof(this) + "]";
                };
              }
            ),
            /***/
            2140: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var call = __webpack_require__2(6916);
                var isCallable = __webpack_require__2(614);
                var isObject = __webpack_require__2(111);
                var TypeError2 = global.TypeError;
                module2.exports = function(input, pref) {
                  var fn, val;
                  if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
                    return val;
                  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input)))
                    return val;
                  if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
                    return val;
                  throw TypeError2("Can't convert object to primitive value");
                };
              }
            ),
            /***/
            3887: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var getBuiltIn = __webpack_require__2(5005);
                var uncurryThis = __webpack_require__2(1702);
                var getOwnPropertyNamesModule = __webpack_require__2(8006);
                var getOwnPropertySymbolsModule = __webpack_require__2(5181);
                var anObject = __webpack_require__2(9670);
                var concat = uncurryThis([].concat);
                module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
                  var keys = getOwnPropertyNamesModule.f(anObject(it));
                  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
                  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
                };
              }
            ),
            /***/
            857: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                module2.exports = global;
              }
            ),
            /***/
            2534: (
              /***/
              function(module2) {
                module2.exports = function(exec) {
                  try {
                    return { error: false, value: exec() };
                  } catch (error) {
                    return { error: true, value: error };
                  }
                };
              }
            ),
            /***/
            9478: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var anObject = __webpack_require__2(9670);
                var isObject = __webpack_require__2(111);
                var newPromiseCapability = __webpack_require__2(8523);
                module2.exports = function(C, x) {
                  anObject(C);
                  if (isObject(x) && x.constructor === C)
                    return x;
                  var promiseCapability = newPromiseCapability.f(C);
                  var resolve = promiseCapability.resolve;
                  resolve(x);
                  return promiseCapability.promise;
                };
              }
            ),
            /***/
            2248: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var redefine = __webpack_require__2(1320);
                module2.exports = function(target, src, options) {
                  for (var key in src)
                    redefine(target, key, src[key], options);
                  return target;
                };
              }
            ),
            /***/
            1320: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var isCallable = __webpack_require__2(614);
                var hasOwn = __webpack_require__2(2597);
                var createNonEnumerableProperty = __webpack_require__2(8880);
                var setGlobal = __webpack_require__2(3505);
                var inspectSource = __webpack_require__2(2788);
                var InternalStateModule = __webpack_require__2(9909);
                var CONFIGURABLE_FUNCTION_NAME = __webpack_require__2(6530).CONFIGURABLE;
                var getInternalState = InternalStateModule.get;
                var enforceInternalState = InternalStateModule.enforce;
                var TEMPLATE = String(String).split("String");
                (module2.exports = function(O, key, value, options) {
                  var unsafe = options ? !!options.unsafe : false;
                  var simple = options ? !!options.enumerable : false;
                  var noTargetGet = options ? !!options.noTargetGet : false;
                  var name = options && options.name !== void 0 ? options.name : key;
                  var state;
                  if (isCallable(value)) {
                    if (String(name).slice(0, 7) === "Symbol(") {
                      name = "[" + String(name).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
                    }
                    if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
                      createNonEnumerableProperty(value, "name", name);
                    }
                    state = enforceInternalState(value);
                    if (!state.source) {
                      state.source = TEMPLATE.join(typeof name == "string" ? name : "");
                    }
                  }
                  if (O === global) {
                    if (simple)
                      O[key] = value;
                    else
                      setGlobal(key, value);
                    return;
                  } else if (!unsafe) {
                    delete O[key];
                  } else if (!noTargetGet && O[key]) {
                    simple = true;
                  }
                  if (simple)
                    O[key] = value;
                  else
                    createNonEnumerableProperty(O, key, value);
                })(Function.prototype, "toString", function toString() {
                  return isCallable(this) && getInternalState(this).source || inspectSource(this);
                });
              }
            ),
            /***/
            7651: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var call = __webpack_require__2(6916);
                var anObject = __webpack_require__2(9670);
                var isCallable = __webpack_require__2(614);
                var classof = __webpack_require__2(4326);
                var regexpExec = __webpack_require__2(2261);
                var TypeError2 = global.TypeError;
                module2.exports = function(R, S) {
                  var exec = R.exec;
                  if (isCallable(exec)) {
                    var result = call(exec, R, S);
                    if (result !== null)
                      anObject(result);
                    return result;
                  }
                  if (classof(R) === "RegExp")
                    return call(regexpExec, R, S);
                  throw TypeError2("RegExp#exec called on incompatible receiver");
                };
              }
            ),
            /***/
            2261: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var call = __webpack_require__2(6916);
                var uncurryThis = __webpack_require__2(1702);
                var toString = __webpack_require__2(1340);
                var regexpFlags = __webpack_require__2(7066);
                var stickyHelpers = __webpack_require__2(2999);
                var shared = __webpack_require__2(2309);
                var create = __webpack_require__2(30);
                var getInternalState = __webpack_require__2(9909).get;
                var UNSUPPORTED_DOT_ALL = __webpack_require__2(9441);
                var UNSUPPORTED_NCG = __webpack_require__2(7168);
                var nativeReplace = shared("native-string-replace", String.prototype.replace);
                var nativeExec = RegExp.prototype.exec;
                var patchedExec = nativeExec;
                var charAt = uncurryThis("".charAt);
                var indexOf = uncurryThis("".indexOf);
                var replace = uncurryThis("".replace);
                var stringSlice = uncurryThis("".slice);
                var UPDATES_LAST_INDEX_WRONG = function() {
                  var re1 = /a/;
                  var re2 = /b*/g;
                  call(nativeExec, re1, "a");
                  call(nativeExec, re2, "a");
                  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
                }();
                var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;
                var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
                var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
                if (PATCH) {
                  patchedExec = function exec(string) {
                    var re = this;
                    var state = getInternalState(re);
                    var str = toString(string);
                    var raw = state.raw;
                    var result, reCopy, lastIndex, match, i, object, group;
                    if (raw) {
                      raw.lastIndex = re.lastIndex;
                      result = call(patchedExec, raw, str);
                      re.lastIndex = raw.lastIndex;
                      return result;
                    }
                    var groups = state.groups;
                    var sticky = UNSUPPORTED_Y && re.sticky;
                    var flags = call(regexpFlags, re);
                    var source = re.source;
                    var charsAdded = 0;
                    var strCopy = str;
                    if (sticky) {
                      flags = replace(flags, "y", "");
                      if (indexOf(flags, "g") === -1) {
                        flags += "g";
                      }
                      strCopy = stringSlice(str, re.lastIndex);
                      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== "\n")) {
                        source = "(?: " + source + ")";
                        strCopy = " " + strCopy;
                        charsAdded++;
                      }
                      reCopy = new RegExp("^(?:" + source + ")", flags);
                    }
                    if (NPCG_INCLUDED) {
                      reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
                    }
                    if (UPDATES_LAST_INDEX_WRONG)
                      lastIndex = re.lastIndex;
                    match = call(nativeExec, sticky ? reCopy : re, strCopy);
                    if (sticky) {
                      if (match) {
                        match.input = stringSlice(match.input, charsAdded);
                        match[0] = stringSlice(match[0], charsAdded);
                        match.index = re.lastIndex;
                        re.lastIndex += match[0].length;
                      } else
                        re.lastIndex = 0;
                    } else if (UPDATES_LAST_INDEX_WRONG && match) {
                      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
                    }
                    if (NPCG_INCLUDED && match && match.length > 1) {
                      call(nativeReplace, match[0], reCopy, function() {
                        for (i = 1; i < arguments.length - 2; i++) {
                          if (arguments[i] === void 0)
                            match[i] = void 0;
                        }
                      });
                    }
                    if (match && groups) {
                      match.groups = object = create(null);
                      for (i = 0; i < groups.length; i++) {
                        group = groups[i];
                        object[group[0]] = match[group[1]];
                      }
                    }
                    return match;
                  };
                }
                module2.exports = patchedExec;
              }
            ),
            /***/
            7066: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var anObject = __webpack_require__2(9670);
                module2.exports = function() {
                  var that = anObject(this);
                  var result = "";
                  if (that.global)
                    result += "g";
                  if (that.ignoreCase)
                    result += "i";
                  if (that.multiline)
                    result += "m";
                  if (that.dotAll)
                    result += "s";
                  if (that.unicode)
                    result += "u";
                  if (that.sticky)
                    result += "y";
                  return result;
                };
              }
            ),
            /***/
            2999: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                var fails = __webpack_require__2(7293);
                var global = __webpack_require__2(7854);
                var $RegExp = global.RegExp;
                exports2.UNSUPPORTED_Y = fails(function() {
                  var re = $RegExp("a", "y");
                  re.lastIndex = 2;
                  return re.exec("abcd") != null;
                });
                exports2.BROKEN_CARET = fails(function() {
                  var re = $RegExp("^r", "gy");
                  re.lastIndex = 2;
                  return re.exec("str") != null;
                });
              }
            ),
            /***/
            9441: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var fails = __webpack_require__2(7293);
                var global = __webpack_require__2(7854);
                var $RegExp = global.RegExp;
                module2.exports = fails(function() {
                  var re = $RegExp(".", "s");
                  return !(re.dotAll && re.exec("\n") && re.flags === "s");
                });
              }
            ),
            /***/
            7168: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var fails = __webpack_require__2(7293);
                var global = __webpack_require__2(7854);
                var $RegExp = global.RegExp;
                module2.exports = fails(function() {
                  var re = $RegExp("(?<a>b)", "g");
                  return re.exec("b").groups.a !== "b" || "b".replace(re, "$<a>c") !== "bc";
                });
              }
            ),
            /***/
            4488: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var TypeError2 = global.TypeError;
                module2.exports = function(it) {
                  if (it == void 0)
                    throw TypeError2("Can't call method on " + it);
                  return it;
                };
              }
            ),
            /***/
            3505: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var defineProperty = Object.defineProperty;
                module2.exports = function(key, value) {
                  try {
                    defineProperty(global, key, { value, configurable: true, writable: true });
                  } catch (error) {
                    global[key] = value;
                  }
                  return value;
                };
              }
            ),
            /***/
            6340: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var getBuiltIn = __webpack_require__2(5005);
                var definePropertyModule = __webpack_require__2(3070);
                var wellKnownSymbol = __webpack_require__2(5112);
                var DESCRIPTORS = __webpack_require__2(9781);
                var SPECIES = wellKnownSymbol("species");
                module2.exports = function(CONSTRUCTOR_NAME) {
                  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
                  var defineProperty = definePropertyModule.f;
                  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
                    defineProperty(Constructor, SPECIES, {
                      configurable: true,
                      get: function() {
                        return this;
                      }
                    });
                  }
                };
              }
            ),
            /***/
            8003: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var defineProperty = __webpack_require__2(3070).f;
                var hasOwn = __webpack_require__2(2597);
                var wellKnownSymbol = __webpack_require__2(5112);
                var TO_STRING_TAG = wellKnownSymbol("toStringTag");
                module2.exports = function(it, TAG, STATIC) {
                  if (it && !hasOwn(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
                    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
                  }
                };
              }
            ),
            /***/
            6200: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var shared = __webpack_require__2(2309);
                var uid = __webpack_require__2(9711);
                var keys = shared("keys");
                module2.exports = function(key) {
                  return keys[key] || (keys[key] = uid(key));
                };
              }
            ),
            /***/
            5465: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var setGlobal = __webpack_require__2(3505);
                var SHARED = "__core-js_shared__";
                var store = global[SHARED] || setGlobal(SHARED, {});
                module2.exports = store;
              }
            ),
            /***/
            2309: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var IS_PURE = __webpack_require__2(1913);
                var store = __webpack_require__2(5465);
                (module2.exports = function(key, value) {
                  return store[key] || (store[key] = value !== void 0 ? value : {});
                })("versions", []).push({
                  version: "3.19.0",
                  mode: IS_PURE ? "pure" : "global",
                  copyright: " 2021 Denis Pushkarev (zloirock.ru)"
                });
              }
            ),
            /***/
            6707: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var anObject = __webpack_require__2(9670);
                var aConstructor = __webpack_require__2(9483);
                var wellKnownSymbol = __webpack_require__2(5112);
                var SPECIES = wellKnownSymbol("species");
                module2.exports = function(O, defaultConstructor) {
                  var C = anObject(O).constructor;
                  var S;
                  return C === void 0 || (S = anObject(C)[SPECIES]) == void 0 ? defaultConstructor : aConstructor(S);
                };
              }
            ),
            /***/
            3429: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var fails = __webpack_require__2(7293);
                module2.exports = function(METHOD_NAME) {
                  return fails(function() {
                    var test = ""[METHOD_NAME]('"');
                    return test !== test.toLowerCase() || test.split('"').length > 3;
                  });
                };
              }
            ),
            /***/
            8710: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var uncurryThis = __webpack_require__2(1702);
                var toIntegerOrInfinity = __webpack_require__2(9303);
                var toString = __webpack_require__2(1340);
                var requireObjectCoercible = __webpack_require__2(4488);
                var charAt = uncurryThis("".charAt);
                var charCodeAt = uncurryThis("".charCodeAt);
                var stringSlice = uncurryThis("".slice);
                var createMethod = function(CONVERT_TO_STRING) {
                  return function($this, pos) {
                    var S = toString(requireObjectCoercible($this));
                    var position = toIntegerOrInfinity(pos);
                    var size = S.length;
                    var first, second;
                    if (position < 0 || position >= size)
                      return CONVERT_TO_STRING ? "" : void 0;
                    first = charCodeAt(S, position);
                    return first < 55296 || first > 56319 || position + 1 === size || (second = charCodeAt(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
                  };
                };
                module2.exports = {
                  // `String.prototype.codePointAt` method
                  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
                  codeAt: createMethod(false),
                  // `String.prototype.at` method
                  // https://github.com/mathiasbynens/String.prototype.at
                  charAt: createMethod(true)
                };
              }
            ),
            /***/
            8415: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var global = __webpack_require__2(7854);
                var toIntegerOrInfinity = __webpack_require__2(9303);
                var toString = __webpack_require__2(1340);
                var requireObjectCoercible = __webpack_require__2(4488);
                var RangeError2 = global.RangeError;
                module2.exports = function repeat(count) {
                  var str = toString(requireObjectCoercible(this));
                  var result = "";
                  var n = toIntegerOrInfinity(count);
                  if (n < 0 || n == Infinity)
                    throw RangeError2("Wrong number of repetitions");
                  for (; n > 0; (n >>>= 1) && (str += str))
                    if (n & 1)
                      result += str;
                  return result;
                };
              }
            ),
            /***/
            6091: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var PROPER_FUNCTION_NAME = __webpack_require__2(6530).PROPER;
                var fails = __webpack_require__2(7293);
                var whitespaces = __webpack_require__2(1361);
                var non = "";
                module2.exports = function(METHOD_NAME) {
                  return fails(function() {
                    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
                  });
                };
              }
            ),
            /***/
            3111: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var uncurryThis = __webpack_require__2(1702);
                var requireObjectCoercible = __webpack_require__2(4488);
                var toString = __webpack_require__2(1340);
                var whitespaces = __webpack_require__2(1361);
                var replace = uncurryThis("".replace);
                var whitespace = "[" + whitespaces + "]";
                var ltrim = RegExp("^" + whitespace + whitespace + "*");
                var rtrim = RegExp(whitespace + whitespace + "*$");
                var createMethod = function(TYPE) {
                  return function($this) {
                    var string = toString(requireObjectCoercible($this));
                    if (TYPE & 1)
                      string = replace(string, ltrim, "");
                    if (TYPE & 2)
                      string = replace(string, rtrim, "");
                    return string;
                  };
                };
                module2.exports = {
                  // `String.prototype.{ trimLeft, trimStart }` methods
                  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
                  start: createMethod(1),
                  // `String.prototype.{ trimRight, trimEnd }` methods
                  // https://tc39.es/ecma262/#sec-string.prototype.trimend
                  end: createMethod(2),
                  // `String.prototype.trim` method
                  // https://tc39.es/ecma262/#sec-string.prototype.trim
                  trim: createMethod(3)
                };
              }
            ),
            /***/
            261: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var apply = __webpack_require__2(2104);
                var bind = __webpack_require__2(9974);
                var isCallable = __webpack_require__2(614);
                var hasOwn = __webpack_require__2(2597);
                var fails = __webpack_require__2(7293);
                var html = __webpack_require__2(490);
                var arraySlice = __webpack_require__2(206);
                var createElement = __webpack_require__2(317);
                var IS_IOS = __webpack_require__2(6833);
                var IS_NODE = __webpack_require__2(5268);
                var set = global.setImmediate;
                var clear = global.clearImmediate;
                var process = global.process;
                var Dispatch = global.Dispatch;
                var Function2 = global.Function;
                var MessageChannel = global.MessageChannel;
                var String2 = global.String;
                var counter = 0;
                var queue = {};
                var ONREADYSTATECHANGE = "onreadystatechange";
                var location2, defer, channel, port;
                try {
                  location2 = global.location;
                } catch (error) {
                }
                var run = function(id) {
                  if (hasOwn(queue, id)) {
                    var fn = queue[id];
                    delete queue[id];
                    fn();
                  }
                };
                var runner = function(id) {
                  return function() {
                    run(id);
                  };
                };
                var listener = function(event) {
                  run(event.data);
                };
                var post = function(id) {
                  global.postMessage(String2(id), location2.protocol + "//" + location2.host);
                };
                if (!set || !clear) {
                  set = function setImmediate(fn) {
                    var args = arraySlice(arguments, 1);
                    queue[++counter] = function() {
                      apply(isCallable(fn) ? fn : Function2(fn), void 0, args);
                    };
                    defer(counter);
                    return counter;
                  };
                  clear = function clearImmediate(id) {
                    delete queue[id];
                  };
                  if (IS_NODE) {
                    defer = function(id) {
                      process.nextTick(runner(id));
                    };
                  } else if (Dispatch && Dispatch.now) {
                    defer = function(id) {
                      Dispatch.now(runner(id));
                    };
                  } else if (MessageChannel && !IS_IOS) {
                    channel = new MessageChannel();
                    port = channel.port2;
                    channel.port1.onmessage = listener;
                    defer = bind(port.postMessage, port);
                  } else if (global.addEventListener && isCallable(global.postMessage) && !global.importScripts && location2 && location2.protocol !== "file:" && !fails(post)) {
                    defer = post;
                    global.addEventListener("message", listener, false);
                  } else if (ONREADYSTATECHANGE in createElement("script")) {
                    defer = function(id) {
                      html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
                        html.removeChild(this);
                        run(id);
                      };
                    };
                  } else {
                    defer = function(id) {
                      setTimeout(runner(id), 0);
                    };
                  }
                }
                module2.exports = {
                  set,
                  clear
                };
              }
            ),
            /***/
            863: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var uncurryThis = __webpack_require__2(1702);
                module2.exports = uncurryThis(1 .valueOf);
              }
            ),
            /***/
            1400: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var toIntegerOrInfinity = __webpack_require__2(9303);
                var max = Math.max;
                var min = Math.min;
                module2.exports = function(index, length) {
                  var integer = toIntegerOrInfinity(index);
                  return integer < 0 ? max(integer + length, 0) : min(integer, length);
                };
              }
            ),
            /***/
            7067: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var toIntegerOrInfinity = __webpack_require__2(9303);
                var toLength = __webpack_require__2(7466);
                var RangeError2 = global.RangeError;
                module2.exports = function(it) {
                  if (it === void 0)
                    return 0;
                  var number = toIntegerOrInfinity(it);
                  var length = toLength(number);
                  if (number !== length)
                    throw RangeError2("Wrong length or index");
                  return length;
                };
              }
            ),
            /***/
            5656: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var IndexedObject = __webpack_require__2(8361);
                var requireObjectCoercible = __webpack_require__2(4488);
                module2.exports = function(it) {
                  return IndexedObject(requireObjectCoercible(it));
                };
              }
            ),
            /***/
            9303: (
              /***/
              function(module2) {
                var ceil = Math.ceil;
                var floor = Math.floor;
                module2.exports = function(argument) {
                  var number = +argument;
                  return number !== number || number === 0 ? 0 : (number > 0 ? floor : ceil)(number);
                };
              }
            ),
            /***/
            7466: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var toIntegerOrInfinity = __webpack_require__2(9303);
                var min = Math.min;
                module2.exports = function(argument) {
                  return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
                };
              }
            ),
            /***/
            7908: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var requireObjectCoercible = __webpack_require__2(4488);
                var Object2 = global.Object;
                module2.exports = function(argument) {
                  return Object2(requireObjectCoercible(argument));
                };
              }
            ),
            /***/
            4590: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var toPositiveInteger = __webpack_require__2(3002);
                var RangeError2 = global.RangeError;
                module2.exports = function(it, BYTES) {
                  var offset = toPositiveInteger(it);
                  if (offset % BYTES)
                    throw RangeError2("Wrong offset");
                  return offset;
                };
              }
            ),
            /***/
            3002: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var toIntegerOrInfinity = __webpack_require__2(9303);
                var RangeError2 = global.RangeError;
                module2.exports = function(it) {
                  var result = toIntegerOrInfinity(it);
                  if (result < 0)
                    throw RangeError2("The argument can't be less than 0");
                  return result;
                };
              }
            ),
            /***/
            7593: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var call = __webpack_require__2(6916);
                var isObject = __webpack_require__2(111);
                var isSymbol = __webpack_require__2(2190);
                var getMethod = __webpack_require__2(8173);
                var ordinaryToPrimitive = __webpack_require__2(2140);
                var wellKnownSymbol = __webpack_require__2(5112);
                var TypeError2 = global.TypeError;
                var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
                module2.exports = function(input, pref) {
                  if (!isObject(input) || isSymbol(input))
                    return input;
                  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
                  var result;
                  if (exoticToPrim) {
                    if (pref === void 0)
                      pref = "default";
                    result = call(exoticToPrim, input, pref);
                    if (!isObject(result) || isSymbol(result))
                      return result;
                    throw TypeError2("Can't convert object to primitive value");
                  }
                  if (pref === void 0)
                    pref = "number";
                  return ordinaryToPrimitive(input, pref);
                };
              }
            ),
            /***/
            4948: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var toPrimitive = __webpack_require__2(7593);
                var isSymbol = __webpack_require__2(2190);
                module2.exports = function(argument) {
                  var key = toPrimitive(argument, "string");
                  return isSymbol(key) ? key : key + "";
                };
              }
            ),
            /***/
            1694: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var wellKnownSymbol = __webpack_require__2(5112);
                var TO_STRING_TAG = wellKnownSymbol("toStringTag");
                var test = {};
                test[TO_STRING_TAG] = "z";
                module2.exports = String(test) === "[object z]";
              }
            ),
            /***/
            1340: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var classof = __webpack_require__2(648);
                var String2 = global.String;
                module2.exports = function(argument) {
                  if (classof(argument) === "Symbol")
                    throw TypeError("Cannot convert a Symbol value to a string");
                  return String2(argument);
                };
              }
            ),
            /***/
            6330: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var String2 = global.String;
                module2.exports = function(argument) {
                  try {
                    return String2(argument);
                  } catch (error) {
                    return "Object";
                  }
                };
              }
            ),
            /***/
            9843: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var global = __webpack_require__2(7854);
                var call = __webpack_require__2(6916);
                var DESCRIPTORS = __webpack_require__2(9781);
                var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__2(3832);
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var ArrayBufferModule = __webpack_require__2(2091);
                var anInstance = __webpack_require__2(5787);
                var createPropertyDescriptor = __webpack_require__2(9114);
                var createNonEnumerableProperty = __webpack_require__2(8880);
                var isIntegralNumber = __webpack_require__2(5988);
                var toLength = __webpack_require__2(7466);
                var toIndex = __webpack_require__2(7067);
                var toOffset = __webpack_require__2(4590);
                var toPropertyKey = __webpack_require__2(4948);
                var hasOwn = __webpack_require__2(2597);
                var classof = __webpack_require__2(648);
                var isObject = __webpack_require__2(111);
                var isSymbol = __webpack_require__2(2190);
                var create = __webpack_require__2(30);
                var isPrototypeOf = __webpack_require__2(7976);
                var setPrototypeOf = __webpack_require__2(7674);
                var getOwnPropertyNames = __webpack_require__2(8006).f;
                var typedArrayFrom = __webpack_require__2(7321);
                var forEach = __webpack_require__2(2092).forEach;
                var setSpecies = __webpack_require__2(6340);
                var definePropertyModule = __webpack_require__2(3070);
                var getOwnPropertyDescriptorModule = __webpack_require__2(1236);
                var InternalStateModule = __webpack_require__2(9909);
                var inheritIfRequired = __webpack_require__2(9587);
                var getInternalState = InternalStateModule.get;
                var setInternalState = InternalStateModule.set;
                var nativeDefineProperty = definePropertyModule.f;
                var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                var round = Math.round;
                var RangeError2 = global.RangeError;
                var ArrayBuffer2 = ArrayBufferModule.ArrayBuffer;
                var ArrayBufferPrototype = ArrayBuffer2.prototype;
                var DataView2 = ArrayBufferModule.DataView;
                var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
                var TYPED_ARRAY_CONSTRUCTOR = ArrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
                var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
                var TypedArray = ArrayBufferViewCore.TypedArray;
                var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
                var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
                var isTypedArray = ArrayBufferViewCore.isTypedArray;
                var BYTES_PER_ELEMENT = "BYTES_PER_ELEMENT";
                var WRONG_LENGTH = "Wrong length";
                var fromList = function(C, list) {
                  aTypedArrayConstructor(C);
                  var index = 0;
                  var length = list.length;
                  var result = new C(length);
                  while (length > index)
                    result[index] = list[index++];
                  return result;
                };
                var addGetter = function(it, key) {
                  nativeDefineProperty(it, key, { get: function() {
                    return getInternalState(this)[key];
                  } });
                };
                var isArrayBuffer = function(it) {
                  var klass;
                  return isPrototypeOf(ArrayBufferPrototype, it) || (klass = classof(it)) == "ArrayBuffer" || klass == "SharedArrayBuffer";
                };
                var isTypedArrayIndex = function(target, key) {
                  return isTypedArray(target) && !isSymbol(key) && key in target && isIntegralNumber(+key) && key >= 0;
                };
                var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
                  key = toPropertyKey(key);
                  return isTypedArrayIndex(target, key) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
                };
                var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
                  key = toPropertyKey(key);
                  if (isTypedArrayIndex(target, key) && isObject(descriptor) && hasOwn(descriptor, "value") && !hasOwn(descriptor, "get") && !hasOwn(descriptor, "set") && !descriptor.configurable && (!hasOwn(descriptor, "writable") || descriptor.writable) && (!hasOwn(descriptor, "enumerable") || descriptor.enumerable)) {
                    target[key] = descriptor.value;
                    return target;
                  }
                  return nativeDefineProperty(target, key, descriptor);
                };
                if (DESCRIPTORS) {
                  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
                    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
                    definePropertyModule.f = wrappedDefineProperty;
                    addGetter(TypedArrayPrototype, "buffer");
                    addGetter(TypedArrayPrototype, "byteOffset");
                    addGetter(TypedArrayPrototype, "byteLength");
                    addGetter(TypedArrayPrototype, "length");
                  }
                  $({ target: "Object", stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
                    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
                    defineProperty: wrappedDefineProperty
                  });
                  module2.exports = function(TYPE, wrapper, CLAMPED) {
                    var BYTES = TYPE.match(/\d+$/)[0] / 8;
                    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? "Clamped" : "") + "Array";
                    var GETTER = "get" + TYPE;
                    var SETTER = "set" + TYPE;
                    var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
                    var TypedArrayConstructor = NativeTypedArrayConstructor;
                    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
                    var exported = {};
                    var getter = function(that, index) {
                      var data = getInternalState(that);
                      return data.view[GETTER](index * BYTES + data.byteOffset, true);
                    };
                    var setter = function(that, index, value) {
                      var data = getInternalState(that);
                      if (CLAMPED)
                        value = (value = round(value)) < 0 ? 0 : value > 255 ? 255 : value & 255;
                      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
                    };
                    var addElement = function(that, index) {
                      nativeDefineProperty(that, index, {
                        get: function() {
                          return getter(this, index);
                        },
                        set: function(value) {
                          return setter(this, index, value);
                        },
                        enumerable: true
                      });
                    };
                    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
                      TypedArrayConstructor = wrapper(function(that, data, offset, $length) {
                        anInstance(that, TypedArrayConstructorPrototype);
                        var index = 0;
                        var byteOffset = 0;
                        var buffer, byteLength, length;
                        if (!isObject(data)) {
                          length = toIndex(data);
                          byteLength = length * BYTES;
                          buffer = new ArrayBuffer2(byteLength);
                        } else if (isArrayBuffer(data)) {
                          buffer = data;
                          byteOffset = toOffset(offset, BYTES);
                          var $len = data.byteLength;
                          if ($length === void 0) {
                            if ($len % BYTES)
                              throw RangeError2(WRONG_LENGTH);
                            byteLength = $len - byteOffset;
                            if (byteLength < 0)
                              throw RangeError2(WRONG_LENGTH);
                          } else {
                            byteLength = toLength($length) * BYTES;
                            if (byteLength + byteOffset > $len)
                              throw RangeError2(WRONG_LENGTH);
                          }
                          length = byteLength / BYTES;
                        } else if (isTypedArray(data)) {
                          return fromList(TypedArrayConstructor, data);
                        } else {
                          return call(typedArrayFrom, TypedArrayConstructor, data);
                        }
                        setInternalState(that, {
                          buffer,
                          byteOffset,
                          byteLength,
                          length,
                          view: new DataView2(buffer)
                        });
                        while (index < length)
                          addElement(that, index++);
                      });
                      if (setPrototypeOf)
                        setPrototypeOf(TypedArrayConstructor, TypedArray);
                      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
                    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
                      TypedArrayConstructor = wrapper(function(dummy, data, typedArrayOffset, $length) {
                        anInstance(dummy, TypedArrayConstructorPrototype);
                        return inheritIfRequired(function() {
                          if (!isObject(data))
                            return new NativeTypedArrayConstructor(toIndex(data));
                          if (isArrayBuffer(data))
                            return $length !== void 0 ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== void 0 ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
                          if (isTypedArray(data))
                            return fromList(TypedArrayConstructor, data);
                          return call(typedArrayFrom, TypedArrayConstructor, data);
                        }(), dummy, TypedArrayConstructor);
                      });
                      if (setPrototypeOf)
                        setPrototypeOf(TypedArrayConstructor, TypedArray);
                      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function(key) {
                        if (!(key in TypedArrayConstructor)) {
                          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
                        }
                      });
                      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
                    }
                    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
                      createNonEnumerableProperty(TypedArrayConstructorPrototype, "constructor", TypedArrayConstructor);
                    }
                    createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_CONSTRUCTOR, TypedArrayConstructor);
                    if (TYPED_ARRAY_TAG) {
                      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
                    }
                    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
                    $({
                      global: true,
                      forced: TypedArrayConstructor != NativeTypedArrayConstructor,
                      sham: !NATIVE_ARRAY_BUFFER_VIEWS
                    }, exported);
                    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
                      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
                    }
                    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
                      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
                    }
                    setSpecies(CONSTRUCTOR_NAME);
                  };
                } else
                  module2.exports = function() {
                  };
              }
            ),
            /***/
            3832: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var fails = __webpack_require__2(7293);
                var checkCorrectnessOfIteration = __webpack_require__2(7072);
                var NATIVE_ARRAY_BUFFER_VIEWS = __webpack_require__2(2094).NATIVE_ARRAY_BUFFER_VIEWS;
                var ArrayBuffer2 = global.ArrayBuffer;
                var Int8Array2 = global.Int8Array;
                module2.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function() {
                  Int8Array2(1);
                }) || !fails(function() {
                  new Int8Array2(-1);
                }) || !checkCorrectnessOfIteration(function(iterable) {
                  new Int8Array2();
                  new Int8Array2(null);
                  new Int8Array2(1.5);
                  new Int8Array2(iterable);
                }, true) || fails(function() {
                  return new Int8Array2(new ArrayBuffer2(2), 1, void 0).length !== 1;
                });
              }
            ),
            /***/
            3074: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var arrayFromConstructorAndList = __webpack_require__2(7745);
                var typedArraySpeciesConstructor = __webpack_require__2(6304);
                module2.exports = function(instance, list) {
                  return arrayFromConstructorAndList(typedArraySpeciesConstructor(instance), list);
                };
              }
            ),
            /***/
            7321: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var bind = __webpack_require__2(9974);
                var call = __webpack_require__2(6916);
                var aConstructor = __webpack_require__2(9483);
                var toObject = __webpack_require__2(7908);
                var lengthOfArrayLike = __webpack_require__2(6244);
                var getIterator = __webpack_require__2(8554);
                var getIteratorMethod = __webpack_require__2(1246);
                var isArrayIteratorMethod = __webpack_require__2(7659);
                var aTypedArrayConstructor = __webpack_require__2(2094).aTypedArrayConstructor;
                module2.exports = function from(source) {
                  var C = aConstructor(this);
                  var O = toObject(source);
                  var argumentsLength = arguments.length;
                  var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
                  var mapping = mapfn !== void 0;
                  var iteratorMethod = getIteratorMethod(O);
                  var i, length, result, step, iterator, next;
                  if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
                    iterator = getIterator(O, iteratorMethod);
                    next = iterator.next;
                    O = [];
                    while (!(step = call(next, iterator)).done) {
                      O.push(step.value);
                    }
                  }
                  if (mapping && argumentsLength > 2) {
                    mapfn = bind(mapfn, arguments[2]);
                  }
                  length = lengthOfArrayLike(O);
                  result = new (aTypedArrayConstructor(C))(length);
                  for (i = 0; length > i; i++) {
                    result[i] = mapping ? mapfn(O[i], i) : O[i];
                  }
                  return result;
                };
              }
            ),
            /***/
            6304: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var speciesConstructor = __webpack_require__2(6707);
                var TYPED_ARRAY_CONSTRUCTOR = ArrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
                var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
                module2.exports = function(originalArray) {
                  return aTypedArrayConstructor(speciesConstructor(originalArray, originalArray[TYPED_ARRAY_CONSTRUCTOR]));
                };
              }
            ),
            /***/
            9711: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var uncurryThis = __webpack_require__2(1702);
                var id = 0;
                var postfix = Math.random();
                var toString = uncurryThis(1 .toString);
                module2.exports = function(key) {
                  return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
                };
              }
            ),
            /***/
            3307: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var NATIVE_SYMBOL = __webpack_require__2(133);
                module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
              }
            ),
            /***/
            6061: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                var wellKnownSymbol = __webpack_require__2(5112);
                exports2.f = wellKnownSymbol;
              }
            ),
            /***/
            5112: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var shared = __webpack_require__2(2309);
                var hasOwn = __webpack_require__2(2597);
                var uid = __webpack_require__2(9711);
                var NATIVE_SYMBOL = __webpack_require__2(133);
                var USE_SYMBOL_AS_UID = __webpack_require__2(3307);
                var WellKnownSymbolsStore = shared("wks");
                var Symbol2 = global.Symbol;
                var symbolFor = Symbol2 && Symbol2["for"];
                var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
                module2.exports = function(name) {
                  if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == "string")) {
                    var description = "Symbol." + name;
                    if (NATIVE_SYMBOL && hasOwn(Symbol2, name)) {
                      WellKnownSymbolsStore[name] = Symbol2[name];
                    } else if (USE_SYMBOL_AS_UID && symbolFor) {
                      WellKnownSymbolsStore[name] = symbolFor(description);
                    } else {
                      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
                    }
                  }
                  return WellKnownSymbolsStore[name];
                };
              }
            ),
            /***/
            1361: (
              /***/
              function(module2) {
                module2.exports = "	\n\v\f\r \u2028\u2029\uFEFF";
              }
            ),
            /***/
            9170: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var global = __webpack_require__2(7854);
                var isPrototypeOf = __webpack_require__2(7976);
                var getPrototypeOf = __webpack_require__2(9518);
                var setPrototypeOf = __webpack_require__2(7674);
                var copyConstructorProperties = __webpack_require__2(9920);
                var create = __webpack_require__2(30);
                var createNonEnumerableProperty = __webpack_require__2(8880);
                var createPropertyDescriptor = __webpack_require__2(9114);
                var clearErrorStack = __webpack_require__2(7741);
                var installErrorCause = __webpack_require__2(8340);
                var iterate = __webpack_require__2(408);
                var normalizeStringArgument = __webpack_require__2(6277);
                var ERROR_STACK_INSTALLABLE = __webpack_require__2(2914);
                var Error2 = global.Error;
                var push = [].push;
                var $AggregateError = function AggregateError2(errors, message) {
                  var that = isPrototypeOf(AggregateErrorPrototype, this) ? this : create(AggregateErrorPrototype);
                  var options = arguments.length > 2 ? arguments[2] : void 0;
                  if (setPrototypeOf) {
                    that = setPrototypeOf(new Error2(void 0), getPrototypeOf(that));
                  }
                  createNonEnumerableProperty(that, "message", normalizeStringArgument(message, ""));
                  if (ERROR_STACK_INSTALLABLE)
                    createNonEnumerableProperty(that, "stack", clearErrorStack(that.stack, 1));
                  installErrorCause(that, options);
                  var errorsArray = [];
                  iterate(errors, push, { that: errorsArray });
                  createNonEnumerableProperty(that, "errors", errorsArray);
                  return that;
                };
                if (setPrototypeOf)
                  setPrototypeOf($AggregateError, Error2);
                else
                  copyConstructorProperties($AggregateError, Error2);
                var AggregateErrorPrototype = $AggregateError.prototype = create(Error2.prototype, {
                  constructor: createPropertyDescriptor(1, $AggregateError),
                  message: createPropertyDescriptor(1, ""),
                  name: createPropertyDescriptor(1, "AggregateError")
                });
                $({ global: true }, {
                  AggregateError: $AggregateError
                });
              }
            ),
            /***/
            2222: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var global = __webpack_require__2(7854);
                var fails = __webpack_require__2(7293);
                var isArray = __webpack_require__2(3157);
                var isObject = __webpack_require__2(111);
                var toObject = __webpack_require__2(7908);
                var lengthOfArrayLike = __webpack_require__2(6244);
                var createProperty = __webpack_require__2(6135);
                var arraySpeciesCreate = __webpack_require__2(5417);
                var arrayMethodHasSpeciesSupport = __webpack_require__2(1194);
                var wellKnownSymbol = __webpack_require__2(5112);
                var V8_VERSION = __webpack_require__2(7392);
                var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
                var MAX_SAFE_INTEGER = 9007199254740991;
                var MAXIMUM_ALLOWED_INDEX_EXCEEDED = "Maximum allowed index exceeded";
                var TypeError2 = global.TypeError;
                var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
                  var array = [];
                  array[IS_CONCAT_SPREADABLE] = false;
                  return array.concat()[0] !== array;
                });
                var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("concat");
                var isConcatSpreadable = function(O) {
                  if (!isObject(O))
                    return false;
                  var spreadable = O[IS_CONCAT_SPREADABLE];
                  return spreadable !== void 0 ? !!spreadable : isArray(O);
                };
                var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
                $({ target: "Array", proto: true, forced: FORCED }, {
                  // eslint-disable-next-line no-unused-vars -- required for `.length`
                  concat: function concat(arg) {
                    var O = toObject(this);
                    var A = arraySpeciesCreate(O, 0);
                    var n = 0;
                    var i, k, length, len, E;
                    for (i = -1, length = arguments.length; i < length; i++) {
                      E = i === -1 ? O : arguments[i];
                      if (isConcatSpreadable(E)) {
                        len = lengthOfArrayLike(E);
                        if (n + len > MAX_SAFE_INTEGER)
                          throw TypeError2(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                        for (k = 0; k < len; k++, n++)
                          if (k in E)
                            createProperty(A, n, E[k]);
                      } else {
                        if (n >= MAX_SAFE_INTEGER)
                          throw TypeError2(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                        createProperty(A, n++, E);
                      }
                    }
                    A.length = n;
                    return A;
                  }
                });
              }
            ),
            /***/
            545: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(2109);
                var copyWithin = __webpack_require__2(1048);
                var addToUnscopables = __webpack_require__2(1223);
                $({ target: "Array", proto: true }, {
                  copyWithin
                });
                addToUnscopables("copyWithin");
              }
            ),
            /***/
            3290: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(2109);
                var fill = __webpack_require__2(1285);
                var addToUnscopables = __webpack_require__2(1223);
                $({ target: "Array", proto: true }, {
                  fill
                });
                addToUnscopables("fill");
              }
            ),
            /***/
            7327: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var $filter = __webpack_require__2(2092).filter;
                var arrayMethodHasSpeciesSupport = __webpack_require__2(1194);
                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
                $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
                  filter: function filter(callbackfn) {
                    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                  }
                });
              }
            ),
            /***/
            1038: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(2109);
                var from = __webpack_require__2(8457);
                var checkCorrectnessOfIteration = __webpack_require__2(7072);
                var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
                  Array.from(iterable);
                });
                $({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
                  from
                });
              }
            ),
            /***/
            6699: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var $includes = __webpack_require__2(1318).includes;
                var addToUnscopables = __webpack_require__2(1223);
                $({ target: "Array", proto: true }, {
                  includes: function includes(el) {
                    return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
                  }
                });
                addToUnscopables("includes");
              }
            ),
            /***/
            6992: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var toIndexedObject = __webpack_require__2(5656);
                var addToUnscopables = __webpack_require__2(1223);
                var Iterators = __webpack_require__2(7497);
                var InternalStateModule = __webpack_require__2(9909);
                var defineIterator = __webpack_require__2(654);
                var ARRAY_ITERATOR = "Array Iterator";
                var setInternalState = InternalStateModule.set;
                var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
                module2.exports = defineIterator(Array, "Array", function(iterated, kind) {
                  setInternalState(this, {
                    type: ARRAY_ITERATOR,
                    target: toIndexedObject(iterated),
                    // target
                    index: 0,
                    // next index
                    kind
                    // kind
                  });
                }, function() {
                  var state = getInternalState(this);
                  var target = state.target;
                  var kind = state.kind;
                  var index = state.index++;
                  if (!target || index >= target.length) {
                    state.target = void 0;
                    return { value: void 0, done: true };
                  }
                  if (kind == "keys")
                    return { value: index, done: false };
                  if (kind == "values")
                    return { value: target[index], done: false };
                  return { value: [index, target[index]], done: false };
                }, "values");
                Iterators.Arguments = Iterators.Array;
                addToUnscopables("keys");
                addToUnscopables("values");
                addToUnscopables("entries");
              }
            ),
            /***/
            9600: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var uncurryThis = __webpack_require__2(1702);
                var IndexedObject = __webpack_require__2(8361);
                var toIndexedObject = __webpack_require__2(5656);
                var arrayMethodIsStrict = __webpack_require__2(9341);
                var un$Join = uncurryThis([].join);
                var ES3_STRINGS = IndexedObject != Object;
                var STRICT_METHOD = arrayMethodIsStrict("join", ",");
                $({ target: "Array", proto: true, forced: ES3_STRINGS || !STRICT_METHOD }, {
                  join: function join(separator) {
                    return un$Join(toIndexedObject(this), separator === void 0 ? "," : separator);
                  }
                });
              }
            ),
            /***/
            1249: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var $map = __webpack_require__2(2092).map;
                var arrayMethodHasSpeciesSupport = __webpack_require__2(1194);
                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
                $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
                  map: function map(callbackfn) {
                    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                  }
                });
              }
            ),
            /***/
            7042: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var global = __webpack_require__2(7854);
                var isArray = __webpack_require__2(3157);
                var isConstructor = __webpack_require__2(4411);
                var isObject = __webpack_require__2(111);
                var toAbsoluteIndex = __webpack_require__2(1400);
                var lengthOfArrayLike = __webpack_require__2(6244);
                var toIndexedObject = __webpack_require__2(5656);
                var createProperty = __webpack_require__2(6135);
                var wellKnownSymbol = __webpack_require__2(5112);
                var arrayMethodHasSpeciesSupport = __webpack_require__2(1194);
                var un$Slice = __webpack_require__2(206);
                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
                var SPECIES = wellKnownSymbol("species");
                var Array2 = global.Array;
                var max = Math.max;
                $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
                  slice: function slice(start, end) {
                    var O = toIndexedObject(this);
                    var length = lengthOfArrayLike(O);
                    var k = toAbsoluteIndex(start, length);
                    var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
                    var Constructor, result, n;
                    if (isArray(O)) {
                      Constructor = O.constructor;
                      if (isConstructor(Constructor) && (Constructor === Array2 || isArray(Constructor.prototype))) {
                        Constructor = void 0;
                      } else if (isObject(Constructor)) {
                        Constructor = Constructor[SPECIES];
                        if (Constructor === null)
                          Constructor = void 0;
                      }
                      if (Constructor === Array2 || Constructor === void 0) {
                        return un$Slice(O, k, fin);
                      }
                    }
                    result = new (Constructor === void 0 ? Array2 : Constructor)(max(fin - k, 0));
                    for (n = 0; k < fin; k++, n++)
                      if (k in O)
                        createProperty(result, n, O[k]);
                    result.length = n;
                    return result;
                  }
                });
              }
            ),
            /***/
            2707: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var uncurryThis = __webpack_require__2(1702);
                var aCallable = __webpack_require__2(9662);
                var toObject = __webpack_require__2(7908);
                var lengthOfArrayLike = __webpack_require__2(6244);
                var toString = __webpack_require__2(1340);
                var fails = __webpack_require__2(7293);
                var internalSort = __webpack_require__2(4362);
                var arrayMethodIsStrict = __webpack_require__2(9341);
                var FF = __webpack_require__2(8886);
                var IE_OR_EDGE = __webpack_require__2(256);
                var V8 = __webpack_require__2(7392);
                var WEBKIT = __webpack_require__2(8008);
                var test = [];
                var un$Sort = uncurryThis(test.sort);
                var push = uncurryThis(test.push);
                var FAILS_ON_UNDEFINED = fails(function() {
                  test.sort(void 0);
                });
                var FAILS_ON_NULL = fails(function() {
                  test.sort(null);
                });
                var STRICT_METHOD = arrayMethodIsStrict("sort");
                var STABLE_SORT = !fails(function() {
                  if (V8)
                    return V8 < 70;
                  if (FF && FF > 3)
                    return;
                  if (IE_OR_EDGE)
                    return true;
                  if (WEBKIT)
                    return WEBKIT < 603;
                  var result = "";
                  var code, chr, value, index;
                  for (code = 65; code < 76; code++) {
                    chr = String.fromCharCode(code);
                    switch (code) {
                      case 66:
                      case 69:
                      case 70:
                      case 72:
                        value = 3;
                        break;
                      case 68:
                      case 71:
                        value = 4;
                        break;
                      default:
                        value = 2;
                    }
                    for (index = 0; index < 47; index++) {
                      test.push({ k: chr + index, v: value });
                    }
                  }
                  test.sort(function(a, b) {
                    return b.v - a.v;
                  });
                  for (index = 0; index < test.length; index++) {
                    chr = test[index].k.charAt(0);
                    if (result.charAt(result.length - 1) !== chr)
                      result += chr;
                  }
                  return result !== "DGBEFHACIJK";
                });
                var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
                var getSortCompare = function(comparefn) {
                  return function(x, y) {
                    if (y === void 0)
                      return -1;
                    if (x === void 0)
                      return 1;
                    if (comparefn !== void 0)
                      return +comparefn(x, y) || 0;
                    return toString(x) > toString(y) ? 1 : -1;
                  };
                };
                $({ target: "Array", proto: true, forced: FORCED }, {
                  sort: function sort(comparefn) {
                    if (comparefn !== void 0)
                      aCallable(comparefn);
                    var array = toObject(this);
                    if (STABLE_SORT)
                      return comparefn === void 0 ? un$Sort(array) : un$Sort(array, comparefn);
                    var items = [];
                    var arrayLength = lengthOfArrayLike(array);
                    var itemsLength, index;
                    for (index = 0; index < arrayLength; index++) {
                      if (index in array)
                        push(items, array[index]);
                    }
                    internalSort(items, getSortCompare(comparefn));
                    itemsLength = items.length;
                    index = 0;
                    while (index < itemsLength)
                      array[index] = items[index++];
                    while (index < arrayLength)
                      delete array[index++];
                    return array;
                  }
                });
              }
            ),
            /***/
            561: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var global = __webpack_require__2(7854);
                var toAbsoluteIndex = __webpack_require__2(1400);
                var toIntegerOrInfinity = __webpack_require__2(9303);
                var lengthOfArrayLike = __webpack_require__2(6244);
                var toObject = __webpack_require__2(7908);
                var arraySpeciesCreate = __webpack_require__2(5417);
                var createProperty = __webpack_require__2(6135);
                var arrayMethodHasSpeciesSupport = __webpack_require__2(1194);
                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
                var TypeError2 = global.TypeError;
                var max = Math.max;
                var min = Math.min;
                var MAX_SAFE_INTEGER = 9007199254740991;
                var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = "Maximum allowed length exceeded";
                $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
                  splice: function splice(start, deleteCount) {
                    var O = toObject(this);
                    var len = lengthOfArrayLike(O);
                    var actualStart = toAbsoluteIndex(start, len);
                    var argumentsLength = arguments.length;
                    var insertCount, actualDeleteCount, A, k, from, to;
                    if (argumentsLength === 0) {
                      insertCount = actualDeleteCount = 0;
                    } else if (argumentsLength === 1) {
                      insertCount = 0;
                      actualDeleteCount = len - actualStart;
                    } else {
                      insertCount = argumentsLength - 2;
                      actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
                    }
                    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
                      throw TypeError2(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
                    }
                    A = arraySpeciesCreate(O, actualDeleteCount);
                    for (k = 0; k < actualDeleteCount; k++) {
                      from = actualStart + k;
                      if (from in O)
                        createProperty(A, k, O[from]);
                    }
                    A.length = actualDeleteCount;
                    if (insertCount < actualDeleteCount) {
                      for (k = actualStart; k < len - actualDeleteCount; k++) {
                        from = k + actualDeleteCount;
                        to = k + insertCount;
                        if (from in O)
                          O[to] = O[from];
                        else
                          delete O[to];
                      }
                      for (k = len; k > len - actualDeleteCount + insertCount; k--)
                        delete O[k - 1];
                    } else if (insertCount > actualDeleteCount) {
                      for (k = len - actualDeleteCount; k > actualStart; k--) {
                        from = k + actualDeleteCount - 1;
                        to = k + insertCount - 1;
                        if (from in O)
                          O[to] = O[from];
                        else
                          delete O[to];
                      }
                    }
                    for (k = 0; k < insertCount; k++) {
                      O[k + actualStart] = arguments[k + 2];
                    }
                    O.length = len - actualDeleteCount + insertCount;
                    return A;
                  }
                });
              }
            ),
            /***/
            6078: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var hasOwn = __webpack_require__2(2597);
                var redefine = __webpack_require__2(1320);
                var dateToPrimitive = __webpack_require__2(8709);
                var wellKnownSymbol = __webpack_require__2(5112);
                var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
                var DatePrototype = Date.prototype;
                if (!hasOwn(DatePrototype, TO_PRIMITIVE)) {
                  redefine(DatePrototype, TO_PRIMITIVE, dateToPrimitive);
                }
              }
            ),
            /***/
            8309: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var DESCRIPTORS = __webpack_require__2(9781);
                var FUNCTION_NAME_EXISTS = __webpack_require__2(6530).EXISTS;
                var uncurryThis = __webpack_require__2(1702);
                var defineProperty = __webpack_require__2(3070).f;
                var FunctionPrototype = Function.prototype;
                var functionToString = uncurryThis(FunctionPrototype.toString);
                var nameRE = /^\s*function ([^ (]*)/;
                var regExpExec = uncurryThis(nameRE.exec);
                var NAME = "name";
                if (DESCRIPTORS && !FUNCTION_NAME_EXISTS) {
                  defineProperty(FunctionPrototype, NAME, {
                    configurable: true,
                    get: function() {
                      try {
                        return regExpExec(nameRE, functionToString(this))[1];
                      } catch (error) {
                        return "";
                      }
                    }
                  });
                }
              }
            ),
            /***/
            5837: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(2109);
                var global = __webpack_require__2(7854);
                $({ global: true }, {
                  globalThis: global
                });
              }
            ),
            /***/
            3706: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var setToStringTag = __webpack_require__2(8003);
                setToStringTag(global.JSON, "JSON", true);
              }
            ),
            /***/
            1532: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var collection = __webpack_require__2(7710);
                var collectionStrong = __webpack_require__2(5631);
                collection("Map", function(init) {
                  return function Map2() {
                    return init(this, arguments.length ? arguments[0] : void 0);
                  };
                }, collectionStrong);
              }
            ),
            /***/
            2703: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var setToStringTag = __webpack_require__2(8003);
                setToStringTag(Math, "Math", true);
              }
            ),
            /***/
            9653: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var DESCRIPTORS = __webpack_require__2(9781);
                var global = __webpack_require__2(7854);
                var uncurryThis = __webpack_require__2(1702);
                var isForced = __webpack_require__2(4705);
                var redefine = __webpack_require__2(1320);
                var hasOwn = __webpack_require__2(2597);
                var inheritIfRequired = __webpack_require__2(9587);
                var isPrototypeOf = __webpack_require__2(7976);
                var isSymbol = __webpack_require__2(2190);
                var toPrimitive = __webpack_require__2(7593);
                var fails = __webpack_require__2(7293);
                var getOwnPropertyNames = __webpack_require__2(8006).f;
                var getOwnPropertyDescriptor = __webpack_require__2(1236).f;
                var defineProperty = __webpack_require__2(3070).f;
                var thisNumberValue = __webpack_require__2(863);
                var trim = __webpack_require__2(3111).trim;
                var NUMBER = "Number";
                var NativeNumber = global[NUMBER];
                var NumberPrototype = NativeNumber.prototype;
                var TypeError2 = global.TypeError;
                var arraySlice = uncurryThis("".slice);
                var charCodeAt = uncurryThis("".charCodeAt);
                var toNumeric = function(value) {
                  var primValue = toPrimitive(value, "number");
                  return typeof primValue == "bigint" ? primValue : toNumber(primValue);
                };
                var toNumber = function(argument) {
                  var it = toPrimitive(argument, "number");
                  var first, third, radix, maxCode, digits, length, index, code;
                  if (isSymbol(it))
                    throw TypeError2("Cannot convert a Symbol value to a number");
                  if (typeof it == "string" && it.length > 2) {
                    it = trim(it);
                    first = charCodeAt(it, 0);
                    if (first === 43 || first === 45) {
                      third = charCodeAt(it, 2);
                      if (third === 88 || third === 120)
                        return NaN;
                    } else if (first === 48) {
                      switch (charCodeAt(it, 1)) {
                        case 66:
                        case 98:
                          radix = 2;
                          maxCode = 49;
                          break;
                        case 79:
                        case 111:
                          radix = 8;
                          maxCode = 55;
                          break;
                        default:
                          return +it;
                      }
                      digits = arraySlice(it, 2);
                      length = digits.length;
                      for (index = 0; index < length; index++) {
                        code = charCodeAt(digits, index);
                        if (code < 48 || code > maxCode)
                          return NaN;
                      }
                      return parseInt(digits, radix);
                    }
                  }
                  return +it;
                };
                if (isForced(NUMBER, !NativeNumber(" 0o1") || !NativeNumber("0b1") || NativeNumber("+0x1"))) {
                  var NumberWrapper = function Number2(value) {
                    var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
                    var dummy = this;
                    return isPrototypeOf(NumberPrototype, dummy) && fails(function() {
                      thisNumberValue(dummy);
                    }) ? inheritIfRequired(Object(n), dummy, NumberWrapper) : n;
                  };
                  for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (
                    // ES3:
                    "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(",")
                  ), j = 0, key; keys.length > j; j++) {
                    if (hasOwn(NativeNumber, key = keys[j]) && !hasOwn(NumberWrapper, key)) {
                      defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
                    }
                  }
                  NumberWrapper.prototype = NumberPrototype;
                  NumberPrototype.constructor = NumberWrapper;
                  redefine(global, NUMBER, NumberWrapper);
                }
              }
            ),
            /***/
            3299: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(2109);
                $({ target: "Number", stat: true }, {
                  EPSILON: Math.pow(2, -52)
                });
              }
            ),
            /***/
            5192: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(2109);
                var numberIsFinite = __webpack_require__2(7023);
                $({ target: "Number", stat: true }, { isFinite: numberIsFinite });
              }
            ),
            /***/
            3161: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(2109);
                var isIntegralNumber = __webpack_require__2(5988);
                $({ target: "Number", stat: true }, {
                  isInteger: isIntegralNumber
                });
              }
            ),
            /***/
            6977: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var global = __webpack_require__2(7854);
                var uncurryThis = __webpack_require__2(1702);
                var toIntegerOrInfinity = __webpack_require__2(9303);
                var thisNumberValue = __webpack_require__2(863);
                var $repeat = __webpack_require__2(8415);
                var fails = __webpack_require__2(7293);
                var RangeError2 = global.RangeError;
                var String2 = global.String;
                var floor = Math.floor;
                var repeat = uncurryThis($repeat);
                var stringSlice = uncurryThis("".slice);
                var un$ToFixed = uncurryThis(1 .toFixed);
                var pow = function(x, n, acc) {
                  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
                };
                var log = function(x) {
                  var n = 0;
                  var x2 = x;
                  while (x2 >= 4096) {
                    n += 12;
                    x2 /= 4096;
                  }
                  while (x2 >= 2) {
                    n += 1;
                    x2 /= 2;
                  }
                  return n;
                };
                var multiply = function(data, n, c) {
                  var index = -1;
                  var c2 = c;
                  while (++index < 6) {
                    c2 += n * data[index];
                    data[index] = c2 % 1e7;
                    c2 = floor(c2 / 1e7);
                  }
                };
                var divide = function(data, n) {
                  var index = 6;
                  var c = 0;
                  while (--index >= 0) {
                    c += data[index];
                    data[index] = floor(c / n);
                    c = c % n * 1e7;
                  }
                };
                var dataToString = function(data) {
                  var index = 6;
                  var s = "";
                  while (--index >= 0) {
                    if (s !== "" || index === 0 || data[index] !== 0) {
                      var t = String2(data[index]);
                      s = s === "" ? t : s + repeat("0", 7 - t.length) + t;
                    }
                  }
                  return s;
                };
                var FORCED = fails(function() {
                  return un$ToFixed(8e-5, 3) !== "0.000" || un$ToFixed(0.9, 0) !== "1" || un$ToFixed(1.255, 2) !== "1.25" || un$ToFixed(1000000000000000100, 0) !== "1000000000000000128";
                }) || !fails(function() {
                  un$ToFixed({});
                });
                $({ target: "Number", proto: true, forced: FORCED }, {
                  toFixed: function toFixed(fractionDigits) {
                    var number = thisNumberValue(this);
                    var fractDigits = toIntegerOrInfinity(fractionDigits);
                    var data = [0, 0, 0, 0, 0, 0];
                    var sign = "";
                    var result = "0";
                    var e, z, j, k;
                    if (fractDigits < 0 || fractDigits > 20)
                      throw RangeError2("Incorrect fraction digits");
                    if (number != number)
                      return "NaN";
                    if (number <= -1e21 || number >= 1e21)
                      return String2(number);
                    if (number < 0) {
                      sign = "-";
                      number = -number;
                    }
                    if (number > 1e-21) {
                      e = log(number * pow(2, 69, 1)) - 69;
                      z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
                      z *= 4503599627370496;
                      e = 52 - e;
                      if (e > 0) {
                        multiply(data, 0, z);
                        j = fractDigits;
                        while (j >= 7) {
                          multiply(data, 1e7, 0);
                          j -= 7;
                        }
                        multiply(data, pow(10, j, 1), 0);
                        j = e - 1;
                        while (j >= 23) {
                          divide(data, 1 << 23);
                          j -= 23;
                        }
                        divide(data, 1 << j);
                        multiply(data, 1, 1);
                        divide(data, 2);
                        result = dataToString(data);
                      } else {
                        multiply(data, 0, z);
                        multiply(data, 1 << -e, 0);
                        result = dataToString(data) + repeat("0", fractDigits);
                      }
                    }
                    if (fractDigits > 0) {
                      k = result.length;
                      result = sign + (k <= fractDigits ? "0." + repeat("0", fractDigits - k) + result : stringSlice(result, 0, k - fractDigits) + "." + stringSlice(result, k - fractDigits));
                    } else {
                      result = sign + result;
                    }
                    return result;
                  }
                });
              }
            ),
            /***/
            9601: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(2109);
                var assign = __webpack_require__2(1574);
                $({ target: "Object", stat: true, forced: Object.assign !== assign }, {
                  assign
                });
              }
            ),
            /***/
            3371: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(2109);
                var FREEZING = __webpack_require__2(6677);
                var fails = __webpack_require__2(7293);
                var isObject = __webpack_require__2(111);
                var onFreeze = __webpack_require__2(2423).onFreeze;
                var $freeze = Object.freeze;
                var FAILS_ON_PRIMITIVES = fails(function() {
                  $freeze(1);
                });
                $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
                  freeze: function freeze(it) {
                    return $freeze && isObject(it) ? $freeze(onFreeze(it)) : it;
                  }
                });
              }
            ),
            /***/
            5003: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(2109);
                var fails = __webpack_require__2(7293);
                var toIndexedObject = __webpack_require__2(5656);
                var nativeGetOwnPropertyDescriptor = __webpack_require__2(1236).f;
                var DESCRIPTORS = __webpack_require__2(9781);
                var FAILS_ON_PRIMITIVES = fails(function() {
                  nativeGetOwnPropertyDescriptor(1);
                });
                var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;
                $({ target: "Object", stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
                  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
                    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
                  }
                });
              }
            ),
            /***/
            9337: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(2109);
                var DESCRIPTORS = __webpack_require__2(9781);
                var ownKeys = __webpack_require__2(3887);
                var toIndexedObject = __webpack_require__2(5656);
                var getOwnPropertyDescriptorModule = __webpack_require__2(1236);
                var createProperty = __webpack_require__2(6135);
                $({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
                  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
                    var O = toIndexedObject(object);
                    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                    var keys = ownKeys(O);
                    var result = {};
                    var index = 0;
                    var key, descriptor;
                    while (keys.length > index) {
                      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
                      if (descriptor !== void 0)
                        createProperty(result, key, descriptor);
                    }
                    return result;
                  }
                });
              }
            ),
            /***/
            489: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(2109);
                var fails = __webpack_require__2(7293);
                var toObject = __webpack_require__2(7908);
                var nativeGetPrototypeOf = __webpack_require__2(9518);
                var CORRECT_PROTOTYPE_GETTER = __webpack_require__2(8544);
                var FAILS_ON_PRIMITIVES = fails(function() {
                  nativeGetPrototypeOf(1);
                });
                $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
                  getPrototypeOf: function getPrototypeOf(it) {
                    return nativeGetPrototypeOf(toObject(it));
                  }
                });
              }
            ),
            /***/
            7941: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(2109);
                var toObject = __webpack_require__2(7908);
                var nativeKeys = __webpack_require__2(1956);
                var fails = __webpack_require__2(7293);
                var FAILS_ON_PRIMITIVES = fails(function() {
                  nativeKeys(1);
                });
                $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
                  keys: function keys(it) {
                    return nativeKeys(toObject(it));
                  }
                });
              }
            ),
            /***/
            1539: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var TO_STRING_TAG_SUPPORT = __webpack_require__2(1694);
                var redefine = __webpack_require__2(1320);
                var toString = __webpack_require__2(288);
                if (!TO_STRING_TAG_SUPPORT) {
                  redefine(Object.prototype, "toString", toString, { unsafe: true });
                }
              }
            ),
            /***/
            2479: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(2109);
                var $values = __webpack_require__2(4699).values;
                $({ target: "Object", stat: true }, {
                  values: function values(O) {
                    return $values(O);
                  }
                });
              }
            ),
            /***/
            7922: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var call = __webpack_require__2(6916);
                var aCallable = __webpack_require__2(9662);
                var newPromiseCapabilityModule = __webpack_require__2(8523);
                var perform = __webpack_require__2(2534);
                var iterate = __webpack_require__2(408);
                $({ target: "Promise", stat: true }, {
                  allSettled: function allSettled(iterable) {
                    var C = this;
                    var capability = newPromiseCapabilityModule.f(C);
                    var resolve = capability.resolve;
                    var reject = capability.reject;
                    var result = perform(function() {
                      var promiseResolve = aCallable(C.resolve);
                      var values = [];
                      var counter = 0;
                      var remaining = 1;
                      iterate(iterable, function(promise) {
                        var index = counter++;
                        var alreadyCalled = false;
                        remaining++;
                        call(promiseResolve, C, promise).then(function(value) {
                          if (alreadyCalled)
                            return;
                          alreadyCalled = true;
                          values[index] = { status: "fulfilled", value };
                          --remaining || resolve(values);
                        }, function(error) {
                          if (alreadyCalled)
                            return;
                          alreadyCalled = true;
                          values[index] = { status: "rejected", reason: error };
                          --remaining || resolve(values);
                        });
                      });
                      --remaining || resolve(values);
                    });
                    if (result.error)
                      reject(result.value);
                    return capability.promise;
                  }
                });
              }
            ),
            /***/
            4668: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var aCallable = __webpack_require__2(9662);
                var getBuiltIn = __webpack_require__2(5005);
                var call = __webpack_require__2(6916);
                var newPromiseCapabilityModule = __webpack_require__2(8523);
                var perform = __webpack_require__2(2534);
                var iterate = __webpack_require__2(408);
                var PROMISE_ANY_ERROR = "No one promise resolved";
                $({ target: "Promise", stat: true }, {
                  any: function any(iterable) {
                    var C = this;
                    var AggregateError2 = getBuiltIn("AggregateError");
                    var capability = newPromiseCapabilityModule.f(C);
                    var resolve = capability.resolve;
                    var reject = capability.reject;
                    var result = perform(function() {
                      var promiseResolve = aCallable(C.resolve);
                      var errors = [];
                      var counter = 0;
                      var remaining = 1;
                      var alreadyResolved = false;
                      iterate(iterable, function(promise) {
                        var index = counter++;
                        var alreadyRejected = false;
                        remaining++;
                        call(promiseResolve, C, promise).then(function(value) {
                          if (alreadyRejected || alreadyResolved)
                            return;
                          alreadyResolved = true;
                          resolve(value);
                        }, function(error) {
                          if (alreadyRejected || alreadyResolved)
                            return;
                          alreadyRejected = true;
                          errors[index] = error;
                          --remaining || reject(new AggregateError2(errors, PROMISE_ANY_ERROR));
                        });
                      });
                      --remaining || reject(new AggregateError2(errors, PROMISE_ANY_ERROR));
                    });
                    if (result.error)
                      reject(result.value);
                    return capability.promise;
                  }
                });
              }
            ),
            /***/
            7727: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var IS_PURE = __webpack_require__2(1913);
                var NativePromise = __webpack_require__2(3366);
                var fails = __webpack_require__2(7293);
                var getBuiltIn = __webpack_require__2(5005);
                var isCallable = __webpack_require__2(614);
                var speciesConstructor = __webpack_require__2(6707);
                var promiseResolve = __webpack_require__2(9478);
                var redefine = __webpack_require__2(1320);
                var NON_GENERIC = !!NativePromise && fails(function() {
                  NativePromise.prototype["finally"].call({ then: function() {
                  } }, function() {
                  });
                });
                $({ target: "Promise", proto: true, real: true, forced: NON_GENERIC }, {
                  "finally": function(onFinally) {
                    var C = speciesConstructor(this, getBuiltIn("Promise"));
                    var isFunction = isCallable(onFinally);
                    return this.then(
                      isFunction ? function(x) {
                        return promiseResolve(C, onFinally()).then(function() {
                          return x;
                        });
                      } : onFinally,
                      isFunction ? function(e) {
                        return promiseResolve(C, onFinally()).then(function() {
                          throw e;
                        });
                      } : onFinally
                    );
                  }
                });
                if (!IS_PURE && isCallable(NativePromise)) {
                  var method = getBuiltIn("Promise").prototype["finally"];
                  if (NativePromise.prototype["finally"] !== method) {
                    redefine(NativePromise.prototype, "finally", method, { unsafe: true });
                  }
                }
              }
            ),
            /***/
            8674: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var IS_PURE = __webpack_require__2(1913);
                var global = __webpack_require__2(7854);
                var getBuiltIn = __webpack_require__2(5005);
                var call = __webpack_require__2(6916);
                var NativePromise = __webpack_require__2(3366);
                var redefine = __webpack_require__2(1320);
                var redefineAll = __webpack_require__2(2248);
                var setPrototypeOf = __webpack_require__2(7674);
                var setToStringTag = __webpack_require__2(8003);
                var setSpecies = __webpack_require__2(6340);
                var aCallable = __webpack_require__2(9662);
                var isCallable = __webpack_require__2(614);
                var isObject = __webpack_require__2(111);
                var anInstance = __webpack_require__2(5787);
                var inspectSource = __webpack_require__2(2788);
                var iterate = __webpack_require__2(408);
                var checkCorrectnessOfIteration = __webpack_require__2(7072);
                var speciesConstructor = __webpack_require__2(6707);
                var task = __webpack_require__2(261).set;
                var microtask = __webpack_require__2(5948);
                var promiseResolve = __webpack_require__2(9478);
                var hostReportErrors = __webpack_require__2(842);
                var newPromiseCapabilityModule = __webpack_require__2(8523);
                var perform = __webpack_require__2(2534);
                var InternalStateModule = __webpack_require__2(9909);
                var isForced = __webpack_require__2(4705);
                var wellKnownSymbol = __webpack_require__2(5112);
                var IS_BROWSER = __webpack_require__2(7871);
                var IS_NODE = __webpack_require__2(5268);
                var V8_VERSION = __webpack_require__2(7392);
                var SPECIES = wellKnownSymbol("species");
                var PROMISE = "Promise";
                var getInternalState = InternalStateModule.get;
                var setInternalState = InternalStateModule.set;
                var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
                var NativePromisePrototype = NativePromise && NativePromise.prototype;
                var PromiseConstructor = NativePromise;
                var PromisePrototype = NativePromisePrototype;
                var TypeError2 = global.TypeError;
                var document2 = global.document;
                var process = global.process;
                var newPromiseCapability = newPromiseCapabilityModule.f;
                var newGenericPromiseCapability = newPromiseCapability;
                var DISPATCH_EVENT = !!(document2 && document2.createEvent && global.dispatchEvent);
                var NATIVE_REJECTION_EVENT = isCallable(global.PromiseRejectionEvent);
                var UNHANDLED_REJECTION = "unhandledrejection";
                var REJECTION_HANDLED = "rejectionhandled";
                var PENDING = 0;
                var FULFILLED = 1;
                var REJECTED = 2;
                var HANDLED = 1;
                var UNHANDLED = 2;
                var SUBCLASSING = false;
                var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
                var FORCED = isForced(PROMISE, function() {
                  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(PromiseConstructor);
                  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(PromiseConstructor);
                  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
                    return true;
                  if (IS_PURE && !PromisePrototype["finally"])
                    return true;
                  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE))
                    return false;
                  var promise = new PromiseConstructor(function(resolve) {
                    resolve(1);
                  });
                  var FakePromise = function(exec) {
                    exec(function() {
                    }, function() {
                    });
                  };
                  var constructor = promise.constructor = {};
                  constructor[SPECIES] = FakePromise;
                  SUBCLASSING = promise.then(function() {
                  }) instanceof FakePromise;
                  if (!SUBCLASSING)
                    return true;
                  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_REJECTION_EVENT;
                });
                var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function(iterable) {
                  PromiseConstructor.all(iterable)["catch"](function() {
                  });
                });
                var isThenable = function(it) {
                  var then;
                  return isObject(it) && isCallable(then = it.then) ? then : false;
                };
                var notify = function(state, isReject) {
                  if (state.notified)
                    return;
                  state.notified = true;
                  var chain = state.reactions;
                  microtask(function() {
                    var value = state.value;
                    var ok = state.state == FULFILLED;
                    var index = 0;
                    while (chain.length > index) {
                      var reaction = chain[index++];
                      var handler = ok ? reaction.ok : reaction.fail;
                      var resolve = reaction.resolve;
                      var reject = reaction.reject;
                      var domain = reaction.domain;
                      var result, then, exited;
                      try {
                        if (handler) {
                          if (!ok) {
                            if (state.rejection === UNHANDLED)
                              onHandleUnhandled(state);
                            state.rejection = HANDLED;
                          }
                          if (handler === true)
                            result = value;
                          else {
                            if (domain)
                              domain.enter();
                            result = handler(value);
                            if (domain) {
                              domain.exit();
                              exited = true;
                            }
                          }
                          if (result === reaction.promise) {
                            reject(TypeError2("Promise-chain cycle"));
                          } else if (then = isThenable(result)) {
                            call(then, result, resolve, reject);
                          } else
                            resolve(result);
                        } else
                          reject(value);
                      } catch (error) {
                        if (domain && !exited)
                          domain.exit();
                        reject(error);
                      }
                    }
                    state.reactions = [];
                    state.notified = false;
                    if (isReject && !state.rejection)
                      onUnhandled(state);
                  });
                };
                var dispatchEvent = function(name, promise, reason) {
                  var event, handler;
                  if (DISPATCH_EVENT) {
                    event = document2.createEvent("Event");
                    event.promise = promise;
                    event.reason = reason;
                    event.initEvent(name, false, true);
                    global.dispatchEvent(event);
                  } else
                    event = { promise, reason };
                  if (!NATIVE_REJECTION_EVENT && (handler = global["on" + name]))
                    handler(event);
                  else if (name === UNHANDLED_REJECTION)
                    hostReportErrors("Unhandled promise rejection", reason);
                };
                var onUnhandled = function(state) {
                  call(task, global, function() {
                    var promise = state.facade;
                    var value = state.value;
                    var IS_UNHANDLED = isUnhandled(state);
                    var result;
                    if (IS_UNHANDLED) {
                      result = perform(function() {
                        if (IS_NODE) {
                          process.emit("unhandledRejection", value, promise);
                        } else
                          dispatchEvent(UNHANDLED_REJECTION, promise, value);
                      });
                      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
                      if (result.error)
                        throw result.value;
                    }
                  });
                };
                var isUnhandled = function(state) {
                  return state.rejection !== HANDLED && !state.parent;
                };
                var onHandleUnhandled = function(state) {
                  call(task, global, function() {
                    var promise = state.facade;
                    if (IS_NODE) {
                      process.emit("rejectionHandled", promise);
                    } else
                      dispatchEvent(REJECTION_HANDLED, promise, state.value);
                  });
                };
                var bind = function(fn, state, unwrap) {
                  return function(value) {
                    fn(state, value, unwrap);
                  };
                };
                var internalReject = function(state, value, unwrap) {
                  if (state.done)
                    return;
                  state.done = true;
                  if (unwrap)
                    state = unwrap;
                  state.value = value;
                  state.state = REJECTED;
                  notify(state, true);
                };
                var internalResolve = function(state, value, unwrap) {
                  if (state.done)
                    return;
                  state.done = true;
                  if (unwrap)
                    state = unwrap;
                  try {
                    if (state.facade === value)
                      throw TypeError2("Promise can't be resolved itself");
                    var then = isThenable(value);
                    if (then) {
                      microtask(function() {
                        var wrapper = { done: false };
                        try {
                          call(
                            then,
                            value,
                            bind(internalResolve, wrapper, state),
                            bind(internalReject, wrapper, state)
                          );
                        } catch (error) {
                          internalReject(wrapper, error, state);
                        }
                      });
                    } else {
                      state.value = value;
                      state.state = FULFILLED;
                      notify(state, false);
                    }
                  } catch (error) {
                    internalReject({ done: false }, error, state);
                  }
                };
                if (FORCED) {
                  PromiseConstructor = function Promise2(executor) {
                    anInstance(this, PromisePrototype);
                    aCallable(executor);
                    call(Internal, this);
                    var state = getInternalState(this);
                    try {
                      executor(bind(internalResolve, state), bind(internalReject, state));
                    } catch (error) {
                      internalReject(state, error);
                    }
                  };
                  PromisePrototype = PromiseConstructor.prototype;
                  Internal = function Promise2(executor) {
                    setInternalState(this, {
                      type: PROMISE,
                      done: false,
                      notified: false,
                      parent: false,
                      reactions: [],
                      rejection: false,
                      state: PENDING,
                      value: void 0
                    });
                  };
                  Internal.prototype = redefineAll(PromisePrototype, {
                    // `Promise.prototype.then` method
                    // https://tc39.es/ecma262/#sec-promise.prototype.then
                    then: function then(onFulfilled, onRejected) {
                      var state = getInternalPromiseState(this);
                      var reactions = state.reactions;
                      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
                      reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
                      reaction.fail = isCallable(onRejected) && onRejected;
                      reaction.domain = IS_NODE ? process.domain : void 0;
                      state.parent = true;
                      reactions[reactions.length] = reaction;
                      if (state.state != PENDING)
                        notify(state, false);
                      return reaction.promise;
                    },
                    // `Promise.prototype.catch` method
                    // https://tc39.es/ecma262/#sec-promise.prototype.catch
                    "catch": function(onRejected) {
                      return this.then(void 0, onRejected);
                    }
                  });
                  OwnPromiseCapability = function() {
                    var promise = new Internal();
                    var state = getInternalState(promise);
                    this.promise = promise;
                    this.resolve = bind(internalResolve, state);
                    this.reject = bind(internalReject, state);
                  };
                  newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
                    return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
                  };
                  if (!IS_PURE && isCallable(NativePromise) && NativePromisePrototype !== Object.prototype) {
                    nativeThen = NativePromisePrototype.then;
                    if (!SUBCLASSING) {
                      redefine(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
                        var that = this;
                        return new PromiseConstructor(function(resolve, reject) {
                          call(nativeThen, that, resolve, reject);
                        }).then(onFulfilled, onRejected);
                      }, { unsafe: true });
                      redefine(NativePromisePrototype, "catch", PromisePrototype["catch"], { unsafe: true });
                    }
                    try {
                      delete NativePromisePrototype.constructor;
                    } catch (error) {
                    }
                    if (setPrototypeOf) {
                      setPrototypeOf(NativePromisePrototype, PromisePrototype);
                    }
                  }
                }
                $({ global: true, wrap: true, forced: FORCED }, {
                  Promise: PromiseConstructor
                });
                setToStringTag(PromiseConstructor, PROMISE, false, true);
                setSpecies(PROMISE);
                PromiseWrapper = getBuiltIn(PROMISE);
                $({ target: PROMISE, stat: true, forced: FORCED }, {
                  // `Promise.reject` method
                  // https://tc39.es/ecma262/#sec-promise.reject
                  reject: function reject(r) {
                    var capability = newPromiseCapability(this);
                    call(capability.reject, void 0, r);
                    return capability.promise;
                  }
                });
                $({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
                  // `Promise.resolve` method
                  // https://tc39.es/ecma262/#sec-promise.resolve
                  resolve: function resolve(x) {
                    return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
                  }
                });
                $({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
                  // `Promise.all` method
                  // https://tc39.es/ecma262/#sec-promise.all
                  all: function all(iterable) {
                    var C = this;
                    var capability = newPromiseCapability(C);
                    var resolve = capability.resolve;
                    var reject = capability.reject;
                    var result = perform(function() {
                      var $promiseResolve = aCallable(C.resolve);
                      var values = [];
                      var counter = 0;
                      var remaining = 1;
                      iterate(iterable, function(promise) {
                        var index = counter++;
                        var alreadyCalled = false;
                        remaining++;
                        call($promiseResolve, C, promise).then(function(value) {
                          if (alreadyCalled)
                            return;
                          alreadyCalled = true;
                          values[index] = value;
                          --remaining || resolve(values);
                        }, reject);
                      });
                      --remaining || resolve(values);
                    });
                    if (result.error)
                      reject(result.value);
                    return capability.promise;
                  },
                  // `Promise.race` method
                  // https://tc39.es/ecma262/#sec-promise.race
                  race: function race(iterable) {
                    var C = this;
                    var capability = newPromiseCapability(C);
                    var reject = capability.reject;
                    var result = perform(function() {
                      var $promiseResolve = aCallable(C.resolve);
                      iterate(iterable, function(promise) {
                        call($promiseResolve, C, promise).then(capability.resolve, reject);
                      });
                    });
                    if (result.error)
                      reject(result.value);
                    return capability.promise;
                  }
                });
              }
            ),
            /***/
            2419: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(2109);
                var getBuiltIn = __webpack_require__2(5005);
                var apply = __webpack_require__2(2104);
                var bind = __webpack_require__2(7065);
                var aConstructor = __webpack_require__2(9483);
                var anObject = __webpack_require__2(9670);
                var isObject = __webpack_require__2(111);
                var create = __webpack_require__2(30);
                var fails = __webpack_require__2(7293);
                var nativeConstruct = getBuiltIn("Reflect", "construct");
                var ObjectPrototype = Object.prototype;
                var push = [].push;
                var NEW_TARGET_BUG = fails(function() {
                  function F() {
                  }
                  return !(nativeConstruct(function() {
                  }, [], F) instanceof F);
                });
                var ARGS_BUG = !fails(function() {
                  nativeConstruct(function() {
                  });
                });
                var FORCED = NEW_TARGET_BUG || ARGS_BUG;
                $({ target: "Reflect", stat: true, forced: FORCED, sham: FORCED }, {
                  construct: function construct(Target, args) {
                    aConstructor(Target);
                    anObject(args);
                    var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
                    if (ARGS_BUG && !NEW_TARGET_BUG)
                      return nativeConstruct(Target, args, newTarget);
                    if (Target == newTarget) {
                      switch (args.length) {
                        case 0:
                          return new Target();
                        case 1:
                          return new Target(args[0]);
                        case 2:
                          return new Target(args[0], args[1]);
                        case 3:
                          return new Target(args[0], args[1], args[2]);
                        case 4:
                          return new Target(args[0], args[1], args[2], args[3]);
                      }
                      var $args = [null];
                      apply(push, $args, args);
                      return new (apply(bind, Target, $args))();
                    }
                    var proto = newTarget.prototype;
                    var instance = create(isObject(proto) ? proto : ObjectPrototype);
                    var result = apply(Target, instance, args);
                    return isObject(result) ? result : instance;
                  }
                });
              }
            ),
            /***/
            4916: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var exec = __webpack_require__2(2261);
                $({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
                  exec
                });
              }
            ),
            /***/
            2087: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var DESCRIPTORS = __webpack_require__2(9781);
                var objectDefinePropertyModule = __webpack_require__2(3070);
                var regExpFlags = __webpack_require__2(7066);
                var fails = __webpack_require__2(7293);
                var RegExpPrototype = RegExp.prototype;
                var FORCED = DESCRIPTORS && fails(function() {
                  return Object.getOwnPropertyDescriptor(RegExpPrototype, "flags").get.call({ dotAll: true, sticky: true }) !== "sy";
                });
                if (FORCED)
                  objectDefinePropertyModule.f(RegExpPrototype, "flags", {
                    configurable: true,
                    get: regExpFlags
                  });
              }
            ),
            /***/
            9714: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var uncurryThis = __webpack_require__2(1702);
                var PROPER_FUNCTION_NAME = __webpack_require__2(6530).PROPER;
                var redefine = __webpack_require__2(1320);
                var anObject = __webpack_require__2(9670);
                var isPrototypeOf = __webpack_require__2(7976);
                var $toString = __webpack_require__2(1340);
                var fails = __webpack_require__2(7293);
                var regExpFlags = __webpack_require__2(7066);
                var TO_STRING = "toString";
                var RegExpPrototype = RegExp.prototype;
                var n$ToString = RegExpPrototype[TO_STRING];
                var getFlags = uncurryThis(regExpFlags);
                var NOT_GENERIC = fails(function() {
                  return n$ToString.call({ source: "a", flags: "b" }) != "/a/b";
                });
                var INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;
                if (NOT_GENERIC || INCORRECT_NAME) {
                  redefine(RegExp.prototype, TO_STRING, function toString() {
                    var R = anObject(this);
                    var p = $toString(R.source);
                    var rf = R.flags;
                    var f = $toString(rf === void 0 && isPrototypeOf(RegExpPrototype, R) && !("flags" in RegExpPrototype) ? getFlags(R) : rf);
                    return "/" + p + "/" + f;
                  }, { unsafe: true });
                }
              }
            ),
            /***/
            189: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var collection = __webpack_require__2(7710);
                var collectionStrong = __webpack_require__2(5631);
                collection("Set", function(init) {
                  return function Set2() {
                    return init(this, arguments.length ? arguments[0] : void 0);
                  };
                }, collectionStrong);
              }
            ),
            /***/
            9841: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var codeAt = __webpack_require__2(8710).codeAt;
                $({ target: "String", proto: true }, {
                  codePointAt: function codePointAt(pos) {
                    return codeAt(this, pos);
                  }
                });
              }
            ),
            /***/
            4953: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(2109);
                var global = __webpack_require__2(7854);
                var uncurryThis = __webpack_require__2(1702);
                var toAbsoluteIndex = __webpack_require__2(1400);
                var RangeError2 = global.RangeError;
                var fromCharCode = String.fromCharCode;
                var $fromCodePoint = String.fromCodePoint;
                var join = uncurryThis([].join);
                var INCORRECT_LENGTH = !!$fromCodePoint && $fromCodePoint.length != 1;
                $({ target: "String", stat: true, forced: INCORRECT_LENGTH }, {
                  // eslint-disable-next-line no-unused-vars -- required for `.length`
                  fromCodePoint: function fromCodePoint(x) {
                    var elements = [];
                    var length = arguments.length;
                    var i = 0;
                    var code;
                    while (length > i) {
                      code = +arguments[i++];
                      if (toAbsoluteIndex(code, 1114111) !== code)
                        throw RangeError2(code + " is not a valid code point");
                      elements[i] = code < 65536 ? fromCharCode(code) : fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320);
                    }
                    return join(elements, "");
                  }
                });
              }
            ),
            /***/
            2023: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var uncurryThis = __webpack_require__2(1702);
                var notARegExp = __webpack_require__2(3929);
                var requireObjectCoercible = __webpack_require__2(4488);
                var toString = __webpack_require__2(1340);
                var correctIsRegExpLogic = __webpack_require__2(4964);
                var stringIndexOf = uncurryThis("".indexOf);
                $({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
                  includes: function includes(searchString) {
                    return !!~stringIndexOf(
                      toString(requireObjectCoercible(this)),
                      toString(notARegExp(searchString)),
                      arguments.length > 1 ? arguments[1] : void 0
                    );
                  }
                });
              }
            ),
            /***/
            8734: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var createHTML = __webpack_require__2(4230);
                var forcedStringHTMLMethod = __webpack_require__2(3429);
                $({ target: "String", proto: true, forced: forcedStringHTMLMethod("italics") }, {
                  italics: function italics() {
                    return createHTML(this, "i", "", "");
                  }
                });
              }
            ),
            /***/
            8783: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var charAt = __webpack_require__2(8710).charAt;
                var toString = __webpack_require__2(1340);
                var InternalStateModule = __webpack_require__2(9909);
                var defineIterator = __webpack_require__2(654);
                var STRING_ITERATOR = "String Iterator";
                var setInternalState = InternalStateModule.set;
                var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
                defineIterator(String, "String", function(iterated) {
                  setInternalState(this, {
                    type: STRING_ITERATOR,
                    string: toString(iterated),
                    index: 0
                  });
                }, function next() {
                  var state = getInternalState(this);
                  var string = state.string;
                  var index = state.index;
                  var point;
                  if (index >= string.length)
                    return { value: void 0, done: true };
                  point = charAt(string, index);
                  state.index += point.length;
                  return { value: point, done: false };
                });
              }
            ),
            /***/
            9254: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var createHTML = __webpack_require__2(4230);
                var forcedStringHTMLMethod = __webpack_require__2(3429);
                $({ target: "String", proto: true, forced: forcedStringHTMLMethod("link") }, {
                  link: function link(url) {
                    return createHTML(this, "a", "href", url);
                  }
                });
              }
            ),
            /***/
            6373: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var global = __webpack_require__2(7854);
                var call = __webpack_require__2(6916);
                var uncurryThis = __webpack_require__2(1702);
                var createIteratorConstructor = __webpack_require__2(4994);
                var requireObjectCoercible = __webpack_require__2(4488);
                var toLength = __webpack_require__2(7466);
                var toString = __webpack_require__2(1340);
                var anObject = __webpack_require__2(9670);
                var classof = __webpack_require__2(4326);
                var isPrototypeOf = __webpack_require__2(7976);
                var isRegExp = __webpack_require__2(7850);
                var regExpFlags = __webpack_require__2(7066);
                var getMethod = __webpack_require__2(8173);
                var redefine = __webpack_require__2(1320);
                var fails = __webpack_require__2(7293);
                var wellKnownSymbol = __webpack_require__2(5112);
                var speciesConstructor = __webpack_require__2(6707);
                var advanceStringIndex = __webpack_require__2(1530);
                var regExpExec = __webpack_require__2(7651);
                var InternalStateModule = __webpack_require__2(9909);
                var IS_PURE = __webpack_require__2(1913);
                var MATCH_ALL = wellKnownSymbol("matchAll");
                var REGEXP_STRING = "RegExp String";
                var REGEXP_STRING_ITERATOR = REGEXP_STRING + " Iterator";
                var setInternalState = InternalStateModule.set;
                var getInternalState = InternalStateModule.getterFor(REGEXP_STRING_ITERATOR);
                var RegExpPrototype = RegExp.prototype;
                var TypeError2 = global.TypeError;
                var getFlags = uncurryThis(regExpFlags);
                var stringIndexOf = uncurryThis("".indexOf);
                var un$MatchAll = uncurryThis("".matchAll);
                var WORKS_WITH_NON_GLOBAL_REGEX = !!un$MatchAll && !fails(function() {
                  un$MatchAll("a", /./);
                });
                var $RegExpStringIterator = createIteratorConstructor(function RegExpStringIterator(regexp, string, $global, fullUnicode) {
                  setInternalState(this, {
                    type: REGEXP_STRING_ITERATOR,
                    regexp,
                    string,
                    global: $global,
                    unicode: fullUnicode,
                    done: false
                  });
                }, REGEXP_STRING, function next() {
                  var state = getInternalState(this);
                  if (state.done)
                    return { value: void 0, done: true };
                  var R = state.regexp;
                  var S = state.string;
                  var match = regExpExec(R, S);
                  if (match === null)
                    return { value: void 0, done: state.done = true };
                  if (state.global) {
                    if (toString(match[0]) === "")
                      R.lastIndex = advanceStringIndex(S, toLength(R.lastIndex), state.unicode);
                    return { value: match, done: false };
                  }
                  state.done = true;
                  return { value: match, done: false };
                });
                var $matchAll = function(string) {
                  var R = anObject(this);
                  var S = toString(string);
                  var C, flagsValue, flags, matcher, $global, fullUnicode;
                  C = speciesConstructor(R, RegExp);
                  flagsValue = R.flags;
                  if (flagsValue === void 0 && isPrototypeOf(RegExpPrototype, R) && !("flags" in RegExpPrototype)) {
                    flagsValue = getFlags(R);
                  }
                  flags = flagsValue === void 0 ? "" : toString(flagsValue);
                  matcher = new C(C === RegExp ? R.source : R, flags);
                  $global = !!~stringIndexOf(flags, "g");
                  fullUnicode = !!~stringIndexOf(flags, "u");
                  matcher.lastIndex = toLength(R.lastIndex);
                  return new $RegExpStringIterator(matcher, S, $global, fullUnicode);
                };
                $({ target: "String", proto: true, forced: WORKS_WITH_NON_GLOBAL_REGEX }, {
                  matchAll: function matchAll(regexp) {
                    var O = requireObjectCoercible(this);
                    var flags, S, matcher, rx;
                    if (regexp != null) {
                      if (isRegExp(regexp)) {
                        flags = toString(requireObjectCoercible(
                          "flags" in RegExpPrototype ? regexp.flags : getFlags(regexp)
                        ));
                        if (!~stringIndexOf(flags, "g"))
                          throw TypeError2("`.matchAll` does not allow non-global regexes");
                      }
                      if (WORKS_WITH_NON_GLOBAL_REGEX)
                        return un$MatchAll(O, regexp);
                      matcher = getMethod(regexp, MATCH_ALL);
                      if (matcher === void 0 && IS_PURE && classof(regexp) == "RegExp")
                        matcher = $matchAll;
                      if (matcher)
                        return call(matcher, regexp, O);
                    } else if (WORKS_WITH_NON_GLOBAL_REGEX)
                      return un$MatchAll(O, regexp);
                    S = toString(O);
                    rx = new RegExp(regexp, "g");
                    return IS_PURE ? call($matchAll, rx, S) : rx[MATCH_ALL](S);
                  }
                });
                IS_PURE || MATCH_ALL in RegExpPrototype || redefine(RegExpPrototype, MATCH_ALL, $matchAll);
              }
            ),
            /***/
            4723: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var call = __webpack_require__2(6916);
                var fixRegExpWellKnownSymbolLogic = __webpack_require__2(7007);
                var anObject = __webpack_require__2(9670);
                var toLength = __webpack_require__2(7466);
                var toString = __webpack_require__2(1340);
                var requireObjectCoercible = __webpack_require__2(4488);
                var getMethod = __webpack_require__2(8173);
                var advanceStringIndex = __webpack_require__2(1530);
                var regExpExec = __webpack_require__2(7651);
                fixRegExpWellKnownSymbolLogic("match", function(MATCH, nativeMatch, maybeCallNative) {
                  return [
                    // `String.prototype.match` method
                    // https://tc39.es/ecma262/#sec-string.prototype.match
                    function match(regexp) {
                      var O = requireObjectCoercible(this);
                      var matcher = regexp == void 0 ? void 0 : getMethod(regexp, MATCH);
                      return matcher ? call(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString(O));
                    },
                    // `RegExp.prototype[@@match]` method
                    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
                    function(string) {
                      var rx = anObject(this);
                      var S = toString(string);
                      var res = maybeCallNative(nativeMatch, rx, S);
                      if (res.done)
                        return res.value;
                      if (!rx.global)
                        return regExpExec(rx, S);
                      var fullUnicode = rx.unicode;
                      rx.lastIndex = 0;
                      var A = [];
                      var n = 0;
                      var result;
                      while ((result = regExpExec(rx, S)) !== null) {
                        var matchStr = toString(result[0]);
                        A[n] = matchStr;
                        if (matchStr === "")
                          rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
                        n++;
                      }
                      return n === 0 ? null : A;
                    }
                  ];
                });
              }
            ),
            /***/
            2481: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(2109);
                var repeat = __webpack_require__2(8415);
                $({ target: "String", proto: true }, {
                  repeat
                });
              }
            ),
            /***/
            5306: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var apply = __webpack_require__2(2104);
                var call = __webpack_require__2(6916);
                var uncurryThis = __webpack_require__2(1702);
                var fixRegExpWellKnownSymbolLogic = __webpack_require__2(7007);
                var fails = __webpack_require__2(7293);
                var anObject = __webpack_require__2(9670);
                var isCallable = __webpack_require__2(614);
                var toIntegerOrInfinity = __webpack_require__2(9303);
                var toLength = __webpack_require__2(7466);
                var toString = __webpack_require__2(1340);
                var requireObjectCoercible = __webpack_require__2(4488);
                var advanceStringIndex = __webpack_require__2(1530);
                var getMethod = __webpack_require__2(8173);
                var getSubstitution = __webpack_require__2(647);
                var regExpExec = __webpack_require__2(7651);
                var wellKnownSymbol = __webpack_require__2(5112);
                var REPLACE = wellKnownSymbol("replace");
                var max = Math.max;
                var min = Math.min;
                var concat = uncurryThis([].concat);
                var push = uncurryThis([].push);
                var stringIndexOf = uncurryThis("".indexOf);
                var stringSlice = uncurryThis("".slice);
                var maybeToString = function(it) {
                  return it === void 0 ? it : String(it);
                };
                var REPLACE_KEEPS_$0 = function() {
                  return "a".replace(/./, "$0") === "$0";
                }();
                var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
                  if (/./[REPLACE]) {
                    return /./[REPLACE]("a", "$0") === "";
                  }
                  return false;
                }();
                var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
                  var re = /./;
                  re.exec = function() {
                    var result = [];
                    result.groups = { a: "7" };
                    return result;
                  };
                  return "".replace(re, "$<a>") !== "7";
                });
                fixRegExpWellKnownSymbolLogic("replace", function(_, nativeReplace, maybeCallNative) {
                  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
                  return [
                    // `String.prototype.replace` method
                    // https://tc39.es/ecma262/#sec-string.prototype.replace
                    function replace(searchValue, replaceValue) {
                      var O = requireObjectCoercible(this);
                      var replacer = searchValue == void 0 ? void 0 : getMethod(searchValue, REPLACE);
                      return replacer ? call(replacer, searchValue, O, replaceValue) : call(nativeReplace, toString(O), searchValue, replaceValue);
                    },
                    // `RegExp.prototype[@@replace]` method
                    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
                    function(string, replaceValue) {
                      var rx = anObject(this);
                      var S = toString(string);
                      if (typeof replaceValue == "string" && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, "$<") === -1) {
                        var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
                        if (res.done)
                          return res.value;
                      }
                      var functionalReplace = isCallable(replaceValue);
                      if (!functionalReplace)
                        replaceValue = toString(replaceValue);
                      var global = rx.global;
                      if (global) {
                        var fullUnicode = rx.unicode;
                        rx.lastIndex = 0;
                      }
                      var results = [];
                      while (true) {
                        var result = regExpExec(rx, S);
                        if (result === null)
                          break;
                        push(results, result);
                        if (!global)
                          break;
                        var matchStr = toString(result[0]);
                        if (matchStr === "")
                          rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
                      }
                      var accumulatedResult = "";
                      var nextSourcePosition = 0;
                      for (var i = 0; i < results.length; i++) {
                        result = results[i];
                        var matched = toString(result[0]);
                        var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);
                        var captures = [];
                        for (var j = 1; j < result.length; j++)
                          push(captures, maybeToString(result[j]));
                        var namedCaptures = result.groups;
                        if (functionalReplace) {
                          var replacerArgs = concat([matched], captures, position, S);
                          if (namedCaptures !== void 0)
                            push(replacerArgs, namedCaptures);
                          var replacement = toString(apply(replaceValue, void 0, replacerArgs));
                        } else {
                          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
                        }
                        if (position >= nextSourcePosition) {
                          accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
                          nextSourcePosition = position + matched.length;
                        }
                      }
                      return accumulatedResult + stringSlice(S, nextSourcePosition);
                    }
                  ];
                }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
              }
            ),
            /***/
            3123: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var apply = __webpack_require__2(2104);
                var call = __webpack_require__2(6916);
                var uncurryThis = __webpack_require__2(1702);
                var fixRegExpWellKnownSymbolLogic = __webpack_require__2(7007);
                var isRegExp = __webpack_require__2(7850);
                var anObject = __webpack_require__2(9670);
                var requireObjectCoercible = __webpack_require__2(4488);
                var speciesConstructor = __webpack_require__2(6707);
                var advanceStringIndex = __webpack_require__2(1530);
                var toLength = __webpack_require__2(7466);
                var toString = __webpack_require__2(1340);
                var getMethod = __webpack_require__2(8173);
                var arraySlice = __webpack_require__2(206);
                var callRegExpExec = __webpack_require__2(7651);
                var regexpExec = __webpack_require__2(2261);
                var stickyHelpers = __webpack_require__2(2999);
                var fails = __webpack_require__2(7293);
                var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
                var MAX_UINT32 = 4294967295;
                var min = Math.min;
                var $push = [].push;
                var exec = uncurryThis(/./.exec);
                var push = uncurryThis($push);
                var stringSlice = uncurryThis("".slice);
                var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
                  var re = /(?:)/;
                  var originalExec = re.exec;
                  re.exec = function() {
                    return originalExec.apply(this, arguments);
                  };
                  var result = "ab".split(re);
                  return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
                });
                fixRegExpWellKnownSymbolLogic("split", function(SPLIT, nativeSplit, maybeCallNative) {
                  var internalSplit;
                  if ("abbc".split(/(b)*/)[1] == "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
                  "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
                  ".".split(/()()/).length > 1 || "".split(/.?/).length) {
                    internalSplit = function(separator, limit) {
                      var string = toString(requireObjectCoercible(this));
                      var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
                      if (lim === 0)
                        return [];
                      if (separator === void 0)
                        return [string];
                      if (!isRegExp(separator)) {
                        return call(nativeSplit, string, separator, lim);
                      }
                      var output = [];
                      var flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : "");
                      var lastLastIndex = 0;
                      var separatorCopy = new RegExp(separator.source, flags + "g");
                      var match, lastIndex, lastLength;
                      while (match = call(regexpExec, separatorCopy, string)) {
                        lastIndex = separatorCopy.lastIndex;
                        if (lastIndex > lastLastIndex) {
                          push(output, stringSlice(string, lastLastIndex, match.index));
                          if (match.length > 1 && match.index < string.length)
                            apply($push, output, arraySlice(match, 1));
                          lastLength = match[0].length;
                          lastLastIndex = lastIndex;
                          if (output.length >= lim)
                            break;
                        }
                        if (separatorCopy.lastIndex === match.index)
                          separatorCopy.lastIndex++;
                      }
                      if (lastLastIndex === string.length) {
                        if (lastLength || !exec(separatorCopy, ""))
                          push(output, "");
                      } else
                        push(output, stringSlice(string, lastLastIndex));
                      return output.length > lim ? arraySlice(output, 0, lim) : output;
                    };
                  } else if ("0".split(void 0, 0).length) {
                    internalSplit = function(separator, limit) {
                      return separator === void 0 && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
                    };
                  } else
                    internalSplit = nativeSplit;
                  return [
                    // `String.prototype.split` method
                    // https://tc39.es/ecma262/#sec-string.prototype.split
                    function split(separator, limit) {
                      var O = requireObjectCoercible(this);
                      var splitter = separator == void 0 ? void 0 : getMethod(separator, SPLIT);
                      return splitter ? call(splitter, separator, O, limit) : call(internalSplit, toString(O), separator, limit);
                    },
                    // `RegExp.prototype[@@split]` method
                    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
                    //
                    // NOTE: This cannot be properly polyfilled in engines that don't support
                    // the 'y' flag.
                    function(string, limit) {
                      var rx = anObject(this);
                      var S = toString(string);
                      var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
                      if (res.done)
                        return res.value;
                      var C = speciesConstructor(rx, RegExp);
                      var unicodeMatching = rx.unicode;
                      var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
                      var splitter = new C(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
                      var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
                      if (lim === 0)
                        return [];
                      if (S.length === 0)
                        return callRegExpExec(splitter, S) === null ? [S] : [];
                      var p = 0;
                      var q = 0;
                      var A = [];
                      while (q < S.length) {
                        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
                        var z = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);
                        var e;
                        if (z === null || (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p) {
                          q = advanceStringIndex(S, q, unicodeMatching);
                        } else {
                          push(A, stringSlice(S, p, q));
                          if (A.length === lim)
                            return A;
                          for (var i = 1; i <= z.length - 1; i++) {
                            push(A, z[i]);
                            if (A.length === lim)
                              return A;
                          }
                          q = p = e;
                        }
                      }
                      push(A, stringSlice(S, p));
                      return A;
                    }
                  ];
                }, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
              }
            ),
            /***/
            7397: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var createHTML = __webpack_require__2(4230);
                var forcedStringHTMLMethod = __webpack_require__2(3429);
                $({ target: "String", proto: true, forced: forcedStringHTMLMethod("strike") }, {
                  strike: function strike() {
                    return createHTML(this, "strike", "", "");
                  }
                });
              }
            ),
            /***/
            3210: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var $trim = __webpack_require__2(3111).trim;
                var forcedStringTrimMethod = __webpack_require__2(6091);
                $({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
                  trim: function trim() {
                    return $trim(this);
                  }
                });
              }
            ),
            /***/
            2443: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var defineWellKnownSymbol = __webpack_require__2(7235);
                defineWellKnownSymbol("asyncIterator");
              }
            ),
            /***/
            1817: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var DESCRIPTORS = __webpack_require__2(9781);
                var global = __webpack_require__2(7854);
                var uncurryThis = __webpack_require__2(1702);
                var hasOwn = __webpack_require__2(2597);
                var isCallable = __webpack_require__2(614);
                var isPrototypeOf = __webpack_require__2(7976);
                var toString = __webpack_require__2(1340);
                var defineProperty = __webpack_require__2(3070).f;
                var copyConstructorProperties = __webpack_require__2(9920);
                var NativeSymbol = global.Symbol;
                var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;
                if (DESCRIPTORS && isCallable(NativeSymbol) && (!("description" in SymbolPrototype) || // Safari 12 bug
                NativeSymbol().description !== void 0)) {
                  var EmptyStringDescriptionStore = {};
                  var SymbolWrapper = function Symbol2() {
                    var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : toString(arguments[0]);
                    var result = isPrototypeOf(SymbolPrototype, this) ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
                    if (description === "")
                      EmptyStringDescriptionStore[result] = true;
                    return result;
                  };
                  copyConstructorProperties(SymbolWrapper, NativeSymbol);
                  SymbolWrapper.prototype = SymbolPrototype;
                  SymbolPrototype.constructor = SymbolWrapper;
                  var NATIVE_SYMBOL = String(NativeSymbol("test")) == "Symbol(test)";
                  var symbolToString = uncurryThis(SymbolPrototype.toString);
                  var symbolValueOf = uncurryThis(SymbolPrototype.valueOf);
                  var regexp = /^Symbol\((.*)\)[^)]+$/;
                  var replace = uncurryThis("".replace);
                  var stringSlice = uncurryThis("".slice);
                  defineProperty(SymbolPrototype, "description", {
                    configurable: true,
                    get: function description() {
                      var symbol = symbolValueOf(this);
                      var string = symbolToString(symbol);
                      if (hasOwn(EmptyStringDescriptionStore, symbol))
                        return "";
                      var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, "$1");
                      return desc === "" ? void 0 : desc;
                    }
                  });
                  $({ global: true, forced: true }, {
                    Symbol: SymbolWrapper
                  });
                }
              }
            ),
            /***/
            2165: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var defineWellKnownSymbol = __webpack_require__2(7235);
                defineWellKnownSymbol("iterator");
              }
            ),
            /***/
            2526: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var global = __webpack_require__2(7854);
                var getBuiltIn = __webpack_require__2(5005);
                var apply = __webpack_require__2(2104);
                var call = __webpack_require__2(6916);
                var uncurryThis = __webpack_require__2(1702);
                var IS_PURE = __webpack_require__2(1913);
                var DESCRIPTORS = __webpack_require__2(9781);
                var NATIVE_SYMBOL = __webpack_require__2(133);
                var fails = __webpack_require__2(7293);
                var hasOwn = __webpack_require__2(2597);
                var isArray = __webpack_require__2(3157);
                var isCallable = __webpack_require__2(614);
                var isObject = __webpack_require__2(111);
                var isPrototypeOf = __webpack_require__2(7976);
                var isSymbol = __webpack_require__2(2190);
                var anObject = __webpack_require__2(9670);
                var toObject = __webpack_require__2(7908);
                var toIndexedObject = __webpack_require__2(5656);
                var toPropertyKey = __webpack_require__2(4948);
                var $toString = __webpack_require__2(1340);
                var createPropertyDescriptor = __webpack_require__2(9114);
                var nativeObjectCreate = __webpack_require__2(30);
                var objectKeys = __webpack_require__2(1956);
                var getOwnPropertyNamesModule = __webpack_require__2(8006);
                var getOwnPropertyNamesExternal = __webpack_require__2(1156);
                var getOwnPropertySymbolsModule = __webpack_require__2(5181);
                var getOwnPropertyDescriptorModule = __webpack_require__2(1236);
                var definePropertyModule = __webpack_require__2(3070);
                var propertyIsEnumerableModule = __webpack_require__2(5296);
                var arraySlice = __webpack_require__2(206);
                var redefine = __webpack_require__2(1320);
                var shared = __webpack_require__2(2309);
                var sharedKey = __webpack_require__2(6200);
                var hiddenKeys = __webpack_require__2(3501);
                var uid = __webpack_require__2(9711);
                var wellKnownSymbol = __webpack_require__2(5112);
                var wrappedWellKnownSymbolModule = __webpack_require__2(6061);
                var defineWellKnownSymbol = __webpack_require__2(7235);
                var setToStringTag = __webpack_require__2(8003);
                var InternalStateModule = __webpack_require__2(9909);
                var $forEach = __webpack_require__2(2092).forEach;
                var HIDDEN = sharedKey("hidden");
                var SYMBOL = "Symbol";
                var PROTOTYPE = "prototype";
                var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
                var setInternalState = InternalStateModule.set;
                var getInternalState = InternalStateModule.getterFor(SYMBOL);
                var ObjectPrototype = Object[PROTOTYPE];
                var $Symbol = global.Symbol;
                var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
                var TypeError2 = global.TypeError;
                var QObject = global.QObject;
                var $stringify = getBuiltIn("JSON", "stringify");
                var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                var nativeDefineProperty = definePropertyModule.f;
                var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
                var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
                var push = uncurryThis([].push);
                var AllSymbols = shared("symbols");
                var ObjectPrototypeSymbols = shared("op-symbols");
                var StringToSymbolRegistry = shared("string-to-symbol-registry");
                var SymbolToStringRegistry = shared("symbol-to-string-registry");
                var WellKnownSymbolsStore = shared("wks");
                var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
                var setSymbolDescriptor = DESCRIPTORS && fails(function() {
                  return nativeObjectCreate(nativeDefineProperty({}, "a", {
                    get: function() {
                      return nativeDefineProperty(this, "a", { value: 7 }).a;
                    }
                  })).a != 7;
                }) ? function(O, P, Attributes) {
                  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
                  if (ObjectPrototypeDescriptor)
                    delete ObjectPrototype[P];
                  nativeDefineProperty(O, P, Attributes);
                  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
                    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
                  }
                } : nativeDefineProperty;
                var wrap = function(tag, description) {
                  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
                  setInternalState(symbol, {
                    type: SYMBOL,
                    tag,
                    description
                  });
                  if (!DESCRIPTORS)
                    symbol.description = description;
                  return symbol;
                };
                var $defineProperty = function defineProperty(O, P, Attributes) {
                  if (O === ObjectPrototype)
                    $defineProperty(ObjectPrototypeSymbols, P, Attributes);
                  anObject(O);
                  var key = toPropertyKey(P);
                  anObject(Attributes);
                  if (hasOwn(AllSymbols, key)) {
                    if (!Attributes.enumerable) {
                      if (!hasOwn(O, HIDDEN))
                        nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
                      O[HIDDEN][key] = true;
                    } else {
                      if (hasOwn(O, HIDDEN) && O[HIDDEN][key])
                        O[HIDDEN][key] = false;
                      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
                    }
                    return setSymbolDescriptor(O, key, Attributes);
                  }
                  return nativeDefineProperty(O, key, Attributes);
                };
                var $defineProperties = function defineProperties(O, Properties) {
                  anObject(O);
                  var properties = toIndexedObject(Properties);
                  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
                  $forEach(keys, function(key) {
                    if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key))
                      $defineProperty(O, key, properties[key]);
                  });
                  return O;
                };
                var $create = function create(O, Properties) {
                  return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
                };
                var $propertyIsEnumerable = function propertyIsEnumerable(V) {
                  var P = toPropertyKey(V);
                  var enumerable = call(nativePropertyIsEnumerable, this, P);
                  if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P))
                    return false;
                  return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
                };
                var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
                  var it = toIndexedObject(O);
                  var key = toPropertyKey(P);
                  if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key))
                    return;
                  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
                  if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
                    descriptor.enumerable = true;
                  }
                  return descriptor;
                };
                var $getOwnPropertyNames = function getOwnPropertyNames(O) {
                  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
                  var result = [];
                  $forEach(names, function(key) {
                    if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key))
                      push(result, key);
                  });
                  return result;
                };
                var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
                  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
                  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
                  var result = [];
                  $forEach(names, function(key) {
                    if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
                      push(result, AllSymbols[key]);
                    }
                  });
                  return result;
                };
                if (!NATIVE_SYMBOL) {
                  $Symbol = function Symbol2() {
                    if (isPrototypeOf(SymbolPrototype, this))
                      throw TypeError2("Symbol is not a constructor");
                    var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);
                    var tag = uid(description);
                    var setter = function(value) {
                      if (this === ObjectPrototype)
                        call(setter, ObjectPrototypeSymbols, value);
                      if (hasOwn(this, HIDDEN) && hasOwn(this[HIDDEN], tag))
                        this[HIDDEN][tag] = false;
                      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
                    };
                    if (DESCRIPTORS && USE_SETTER)
                      setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
                    return wrap(tag, description);
                  };
                  SymbolPrototype = $Symbol[PROTOTYPE];
                  redefine(SymbolPrototype, "toString", function toString() {
                    return getInternalState(this).tag;
                  });
                  redefine($Symbol, "withoutSetter", function(description) {
                    return wrap(uid(description), description);
                  });
                  propertyIsEnumerableModule.f = $propertyIsEnumerable;
                  definePropertyModule.f = $defineProperty;
                  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
                  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
                  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
                  wrappedWellKnownSymbolModule.f = function(name) {
                    return wrap(wellKnownSymbol(name), name);
                  };
                  if (DESCRIPTORS) {
                    nativeDefineProperty(SymbolPrototype, "description", {
                      configurable: true,
                      get: function description() {
                        return getInternalState(this).description;
                      }
                    });
                    if (!IS_PURE) {
                      redefine(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
                    }
                  }
                }
                $({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
                  Symbol: $Symbol
                });
                $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
                  defineWellKnownSymbol(name);
                });
                $({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
                  // `Symbol.for` method
                  // https://tc39.es/ecma262/#sec-symbol.for
                  "for": function(key) {
                    var string = $toString(key);
                    if (hasOwn(StringToSymbolRegistry, string))
                      return StringToSymbolRegistry[string];
                    var symbol = $Symbol(string);
                    StringToSymbolRegistry[string] = symbol;
                    SymbolToStringRegistry[symbol] = string;
                    return symbol;
                  },
                  // `Symbol.keyFor` method
                  // https://tc39.es/ecma262/#sec-symbol.keyfor
                  keyFor: function keyFor(sym) {
                    if (!isSymbol(sym))
                      throw TypeError2(sym + " is not a symbol");
                    if (hasOwn(SymbolToStringRegistry, sym))
                      return SymbolToStringRegistry[sym];
                  },
                  useSetter: function() {
                    USE_SETTER = true;
                  },
                  useSimple: function() {
                    USE_SETTER = false;
                  }
                });
                $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
                  // `Object.create` method
                  // https://tc39.es/ecma262/#sec-object.create
                  create: $create,
                  // `Object.defineProperty` method
                  // https://tc39.es/ecma262/#sec-object.defineproperty
                  defineProperty: $defineProperty,
                  // `Object.defineProperties` method
                  // https://tc39.es/ecma262/#sec-object.defineproperties
                  defineProperties: $defineProperties,
                  // `Object.getOwnPropertyDescriptor` method
                  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
                  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
                });
                $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
                  // `Object.getOwnPropertyNames` method
                  // https://tc39.es/ecma262/#sec-object.getownpropertynames
                  getOwnPropertyNames: $getOwnPropertyNames,
                  // `Object.getOwnPropertySymbols` method
                  // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
                  getOwnPropertySymbols: $getOwnPropertySymbols
                });
                $({ target: "Object", stat: true, forced: fails(function() {
                  getOwnPropertySymbolsModule.f(1);
                }) }, {
                  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
                    return getOwnPropertySymbolsModule.f(toObject(it));
                  }
                });
                if ($stringify) {
                  var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function() {
                    var symbol = $Symbol();
                    return $stringify([symbol]) != "[null]" || $stringify({ a: symbol }) != "{}" || $stringify(Object(symbol)) != "{}";
                  });
                  $({ target: "JSON", stat: true, forced: FORCED_JSON_STRINGIFY }, {
                    // eslint-disable-next-line no-unused-vars -- required for `.length`
                    stringify: function stringify(it, replacer, space) {
                      var args = arraySlice(arguments);
                      var $replacer = replacer;
                      if (!isObject(replacer) && it === void 0 || isSymbol(it))
                        return;
                      if (!isArray(replacer))
                        replacer = function(key, value) {
                          if (isCallable($replacer))
                            value = call($replacer, this, key, value);
                          if (!isSymbol(value))
                            return value;
                        };
                      args[1] = replacer;
                      return apply($stringify, null, args);
                    }
                  });
                }
                if (!SymbolPrototype[TO_PRIMITIVE]) {
                  var valueOf = SymbolPrototype.valueOf;
                  redefine(SymbolPrototype, TO_PRIMITIVE, function(hint) {
                    return call(valueOf, this);
                  });
                }
                setToStringTag($Symbol, SYMBOL);
                hiddenKeys[HIDDEN] = true;
              }
            ),
            /***/
            6649: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var defineWellKnownSymbol = __webpack_require__2(7235);
                defineWellKnownSymbol("toPrimitive");
              }
            ),
            /***/
            3680: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var defineWellKnownSymbol = __webpack_require__2(7235);
                defineWellKnownSymbol("toStringTag");
              }
            ),
            /***/
            2990: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var uncurryThis = __webpack_require__2(1702);
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var $ArrayCopyWithin = __webpack_require__2(1048);
                var u$ArrayCopyWithin = uncurryThis($ArrayCopyWithin);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("copyWithin", function copyWithin(target, start) {
                  return u$ArrayCopyWithin(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : void 0);
                });
              }
            ),
            /***/
            8927: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var $every = __webpack_require__2(2092).every;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("every", function every(callbackfn) {
                  return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            3105: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var call = __webpack_require__2(6916);
                var $fill = __webpack_require__2(1285);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("fill", function fill(value) {
                  var length = arguments.length;
                  return call(
                    $fill,
                    aTypedArray(this),
                    value,
                    length > 1 ? arguments[1] : void 0,
                    length > 2 ? arguments[2] : void 0
                  );
                });
              }
            ),
            /***/
            5035: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var $filter = __webpack_require__2(2092).filter;
                var fromSpeciesAndList = __webpack_require__2(3074);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("filter", function filter(callbackfn) {
                  var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                  return fromSpeciesAndList(this, list);
                });
              }
            ),
            /***/
            7174: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var $findIndex = __webpack_require__2(2092).findIndex;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("findIndex", function findIndex(predicate) {
                  return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            4345: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var $find = __webpack_require__2(2092).find;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("find", function find(predicate) {
                  return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            4197: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var createTypedArrayConstructor = __webpack_require__2(9843);
                createTypedArrayConstructor("Float32", function(init) {
                  return function Float32Array2(data, byteOffset, length) {
                    return init(this, data, byteOffset, length);
                  };
                });
              }
            ),
            /***/
            6495: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var createTypedArrayConstructor = __webpack_require__2(9843);
                createTypedArrayConstructor("Float64", function(init) {
                  return function Float64Array2(data, byteOffset, length) {
                    return init(this, data, byteOffset, length);
                  };
                });
              }
            ),
            /***/
            2846: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var $forEach = __webpack_require__2(2092).forEach;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("forEach", function forEach(callbackfn) {
                  $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            8145: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__2(3832);
                var exportTypedArrayStaticMethod = __webpack_require__2(2094).exportTypedArrayStaticMethod;
                var typedArrayFrom = __webpack_require__2(7321);
                exportTypedArrayStaticMethod("from", typedArrayFrom, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);
              }
            ),
            /***/
            4731: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var $includes = __webpack_require__2(1318).includes;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("includes", function includes(searchElement) {
                  return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            7209: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var $indexOf = __webpack_require__2(1318).indexOf;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("indexOf", function indexOf(searchElement) {
                  return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            5109: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var createTypedArrayConstructor = __webpack_require__2(9843);
                createTypedArrayConstructor("Int16", function(init) {
                  return function Int16Array2(data, byteOffset, length) {
                    return init(this, data, byteOffset, length);
                  };
                });
              }
            ),
            /***/
            5125: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var createTypedArrayConstructor = __webpack_require__2(9843);
                createTypedArrayConstructor("Int32", function(init) {
                  return function Int32Array2(data, byteOffset, length) {
                    return init(this, data, byteOffset, length);
                  };
                });
              }
            ),
            /***/
            7145: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var createTypedArrayConstructor = __webpack_require__2(9843);
                createTypedArrayConstructor("Int8", function(init) {
                  return function Int8Array2(data, byteOffset, length) {
                    return init(this, data, byteOffset, length);
                  };
                });
              }
            ),
            /***/
            6319: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var global = __webpack_require__2(7854);
                var uncurryThis = __webpack_require__2(1702);
                var PROPER_FUNCTION_NAME = __webpack_require__2(6530).PROPER;
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var ArrayIterators = __webpack_require__2(6992);
                var wellKnownSymbol = __webpack_require__2(5112);
                var ITERATOR = wellKnownSymbol("iterator");
                var Uint8Array2 = global.Uint8Array;
                var arrayValues = uncurryThis(ArrayIterators.values);
                var arrayKeys = uncurryThis(ArrayIterators.keys);
                var arrayEntries = uncurryThis(ArrayIterators.entries);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                var nativeTypedArrayIterator = Uint8Array2 && Uint8Array2.prototype[ITERATOR];
                var PROPER_ARRAY_VALUES_NAME = !!nativeTypedArrayIterator && nativeTypedArrayIterator.name === "values";
                var typedArrayValues = function values() {
                  return arrayValues(aTypedArray(this));
                };
                exportTypedArrayMethod("entries", function entries() {
                  return arrayEntries(aTypedArray(this));
                });
                exportTypedArrayMethod("keys", function keys() {
                  return arrayKeys(aTypedArray(this));
                });
                exportTypedArrayMethod("values", typedArrayValues, PROPER_FUNCTION_NAME && !PROPER_ARRAY_VALUES_NAME);
                exportTypedArrayMethod(ITERATOR, typedArrayValues, PROPER_FUNCTION_NAME && !PROPER_ARRAY_VALUES_NAME);
              }
            ),
            /***/
            8867: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var uncurryThis = __webpack_require__2(1702);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                var $join = uncurryThis([].join);
                exportTypedArrayMethod("join", function join(separator) {
                  return $join(aTypedArray(this), separator);
                });
              }
            ),
            /***/
            7789: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var apply = __webpack_require__2(2104);
                var $lastIndexOf = __webpack_require__2(6583);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("lastIndexOf", function lastIndexOf(searchElement) {
                  var length = arguments.length;
                  return apply($lastIndexOf, aTypedArray(this), length > 1 ? [searchElement, arguments[1]] : [searchElement]);
                });
              }
            ),
            /***/
            3739: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var $map = __webpack_require__2(2092).map;
                var typedArraySpeciesConstructor = __webpack_require__2(6304);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("map", function map(mapfn) {
                  return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : void 0, function(O, length) {
                    return new (typedArraySpeciesConstructor(O))(length);
                  });
                });
              }
            ),
            /***/
            4483: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var $reduceRight = __webpack_require__2(3671).right;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("reduceRight", function reduceRight(callbackfn) {
                  var length = arguments.length;
                  return $reduceRight(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            9368: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var $reduce = __webpack_require__2(3671).left;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("reduce", function reduce(callbackfn) {
                  var length = arguments.length;
                  return $reduce(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            2056: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                var floor = Math.floor;
                exportTypedArrayMethod("reverse", function reverse() {
                  var that = this;
                  var length = aTypedArray(that).length;
                  var middle = floor(length / 2);
                  var index = 0;
                  var value;
                  while (index < middle) {
                    value = that[index];
                    that[index++] = that[--length];
                    that[length] = value;
                  }
                  return that;
                });
              }
            ),
            /***/
            3462: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var global = __webpack_require__2(7854);
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var lengthOfArrayLike = __webpack_require__2(6244);
                var toOffset = __webpack_require__2(4590);
                var toObject = __webpack_require__2(7908);
                var fails = __webpack_require__2(7293);
                var RangeError2 = global.RangeError;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                var FORCED = fails(function() {
                  new Int8Array(1).set({});
                });
                exportTypedArrayMethod("set", function set(arrayLike) {
                  aTypedArray(this);
                  var offset = toOffset(arguments.length > 1 ? arguments[1] : void 0, 1);
                  var length = this.length;
                  var src = toObject(arrayLike);
                  var len = lengthOfArrayLike(src);
                  var index = 0;
                  if (len + offset > length)
                    throw RangeError2("Wrong length");
                  while (index < len)
                    this[offset + index] = src[index++];
                }, FORCED);
              }
            ),
            /***/
            678: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var typedArraySpeciesConstructor = __webpack_require__2(6304);
                var fails = __webpack_require__2(7293);
                var arraySlice = __webpack_require__2(206);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                var FORCED = fails(function() {
                  new Int8Array(1).slice();
                });
                exportTypedArrayMethod("slice", function slice(start, end) {
                  var list = arraySlice(aTypedArray(this), start, end);
                  var C = typedArraySpeciesConstructor(this);
                  var index = 0;
                  var length = list.length;
                  var result = new C(length);
                  while (length > index)
                    result[index] = list[index++];
                  return result;
                }, FORCED);
              }
            ),
            /***/
            7462: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var $some = __webpack_require__2(2092).some;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("some", function some(callbackfn) {
                  return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            3824: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var global = __webpack_require__2(7854);
                var uncurryThis = __webpack_require__2(1702);
                var fails = __webpack_require__2(7293);
                var aCallable = __webpack_require__2(9662);
                var internalSort = __webpack_require__2(4362);
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var FF = __webpack_require__2(8886);
                var IE_OR_EDGE = __webpack_require__2(256);
                var V8 = __webpack_require__2(7392);
                var WEBKIT = __webpack_require__2(8008);
                var Array2 = global.Array;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                var Uint16Array2 = global.Uint16Array;
                var un$Sort = Uint16Array2 && uncurryThis(Uint16Array2.prototype.sort);
                var ACCEPT_INCORRECT_ARGUMENTS = !!un$Sort && !(fails(function() {
                  un$Sort(new Uint16Array2(2), null);
                }) && fails(function() {
                  un$Sort(new Uint16Array2(2), {});
                }));
                var STABLE_SORT = !!un$Sort && !fails(function() {
                  if (V8)
                    return V8 < 74;
                  if (FF)
                    return FF < 67;
                  if (IE_OR_EDGE)
                    return true;
                  if (WEBKIT)
                    return WEBKIT < 602;
                  var array = new Uint16Array2(516);
                  var expected = Array2(516);
                  var index, mod;
                  for (index = 0; index < 516; index++) {
                    mod = index % 4;
                    array[index] = 515 - index;
                    expected[index] = index - 2 * mod + 3;
                  }
                  un$Sort(array, function(a, b) {
                    return (a / 4 | 0) - (b / 4 | 0);
                  });
                  for (index = 0; index < 516; index++) {
                    if (array[index] !== expected[index])
                      return true;
                  }
                });
                var getSortCompare = function(comparefn) {
                  return function(x, y) {
                    if (comparefn !== void 0)
                      return +comparefn(x, y) || 0;
                    if (y !== y)
                      return -1;
                    if (x !== x)
                      return 1;
                    if (x === 0 && y === 0)
                      return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
                    return x > y;
                  };
                };
                exportTypedArrayMethod("sort", function sort(comparefn) {
                  if (comparefn !== void 0)
                    aCallable(comparefn);
                  if (STABLE_SORT)
                    return un$Sort(this, comparefn);
                  return internalSort(aTypedArray(this), getSortCompare(comparefn));
                }, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);
              }
            ),
            /***/
            5021: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var toLength = __webpack_require__2(7466);
                var toAbsoluteIndex = __webpack_require__2(1400);
                var typedArraySpeciesConstructor = __webpack_require__2(6304);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("subarray", function subarray(begin, end) {
                  var O = aTypedArray(this);
                  var length = O.length;
                  var beginIndex = toAbsoluteIndex(begin, length);
                  var C = typedArraySpeciesConstructor(O);
                  return new C(
                    O.buffer,
                    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
                    toLength((end === void 0 ? length : toAbsoluteIndex(end, length)) - beginIndex)
                  );
                });
              }
            ),
            /***/
            2974: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var global = __webpack_require__2(7854);
                var apply = __webpack_require__2(2104);
                var ArrayBufferViewCore = __webpack_require__2(2094);
                var fails = __webpack_require__2(7293);
                var arraySlice = __webpack_require__2(206);
                var Int8Array2 = global.Int8Array;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                var $toLocaleString = [].toLocaleString;
                var TO_LOCALE_STRING_BUG = !!Int8Array2 && fails(function() {
                  $toLocaleString.call(new Int8Array2(1));
                });
                var FORCED = fails(function() {
                  return [1, 2].toLocaleString() != new Int8Array2([1, 2]).toLocaleString();
                }) || !fails(function() {
                  Int8Array2.prototype.toLocaleString.call([1, 2]);
                });
                exportTypedArrayMethod("toLocaleString", function toLocaleString() {
                  return apply(
                    $toLocaleString,
                    TO_LOCALE_STRING_BUG ? arraySlice(aTypedArray(this)) : aTypedArray(this),
                    arraySlice(arguments)
                  );
                }, FORCED);
              }
            ),
            /***/
            5016: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var exportTypedArrayMethod = __webpack_require__2(2094).exportTypedArrayMethod;
                var fails = __webpack_require__2(7293);
                var global = __webpack_require__2(7854);
                var uncurryThis = __webpack_require__2(1702);
                var Uint8Array2 = global.Uint8Array;
                var Uint8ArrayPrototype = Uint8Array2 && Uint8Array2.prototype || {};
                var arrayToString = [].toString;
                var join = uncurryThis([].join);
                if (fails(function() {
                  arrayToString.call({});
                })) {
                  arrayToString = function toString() {
                    return join(this);
                  };
                }
                var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;
                exportTypedArrayMethod("toString", arrayToString, IS_NOT_ARRAY_METHOD);
              }
            ),
            /***/
            8255: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var createTypedArrayConstructor = __webpack_require__2(9843);
                createTypedArrayConstructor("Uint16", function(init) {
                  return function Uint16Array2(data, byteOffset, length) {
                    return init(this, data, byteOffset, length);
                  };
                });
              }
            ),
            /***/
            9135: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var createTypedArrayConstructor = __webpack_require__2(9843);
                createTypedArrayConstructor("Uint32", function(init) {
                  return function Uint32Array2(data, byteOffset, length) {
                    return init(this, data, byteOffset, length);
                  };
                });
              }
            ),
            /***/
            2472: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var createTypedArrayConstructor = __webpack_require__2(9843);
                createTypedArrayConstructor("Uint8", function(init) {
                  return function Uint8Array2(data, byteOffset, length) {
                    return init(this, data, byteOffset, length);
                  };
                });
              }
            ),
            /***/
            9743: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var createTypedArrayConstructor = __webpack_require__2(9843);
                createTypedArrayConstructor("Uint8", function(init) {
                  return function Uint8ClampedArray2(data, byteOffset, length) {
                    return init(this, data, byteOffset, length);
                  };
                }, true);
              }
            ),
            /***/
            8628: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                __webpack_require__2(9170);
              }
            ),
            /***/
            5743: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                __webpack_require__2(5837);
              }
            ),
            /***/
            7314: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                __webpack_require__2(7922);
              }
            ),
            /***/
            6290: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                __webpack_require__2(4668);
              }
            ),
            /***/
            7479: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var newPromiseCapabilityModule = __webpack_require__2(8523);
                var perform = __webpack_require__2(2534);
                $({ target: "Promise", stat: true }, {
                  "try": function(callbackfn) {
                    var promiseCapability = newPromiseCapabilityModule.f(this);
                    var result = perform(callbackfn);
                    (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value);
                    return promiseCapability.promise;
                  }
                });
              }
            ),
            /***/
            3728: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                __webpack_require__2(6373);
              }
            ),
            /***/
            4747: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var DOMIterables = __webpack_require__2(8324);
                var DOMTokenListPrototype = __webpack_require__2(8509);
                var forEach = __webpack_require__2(8533);
                var createNonEnumerableProperty = __webpack_require__2(8880);
                var handlePrototype = function(CollectionPrototype) {
                  if (CollectionPrototype && CollectionPrototype.forEach !== forEach)
                    try {
                      createNonEnumerableProperty(CollectionPrototype, "forEach", forEach);
                    } catch (error) {
                      CollectionPrototype.forEach = forEach;
                    }
                };
                for (var COLLECTION_NAME in DOMIterables) {
                  if (DOMIterables[COLLECTION_NAME]) {
                    handlePrototype(global[COLLECTION_NAME] && global[COLLECTION_NAME].prototype);
                  }
                }
                handlePrototype(DOMTokenListPrototype);
              }
            ),
            /***/
            3948: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(7854);
                var DOMIterables = __webpack_require__2(8324);
                var DOMTokenListPrototype = __webpack_require__2(8509);
                var ArrayIteratorMethods = __webpack_require__2(6992);
                var createNonEnumerableProperty = __webpack_require__2(8880);
                var wellKnownSymbol = __webpack_require__2(5112);
                var ITERATOR = wellKnownSymbol("iterator");
                var TO_STRING_TAG = wellKnownSymbol("toStringTag");
                var ArrayValues = ArrayIteratorMethods.values;
                var handlePrototype = function(CollectionPrototype, COLLECTION_NAME2) {
                  if (CollectionPrototype) {
                    if (CollectionPrototype[ITERATOR] !== ArrayValues)
                      try {
                        createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
                      } catch (error) {
                        CollectionPrototype[ITERATOR] = ArrayValues;
                      }
                    if (!CollectionPrototype[TO_STRING_TAG]) {
                      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME2);
                    }
                    if (DOMIterables[COLLECTION_NAME2])
                      for (var METHOD_NAME in ArrayIteratorMethods) {
                        if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
                          try {
                            createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
                          } catch (error) {
                            CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
                          }
                      }
                  }
                };
                for (var COLLECTION_NAME in DOMIterables) {
                  handlePrototype(global[COLLECTION_NAME] && global[COLLECTION_NAME].prototype, COLLECTION_NAME);
                }
                handlePrototype(DOMTokenListPrototype, "DOMTokenList");
              }
            ),
            /***/
            3753: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(2109);
                var call = __webpack_require__2(6916);
                $({ target: "URL", proto: true, enumerable: true }, {
                  toJSON: function toJSON() {
                    return call(URL.prototype.toString, this);
                  }
                });
              }
            ),
            /***/
            1150: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var parent = __webpack_require__2(7633);
                __webpack_require__2(3948);
                module2.exports = parent;
              }
            ),
            /***/
            251: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var objectKeys = __webpack_require__2(2215);
                var isArguments = __webpack_require__2(2584);
                var is = __webpack_require__2(609);
                var isRegex = __webpack_require__2(8420);
                var flags = __webpack_require__2(2847);
                var isDate = __webpack_require__2(8923);
                var getTime = Date.prototype.getTime;
                function deepEqual(actual, expected, options) {
                  var opts = options || {};
                  if (opts.strict ? is(actual, expected) : actual === expected) {
                    return true;
                  }
                  if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
                    return opts.strict ? is(actual, expected) : actual == expected;
                  }
                  return objEquiv(actual, expected, opts);
                }
                function isUndefinedOrNull(value) {
                  return value === null || value === void 0;
                }
                function isBuffer(x) {
                  if (!x || typeof x !== "object" || typeof x.length !== "number") {
                    return false;
                  }
                  if (typeof x.copy !== "function" || typeof x.slice !== "function") {
                    return false;
                  }
                  if (x.length > 0 && typeof x[0] !== "number") {
                    return false;
                  }
                  return true;
                }
                function objEquiv(a, b, opts) {
                  var i, key;
                  if (typeof a !== typeof b) {
                    return false;
                  }
                  if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) {
                    return false;
                  }
                  if (a.prototype !== b.prototype) {
                    return false;
                  }
                  if (isArguments(a) !== isArguments(b)) {
                    return false;
                  }
                  var aIsRegex = isRegex(a);
                  var bIsRegex = isRegex(b);
                  if (aIsRegex !== bIsRegex) {
                    return false;
                  }
                  if (aIsRegex || bIsRegex) {
                    return a.source === b.source && flags(a) === flags(b);
                  }
                  if (isDate(a) && isDate(b)) {
                    return getTime.call(a) === getTime.call(b);
                  }
                  var aIsBuffer = isBuffer(a);
                  var bIsBuffer = isBuffer(b);
                  if (aIsBuffer !== bIsBuffer) {
                    return false;
                  }
                  if (aIsBuffer || bIsBuffer) {
                    if (a.length !== b.length) {
                      return false;
                    }
                    for (i = 0; i < a.length; i++) {
                      if (a[i] !== b[i]) {
                        return false;
                      }
                    }
                    return true;
                  }
                  if (typeof a !== typeof b) {
                    return false;
                  }
                  try {
                    var ka = objectKeys(a);
                    var kb = objectKeys(b);
                  } catch (e) {
                    return false;
                  }
                  if (ka.length !== kb.length) {
                    return false;
                  }
                  ka.sort();
                  kb.sort();
                  for (i = ka.length - 1; i >= 0; i--) {
                    if (ka[i] != kb[i]) {
                      return false;
                    }
                  }
                  for (i = ka.length - 1; i >= 0; i--) {
                    key = ka[i];
                    if (!deepEqual(a[key], b[key], opts)) {
                      return false;
                    }
                  }
                  return true;
                }
                module2.exports = deepEqual;
              }
            ),
            /***/
            4289: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var keys = __webpack_require__2(2215);
                var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
                var toStr = Object.prototype.toString;
                var concat = Array.prototype.concat;
                var origDefineProperty = Object.defineProperty;
                var isFunction = function(fn) {
                  return typeof fn === "function" && toStr.call(fn) === "[object Function]";
                };
                var hasPropertyDescriptors = __webpack_require__2(1044)();
                var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
                var defineProperty = function(object, name, value, predicate) {
                  if (name in object && (!isFunction(predicate) || !predicate())) {
                    return;
                  }
                  if (supportsDescriptors) {
                    origDefineProperty(object, name, {
                      configurable: true,
                      enumerable: false,
                      value,
                      writable: true
                    });
                  } else {
                    object[name] = value;
                  }
                };
                var defineProperties = function(object, map) {
                  var predicates = arguments.length > 2 ? arguments[2] : {};
                  var props = keys(map);
                  if (hasSymbols) {
                    props = concat.call(props, Object.getOwnPropertySymbols(map));
                  }
                  for (var i = 0; i < props.length; i += 1) {
                    defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
                  }
                };
                defineProperties.supportsDescriptors = !!supportsDescriptors;
                module2.exports = defineProperties;
              }
            ),
            /***/
            8091: (
              /***/
              function(module2) {
                "use strict";
                function assign(target, firstSource) {
                  if (target === void 0 || target === null) {
                    throw new TypeError("Cannot convert first argument to object");
                  }
                  var to = Object(target);
                  for (var i = 1; i < arguments.length; i++) {
                    var nextSource = arguments[i];
                    if (nextSource === void 0 || nextSource === null) {
                      continue;
                    }
                    var keysArray = Object.keys(Object(nextSource));
                    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
                      var nextKey = keysArray[nextIndex];
                      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                      if (desc !== void 0 && desc.enumerable) {
                        to[nextKey] = nextSource[nextKey];
                      }
                    }
                  }
                  return to;
                }
                function polyfill() {
                  if (!Object.assign) {
                    Object.defineProperty(Object, "assign", {
                      enumerable: false,
                      configurable: true,
                      writable: true,
                      value: assign
                    });
                  }
                }
                module2.exports = {
                  assign,
                  polyfill
                };
              }
            ),
            /***/
            7187: (
              /***/
              function(module2) {
                "use strict";
                var R = typeof Reflect === "object" ? Reflect : null;
                var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
                  return Function.prototype.apply.call(target, receiver, args);
                };
                var ReflectOwnKeys;
                if (R && typeof R.ownKeys === "function") {
                  ReflectOwnKeys = R.ownKeys;
                } else if (Object.getOwnPropertySymbols) {
                  ReflectOwnKeys = function ReflectOwnKeys2(target) {
                    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
                  };
                } else {
                  ReflectOwnKeys = function ReflectOwnKeys2(target) {
                    return Object.getOwnPropertyNames(target);
                  };
                }
                function ProcessEmitWarning(warning) {
                  if (console && console.warn)
                    console.warn(warning);
                }
                var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
                  return value !== value;
                };
                function EventEmitter() {
                  EventEmitter.init.call(this);
                }
                module2.exports = EventEmitter;
                module2.exports.once = once;
                EventEmitter.EventEmitter = EventEmitter;
                EventEmitter.prototype._events = void 0;
                EventEmitter.prototype._eventsCount = 0;
                EventEmitter.prototype._maxListeners = void 0;
                var defaultMaxListeners = 10;
                function checkListener(listener) {
                  if (typeof listener !== "function") {
                    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
                  }
                }
                Object.defineProperty(EventEmitter, "defaultMaxListeners", {
                  enumerable: true,
                  get: function() {
                    return defaultMaxListeners;
                  },
                  set: function(arg) {
                    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
                      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
                    }
                    defaultMaxListeners = arg;
                  }
                });
                EventEmitter.init = function() {
                  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
                    this._events = /* @__PURE__ */ Object.create(null);
                    this._eventsCount = 0;
                  }
                  this._maxListeners = this._maxListeners || void 0;
                };
                EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
                  if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
                    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
                  }
                  this._maxListeners = n;
                  return this;
                };
                function _getMaxListeners(that) {
                  if (that._maxListeners === void 0)
                    return EventEmitter.defaultMaxListeners;
                  return that._maxListeners;
                }
                EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
                  return _getMaxListeners(this);
                };
                EventEmitter.prototype.emit = function emit(type) {
                  var args = [];
                  for (var i = 1; i < arguments.length; i++)
                    args.push(arguments[i]);
                  var doError = type === "error";
                  var events = this._events;
                  if (events !== void 0)
                    doError = doError && events.error === void 0;
                  else if (!doError)
                    return false;
                  if (doError) {
                    var er;
                    if (args.length > 0)
                      er = args[0];
                    if (er instanceof Error) {
                      throw er;
                    }
                    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
                    err.context = er;
                    throw err;
                  }
                  var handler = events[type];
                  if (handler === void 0)
                    return false;
                  if (typeof handler === "function") {
                    ReflectApply(handler, this, args);
                  } else {
                    var len = handler.length;
                    var listeners = arrayClone(handler, len);
                    for (var i = 0; i < len; ++i)
                      ReflectApply(listeners[i], this, args);
                  }
                  return true;
                };
                function _addListener(target, type, listener, prepend) {
                  var m;
                  var events;
                  var existing;
                  checkListener(listener);
                  events = target._events;
                  if (events === void 0) {
                    events = target._events = /* @__PURE__ */ Object.create(null);
                    target._eventsCount = 0;
                  } else {
                    if (events.newListener !== void 0) {
                      target.emit(
                        "newListener",
                        type,
                        listener.listener ? listener.listener : listener
                      );
                      events = target._events;
                    }
                    existing = events[type];
                  }
                  if (existing === void 0) {
                    existing = events[type] = listener;
                    ++target._eventsCount;
                  } else {
                    if (typeof existing === "function") {
                      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
                    } else if (prepend) {
                      existing.unshift(listener);
                    } else {
                      existing.push(listener);
                    }
                    m = _getMaxListeners(target);
                    if (m > 0 && existing.length > m && !existing.warned) {
                      existing.warned = true;
                      var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                      w.name = "MaxListenersExceededWarning";
                      w.emitter = target;
                      w.type = type;
                      w.count = existing.length;
                      ProcessEmitWarning(w);
                    }
                  }
                  return target;
                }
                EventEmitter.prototype.addListener = function addListener(type, listener) {
                  return _addListener(this, type, listener, false);
                };
                EventEmitter.prototype.on = EventEmitter.prototype.addListener;
                EventEmitter.prototype.prependListener = function prependListener(type, listener) {
                  return _addListener(this, type, listener, true);
                };
                function onceWrapper() {
                  if (!this.fired) {
                    this.target.removeListener(this.type, this.wrapFn);
                    this.fired = true;
                    if (arguments.length === 0)
                      return this.listener.call(this.target);
                    return this.listener.apply(this.target, arguments);
                  }
                }
                function _onceWrap(target, type, listener) {
                  var state = { fired: false, wrapFn: void 0, target, type, listener };
                  var wrapped = onceWrapper.bind(state);
                  wrapped.listener = listener;
                  state.wrapFn = wrapped;
                  return wrapped;
                }
                EventEmitter.prototype.once = function once2(type, listener) {
                  checkListener(listener);
                  this.on(type, _onceWrap(this, type, listener));
                  return this;
                };
                EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
                  checkListener(listener);
                  this.prependListener(type, _onceWrap(this, type, listener));
                  return this;
                };
                EventEmitter.prototype.removeListener = function removeListener(type, listener) {
                  var list, events, position, i, originalListener;
                  checkListener(listener);
                  events = this._events;
                  if (events === void 0)
                    return this;
                  list = events[type];
                  if (list === void 0)
                    return this;
                  if (list === listener || list.listener === listener) {
                    if (--this._eventsCount === 0)
                      this._events = /* @__PURE__ */ Object.create(null);
                    else {
                      delete events[type];
                      if (events.removeListener)
                        this.emit("removeListener", type, list.listener || listener);
                    }
                  } else if (typeof list !== "function") {
                    position = -1;
                    for (i = list.length - 1; i >= 0; i--) {
                      if (list[i] === listener || list[i].listener === listener) {
                        originalListener = list[i].listener;
                        position = i;
                        break;
                      }
                    }
                    if (position < 0)
                      return this;
                    if (position === 0)
                      list.shift();
                    else {
                      spliceOne(list, position);
                    }
                    if (list.length === 1)
                      events[type] = list[0];
                    if (events.removeListener !== void 0)
                      this.emit("removeListener", type, originalListener || listener);
                  }
                  return this;
                };
                EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
                EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
                  var listeners, events, i;
                  events = this._events;
                  if (events === void 0)
                    return this;
                  if (events.removeListener === void 0) {
                    if (arguments.length === 0) {
                      this._events = /* @__PURE__ */ Object.create(null);
                      this._eventsCount = 0;
                    } else if (events[type] !== void 0) {
                      if (--this._eventsCount === 0)
                        this._events = /* @__PURE__ */ Object.create(null);
                      else
                        delete events[type];
                    }
                    return this;
                  }
                  if (arguments.length === 0) {
                    var keys = Object.keys(events);
                    var key;
                    for (i = 0; i < keys.length; ++i) {
                      key = keys[i];
                      if (key === "removeListener")
                        continue;
                      this.removeAllListeners(key);
                    }
                    this.removeAllListeners("removeListener");
                    this._events = /* @__PURE__ */ Object.create(null);
                    this._eventsCount = 0;
                    return this;
                  }
                  listeners = events[type];
                  if (typeof listeners === "function") {
                    this.removeListener(type, listeners);
                  } else if (listeners !== void 0) {
                    for (i = listeners.length - 1; i >= 0; i--) {
                      this.removeListener(type, listeners[i]);
                    }
                  }
                  return this;
                };
                function _listeners(target, type, unwrap) {
                  var events = target._events;
                  if (events === void 0)
                    return [];
                  var evlistener = events[type];
                  if (evlistener === void 0)
                    return [];
                  if (typeof evlistener === "function")
                    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
                  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
                }
                EventEmitter.prototype.listeners = function listeners(type) {
                  return _listeners(this, type, true);
                };
                EventEmitter.prototype.rawListeners = function rawListeners(type) {
                  return _listeners(this, type, false);
                };
                EventEmitter.listenerCount = function(emitter, type) {
                  if (typeof emitter.listenerCount === "function") {
                    return emitter.listenerCount(type);
                  } else {
                    return listenerCount.call(emitter, type);
                  }
                };
                EventEmitter.prototype.listenerCount = listenerCount;
                function listenerCount(type) {
                  var events = this._events;
                  if (events !== void 0) {
                    var evlistener = events[type];
                    if (typeof evlistener === "function") {
                      return 1;
                    } else if (evlistener !== void 0) {
                      return evlistener.length;
                    }
                  }
                  return 0;
                }
                EventEmitter.prototype.eventNames = function eventNames() {
                  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
                };
                function arrayClone(arr, n) {
                  var copy = new Array(n);
                  for (var i = 0; i < n; ++i)
                    copy[i] = arr[i];
                  return copy;
                }
                function spliceOne(list, index) {
                  for (; index + 1 < list.length; index++)
                    list[index] = list[index + 1];
                  list.pop();
                }
                function unwrapListeners(arr) {
                  var ret = new Array(arr.length);
                  for (var i = 0; i < ret.length; ++i) {
                    ret[i] = arr[i].listener || arr[i];
                  }
                  return ret;
                }
                function once(emitter, name) {
                  return new Promise(function(resolve, reject) {
                    function errorListener(err) {
                      emitter.removeListener(name, resolver);
                      reject(err);
                    }
                    function resolver() {
                      if (typeof emitter.removeListener === "function") {
                        emitter.removeListener("error", errorListener);
                      }
                      resolve([].slice.call(arguments));
                    }
                    ;
                    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
                    if (name !== "error") {
                      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
                    }
                  });
                }
                function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
                  if (typeof emitter.on === "function") {
                    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
                  }
                }
                function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
                  if (typeof emitter.on === "function") {
                    if (flags.once) {
                      emitter.once(name, listener);
                    } else {
                      emitter.on(name, listener);
                    }
                  } else if (typeof emitter.addEventListener === "function") {
                    emitter.addEventListener(name, function wrapListener(arg) {
                      if (flags.once) {
                        emitter.removeEventListener(name, wrapListener);
                      }
                      listener(arg);
                    });
                  } else {
                    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
                  }
                }
              }
            ),
            /***/
            2536: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var ___EXPOSE_LOADER_IMPORT___ = __webpack_require__2(4275);
                var ___EXPOSE_LOADER_GET_GLOBAL_THIS___ = __webpack_require__2(7672);
                var ___EXPOSE_LOADER_GLOBAL_THIS___ = ___EXPOSE_LOADER_GET_GLOBAL_THIS___;
                if (typeof ___EXPOSE_LOADER_GLOBAL_THIS___["pdfMake"] === "undefined")
                  ___EXPOSE_LOADER_GLOBAL_THIS___["pdfMake"] = ___EXPOSE_LOADER_IMPORT___;
                module2.exports = ___EXPOSE_LOADER_IMPORT___;
              }
            ),
            /***/
            7672: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                module2.exports = function() {
                  if (typeof globalThis === "object") {
                    return globalThis;
                  }
                  var g;
                  try {
                    g = this || new Function("return this")();
                  } catch (e) {
                    if (typeof window === "object") {
                      return window;
                    }
                    if (typeof self === "object") {
                      return self;
                    }
                    if (typeof __webpack_require__2.g !== "undefined") {
                      return __webpack_require__2.g;
                    }
                  }
                  return g;
                }();
              }
            ),
            /***/
            4029: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isCallable = __webpack_require__2(5320);
                var toStr = Object.prototype.toString;
                var hasOwnProperty = Object.prototype.hasOwnProperty;
                var forEachArray = function forEachArray2(array, iterator, receiver) {
                  for (var i = 0, len = array.length; i < len; i++) {
                    if (hasOwnProperty.call(array, i)) {
                      if (receiver == null) {
                        iterator(array[i], i, array);
                      } else {
                        iterator.call(receiver, array[i], i, array);
                      }
                    }
                  }
                };
                var forEachString = function forEachString2(string, iterator, receiver) {
                  for (var i = 0, len = string.length; i < len; i++) {
                    if (receiver == null) {
                      iterator(string.charAt(i), i, string);
                    } else {
                      iterator.call(receiver, string.charAt(i), i, string);
                    }
                  }
                };
                var forEachObject = function forEachObject2(object, iterator, receiver) {
                  for (var k in object) {
                    if (hasOwnProperty.call(object, k)) {
                      if (receiver == null) {
                        iterator(object[k], k, object);
                      } else {
                        iterator.call(receiver, object[k], k, object);
                      }
                    }
                  }
                };
                var forEach = function forEach2(list, iterator, thisArg) {
                  if (!isCallable(iterator)) {
                    throw new TypeError("iterator must be a function");
                  }
                  var receiver;
                  if (arguments.length >= 3) {
                    receiver = thisArg;
                  }
                  if (toStr.call(list) === "[object Array]") {
                    forEachArray(list, iterator, receiver);
                  } else if (typeof list === "string") {
                    forEachString(list, iterator, receiver);
                  } else {
                    forEachObject(list, iterator, receiver);
                  }
                };
                module2.exports = forEach;
              }
            ),
            /***/
            7648: (
              /***/
              function(module2) {
                "use strict";
                var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
                var slice = Array.prototype.slice;
                var toStr = Object.prototype.toString;
                var funcType = "[object Function]";
                module2.exports = function bind(that) {
                  var target = this;
                  if (typeof target !== "function" || toStr.call(target) !== funcType) {
                    throw new TypeError(ERROR_MESSAGE + target);
                  }
                  var args = slice.call(arguments, 1);
                  var bound;
                  var binder = function() {
                    if (this instanceof bound) {
                      var result = target.apply(
                        this,
                        args.concat(slice.call(arguments))
                      );
                      if (Object(result) === result) {
                        return result;
                      }
                      return this;
                    } else {
                      return target.apply(
                        that,
                        args.concat(slice.call(arguments))
                      );
                    }
                  };
                  var boundLength = Math.max(0, target.length - args.length);
                  var boundArgs = [];
                  for (var i = 0; i < boundLength; i++) {
                    boundArgs.push("$" + i);
                  }
                  bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
                  if (target.prototype) {
                    var Empty = function Empty2() {
                    };
                    Empty.prototype = target.prototype;
                    bound.prototype = new Empty();
                    Empty.prototype = null;
                  }
                  return bound;
                };
              }
            ),
            /***/
            8612: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var implementation = __webpack_require__2(7648);
                module2.exports = Function.prototype.bind || implementation;
              }
            ),
            /***/
            5972: (
              /***/
              function(module2) {
                "use strict";
                var functionsHaveNames = function functionsHaveNames2() {
                  return typeof function f() {
                  }.name === "string";
                };
                var gOPD = Object.getOwnPropertyDescriptor;
                if (gOPD) {
                  try {
                    gOPD([], "length");
                  } catch (e) {
                    gOPD = null;
                  }
                }
                functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
                  if (!functionsHaveNames() || !gOPD) {
                    return false;
                  }
                  var desc = gOPD(function() {
                  }, "name");
                  return !!desc && !!desc.configurable;
                };
                var $bind = Function.prototype.bind;
                functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
                  return functionsHaveNames() && typeof $bind === "function" && function f() {
                  }.bind().name !== "";
                };
                module2.exports = functionsHaveNames;
              }
            ),
            /***/
            210: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var undefined2;
                var $SyntaxError = SyntaxError;
                var $Function = Function;
                var $TypeError = TypeError;
                var getEvalledConstructor = function(expressionSyntax) {
                  try {
                    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
                  } catch (e) {
                  }
                };
                var $gOPD = Object.getOwnPropertyDescriptor;
                if ($gOPD) {
                  try {
                    $gOPD({}, "");
                  } catch (e) {
                    $gOPD = null;
                  }
                }
                var throwTypeError = function() {
                  throw new $TypeError();
                };
                var ThrowTypeError = $gOPD ? function() {
                  try {
                    arguments.callee;
                    return throwTypeError;
                  } catch (calleeThrows) {
                    try {
                      return $gOPD(arguments, "callee").get;
                    } catch (gOPDthrows) {
                      return throwTypeError;
                    }
                  }
                }() : throwTypeError;
                var hasSymbols = __webpack_require__2(1405)();
                var getProto = Object.getPrototypeOf || function(x) {
                  return x.__proto__;
                };
                var needsEval = {};
                var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
                var INTRINSICS = {
                  "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
                  "%Array%": Array,
                  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
                  "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
                  "%AsyncFromSyncIteratorPrototype%": undefined2,
                  "%AsyncFunction%": needsEval,
                  "%AsyncGenerator%": needsEval,
                  "%AsyncGeneratorFunction%": needsEval,
                  "%AsyncIteratorPrototype%": needsEval,
                  "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
                  "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
                  "%Boolean%": Boolean,
                  "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
                  "%Date%": Date,
                  "%decodeURI%": decodeURI,
                  "%decodeURIComponent%": decodeURIComponent,
                  "%encodeURI%": encodeURI,
                  "%encodeURIComponent%": encodeURIComponent,
                  "%Error%": Error,
                  "%eval%": eval,
                  // eslint-disable-line no-eval
                  "%EvalError%": EvalError,
                  "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
                  "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
                  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
                  "%Function%": $Function,
                  "%GeneratorFunction%": needsEval,
                  "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
                  "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
                  "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
                  "%isFinite%": isFinite,
                  "%isNaN%": isNaN,
                  "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
                  "%JSON%": typeof JSON === "object" ? JSON : undefined2,
                  "%Map%": typeof Map === "undefined" ? undefined2 : Map,
                  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
                  "%Math%": Math,
                  "%Number%": Number,
                  "%Object%": Object,
                  "%parseFloat%": parseFloat,
                  "%parseInt%": parseInt,
                  "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
                  "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
                  "%RangeError%": RangeError,
                  "%ReferenceError%": ReferenceError,
                  "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
                  "%RegExp%": RegExp,
                  "%Set%": typeof Set === "undefined" ? undefined2 : Set,
                  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
                  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
                  "%String%": String,
                  "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
                  "%Symbol%": hasSymbols ? Symbol : undefined2,
                  "%SyntaxError%": $SyntaxError,
                  "%ThrowTypeError%": ThrowTypeError,
                  "%TypedArray%": TypedArray,
                  "%TypeError%": $TypeError,
                  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
                  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
                  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
                  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
                  "%URIError%": URIError,
                  "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
                  "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
                  "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
                };
                var doEval = function doEval2(name) {
                  var value;
                  if (name === "%AsyncFunction%") {
                    value = getEvalledConstructor("async function () {}");
                  } else if (name === "%GeneratorFunction%") {
                    value = getEvalledConstructor("function* () {}");
                  } else if (name === "%AsyncGeneratorFunction%") {
                    value = getEvalledConstructor("async function* () {}");
                  } else if (name === "%AsyncGenerator%") {
                    var fn = doEval2("%AsyncGeneratorFunction%");
                    if (fn) {
                      value = fn.prototype;
                    }
                  } else if (name === "%AsyncIteratorPrototype%") {
                    var gen = doEval2("%AsyncGenerator%");
                    if (gen) {
                      value = getProto(gen.prototype);
                    }
                  }
                  INTRINSICS[name] = value;
                  return value;
                };
                var LEGACY_ALIASES = {
                  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
                  "%ArrayPrototype%": ["Array", "prototype"],
                  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
                  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
                  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
                  "%ArrayProto_values%": ["Array", "prototype", "values"],
                  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
                  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
                  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
                  "%BooleanPrototype%": ["Boolean", "prototype"],
                  "%DataViewPrototype%": ["DataView", "prototype"],
                  "%DatePrototype%": ["Date", "prototype"],
                  "%ErrorPrototype%": ["Error", "prototype"],
                  "%EvalErrorPrototype%": ["EvalError", "prototype"],
                  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
                  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
                  "%FunctionPrototype%": ["Function", "prototype"],
                  "%Generator%": ["GeneratorFunction", "prototype"],
                  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
                  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
                  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
                  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
                  "%JSONParse%": ["JSON", "parse"],
                  "%JSONStringify%": ["JSON", "stringify"],
                  "%MapPrototype%": ["Map", "prototype"],
                  "%NumberPrototype%": ["Number", "prototype"],
                  "%ObjectPrototype%": ["Object", "prototype"],
                  "%ObjProto_toString%": ["Object", "prototype", "toString"],
                  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
                  "%PromisePrototype%": ["Promise", "prototype"],
                  "%PromiseProto_then%": ["Promise", "prototype", "then"],
                  "%Promise_all%": ["Promise", "all"],
                  "%Promise_reject%": ["Promise", "reject"],
                  "%Promise_resolve%": ["Promise", "resolve"],
                  "%RangeErrorPrototype%": ["RangeError", "prototype"],
                  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
                  "%RegExpPrototype%": ["RegExp", "prototype"],
                  "%SetPrototype%": ["Set", "prototype"],
                  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
                  "%StringPrototype%": ["String", "prototype"],
                  "%SymbolPrototype%": ["Symbol", "prototype"],
                  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
                  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
                  "%TypeErrorPrototype%": ["TypeError", "prototype"],
                  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
                  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
                  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
                  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
                  "%URIErrorPrototype%": ["URIError", "prototype"],
                  "%WeakMapPrototype%": ["WeakMap", "prototype"],
                  "%WeakSetPrototype%": ["WeakSet", "prototype"]
                };
                var bind = __webpack_require__2(8612);
                var hasOwn = __webpack_require__2(7642);
                var $concat = bind.call(Function.call, Array.prototype.concat);
                var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
                var $replace = bind.call(Function.call, String.prototype.replace);
                var $strSlice = bind.call(Function.call, String.prototype.slice);
                var $exec = bind.call(Function.call, RegExp.prototype.exec);
                var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
                var reEscapeChar = /\\(\\)?/g;
                var stringToPath = function stringToPath2(string) {
                  var first = $strSlice(string, 0, 1);
                  var last = $strSlice(string, -1);
                  if (first === "%" && last !== "%") {
                    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
                  } else if (last === "%" && first !== "%") {
                    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
                  }
                  var result = [];
                  $replace(string, rePropName, function(match, number, quote, subString) {
                    result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
                  });
                  return result;
                };
                var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
                  var intrinsicName = name;
                  var alias;
                  if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
                    alias = LEGACY_ALIASES[intrinsicName];
                    intrinsicName = "%" + alias[0] + "%";
                  }
                  if (hasOwn(INTRINSICS, intrinsicName)) {
                    var value = INTRINSICS[intrinsicName];
                    if (value === needsEval) {
                      value = doEval(intrinsicName);
                    }
                    if (typeof value === "undefined" && !allowMissing) {
                      throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
                    }
                    return {
                      alias,
                      name: intrinsicName,
                      value
                    };
                  }
                  throw new $SyntaxError("intrinsic " + name + " does not exist!");
                };
                module2.exports = function GetIntrinsic(name, allowMissing) {
                  if (typeof name !== "string" || name.length === 0) {
                    throw new $TypeError("intrinsic name must be a non-empty string");
                  }
                  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
                    throw new $TypeError('"allowMissing" argument must be a boolean');
                  }
                  if ($exec(/^%?[^%]*%?$/, name) === null) {
                    throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
                  }
                  var parts = stringToPath(name);
                  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
                  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
                  var intrinsicRealName = intrinsic.name;
                  var value = intrinsic.value;
                  var skipFurtherCaching = false;
                  var alias = intrinsic.alias;
                  if (alias) {
                    intrinsicBaseName = alias[0];
                    $spliceApply(parts, $concat([0, 1], alias));
                  }
                  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
                    var part = parts[i];
                    var first = $strSlice(part, 0, 1);
                    var last = $strSlice(part, -1);
                    if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
                      throw new $SyntaxError("property names with quotes must have matching quotes");
                    }
                    if (part === "constructor" || !isOwn) {
                      skipFurtherCaching = true;
                    }
                    intrinsicBaseName += "." + part;
                    intrinsicRealName = "%" + intrinsicBaseName + "%";
                    if (hasOwn(INTRINSICS, intrinsicRealName)) {
                      value = INTRINSICS[intrinsicRealName];
                    } else if (value != null) {
                      if (!(part in value)) {
                        if (!allowMissing) {
                          throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
                        }
                        return void 0;
                      }
                      if ($gOPD && i + 1 >= parts.length) {
                        var desc = $gOPD(value, part);
                        isOwn = !!desc;
                        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                          value = desc.get;
                        } else {
                          value = value[part];
                        }
                      } else {
                        isOwn = hasOwn(value, part);
                        value = value[part];
                      }
                      if (isOwn && !skipFurtherCaching) {
                        INTRINSICS[intrinsicRealName] = value;
                      }
                    }
                  }
                  return value;
                };
              }
            ),
            /***/
            7296: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var GetIntrinsic = __webpack_require__2(210);
                var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
                if ($gOPD) {
                  try {
                    $gOPD([], "length");
                  } catch (e) {
                    $gOPD = null;
                  }
                }
                module2.exports = $gOPD;
              }
            ),
            /***/
            1044: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var GetIntrinsic = __webpack_require__2(210);
                var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
                var hasPropertyDescriptors = function hasPropertyDescriptors2() {
                  if ($defineProperty) {
                    try {
                      $defineProperty({}, "a", { value: 1 });
                      return true;
                    } catch (e) {
                      return false;
                    }
                  }
                  return false;
                };
                hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
                  if (!hasPropertyDescriptors()) {
                    return null;
                  }
                  try {
                    return $defineProperty([], "length", { value: 1 }).length !== 1;
                  } catch (e) {
                    return true;
                  }
                };
                module2.exports = hasPropertyDescriptors;
              }
            ),
            /***/
            1405: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var origSymbol = typeof Symbol !== "undefined" && Symbol;
                var hasSymbolSham = __webpack_require__2(5419);
                module2.exports = function hasNativeSymbols() {
                  if (typeof origSymbol !== "function") {
                    return false;
                  }
                  if (typeof Symbol !== "function") {
                    return false;
                  }
                  if (typeof origSymbol("foo") !== "symbol") {
                    return false;
                  }
                  if (typeof Symbol("bar") !== "symbol") {
                    return false;
                  }
                  return hasSymbolSham();
                };
              }
            ),
            /***/
            5419: (
              /***/
              function(module2) {
                "use strict";
                module2.exports = function hasSymbols() {
                  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
                    return false;
                  }
                  if (typeof Symbol.iterator === "symbol") {
                    return true;
                  }
                  var obj = {};
                  var sym = Symbol("test");
                  var symObj = Object(sym);
                  if (typeof sym === "string") {
                    return false;
                  }
                  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
                    return false;
                  }
                  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
                    return false;
                  }
                  var symVal = 42;
                  obj[sym] = symVal;
                  for (sym in obj) {
                    return false;
                  }
                  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
                    return false;
                  }
                  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
                    return false;
                  }
                  var syms = Object.getOwnPropertySymbols(obj);
                  if (syms.length !== 1 || syms[0] !== sym) {
                    return false;
                  }
                  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
                    return false;
                  }
                  if (typeof Object.getOwnPropertyDescriptor === "function") {
                    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
                    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
                      return false;
                    }
                  }
                  return true;
                };
              }
            ),
            /***/
            6410: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var hasSymbols = __webpack_require__2(5419);
                module2.exports = function hasToStringTagShams() {
                  return hasSymbols() && !!Symbol.toStringTag;
                };
              }
            ),
            /***/
            7642: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var bind = __webpack_require__2(8612);
                module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
              }
            ),
            /***/
            688: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var Buffer = __webpack_require__2(7103).Buffer;
                exports2._dbcs = DBCSCodec;
                var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
                for (var i = 0; i < 256; i++)
                  UNASSIGNED_NODE[i] = UNASSIGNED;
                function DBCSCodec(codecOptions, iconv) {
                  this.encodingName = codecOptions.encodingName;
                  if (!codecOptions)
                    throw new Error("DBCS codec is called without the data.");
                  if (!codecOptions.table)
                    throw new Error("Encoding '" + this.encodingName + "' has no data.");
                  var mappingTable = codecOptions.table();
                  this.decodeTables = [];
                  this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
                  this.decodeTableSeq = [];
                  for (var i2 = 0; i2 < mappingTable.length; i2++)
                    this._addDecodeChunk(mappingTable[i2]);
                  if (typeof codecOptions.gb18030 === "function") {
                    this.gb18030 = codecOptions.gb18030();
                    var commonThirdByteNodeIdx = this.decodeTables.length;
                    this.decodeTables.push(UNASSIGNED_NODE.slice(0));
                    var commonFourthByteNodeIdx = this.decodeTables.length;
                    this.decodeTables.push(UNASSIGNED_NODE.slice(0));
                    var firstByteNode = this.decodeTables[0];
                    for (var i2 = 129; i2 <= 254; i2++) {
                      var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i2]];
                      for (var j = 48; j <= 57; j++) {
                        if (secondByteNode[j] === UNASSIGNED) {
                          secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
                        } else if (secondByteNode[j] > NODE_START) {
                          throw new Error("gb18030 decode tables conflict at byte 2");
                        }
                        var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
                        for (var k = 129; k <= 254; k++) {
                          if (thirdByteNode[k] === UNASSIGNED) {
                            thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
                          } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
                            continue;
                          } else if (thirdByteNode[k] > NODE_START) {
                            throw new Error("gb18030 decode tables conflict at byte 3");
                          }
                          var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
                          for (var l = 48; l <= 57; l++) {
                            if (fourthByteNode[l] === UNASSIGNED)
                              fourthByteNode[l] = GB18030_CODE;
                          }
                        }
                      }
                    }
                  }
                  this.defaultCharUnicode = iconv.defaultCharUnicode;
                  this.encodeTable = [];
                  this.encodeTableSeq = [];
                  var skipEncodeChars = {};
                  if (codecOptions.encodeSkipVals)
                    for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
                      var val = codecOptions.encodeSkipVals[i2];
                      if (typeof val === "number")
                        skipEncodeChars[val] = true;
                      else
                        for (var j = val.from; j <= val.to; j++)
                          skipEncodeChars[j] = true;
                    }
                  this._fillEncodeTable(0, 0, skipEncodeChars);
                  if (codecOptions.encodeAdd) {
                    for (var uChar in codecOptions.encodeAdd)
                      if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
                        this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
                  }
                  this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
                  if (this.defCharSB === UNASSIGNED)
                    this.defCharSB = this.encodeTable[0]["?"];
                  if (this.defCharSB === UNASSIGNED)
                    this.defCharSB = "?".charCodeAt(0);
                }
                DBCSCodec.prototype.encoder = DBCSEncoder;
                DBCSCodec.prototype.decoder = DBCSDecoder;
                DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
                  var bytes = [];
                  for (; addr > 0; addr >>>= 8)
                    bytes.push(addr & 255);
                  if (bytes.length == 0)
                    bytes.push(0);
                  var node = this.decodeTables[0];
                  for (var i2 = bytes.length - 1; i2 > 0; i2--) {
                    var val = node[bytes[i2]];
                    if (val == UNASSIGNED) {
                      node[bytes[i2]] = NODE_START - this.decodeTables.length;
                      this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
                    } else if (val <= NODE_START) {
                      node = this.decodeTables[NODE_START - val];
                    } else
                      throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
                  }
                  return node;
                };
                DBCSCodec.prototype._addDecodeChunk = function(chunk) {
                  var curAddr = parseInt(chunk[0], 16);
                  var writeTable = this._getDecodeTrieNode(curAddr);
                  curAddr = curAddr & 255;
                  for (var k = 1; k < chunk.length; k++) {
                    var part = chunk[k];
                    if (typeof part === "string") {
                      for (var l = 0; l < part.length; ) {
                        var code = part.charCodeAt(l++);
                        if (55296 <= code && code < 56320) {
                          var codeTrail = part.charCodeAt(l++);
                          if (56320 <= codeTrail && codeTrail < 57344)
                            writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
                          else
                            throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
                        } else if (4080 < code && code <= 4095) {
                          var len = 4095 - code + 2;
                          var seq = [];
                          for (var m = 0; m < len; m++)
                            seq.push(part.charCodeAt(l++));
                          writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                          this.decodeTableSeq.push(seq);
                        } else
                          writeTable[curAddr++] = code;
                      }
                    } else if (typeof part === "number") {
                      var charCode = writeTable[curAddr - 1] + 1;
                      for (var l = 0; l < part; l++)
                        writeTable[curAddr++] = charCode++;
                    } else
                      throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
                  }
                  if (curAddr > 255)
                    throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
                };
                DBCSCodec.prototype._getEncodeBucket = function(uCode) {
                  var high = uCode >> 8;
                  if (this.encodeTable[high] === void 0)
                    this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
                  return this.encodeTable[high];
                };
                DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
                  var bucket = this._getEncodeBucket(uCode);
                  var low = uCode & 255;
                  if (bucket[low] <= SEQ_START)
                    this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
                  else if (bucket[low] == UNASSIGNED)
                    bucket[low] = dbcsCode;
                };
                DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
                  var uCode = seq[0];
                  var bucket = this._getEncodeBucket(uCode);
                  var low = uCode & 255;
                  var node;
                  if (bucket[low] <= SEQ_START) {
                    node = this.encodeTableSeq[SEQ_START - bucket[low]];
                  } else {
                    node = {};
                    if (bucket[low] !== UNASSIGNED)
                      node[DEF_CHAR] = bucket[low];
                    bucket[low] = SEQ_START - this.encodeTableSeq.length;
                    this.encodeTableSeq.push(node);
                  }
                  for (var j = 1; j < seq.length - 1; j++) {
                    var oldVal = node[uCode];
                    if (typeof oldVal === "object")
                      node = oldVal;
                    else {
                      node = node[uCode] = {};
                      if (oldVal !== void 0)
                        node[DEF_CHAR] = oldVal;
                    }
                  }
                  uCode = seq[seq.length - 1];
                  node[uCode] = dbcsCode;
                };
                DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
                  var node = this.decodeTables[nodeIdx];
                  var hasValues = false;
                  var subNodeEmpty = {};
                  for (var i2 = 0; i2 < 256; i2++) {
                    var uCode = node[i2];
                    var mbCode = prefix + i2;
                    if (skipEncodeChars[mbCode])
                      continue;
                    if (uCode >= 0) {
                      this._setEncodeChar(uCode, mbCode);
                      hasValues = true;
                    } else if (uCode <= NODE_START) {
                      var subNodeIdx = NODE_START - uCode;
                      if (!subNodeEmpty[subNodeIdx]) {
                        var newPrefix = mbCode << 8 >>> 0;
                        if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
                          hasValues = true;
                        else
                          subNodeEmpty[subNodeIdx] = true;
                      }
                    } else if (uCode <= SEQ_START) {
                      this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
                      hasValues = true;
                    }
                  }
                  return hasValues;
                };
                function DBCSEncoder(options, codec) {
                  this.leadSurrogate = -1;
                  this.seqObj = void 0;
                  this.encodeTable = codec.encodeTable;
                  this.encodeTableSeq = codec.encodeTableSeq;
                  this.defaultCharSingleByte = codec.defCharSB;
                  this.gb18030 = codec.gb18030;
                }
                DBCSEncoder.prototype.write = function(str) {
                  var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
                  while (true) {
                    if (nextChar === -1) {
                      if (i2 == str.length)
                        break;
                      var uCode = str.charCodeAt(i2++);
                    } else {
                      var uCode = nextChar;
                      nextChar = -1;
                    }
                    if (55296 <= uCode && uCode < 57344) {
                      if (uCode < 56320) {
                        if (leadSurrogate === -1) {
                          leadSurrogate = uCode;
                          continue;
                        } else {
                          leadSurrogate = uCode;
                          uCode = UNASSIGNED;
                        }
                      } else {
                        if (leadSurrogate !== -1) {
                          uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
                          leadSurrogate = -1;
                        } else {
                          uCode = UNASSIGNED;
                        }
                      }
                    } else if (leadSurrogate !== -1) {
                      nextChar = uCode;
                      uCode = UNASSIGNED;
                      leadSurrogate = -1;
                    }
                    var dbcsCode = UNASSIGNED;
                    if (seqObj !== void 0 && uCode != UNASSIGNED) {
                      var resCode = seqObj[uCode];
                      if (typeof resCode === "object") {
                        seqObj = resCode;
                        continue;
                      } else if (typeof resCode == "number") {
                        dbcsCode = resCode;
                      } else if (resCode == void 0) {
                        resCode = seqObj[DEF_CHAR];
                        if (resCode !== void 0) {
                          dbcsCode = resCode;
                          nextChar = uCode;
                        } else {
                        }
                      }
                      seqObj = void 0;
                    } else if (uCode >= 0) {
                      var subtable = this.encodeTable[uCode >> 8];
                      if (subtable !== void 0)
                        dbcsCode = subtable[uCode & 255];
                      if (dbcsCode <= SEQ_START) {
                        seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
                        continue;
                      }
                      if (dbcsCode == UNASSIGNED && this.gb18030) {
                        var idx = findIdx(this.gb18030.uChars, uCode);
                        if (idx != -1) {
                          var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                          newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
                          dbcsCode = dbcsCode % 12600;
                          newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
                          dbcsCode = dbcsCode % 1260;
                          newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
                          dbcsCode = dbcsCode % 10;
                          newBuf[j++] = 48 + dbcsCode;
                          continue;
                        }
                      }
                    }
                    if (dbcsCode === UNASSIGNED)
                      dbcsCode = this.defaultCharSingleByte;
                    if (dbcsCode < 256) {
                      newBuf[j++] = dbcsCode;
                    } else if (dbcsCode < 65536) {
                      newBuf[j++] = dbcsCode >> 8;
                      newBuf[j++] = dbcsCode & 255;
                    } else if (dbcsCode < 16777216) {
                      newBuf[j++] = dbcsCode >> 16;
                      newBuf[j++] = dbcsCode >> 8 & 255;
                      newBuf[j++] = dbcsCode & 255;
                    } else {
                      newBuf[j++] = dbcsCode >>> 24;
                      newBuf[j++] = dbcsCode >>> 16 & 255;
                      newBuf[j++] = dbcsCode >>> 8 & 255;
                      newBuf[j++] = dbcsCode & 255;
                    }
                  }
                  this.seqObj = seqObj;
                  this.leadSurrogate = leadSurrogate;
                  return newBuf.slice(0, j);
                };
                DBCSEncoder.prototype.end = function() {
                  if (this.leadSurrogate === -1 && this.seqObj === void 0)
                    return;
                  var newBuf = Buffer.alloc(10), j = 0;
                  if (this.seqObj) {
                    var dbcsCode = this.seqObj[DEF_CHAR];
                    if (dbcsCode !== void 0) {
                      if (dbcsCode < 256) {
                        newBuf[j++] = dbcsCode;
                      } else {
                        newBuf[j++] = dbcsCode >> 8;
                        newBuf[j++] = dbcsCode & 255;
                      }
                    } else {
                    }
                    this.seqObj = void 0;
                  }
                  if (this.leadSurrogate !== -1) {
                    newBuf[j++] = this.defaultCharSingleByte;
                    this.leadSurrogate = -1;
                  }
                  return newBuf.slice(0, j);
                };
                DBCSEncoder.prototype.findIdx = findIdx;
                function DBCSDecoder(options, codec) {
                  this.nodeIdx = 0;
                  this.prevBytes = [];
                  this.decodeTables = codec.decodeTables;
                  this.decodeTableSeq = codec.decodeTableSeq;
                  this.defaultCharUnicode = codec.defaultCharUnicode;
                  this.gb18030 = codec.gb18030;
                }
                DBCSDecoder.prototype.write = function(buf) {
                  var newBuf = Buffer.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBytes = this.prevBytes, prevOffset = this.prevBytes.length, seqStart = -this.prevBytes.length, uCode;
                  for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
                    var curByte = i2 >= 0 ? buf[i2] : prevBytes[i2 + prevOffset];
                    var uCode = this.decodeTables[nodeIdx][curByte];
                    if (uCode >= 0) {
                    } else if (uCode === UNASSIGNED) {
                      uCode = this.defaultCharUnicode.charCodeAt(0);
                      i2 = seqStart;
                    } else if (uCode === GB18030_CODE) {
                      if (i2 >= 3) {
                        var ptr = (buf[i2 - 3] - 129) * 12600 + (buf[i2 - 2] - 48) * 1260 + (buf[i2 - 1] - 129) * 10 + (curByte - 48);
                      } else {
                        var ptr = (prevBytes[i2 - 3 + prevOffset] - 129) * 12600 + ((i2 - 2 >= 0 ? buf[i2 - 2] : prevBytes[i2 - 2 + prevOffset]) - 48) * 1260 + ((i2 - 1 >= 0 ? buf[i2 - 1] : prevBytes[i2 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
                      }
                      var idx = findIdx(this.gb18030.gbChars, ptr);
                      uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
                    } else if (uCode <= NODE_START) {
                      nodeIdx = NODE_START - uCode;
                      continue;
                    } else if (uCode <= SEQ_START) {
                      var seq = this.decodeTableSeq[SEQ_START - uCode];
                      for (var k = 0; k < seq.length - 1; k++) {
                        uCode = seq[k];
                        newBuf[j++] = uCode & 255;
                        newBuf[j++] = uCode >> 8;
                      }
                      uCode = seq[seq.length - 1];
                    } else
                      throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
                    if (uCode >= 65536) {
                      uCode -= 65536;
                      var uCodeLead = 55296 | uCode >> 10;
                      newBuf[j++] = uCodeLead & 255;
                      newBuf[j++] = uCodeLead >> 8;
                      uCode = 56320 | uCode & 1023;
                    }
                    newBuf[j++] = uCode & 255;
                    newBuf[j++] = uCode >> 8;
                    nodeIdx = 0;
                    seqStart = i2 + 1;
                  }
                  this.nodeIdx = nodeIdx;
                  this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
                  return newBuf.slice(0, j).toString("ucs2");
                };
                DBCSDecoder.prototype.end = function() {
                  var ret = "";
                  while (this.prevBytes.length > 0) {
                    ret += this.defaultCharUnicode;
                    var bytesArr = this.prevBytes.slice(1);
                    this.prevBytes = [];
                    this.nodeIdx = 0;
                    if (bytesArr.length > 0)
                      ret += this.write(bytesArr);
                  }
                  this.prevBytes = [];
                  this.nodeIdx = 0;
                  return ret;
                };
                function findIdx(table, val) {
                  if (table[0] > val)
                    return -1;
                  var l = 0, r = table.length;
                  while (l < r - 1) {
                    var mid = l + (r - l + 1 >> 1);
                    if (table[mid] <= val)
                      l = mid;
                    else
                      r = mid;
                  }
                  return l;
                }
              }
            ),
            /***/
            5990: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                module2.exports = {
                  // == Japanese/ShiftJIS ====================================================
                  // All japanese encodings are based on JIS X set of standards:
                  // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
                  // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
                  //              Has several variations in 1978, 1983, 1990 and 1997.
                  // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
                  // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
                  //              2 planes, first is superset of 0208, second - revised 0212.
                  //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
                  // Byte encodings are:
                  //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
                  //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
                  //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
                  //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
                  //               0x00-0x7F       - lower part of 0201
                  //               0x8E, 0xA1-0xDF - upper part of 0201
                  //               (0xA1-0xFE)x2   - 0208 plane (94x94).
                  //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
                  //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
                  //               Used as-is in ISO2022 family.
                  //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
                  //                0201-1976 Roman, 0208-1978, 0208-1983.
                  //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
                  //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
                  //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
                  //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
                  //
                  // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
                  //
                  // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
                  "shiftjis": {
                    type: "_dbcs",
                    table: function() {
                      return __webpack_require__2(7014);
                    },
                    encodeAdd: { "": 92, "": 126 },
                    encodeSkipVals: [{ from: 60736, to: 63808 }]
                  },
                  "csshiftjis": "shiftjis",
                  "mskanji": "shiftjis",
                  "sjis": "shiftjis",
                  "windows31j": "shiftjis",
                  "ms31j": "shiftjis",
                  "xsjis": "shiftjis",
                  "windows932": "shiftjis",
                  "ms932": "shiftjis",
                  "932": "shiftjis",
                  "cp932": "shiftjis",
                  "eucjp": {
                    type: "_dbcs",
                    table: function() {
                      return __webpack_require__2(5633);
                    },
                    encodeAdd: { "": 92, "": 126 }
                  },
                  // TODO: KDDI extension to Shift_JIS
                  // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
                  // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
                  // == Chinese/GBK ==========================================================
                  // http://en.wikipedia.org/wiki/GBK
                  // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
                  // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
                  "gb2312": "cp936",
                  "gb231280": "cp936",
                  "gb23121980": "cp936",
                  "csgb2312": "cp936",
                  "csiso58gb231280": "cp936",
                  "euccn": "cp936",
                  // Microsoft's CP936 is a subset and approximation of GBK.
                  "windows936": "cp936",
                  "ms936": "cp936",
                  "936": "cp936",
                  "cp936": {
                    type: "_dbcs",
                    table: function() {
                      return __webpack_require__2(3336);
                    }
                  },
                  // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
                  "gbk": {
                    type: "_dbcs",
                    table: function() {
                      return __webpack_require__2(3336).concat(__webpack_require__2(4346));
                    }
                  },
                  "xgbk": "gbk",
                  "isoir58": "gbk",
                  // GB18030 is an algorithmic extension of GBK.
                  // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
                  // http://icu-project.org/docs/papers/gb18030.html
                  // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
                  // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
                  "gb18030": {
                    type: "_dbcs",
                    table: function() {
                      return __webpack_require__2(3336).concat(__webpack_require__2(4346));
                    },
                    gb18030: function() {
                      return __webpack_require__2(6258);
                    },
                    encodeSkipVals: [128],
                    encodeAdd: { "": 41699 }
                  },
                  "chinese": "gb18030",
                  // == Korean ===============================================================
                  // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
                  "windows949": "cp949",
                  "ms949": "cp949",
                  "949": "cp949",
                  "cp949": {
                    type: "_dbcs",
                    table: function() {
                      return __webpack_require__2(7348);
                    }
                  },
                  "cseuckr": "cp949",
                  "csksc56011987": "cp949",
                  "euckr": "cp949",
                  "isoir149": "cp949",
                  "korean": "cp949",
                  "ksc56011987": "cp949",
                  "ksc56011989": "cp949",
                  "ksc5601": "cp949",
                  // == Big5/Taiwan/Hong Kong ================================================
                  // There are lots of tables for Big5 and cp950. Please see the following links for history:
                  // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
                  // Variations, in roughly number of defined chars:
                  //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
                  //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
                  //  * Big5-2003 (Taiwan standard) almost superset of cp950.
                  //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
                  //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
                  //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
                  //    Plus, it has 4 combining sequences.
                  //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
                  //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
                  //    Implementations are not consistent within browsers; sometimes labeled as just big5.
                  //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
                  //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
                  //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
                  //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
                  //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
                  // 
                  // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
                  // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
                  "windows950": "cp950",
                  "ms950": "cp950",
                  "950": "cp950",
                  "cp950": {
                    type: "_dbcs",
                    table: function() {
                      return __webpack_require__2(4284);
                    }
                  },
                  // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
                  "big5": "big5hkscs",
                  "big5hkscs": {
                    type: "_dbcs",
                    table: function() {
                      return __webpack_require__2(4284).concat(__webpack_require__2(3480));
                    },
                    encodeSkipVals: [
                      // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
                      // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
                      // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
                      36457,
                      36463,
                      36478,
                      36523,
                      36532,
                      36557,
                      36560,
                      36695,
                      36713,
                      36718,
                      36811,
                      36862,
                      36973,
                      36986,
                      37060,
                      37084,
                      37105,
                      37311,
                      37551,
                      37552,
                      37553,
                      37554,
                      37585,
                      37959,
                      38090,
                      38361,
                      38652,
                      39285,
                      39798,
                      39800,
                      39803,
                      39878,
                      39902,
                      39916,
                      39926,
                      40002,
                      40019,
                      40034,
                      40040,
                      40043,
                      40055,
                      40124,
                      40125,
                      40144,
                      40279,
                      40282,
                      40388,
                      40431,
                      40443,
                      40617,
                      40687,
                      40701,
                      40800,
                      40907,
                      41079,
                      41180,
                      41183,
                      36812,
                      37576,
                      38468,
                      38637,
                      // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
                      41636,
                      41637,
                      41639,
                      41638,
                      41676,
                      41678
                    ]
                  },
                  "cnbig5": "big5hkscs",
                  "csbig5": "big5hkscs",
                  "xxbig5": "big5hkscs"
                };
              }
            ),
            /***/
            6934: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var modules = [
                  __webpack_require__2(1025),
                  __webpack_require__2(7688),
                  __webpack_require__2(1279),
                  __webpack_require__2(758),
                  __webpack_require__2(9068),
                  __webpack_require__2(3769),
                  __webpack_require__2(7018),
                  __webpack_require__2(688),
                  __webpack_require__2(5990)
                ];
                for (var i = 0; i < modules.length; i++) {
                  var module2 = modules[i];
                  for (var enc in module2)
                    if (Object.prototype.hasOwnProperty.call(module2, enc))
                      exports2[enc] = module2[enc];
                }
              }
            ),
            /***/
            1025: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var Buffer = __webpack_require__2(7103).Buffer;
                module2.exports = {
                  // Encodings
                  utf8: { type: "_internal", bomAware: true },
                  cesu8: { type: "_internal", bomAware: true },
                  unicode11utf8: "utf8",
                  ucs2: { type: "_internal", bomAware: true },
                  utf16le: "ucs2",
                  binary: { type: "_internal" },
                  base64: { type: "_internal" },
                  hex: { type: "_internal" },
                  // Codec.
                  _internal: InternalCodec
                };
                function InternalCodec(codecOptions, iconv) {
                  this.enc = codecOptions.encodingName;
                  this.bomAware = codecOptions.bomAware;
                  if (this.enc === "base64")
                    this.encoder = InternalEncoderBase64;
                  else if (this.enc === "cesu8") {
                    this.enc = "utf8";
                    this.encoder = InternalEncoderCesu8;
                    if (Buffer.from("eda0bdedb2a9", "hex").toString() !== "") {
                      this.decoder = InternalDecoderCesu8;
                      this.defaultCharUnicode = iconv.defaultCharUnicode;
                    }
                  }
                }
                InternalCodec.prototype.encoder = InternalEncoder;
                InternalCodec.prototype.decoder = InternalDecoder;
                var StringDecoder = __webpack_require__2(2553).s;
                if (!StringDecoder.prototype.end)
                  StringDecoder.prototype.end = function() {
                  };
                function InternalDecoder(options, codec) {
                  this.decoder = new StringDecoder(codec.enc);
                }
                InternalDecoder.prototype.write = function(buf) {
                  if (!Buffer.isBuffer(buf)) {
                    buf = Buffer.from(buf);
                  }
                  return this.decoder.write(buf);
                };
                InternalDecoder.prototype.end = function() {
                  return this.decoder.end();
                };
                function InternalEncoder(options, codec) {
                  this.enc = codec.enc;
                }
                InternalEncoder.prototype.write = function(str) {
                  return Buffer.from(str, this.enc);
                };
                InternalEncoder.prototype.end = function() {
                };
                function InternalEncoderBase64(options, codec) {
                  this.prevStr = "";
                }
                InternalEncoderBase64.prototype.write = function(str) {
                  str = this.prevStr + str;
                  var completeQuads = str.length - str.length % 4;
                  this.prevStr = str.slice(completeQuads);
                  str = str.slice(0, completeQuads);
                  return Buffer.from(str, "base64");
                };
                InternalEncoderBase64.prototype.end = function() {
                  return Buffer.from(this.prevStr, "base64");
                };
                function InternalEncoderCesu8(options, codec) {
                }
                InternalEncoderCesu8.prototype.write = function(str) {
                  var buf = Buffer.alloc(str.length * 3), bufIdx = 0;
                  for (var i = 0; i < str.length; i++) {
                    var charCode = str.charCodeAt(i);
                    if (charCode < 128)
                      buf[bufIdx++] = charCode;
                    else if (charCode < 2048) {
                      buf[bufIdx++] = 192 + (charCode >>> 6);
                      buf[bufIdx++] = 128 + (charCode & 63);
                    } else {
                      buf[bufIdx++] = 224 + (charCode >>> 12);
                      buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
                      buf[bufIdx++] = 128 + (charCode & 63);
                    }
                  }
                  return buf.slice(0, bufIdx);
                };
                InternalEncoderCesu8.prototype.end = function() {
                };
                function InternalDecoderCesu8(options, codec) {
                  this.acc = 0;
                  this.contBytes = 0;
                  this.accBytes = 0;
                  this.defaultCharUnicode = codec.defaultCharUnicode;
                }
                InternalDecoderCesu8.prototype.write = function(buf) {
                  var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
                  for (var i = 0; i < buf.length; i++) {
                    var curByte = buf[i];
                    if ((curByte & 192) !== 128) {
                      if (contBytes > 0) {
                        res += this.defaultCharUnicode;
                        contBytes = 0;
                      }
                      if (curByte < 128) {
                        res += String.fromCharCode(curByte);
                      } else if (curByte < 224) {
                        acc = curByte & 31;
                        contBytes = 1;
                        accBytes = 1;
                      } else if (curByte < 240) {
                        acc = curByte & 15;
                        contBytes = 2;
                        accBytes = 1;
                      } else {
                        res += this.defaultCharUnicode;
                      }
                    } else {
                      if (contBytes > 0) {
                        acc = acc << 6 | curByte & 63;
                        contBytes--;
                        accBytes++;
                        if (contBytes === 0) {
                          if (accBytes === 2 && acc < 128 && acc > 0)
                            res += this.defaultCharUnicode;
                          else if (accBytes === 3 && acc < 2048)
                            res += this.defaultCharUnicode;
                          else
                            res += String.fromCharCode(acc);
                        }
                      } else {
                        res += this.defaultCharUnicode;
                      }
                    }
                  }
                  this.acc = acc;
                  this.contBytes = contBytes;
                  this.accBytes = accBytes;
                  return res;
                };
                InternalDecoderCesu8.prototype.end = function() {
                  var res = 0;
                  if (this.contBytes > 0)
                    res += this.defaultCharUnicode;
                  return res;
                };
              }
            ),
            /***/
            9068: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var Buffer = __webpack_require__2(7103).Buffer;
                exports2._sbcs = SBCSCodec;
                function SBCSCodec(codecOptions, iconv) {
                  if (!codecOptions)
                    throw new Error("SBCS codec is called without the data.");
                  if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
                    throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
                  if (codecOptions.chars.length === 128) {
                    var asciiString = "";
                    for (var i = 0; i < 128; i++)
                      asciiString += String.fromCharCode(i);
                    codecOptions.chars = asciiString + codecOptions.chars;
                  }
                  this.decodeBuf = Buffer.from(codecOptions.chars, "ucs2");
                  var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
                  for (var i = 0; i < codecOptions.chars.length; i++)
                    encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
                  this.encodeBuf = encodeBuf;
                }
                SBCSCodec.prototype.encoder = SBCSEncoder;
                SBCSCodec.prototype.decoder = SBCSDecoder;
                function SBCSEncoder(options, codec) {
                  this.encodeBuf = codec.encodeBuf;
                }
                SBCSEncoder.prototype.write = function(str) {
                  var buf = Buffer.alloc(str.length);
                  for (var i = 0; i < str.length; i++)
                    buf[i] = this.encodeBuf[str.charCodeAt(i)];
                  return buf;
                };
                SBCSEncoder.prototype.end = function() {
                };
                function SBCSDecoder(options, codec) {
                  this.decodeBuf = codec.decodeBuf;
                }
                SBCSDecoder.prototype.write = function(buf) {
                  var decodeBuf = this.decodeBuf;
                  var newBuf = Buffer.alloc(buf.length * 2);
                  var idx1 = 0, idx2 = 0;
                  for (var i = 0; i < buf.length; i++) {
                    idx1 = buf[i] * 2;
                    idx2 = i * 2;
                    newBuf[idx2] = decodeBuf[idx1];
                    newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
                  }
                  return newBuf.toString("ucs2");
                };
                SBCSDecoder.prototype.end = function() {
                };
              }
            ),
            /***/
            7018: (
              /***/
              function(module2) {
                "use strict";
                module2.exports = {
                  "437": "cp437",
                  "737": "cp737",
                  "775": "cp775",
                  "850": "cp850",
                  "852": "cp852",
                  "855": "cp855",
                  "856": "cp856",
                  "857": "cp857",
                  "858": "cp858",
                  "860": "cp860",
                  "861": "cp861",
                  "862": "cp862",
                  "863": "cp863",
                  "864": "cp864",
                  "865": "cp865",
                  "866": "cp866",
                  "869": "cp869",
                  "874": "windows874",
                  "922": "cp922",
                  "1046": "cp1046",
                  "1124": "cp1124",
                  "1125": "cp1125",
                  "1129": "cp1129",
                  "1133": "cp1133",
                  "1161": "cp1161",
                  "1162": "cp1162",
                  "1163": "cp1163",
                  "1250": "windows1250",
                  "1251": "windows1251",
                  "1252": "windows1252",
                  "1253": "windows1253",
                  "1254": "windows1254",
                  "1255": "windows1255",
                  "1256": "windows1256",
                  "1257": "windows1257",
                  "1258": "windows1258",
                  "28591": "iso88591",
                  "28592": "iso88592",
                  "28593": "iso88593",
                  "28594": "iso88594",
                  "28595": "iso88595",
                  "28596": "iso88596",
                  "28597": "iso88597",
                  "28598": "iso88598",
                  "28599": "iso88599",
                  "28600": "iso885910",
                  "28601": "iso885911",
                  "28603": "iso885913",
                  "28604": "iso885914",
                  "28605": "iso885915",
                  "28606": "iso885916",
                  "windows874": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "win874": "windows874",
                  "cp874": "windows874",
                  "windows1250": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "win1250": "windows1250",
                  "cp1250": "windows1250",
                  "windows1251": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "win1251": "windows1251",
                  "cp1251": "windows1251",
                  "windows1252": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "win1252": "windows1252",
                  "cp1252": "windows1252",
                  "windows1253": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "win1253": "windows1253",
                  "cp1253": "windows1253",
                  "windows1254": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "win1254": "windows1254",
                  "cp1254": "windows1254",
                  "windows1255": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "win1255": "windows1255",
                  "cp1255": "windows1255",
                  "windows1256": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "win1256": "windows1256",
                  "cp1256": "windows1256",
                  "windows1257": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "win1257": "windows1257",
                  "cp1257": "windows1257",
                  "windows1258": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "win1258": "windows1258",
                  "cp1258": "windows1258",
                  "iso88591": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "cp28591": "iso88591",
                  "iso88592": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "cp28592": "iso88592",
                  "iso88593": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "cp28593": "iso88593",
                  "iso88594": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "cp28594": "iso88594",
                  "iso88595": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "cp28595": "iso88595",
                  "iso88596": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "cp28596": "iso88596",
                  "iso88597": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "cp28597": "iso88597",
                  "iso88598": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "cp28598": "iso88598",
                  "iso88599": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "cp28599": "iso88599",
                  "iso885910": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "cp28600": "iso885910",
                  "iso885911": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "cp28601": "iso885911",
                  "iso885913": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "cp28603": "iso885913",
                  "iso885914": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "cp28604": "iso885914",
                  "iso885915": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "cp28605": "iso885915",
                  "iso885916": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "cp28606": "iso885916",
                  "cp437": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm437": "cp437",
                  "csibm437": "cp437",
                  "cp737": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm737": "cp737",
                  "csibm737": "cp737",
                  "cp775": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm775": "cp775",
                  "csibm775": "cp775",
                  "cp850": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm850": "cp850",
                  "csibm850": "cp850",
                  "cp852": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm852": "cp852",
                  "csibm852": "cp852",
                  "cp855": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm855": "cp855",
                  "csibm855": "cp855",
                  "cp856": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm856": "cp856",
                  "csibm856": "cp856",
                  "cp857": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm857": "cp857",
                  "csibm857": "cp857",
                  "cp858": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm858": "cp858",
                  "csibm858": "cp858",
                  "cp860": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm860": "cp860",
                  "csibm860": "cp860",
                  "cp861": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm861": "cp861",
                  "csibm861": "cp861",
                  "cp862": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm862": "cp862",
                  "csibm862": "cp862",
                  "cp863": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm863": "cp863",
                  "csibm863": "cp863",
                  "cp864": {
                    "type": "_sbcs",
                    "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
                  },
                  "ibm864": "cp864",
                  "csibm864": "cp864",
                  "cp865": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm865": "cp865",
                  "csibm865": "cp865",
                  "cp866": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm866": "cp866",
                  "csibm866": "cp866",
                  "cp869": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm869": "cp869",
                  "csibm869": "cp869",
                  "cp922": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm922": "cp922",
                  "csibm922": "cp922",
                  "cp1046": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm1046": "cp1046",
                  "csibm1046": "cp1046",
                  "cp1124": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm1124": "cp1124",
                  "csibm1124": "cp1124",
                  "cp1125": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm1125": "cp1125",
                  "csibm1125": "cp1125",
                  "cp1129": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm1129": "cp1129",
                  "csibm1129": "cp1129",
                  "cp1133": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm1133": "cp1133",
                  "csibm1133": "cp1133",
                  "cp1161": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm1161": "cp1161",
                  "csibm1161": "cp1161",
                  "cp1162": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm1162": "cp1162",
                  "csibm1162": "cp1162",
                  "cp1163": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ibm1163": "cp1163",
                  "csibm1163": "cp1163",
                  "maccroatian": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "maccyrillic": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "macgreek": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "maciceland": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "macroman": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "macromania": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "macthai": {
                    "type": "_sbcs",
                    "chars": "\uFEFF"
                  },
                  "macturkish": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "macukraine": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "koi8r": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "koi8u": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "koi8ru": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "koi8t": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "armscii8": {
                    "type": "_sbcs",
                    "chars": ")(.,-"
                  },
                  "rk1048": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "tcvn": {
                    "type": "_sbcs",
                    "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
                  },
                  "georgianacademy": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "georgianps": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "pt154": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "viscii": {
                    "type": "_sbcs",
                    "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
                  },
                  "iso646cn": {
                    "type": "_sbcs",
                    "chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
                  },
                  "iso646jp": {
                    "type": "_sbcs",
                    "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
                  },
                  "hproman8": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "macintosh": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "ascii": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "tis620": {
                    "type": "_sbcs",
                    "chars": ""
                  }
                };
              }
            ),
            /***/
            3769: (
              /***/
              function(module2) {
                "use strict";
                module2.exports = {
                  // Not supported by iconv, not sure why.
                  "10029": "maccenteuro",
                  "maccenteuro": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "808": "cp808",
                  "ibm808": "cp808",
                  "cp808": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "mik": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  "cp720": {
                    "type": "_sbcs",
                    "chars": ""
                  },
                  // Aliases of generated encodings.
                  "ascii8bit": "ascii",
                  "usascii": "ascii",
                  "ansix34": "ascii",
                  "ansix341968": "ascii",
                  "ansix341986": "ascii",
                  "csascii": "ascii",
                  "cp367": "ascii",
                  "ibm367": "ascii",
                  "isoir6": "ascii",
                  "iso646us": "ascii",
                  "iso646irv": "ascii",
                  "us": "ascii",
                  "latin1": "iso88591",
                  "latin2": "iso88592",
                  "latin3": "iso88593",
                  "latin4": "iso88594",
                  "latin5": "iso88599",
                  "latin6": "iso885910",
                  "latin7": "iso885913",
                  "latin8": "iso885914",
                  "latin9": "iso885915",
                  "latin10": "iso885916",
                  "csisolatin1": "iso88591",
                  "csisolatin2": "iso88592",
                  "csisolatin3": "iso88593",
                  "csisolatin4": "iso88594",
                  "csisolatincyrillic": "iso88595",
                  "csisolatinarabic": "iso88596",
                  "csisolatingreek": "iso88597",
                  "csisolatinhebrew": "iso88598",
                  "csisolatin5": "iso88599",
                  "csisolatin6": "iso885910",
                  "l1": "iso88591",
                  "l2": "iso88592",
                  "l3": "iso88593",
                  "l4": "iso88594",
                  "l5": "iso88599",
                  "l6": "iso885910",
                  "l7": "iso885913",
                  "l8": "iso885914",
                  "l9": "iso885915",
                  "l10": "iso885916",
                  "isoir14": "iso646jp",
                  "isoir57": "iso646cn",
                  "isoir100": "iso88591",
                  "isoir101": "iso88592",
                  "isoir109": "iso88593",
                  "isoir110": "iso88594",
                  "isoir144": "iso88595",
                  "isoir127": "iso88596",
                  "isoir126": "iso88597",
                  "isoir138": "iso88598",
                  "isoir148": "iso88599",
                  "isoir157": "iso885910",
                  "isoir166": "tis620",
                  "isoir179": "iso885913",
                  "isoir199": "iso885914",
                  "isoir203": "iso885915",
                  "isoir226": "iso885916",
                  "cp819": "iso88591",
                  "ibm819": "iso88591",
                  "cyrillic": "iso88595",
                  "arabic": "iso88596",
                  "arabic8": "iso88596",
                  "ecma114": "iso88596",
                  "asmo708": "iso88596",
                  "greek": "iso88597",
                  "greek8": "iso88597",
                  "ecma118": "iso88597",
                  "elot928": "iso88597",
                  "hebrew": "iso88598",
                  "hebrew8": "iso88598",
                  "turkish": "iso88599",
                  "turkish8": "iso88599",
                  "thai": "iso885911",
                  "thai8": "iso885911",
                  "celtic": "iso885914",
                  "celtic8": "iso885914",
                  "isoceltic": "iso885914",
                  "tis6200": "tis620",
                  "tis62025291": "tis620",
                  "tis62025330": "tis620",
                  "10000": "macroman",
                  "10006": "macgreek",
                  "10007": "maccyrillic",
                  "10079": "maciceland",
                  "10081": "macturkish",
                  "cspc8codepage437": "cp437",
                  "cspc775baltic": "cp775",
                  "cspc850multilingual": "cp850",
                  "cspcp852": "cp852",
                  "cspc862latinhebrew": "cp862",
                  "cpgr": "cp869",
                  "msee": "cp1250",
                  "mscyrl": "cp1251",
                  "msansi": "cp1252",
                  "msgreek": "cp1253",
                  "msturk": "cp1254",
                  "mshebr": "cp1255",
                  "msarab": "cp1256",
                  "winbaltrim": "cp1257",
                  "cp20866": "koi8r",
                  "20866": "koi8r",
                  "ibm878": "koi8r",
                  "cskoi8r": "koi8r",
                  "cp21866": "koi8u",
                  "21866": "koi8u",
                  "ibm1168": "koi8u",
                  "strk10482002": "rk1048",
                  "tcvn5712": "tcvn",
                  "tcvn57121": "tcvn",
                  "gb198880": "iso646cn",
                  "cn": "iso646cn",
                  "csiso14jisc6220ro": "iso646jp",
                  "jisc62201969ro": "iso646jp",
                  "jp": "iso646jp",
                  "cshproman8": "hproman8",
                  "r8": "hproman8",
                  "roman8": "hproman8",
                  "xroman8": "hproman8",
                  "ibm1051": "hproman8",
                  "mac": "macintosh",
                  "csmacintosh": "macintosh"
                };
              }
            ),
            /***/
            1279: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var Buffer = __webpack_require__2(7103).Buffer;
                exports2.utf16be = Utf16BECodec;
                function Utf16BECodec() {
                }
                Utf16BECodec.prototype.encoder = Utf16BEEncoder;
                Utf16BECodec.prototype.decoder = Utf16BEDecoder;
                Utf16BECodec.prototype.bomAware = true;
                function Utf16BEEncoder() {
                }
                Utf16BEEncoder.prototype.write = function(str) {
                  var buf = Buffer.from(str, "ucs2");
                  for (var i = 0; i < buf.length; i += 2) {
                    var tmp = buf[i];
                    buf[i] = buf[i + 1];
                    buf[i + 1] = tmp;
                  }
                  return buf;
                };
                Utf16BEEncoder.prototype.end = function() {
                };
                function Utf16BEDecoder() {
                  this.overflowByte = -1;
                }
                Utf16BEDecoder.prototype.write = function(buf) {
                  if (buf.length == 0)
                    return "";
                  var buf2 = Buffer.alloc(buf.length + 1), i = 0, j = 0;
                  if (this.overflowByte !== -1) {
                    buf2[0] = buf[0];
                    buf2[1] = this.overflowByte;
                    i = 1;
                    j = 2;
                  }
                  for (; i < buf.length - 1; i += 2, j += 2) {
                    buf2[j] = buf[i + 1];
                    buf2[j + 1] = buf[i];
                  }
                  this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
                  return buf2.slice(0, j).toString("ucs2");
                };
                Utf16BEDecoder.prototype.end = function() {
                  this.overflowByte = -1;
                };
                exports2.utf16 = Utf16Codec;
                function Utf16Codec(codecOptions, iconv) {
                  this.iconv = iconv;
                }
                Utf16Codec.prototype.encoder = Utf16Encoder;
                Utf16Codec.prototype.decoder = Utf16Decoder;
                function Utf16Encoder(options, codec) {
                  options = options || {};
                  if (options.addBOM === void 0)
                    options.addBOM = true;
                  this.encoder = codec.iconv.getEncoder("utf-16le", options);
                }
                Utf16Encoder.prototype.write = function(str) {
                  return this.encoder.write(str);
                };
                Utf16Encoder.prototype.end = function() {
                  return this.encoder.end();
                };
                function Utf16Decoder(options, codec) {
                  this.decoder = null;
                  this.initialBufs = [];
                  this.initialBufsLen = 0;
                  this.options = options || {};
                  this.iconv = codec.iconv;
                }
                Utf16Decoder.prototype.write = function(buf) {
                  if (!this.decoder) {
                    this.initialBufs.push(buf);
                    this.initialBufsLen += buf.length;
                    if (this.initialBufsLen < 16)
                      return "";
                    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
                    this.decoder = this.iconv.getDecoder(encoding, this.options);
                    var resStr = "";
                    for (var i = 0; i < this.initialBufs.length; i++)
                      resStr += this.decoder.write(this.initialBufs[i]);
                    this.initialBufs.length = this.initialBufsLen = 0;
                    return resStr;
                  }
                  return this.decoder.write(buf);
                };
                Utf16Decoder.prototype.end = function() {
                  if (!this.decoder) {
                    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
                    this.decoder = this.iconv.getDecoder(encoding, this.options);
                    var resStr = "";
                    for (var i = 0; i < this.initialBufs.length; i++)
                      resStr += this.decoder.write(this.initialBufs[i]);
                    var trail = this.decoder.end();
                    if (trail)
                      resStr += trail;
                    this.initialBufs.length = this.initialBufsLen = 0;
                    return resStr;
                  }
                  return this.decoder.end();
                };
                function detectEncoding(bufs, defaultEncoding) {
                  var b = [];
                  var charsProcessed = 0;
                  var asciiCharsLE = 0, asciiCharsBE = 0;
                  outer_loop:
                    for (var i = 0; i < bufs.length; i++) {
                      var buf = bufs[i];
                      for (var j = 0; j < buf.length; j++) {
                        b.push(buf[j]);
                        if (b.length === 2) {
                          if (charsProcessed === 0) {
                            if (b[0] === 255 && b[1] === 254)
                              return "utf-16le";
                            if (b[0] === 254 && b[1] === 255)
                              return "utf-16be";
                          }
                          if (b[0] === 0 && b[1] !== 0)
                            asciiCharsBE++;
                          if (b[0] !== 0 && b[1] === 0)
                            asciiCharsLE++;
                          b.length = 0;
                          charsProcessed++;
                          if (charsProcessed >= 100) {
                            break outer_loop;
                          }
                        }
                      }
                    }
                  if (asciiCharsBE > asciiCharsLE)
                    return "utf-16be";
                  if (asciiCharsBE < asciiCharsLE)
                    return "utf-16le";
                  return defaultEncoding || "utf-16le";
                }
              }
            ),
            /***/
            7688: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var Buffer = __webpack_require__2(7103).Buffer;
                exports2._utf32 = Utf32Codec;
                function Utf32Codec(codecOptions, iconv) {
                  this.iconv = iconv;
                  this.bomAware = true;
                  this.isLE = codecOptions.isLE;
                }
                exports2.utf32le = { type: "_utf32", isLE: true };
                exports2.utf32be = { type: "_utf32", isLE: false };
                exports2.ucs4le = "utf32le";
                exports2.ucs4be = "utf32be";
                Utf32Codec.prototype.encoder = Utf32Encoder;
                Utf32Codec.prototype.decoder = Utf32Decoder;
                function Utf32Encoder(options, codec) {
                  this.isLE = codec.isLE;
                  this.highSurrogate = 0;
                }
                Utf32Encoder.prototype.write = function(str) {
                  var src = Buffer.from(str, "ucs2");
                  var dst = Buffer.alloc(src.length * 2);
                  var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
                  var offset = 0;
                  for (var i = 0; i < src.length; i += 2) {
                    var code = src.readUInt16LE(i);
                    var isHighSurrogate = 55296 <= code && code < 56320;
                    var isLowSurrogate = 56320 <= code && code < 57344;
                    if (this.highSurrogate) {
                      if (isHighSurrogate || !isLowSurrogate) {
                        write32.call(dst, this.highSurrogate, offset);
                        offset += 4;
                      } else {
                        var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
                        write32.call(dst, codepoint, offset);
                        offset += 4;
                        this.highSurrogate = 0;
                        continue;
                      }
                    }
                    if (isHighSurrogate)
                      this.highSurrogate = code;
                    else {
                      write32.call(dst, code, offset);
                      offset += 4;
                      this.highSurrogate = 0;
                    }
                  }
                  if (offset < dst.length)
                    dst = dst.slice(0, offset);
                  return dst;
                };
                Utf32Encoder.prototype.end = function() {
                  if (!this.highSurrogate)
                    return;
                  var buf = Buffer.alloc(4);
                  if (this.isLE)
                    buf.writeUInt32LE(this.highSurrogate, 0);
                  else
                    buf.writeUInt32BE(this.highSurrogate, 0);
                  this.highSurrogate = 0;
                  return buf;
                };
                function Utf32Decoder(options, codec) {
                  this.isLE = codec.isLE;
                  this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
                  this.overflow = [];
                }
                Utf32Decoder.prototype.write = function(src) {
                  if (src.length === 0)
                    return "";
                  var i = 0;
                  var codepoint = 0;
                  var dst = Buffer.alloc(src.length + 4);
                  var offset = 0;
                  var isLE = this.isLE;
                  var overflow = this.overflow;
                  var badChar = this.badChar;
                  if (overflow.length > 0) {
                    for (; i < src.length && overflow.length < 4; i++)
                      overflow.push(src[i]);
                    if (overflow.length === 4) {
                      if (isLE) {
                        codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
                      } else {
                        codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
                      }
                      overflow.length = 0;
                      offset = _writeCodepoint(dst, offset, codepoint, badChar);
                    }
                  }
                  for (; i < src.length - 3; i += 4) {
                    if (isLE) {
                      codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;
                    } else {
                      codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;
                    }
                    offset = _writeCodepoint(dst, offset, codepoint, badChar);
                  }
                  for (; i < src.length; i++) {
                    overflow.push(src[i]);
                  }
                  return dst.slice(0, offset).toString("ucs2");
                };
                function _writeCodepoint(dst, offset, codepoint, badChar) {
                  if (codepoint < 0 || codepoint > 1114111) {
                    codepoint = badChar;
                  }
                  if (codepoint >= 65536) {
                    codepoint -= 65536;
                    var high = 55296 | codepoint >> 10;
                    dst[offset++] = high & 255;
                    dst[offset++] = high >> 8;
                    var codepoint = 56320 | codepoint & 1023;
                  }
                  dst[offset++] = codepoint & 255;
                  dst[offset++] = codepoint >> 8;
                  return offset;
                }
                ;
                Utf32Decoder.prototype.end = function() {
                  this.overflow.length = 0;
                };
                exports2.utf32 = Utf32AutoCodec;
                exports2.ucs4 = "utf32";
                function Utf32AutoCodec(options, iconv) {
                  this.iconv = iconv;
                }
                Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
                Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
                function Utf32AutoEncoder(options, codec) {
                  options = options || {};
                  if (options.addBOM === void 0)
                    options.addBOM = true;
                  this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
                }
                Utf32AutoEncoder.prototype.write = function(str) {
                  return this.encoder.write(str);
                };
                Utf32AutoEncoder.prototype.end = function() {
                  return this.encoder.end();
                };
                function Utf32AutoDecoder(options, codec) {
                  this.decoder = null;
                  this.initialBufs = [];
                  this.initialBufsLen = 0;
                  this.options = options || {};
                  this.iconv = codec.iconv;
                }
                Utf32AutoDecoder.prototype.write = function(buf) {
                  if (!this.decoder) {
                    this.initialBufs.push(buf);
                    this.initialBufsLen += buf.length;
                    if (this.initialBufsLen < 32)
                      return "";
                    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
                    this.decoder = this.iconv.getDecoder(encoding, this.options);
                    var resStr = "";
                    for (var i = 0; i < this.initialBufs.length; i++)
                      resStr += this.decoder.write(this.initialBufs[i]);
                    this.initialBufs.length = this.initialBufsLen = 0;
                    return resStr;
                  }
                  return this.decoder.write(buf);
                };
                Utf32AutoDecoder.prototype.end = function() {
                  if (!this.decoder) {
                    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
                    this.decoder = this.iconv.getDecoder(encoding, this.options);
                    var resStr = "";
                    for (var i = 0; i < this.initialBufs.length; i++)
                      resStr += this.decoder.write(this.initialBufs[i]);
                    var trail = this.decoder.end();
                    if (trail)
                      resStr += trail;
                    this.initialBufs.length = this.initialBufsLen = 0;
                    return resStr;
                  }
                  return this.decoder.end();
                };
                function detectEncoding(bufs, defaultEncoding) {
                  var b = [];
                  var charsProcessed = 0;
                  var invalidLE = 0, invalidBE = 0;
                  var bmpCharsLE = 0, bmpCharsBE = 0;
                  outer_loop:
                    for (var i = 0; i < bufs.length; i++) {
                      var buf = bufs[i];
                      for (var j = 0; j < buf.length; j++) {
                        b.push(buf[j]);
                        if (b.length === 4) {
                          if (charsProcessed === 0) {
                            if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) {
                              return "utf-32le";
                            }
                            if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) {
                              return "utf-32be";
                            }
                          }
                          if (b[0] !== 0 || b[1] > 16)
                            invalidBE++;
                          if (b[3] !== 0 || b[2] > 16)
                            invalidLE++;
                          if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0))
                            bmpCharsBE++;
                          if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0)
                            bmpCharsLE++;
                          b.length = 0;
                          charsProcessed++;
                          if (charsProcessed >= 100) {
                            break outer_loop;
                          }
                        }
                      }
                    }
                  if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE)
                    return "utf-32be";
                  if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE)
                    return "utf-32le";
                  return defaultEncoding || "utf-32le";
                }
              }
            ),
            /***/
            758: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var Buffer = __webpack_require__2(7103).Buffer;
                exports2.utf7 = Utf7Codec;
                exports2.unicode11utf7 = "utf7";
                function Utf7Codec(codecOptions, iconv) {
                  this.iconv = iconv;
                }
                ;
                Utf7Codec.prototype.encoder = Utf7Encoder;
                Utf7Codec.prototype.decoder = Utf7Decoder;
                Utf7Codec.prototype.bomAware = true;
                var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
                function Utf7Encoder(options, codec) {
                  this.iconv = codec.iconv;
                }
                Utf7Encoder.prototype.write = function(str) {
                  return Buffer.from(str.replace(nonDirectChars, function(chunk) {
                    return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
                  }.bind(this)));
                };
                Utf7Encoder.prototype.end = function() {
                };
                function Utf7Decoder(options, codec) {
                  this.iconv = codec.iconv;
                  this.inBase64 = false;
                  this.base64Accum = "";
                }
                var base64Regex = /[A-Za-z0-9\/+]/;
                var base64Chars = [];
                for (var i = 0; i < 256; i++)
                  base64Chars[i] = base64Regex.test(String.fromCharCode(i));
                var plusChar = "+".charCodeAt(0), minusChar = "-".charCodeAt(0), andChar = "&".charCodeAt(0);
                Utf7Decoder.prototype.write = function(buf) {
                  var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
                  for (var i2 = 0; i2 < buf.length; i2++) {
                    if (!inBase64) {
                      if (buf[i2] == plusChar) {
                        res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
                        lastI = i2 + 1;
                        inBase64 = true;
                      }
                    } else {
                      if (!base64Chars[buf[i2]]) {
                        if (i2 == lastI && buf[i2] == minusChar) {
                          res += "+";
                        } else {
                          var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii");
                          res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
                        }
                        if (buf[i2] != minusChar)
                          i2--;
                        lastI = i2 + 1;
                        inBase64 = false;
                        base64Accum = "";
                      }
                    }
                  }
                  if (!inBase64) {
                    res += this.iconv.decode(buf.slice(lastI), "ascii");
                  } else {
                    var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
                    var canBeDecoded = b64str.length - b64str.length % 8;
                    base64Accum = b64str.slice(canBeDecoded);
                    b64str = b64str.slice(0, canBeDecoded);
                    res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
                  }
                  this.inBase64 = inBase64;
                  this.base64Accum = base64Accum;
                  return res;
                };
                Utf7Decoder.prototype.end = function() {
                  var res = "";
                  if (this.inBase64 && this.base64Accum.length > 0)
                    res = this.iconv.decode(Buffer.from(this.base64Accum, "base64"), "utf16-be");
                  this.inBase64 = false;
                  this.base64Accum = "";
                  return res;
                };
                exports2.utf7imap = Utf7IMAPCodec;
                function Utf7IMAPCodec(codecOptions, iconv) {
                  this.iconv = iconv;
                }
                ;
                Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
                Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
                Utf7IMAPCodec.prototype.bomAware = true;
                function Utf7IMAPEncoder(options, codec) {
                  this.iconv = codec.iconv;
                  this.inBase64 = false;
                  this.base64Accum = Buffer.alloc(6);
                  this.base64AccumIdx = 0;
                }
                Utf7IMAPEncoder.prototype.write = function(str) {
                  var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer.alloc(str.length * 5 + 10), bufIdx = 0;
                  for (var i2 = 0; i2 < str.length; i2++) {
                    var uChar = str.charCodeAt(i2);
                    if (32 <= uChar && uChar <= 126) {
                      if (inBase64) {
                        if (base64AccumIdx > 0) {
                          bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
                          base64AccumIdx = 0;
                        }
                        buf[bufIdx++] = minusChar;
                        inBase64 = false;
                      }
                      if (!inBase64) {
                        buf[bufIdx++] = uChar;
                        if (uChar === andChar)
                          buf[bufIdx++] = minusChar;
                      }
                    } else {
                      if (!inBase64) {
                        buf[bufIdx++] = andChar;
                        inBase64 = true;
                      }
                      if (inBase64) {
                        base64Accum[base64AccumIdx++] = uChar >> 8;
                        base64Accum[base64AccumIdx++] = uChar & 255;
                        if (base64AccumIdx == base64Accum.length) {
                          bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
                          base64AccumIdx = 0;
                        }
                      }
                    }
                  }
                  this.inBase64 = inBase64;
                  this.base64AccumIdx = base64AccumIdx;
                  return buf.slice(0, bufIdx);
                };
                Utf7IMAPEncoder.prototype.end = function() {
                  var buf = Buffer.alloc(10), bufIdx = 0;
                  if (this.inBase64) {
                    if (this.base64AccumIdx > 0) {
                      bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
                      this.base64AccumIdx = 0;
                    }
                    buf[bufIdx++] = minusChar;
                    this.inBase64 = false;
                  }
                  return buf.slice(0, bufIdx);
                };
                function Utf7IMAPDecoder(options, codec) {
                  this.iconv = codec.iconv;
                  this.inBase64 = false;
                  this.base64Accum = "";
                }
                var base64IMAPChars = base64Chars.slice();
                base64IMAPChars[",".charCodeAt(0)] = true;
                Utf7IMAPDecoder.prototype.write = function(buf) {
                  var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
                  for (var i2 = 0; i2 < buf.length; i2++) {
                    if (!inBase64) {
                      if (buf[i2] == andChar) {
                        res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
                        lastI = i2 + 1;
                        inBase64 = true;
                      }
                    } else {
                      if (!base64IMAPChars[buf[i2]]) {
                        if (i2 == lastI && buf[i2] == minusChar) {
                          res += "&";
                        } else {
                          var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii").replace(/,/g, "/");
                          res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
                        }
                        if (buf[i2] != minusChar)
                          i2--;
                        lastI = i2 + 1;
                        inBase64 = false;
                        base64Accum = "";
                      }
                    }
                  }
                  if (!inBase64) {
                    res += this.iconv.decode(buf.slice(lastI), "ascii");
                  } else {
                    var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
                    var canBeDecoded = b64str.length - b64str.length % 8;
                    base64Accum = b64str.slice(canBeDecoded);
                    b64str = b64str.slice(0, canBeDecoded);
                    res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
                  }
                  this.inBase64 = inBase64;
                  this.base64Accum = base64Accum;
                  return res;
                };
                Utf7IMAPDecoder.prototype.end = function() {
                  var res = "";
                  if (this.inBase64 && this.base64Accum.length > 0)
                    res = this.iconv.decode(Buffer.from(this.base64Accum, "base64"), "utf16-be");
                  this.inBase64 = false;
                  this.base64Accum = "";
                  return res;
                };
              }
            ),
            /***/
            5395: (
              /***/
              function(__unused_webpack_module, exports2) {
                "use strict";
                var BOMChar = "\uFEFF";
                exports2.PrependBOM = PrependBOMWrapper;
                function PrependBOMWrapper(encoder, options) {
                  this.encoder = encoder;
                  this.addBOM = true;
                }
                PrependBOMWrapper.prototype.write = function(str) {
                  if (this.addBOM) {
                    str = BOMChar + str;
                    this.addBOM = false;
                  }
                  return this.encoder.write(str);
                };
                PrependBOMWrapper.prototype.end = function() {
                  return this.encoder.end();
                };
                exports2.StripBOM = StripBOMWrapper;
                function StripBOMWrapper(decoder, options) {
                  this.decoder = decoder;
                  this.pass = false;
                  this.options = options || {};
                }
                StripBOMWrapper.prototype.write = function(buf) {
                  var res = this.decoder.write(buf);
                  if (this.pass || !res)
                    return res;
                  if (res[0] === BOMChar) {
                    res = res.slice(1);
                    if (typeof this.options.stripBOM === "function")
                      this.options.stripBOM();
                  }
                  this.pass = true;
                  return res;
                };
                StripBOMWrapper.prototype.end = function() {
                  return this.decoder.end();
                };
              }
            ),
            /***/
            4914: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var Buffer = __webpack_require__2(7103).Buffer;
                var bomHandling = __webpack_require__2(5395), iconv = module2.exports;
                iconv.encodings = null;
                iconv.defaultCharUnicode = "";
                iconv.defaultCharSingleByte = "?";
                iconv.encode = function encode(str, encoding, options) {
                  str = "" + (str || "");
                  var encoder = iconv.getEncoder(encoding, options);
                  var res = encoder.write(str);
                  var trail = encoder.end();
                  return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
                };
                iconv.decode = function decode(buf, encoding, options) {
                  if (typeof buf === "string") {
                    if (!iconv.skipDecodeWarning) {
                      console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
                      iconv.skipDecodeWarning = true;
                    }
                    buf = Buffer.from("" + (buf || ""), "binary");
                  }
                  var decoder = iconv.getDecoder(encoding, options);
                  var res = decoder.write(buf);
                  var trail = decoder.end();
                  return trail ? res + trail : res;
                };
                iconv.encodingExists = function encodingExists(enc) {
                  try {
                    iconv.getCodec(enc);
                    return true;
                  } catch (e) {
                    return false;
                  }
                };
                iconv.toEncoding = iconv.encode;
                iconv.fromEncoding = iconv.decode;
                iconv._codecDataCache = {};
                iconv.getCodec = function getCodec(encoding) {
                  if (!iconv.encodings)
                    iconv.encodings = __webpack_require__2(6934);
                  var enc = iconv._canonicalizeEncoding(encoding);
                  var codecOptions = {};
                  while (true) {
                    var codec = iconv._codecDataCache[enc];
                    if (codec)
                      return codec;
                    var codecDef = iconv.encodings[enc];
                    switch (typeof codecDef) {
                      case "string":
                        enc = codecDef;
                        break;
                      case "object":
                        for (var key in codecDef)
                          codecOptions[key] = codecDef[key];
                        if (!codecOptions.encodingName)
                          codecOptions.encodingName = enc;
                        enc = codecDef.type;
                        break;
                      case "function":
                        if (!codecOptions.encodingName)
                          codecOptions.encodingName = enc;
                        codec = new codecDef(codecOptions, iconv);
                        iconv._codecDataCache[codecOptions.encodingName] = codec;
                        return codec;
                      default:
                        throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
                    }
                  }
                };
                iconv._canonicalizeEncoding = function(encoding) {
                  return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
                };
                iconv.getEncoder = function getEncoder(encoding, options) {
                  var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
                  if (codec.bomAware && options && options.addBOM)
                    encoder = new bomHandling.PrependBOM(encoder, options);
                  return encoder;
                };
                iconv.getDecoder = function getDecoder(encoding, options) {
                  var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
                  if (codec.bomAware && !(options && options.stripBOM === false))
                    decoder = new bomHandling.StripBOM(decoder, options);
                  return decoder;
                };
                iconv.enableStreamingAPI = function enableStreamingAPI(stream_module2) {
                  if (iconv.supportsStreams)
                    return;
                  var streams = __webpack_require__2(8044)(stream_module2);
                  iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
                  iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;
                  iconv.encodeStream = function encodeStream(encoding, options) {
                    return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
                  };
                  iconv.decodeStream = function decodeStream(encoding, options) {
                    return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
                  };
                  iconv.supportsStreams = true;
                };
                var stream_module;
                try {
                  stream_module = __webpack_require__2(5832);
                } catch (e) {
                }
                if (stream_module && stream_module.Transform) {
                  iconv.enableStreamingAPI(stream_module);
                } else {
                  iconv.encodeStream = iconv.decodeStream = function() {
                    throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
                  };
                }
                if (false) {
                }
              }
            ),
            /***/
            8044: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var Buffer = __webpack_require__2(7103).Buffer;
                module2.exports = function(stream_module) {
                  var Transform = stream_module.Transform;
                  function IconvLiteEncoderStream(conv, options) {
                    this.conv = conv;
                    options = options || {};
                    options.decodeStrings = false;
                    Transform.call(this, options);
                  }
                  IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
                    constructor: { value: IconvLiteEncoderStream }
                  });
                  IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
                    if (typeof chunk != "string")
                      return done(new Error("Iconv encoding stream needs strings as its input."));
                    try {
                      var res = this.conv.write(chunk);
                      if (res && res.length)
                        this.push(res);
                      done();
                    } catch (e) {
                      done(e);
                    }
                  };
                  IconvLiteEncoderStream.prototype._flush = function(done) {
                    try {
                      var res = this.conv.end();
                      if (res && res.length)
                        this.push(res);
                      done();
                    } catch (e) {
                      done(e);
                    }
                  };
                  IconvLiteEncoderStream.prototype.collect = function(cb) {
                    var chunks = [];
                    this.on("error", cb);
                    this.on("data", function(chunk) {
                      chunks.push(chunk);
                    });
                    this.on("end", function() {
                      cb(null, Buffer.concat(chunks));
                    });
                    return this;
                  };
                  function IconvLiteDecoderStream(conv, options) {
                    this.conv = conv;
                    options = options || {};
                    options.encoding = this.encoding = "utf8";
                    Transform.call(this, options);
                  }
                  IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
                    constructor: { value: IconvLiteDecoderStream }
                  });
                  IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
                    if (!Buffer.isBuffer(chunk) && !(chunk instanceof Uint8Array))
                      return done(new Error("Iconv decoding stream needs buffers as its input."));
                    try {
                      var res = this.conv.write(chunk);
                      if (res && res.length)
                        this.push(res, this.encoding);
                      done();
                    } catch (e) {
                      done(e);
                    }
                  };
                  IconvLiteDecoderStream.prototype._flush = function(done) {
                    try {
                      var res = this.conv.end();
                      if (res && res.length)
                        this.push(res, this.encoding);
                      done();
                    } catch (e) {
                      done(e);
                    }
                  };
                  IconvLiteDecoderStream.prototype.collect = function(cb) {
                    var res = "";
                    this.on("error", cb);
                    this.on("data", function(chunk) {
                      res += chunk;
                    });
                    this.on("end", function() {
                      cb(null, res);
                    });
                    return this;
                  };
                  return {
                    IconvLiteEncoderStream,
                    IconvLiteDecoderStream
                  };
                };
              }
            ),
            /***/
            645: (
              /***/
              function(__unused_webpack_module, exports2) {
                exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
                  var e, m;
                  var eLen = nBytes * 8 - mLen - 1;
                  var eMax = (1 << eLen) - 1;
                  var eBias = eMax >> 1;
                  var nBits = -7;
                  var i = isLE ? nBytes - 1 : 0;
                  var d = isLE ? -1 : 1;
                  var s = buffer[offset + i];
                  i += d;
                  e = s & (1 << -nBits) - 1;
                  s >>= -nBits;
                  nBits += eLen;
                  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
                  }
                  m = e & (1 << -nBits) - 1;
                  e >>= -nBits;
                  nBits += mLen;
                  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
                  }
                  if (e === 0) {
                    e = 1 - eBias;
                  } else if (e === eMax) {
                    return m ? NaN : (s ? -1 : 1) * Infinity;
                  } else {
                    m = m + Math.pow(2, mLen);
                    e = e - eBias;
                  }
                  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
                };
                exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
                  var e, m, c;
                  var eLen = nBytes * 8 - mLen - 1;
                  var eMax = (1 << eLen) - 1;
                  var eBias = eMax >> 1;
                  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                  var i = isLE ? 0 : nBytes - 1;
                  var d = isLE ? 1 : -1;
                  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
                  value = Math.abs(value);
                  if (isNaN(value) || value === Infinity) {
                    m = isNaN(value) ? 1 : 0;
                    e = eMax;
                  } else {
                    e = Math.floor(Math.log(value) / Math.LN2);
                    if (value * (c = Math.pow(2, -e)) < 1) {
                      e--;
                      c *= 2;
                    }
                    if (e + eBias >= 1) {
                      value += rt / c;
                    } else {
                      value += rt * Math.pow(2, 1 - eBias);
                    }
                    if (value * c >= 2) {
                      e++;
                      c /= 2;
                    }
                    if (e + eBias >= eMax) {
                      m = 0;
                      e = eMax;
                    } else if (e + eBias >= 1) {
                      m = (value * c - 1) * Math.pow(2, mLen);
                      e = e + eBias;
                    } else {
                      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                      e = 0;
                    }
                  }
                  for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
                  }
                  e = e << mLen | m;
                  eLen += mLen;
                  for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
                  }
                  buffer[offset + i - d] |= s * 128;
                };
              }
            ),
            /***/
            5717: (
              /***/
              function(module2) {
                if (typeof Object.create === "function") {
                  module2.exports = function inherits(ctor, superCtor) {
                    if (superCtor) {
                      ctor.super_ = superCtor;
                      ctor.prototype = Object.create(superCtor.prototype, {
                        constructor: {
                          value: ctor,
                          enumerable: false,
                          writable: true,
                          configurable: true
                        }
                      });
                    }
                  };
                } else {
                  module2.exports = function inherits(ctor, superCtor) {
                    if (superCtor) {
                      ctor.super_ = superCtor;
                      var TempCtor = function() {
                      };
                      TempCtor.prototype = superCtor.prototype;
                      ctor.prototype = new TempCtor();
                      ctor.prototype.constructor = ctor;
                    }
                  };
                }
              }
            ),
            /***/
            2584: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var hasToStringTag = __webpack_require__2(6410)();
                var callBound = __webpack_require__2(1924);
                var $toString = callBound("Object.prototype.toString");
                var isStandardArguments = function isArguments(value) {
                  if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
                    return false;
                  }
                  return $toString(value) === "[object Arguments]";
                };
                var isLegacyArguments = function isArguments(value) {
                  if (isStandardArguments(value)) {
                    return true;
                  }
                  return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
                };
                var supportsStandardArguments = function() {
                  return isStandardArguments(arguments);
                }();
                isStandardArguments.isLegacyArguments = isLegacyArguments;
                module2.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
              }
            ),
            /***/
            5320: (
              /***/
              function(module2) {
                "use strict";
                var fnToStr = Function.prototype.toString;
                var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
                var badArrayLike;
                var isCallableMarker;
                if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
                  try {
                    badArrayLike = Object.defineProperty({}, "length", {
                      get: function() {
                        throw isCallableMarker;
                      }
                    });
                    isCallableMarker = {};
                    reflectApply(function() {
                      throw 42;
                    }, null, badArrayLike);
                  } catch (_) {
                    if (_ !== isCallableMarker) {
                      reflectApply = null;
                    }
                  }
                } else {
                  reflectApply = null;
                }
                var constructorRegex = /^\s*class\b/;
                var isES6ClassFn = function isES6ClassFunction(value) {
                  try {
                    var fnStr = fnToStr.call(value);
                    return constructorRegex.test(fnStr);
                  } catch (e) {
                    return false;
                  }
                };
                var tryFunctionObject = function tryFunctionToStr(value) {
                  try {
                    if (isES6ClassFn(value)) {
                      return false;
                    }
                    fnToStr.call(value);
                    return true;
                  } catch (e) {
                    return false;
                  }
                };
                var toStr = Object.prototype.toString;
                var objectClass = "[object Object]";
                var fnClass = "[object Function]";
                var genClass = "[object GeneratorFunction]";
                var ddaClass = "[object HTMLAllCollection]";
                var ddaClass2 = "[object HTML document.all class]";
                var ddaClass3 = "[object HTMLCollection]";
                var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
                var isIE68 = !(0 in [,]);
                var isDDA = function isDocumentDotAll() {
                  return false;
                };
                if (typeof document === "object") {
                  var all = document.all;
                  if (toStr.call(all) === toStr.call(document.all)) {
                    isDDA = function isDocumentDotAll(value) {
                      if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
                        try {
                          var str = toStr.call(value);
                          return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
                        } catch (e) {
                        }
                      }
                      return false;
                    };
                  }
                }
                module2.exports = reflectApply ? function isCallable(value) {
                  if (isDDA(value)) {
                    return true;
                  }
                  if (!value) {
                    return false;
                  }
                  if (typeof value !== "function" && typeof value !== "object") {
                    return false;
                  }
                  try {
                    reflectApply(value, null, badArrayLike);
                  } catch (e) {
                    if (e !== isCallableMarker) {
                      return false;
                    }
                  }
                  return !isES6ClassFn(value) && tryFunctionObject(value);
                } : function isCallable(value) {
                  if (isDDA(value)) {
                    return true;
                  }
                  if (!value) {
                    return false;
                  }
                  if (typeof value !== "function" && typeof value !== "object") {
                    return false;
                  }
                  if (hasToStringTag) {
                    return tryFunctionObject(value);
                  }
                  if (isES6ClassFn(value)) {
                    return false;
                  }
                  var strClass = toStr.call(value);
                  if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
                    return false;
                  }
                  return tryFunctionObject(value);
                };
              }
            ),
            /***/
            8923: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var getDay = Date.prototype.getDay;
                var tryDateObject = function tryDateGetDayCall(value) {
                  try {
                    getDay.call(value);
                    return true;
                  } catch (e) {
                    return false;
                  }
                };
                var toStr = Object.prototype.toString;
                var dateClass = "[object Date]";
                var hasToStringTag = __webpack_require__2(6410)();
                module2.exports = function isDateObject(value) {
                  if (typeof value !== "object" || value === null) {
                    return false;
                  }
                  return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
                };
              }
            ),
            /***/
            8662: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var toStr = Object.prototype.toString;
                var fnToStr = Function.prototype.toString;
                var isFnRegex = /^\s*(?:function)?\*/;
                var hasToStringTag = __webpack_require__2(6410)();
                var getProto = Object.getPrototypeOf;
                var getGeneratorFunc = function() {
                  if (!hasToStringTag) {
                    return false;
                  }
                  try {
                    return Function("return function*() {}")();
                  } catch (e) {
                  }
                };
                var GeneratorFunction;
                module2.exports = function isGeneratorFunction(fn) {
                  if (typeof fn !== "function") {
                    return false;
                  }
                  if (isFnRegex.test(fnToStr.call(fn))) {
                    return true;
                  }
                  if (!hasToStringTag) {
                    var str = toStr.call(fn);
                    return str === "[object GeneratorFunction]";
                  }
                  if (!getProto) {
                    return false;
                  }
                  if (typeof GeneratorFunction === "undefined") {
                    var generatorFunc = getGeneratorFunc();
                    GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
                  }
                  return getProto(fn) === GeneratorFunction;
                };
              }
            ),
            /***/
            8611: (
              /***/
              function(module2) {
                "use strict";
                module2.exports = function isNaN2(value) {
                  return value !== value;
                };
              }
            ),
            /***/
            360: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var callBind = __webpack_require__2(5559);
                var define2 = __webpack_require__2(4289);
                var implementation = __webpack_require__2(8611);
                var getPolyfill = __webpack_require__2(9415);
                var shim = __webpack_require__2(6743);
                var polyfill = callBind(getPolyfill(), Number);
                define2(polyfill, {
                  getPolyfill,
                  implementation,
                  shim
                });
                module2.exports = polyfill;
              }
            ),
            /***/
            9415: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var implementation = __webpack_require__2(8611);
                module2.exports = function getPolyfill() {
                  if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) {
                    return Number.isNaN;
                  }
                  return implementation;
                };
              }
            ),
            /***/
            6743: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var define2 = __webpack_require__2(4289);
                var getPolyfill = __webpack_require__2(9415);
                module2.exports = function shimNumberIsNaN() {
                  var polyfill = getPolyfill();
                  define2(Number, { isNaN: polyfill }, {
                    isNaN: function testIsNaN() {
                      return Number.isNaN !== polyfill;
                    }
                  });
                  return polyfill;
                };
              }
            ),
            /***/
            8420: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var callBound = __webpack_require__2(1924);
                var hasToStringTag = __webpack_require__2(6410)();
                var has;
                var $exec;
                var isRegexMarker;
                var badStringifier;
                if (hasToStringTag) {
                  has = callBound("Object.prototype.hasOwnProperty");
                  $exec = callBound("RegExp.prototype.exec");
                  isRegexMarker = {};
                  var throwRegexMarker = function() {
                    throw isRegexMarker;
                  };
                  badStringifier = {
                    toString: throwRegexMarker,
                    valueOf: throwRegexMarker
                  };
                  if (typeof Symbol.toPrimitive === "symbol") {
                    badStringifier[Symbol.toPrimitive] = throwRegexMarker;
                  }
                }
                var $toString = callBound("Object.prototype.toString");
                var gOPD = Object.getOwnPropertyDescriptor;
                var regexClass = "[object RegExp]";
                module2.exports = hasToStringTag ? function isRegex(value) {
                  if (!value || typeof value !== "object") {
                    return false;
                  }
                  var descriptor = gOPD(value, "lastIndex");
                  var hasLastIndexDataProperty = descriptor && has(descriptor, "value");
                  if (!hasLastIndexDataProperty) {
                    return false;
                  }
                  try {
                    $exec(value, badStringifier);
                  } catch (e) {
                    return e === isRegexMarker;
                  }
                } : function isRegex(value) {
                  if (!value || typeof value !== "object" && typeof value !== "function") {
                    return false;
                  }
                  return $toString(value) === regexClass;
                };
              }
            ),
            /***/
            5692: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var forEach = __webpack_require__2(4029);
                var availableTypedArrays = __webpack_require__2(3083);
                var callBound = __webpack_require__2(1924);
                var $toString = callBound("Object.prototype.toString");
                var hasToStringTag = __webpack_require__2(6410)();
                var gOPD = __webpack_require__2(7296);
                var g = typeof globalThis === "undefined" ? __webpack_require__2.g : globalThis;
                var typedArrays = availableTypedArrays();
                var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
                  for (var i = 0; i < array.length; i += 1) {
                    if (array[i] === value) {
                      return i;
                    }
                  }
                  return -1;
                };
                var $slice = callBound("String.prototype.slice");
                var toStrTags = {};
                var getPrototypeOf = Object.getPrototypeOf;
                if (hasToStringTag && gOPD && getPrototypeOf) {
                  forEach(typedArrays, function(typedArray) {
                    var arr = new g[typedArray]();
                    if (Symbol.toStringTag in arr) {
                      var proto = getPrototypeOf(arr);
                      var descriptor = gOPD(proto, Symbol.toStringTag);
                      if (!descriptor) {
                        var superProto = getPrototypeOf(proto);
                        descriptor = gOPD(superProto, Symbol.toStringTag);
                      }
                      toStrTags[typedArray] = descriptor.get;
                    }
                  });
                }
                var tryTypedArrays = function tryAllTypedArrays(value) {
                  var anyTrue = false;
                  forEach(toStrTags, function(getter, typedArray) {
                    if (!anyTrue) {
                      try {
                        anyTrue = getter.call(value) === typedArray;
                      } catch (e) {
                      }
                    }
                  });
                  return anyTrue;
                };
                module2.exports = function isTypedArray(value) {
                  if (!value || typeof value !== "object") {
                    return false;
                  }
                  if (!hasToStringTag || !(Symbol.toStringTag in value)) {
                    var tag = $slice($toString(value), 8, -1);
                    return $indexOf(typedArrays, tag) > -1;
                  }
                  if (!gOPD) {
                    return false;
                  }
                  return tryTypedArrays(value);
                };
              }
            ),
            /***/
            4244: (
              /***/
              function(module2) {
                "use strict";
                var numberIsNaN = function(value) {
                  return value !== value;
                };
                module2.exports = function is(a, b) {
                  if (a === 0 && b === 0) {
                    return 1 / a === 1 / b;
                  }
                  if (a === b) {
                    return true;
                  }
                  if (numberIsNaN(a) && numberIsNaN(b)) {
                    return true;
                  }
                  return false;
                };
              }
            ),
            /***/
            609: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var define2 = __webpack_require__2(4289);
                var callBind = __webpack_require__2(5559);
                var implementation = __webpack_require__2(4244);
                var getPolyfill = __webpack_require__2(5624);
                var shim = __webpack_require__2(2281);
                var polyfill = callBind(getPolyfill(), Object);
                define2(polyfill, {
                  getPolyfill,
                  implementation,
                  shim
                });
                module2.exports = polyfill;
              }
            ),
            /***/
            5624: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var implementation = __webpack_require__2(4244);
                module2.exports = function getPolyfill() {
                  return typeof Object.is === "function" ? Object.is : implementation;
                };
              }
            ),
            /***/
            2281: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var getPolyfill = __webpack_require__2(5624);
                var define2 = __webpack_require__2(4289);
                module2.exports = function shimObjectIs() {
                  var polyfill = getPolyfill();
                  define2(Object, { is: polyfill }, {
                    is: function testObjectIs() {
                      return Object.is !== polyfill;
                    }
                  });
                  return polyfill;
                };
              }
            ),
            /***/
            8987: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var keysShim;
                if (!Object.keys) {
                  var has = Object.prototype.hasOwnProperty;
                  var toStr = Object.prototype.toString;
                  var isArgs = __webpack_require__2(1414);
                  var isEnumerable = Object.prototype.propertyIsEnumerable;
                  var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
                  var hasProtoEnumBug = isEnumerable.call(function() {
                  }, "prototype");
                  var dontEnums = [
                    "toString",
                    "toLocaleString",
                    "valueOf",
                    "hasOwnProperty",
                    "isPrototypeOf",
                    "propertyIsEnumerable",
                    "constructor"
                  ];
                  var equalsConstructorPrototype = function(o) {
                    var ctor = o.constructor;
                    return ctor && ctor.prototype === o;
                  };
                  var excludedKeys = {
                    $applicationCache: true,
                    $console: true,
                    $external: true,
                    $frame: true,
                    $frameElement: true,
                    $frames: true,
                    $innerHeight: true,
                    $innerWidth: true,
                    $onmozfullscreenchange: true,
                    $onmozfullscreenerror: true,
                    $outerHeight: true,
                    $outerWidth: true,
                    $pageXOffset: true,
                    $pageYOffset: true,
                    $parent: true,
                    $scrollLeft: true,
                    $scrollTop: true,
                    $scrollX: true,
                    $scrollY: true,
                    $self: true,
                    $webkitIndexedDB: true,
                    $webkitStorageInfo: true,
                    $window: true
                  };
                  var hasAutomationEqualityBug = function() {
                    if (typeof window === "undefined") {
                      return false;
                    }
                    for (var k in window) {
                      try {
                        if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
                          try {
                            equalsConstructorPrototype(window[k]);
                          } catch (e) {
                            return true;
                          }
                        }
                      } catch (e) {
                        return true;
                      }
                    }
                    return false;
                  }();
                  var equalsConstructorPrototypeIfNotBuggy = function(o) {
                    if (typeof window === "undefined" || !hasAutomationEqualityBug) {
                      return equalsConstructorPrototype(o);
                    }
                    try {
                      return equalsConstructorPrototype(o);
                    } catch (e) {
                      return false;
                    }
                  };
                  keysShim = function keys(object) {
                    var isObject = object !== null && typeof object === "object";
                    var isFunction = toStr.call(object) === "[object Function]";
                    var isArguments = isArgs(object);
                    var isString = isObject && toStr.call(object) === "[object String]";
                    var theKeys = [];
                    if (!isObject && !isFunction && !isArguments) {
                      throw new TypeError("Object.keys called on a non-object");
                    }
                    var skipProto = hasProtoEnumBug && isFunction;
                    if (isString && object.length > 0 && !has.call(object, 0)) {
                      for (var i = 0; i < object.length; ++i) {
                        theKeys.push(String(i));
                      }
                    }
                    if (isArguments && object.length > 0) {
                      for (var j = 0; j < object.length; ++j) {
                        theKeys.push(String(j));
                      }
                    } else {
                      for (var name in object) {
                        if (!(skipProto && name === "prototype") && has.call(object, name)) {
                          theKeys.push(String(name));
                        }
                      }
                    }
                    if (hasDontEnumBug) {
                      var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                      for (var k = 0; k < dontEnums.length; ++k) {
                        if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
                          theKeys.push(dontEnums[k]);
                        }
                      }
                    }
                    return theKeys;
                  };
                }
                module2.exports = keysShim;
              }
            ),
            /***/
            2215: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var slice = Array.prototype.slice;
                var isArgs = __webpack_require__2(1414);
                var origKeys = Object.keys;
                var keysShim = origKeys ? function keys(o) {
                  return origKeys(o);
                } : __webpack_require__2(8987);
                var originalKeys = Object.keys;
                keysShim.shim = function shimObjectKeys() {
                  if (Object.keys) {
                    var keysWorksWithArguments = function() {
                      var args = Object.keys(arguments);
                      return args && args.length === arguments.length;
                    }(1, 2);
                    if (!keysWorksWithArguments) {
                      Object.keys = function keys(object) {
                        if (isArgs(object)) {
                          return originalKeys(slice.call(object));
                        }
                        return originalKeys(object);
                      };
                    }
                  } else {
                    Object.keys = keysShim;
                  }
                  return Object.keys || keysShim;
                };
                module2.exports = keysShim;
              }
            ),
            /***/
            1414: (
              /***/
              function(module2) {
                "use strict";
                var toStr = Object.prototype.toString;
                module2.exports = function isArguments(value) {
                  var str = toStr.call(value);
                  var isArgs = str === "[object Arguments]";
                  if (!isArgs) {
                    isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
                  }
                  return isArgs;
                };
              }
            ),
            /***/
            4236: (
              /***/
              function(__unused_webpack_module, exports2) {
                "use strict";
                var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
                function _has(obj, key) {
                  return Object.prototype.hasOwnProperty.call(obj, key);
                }
                exports2.assign = function(obj) {
                  var sources = Array.prototype.slice.call(arguments, 1);
                  while (sources.length) {
                    var source = sources.shift();
                    if (!source) {
                      continue;
                    }
                    if (typeof source !== "object") {
                      throw new TypeError(source + "must be non-object");
                    }
                    for (var p in source) {
                      if (_has(source, p)) {
                        obj[p] = source[p];
                      }
                    }
                  }
                  return obj;
                };
                exports2.shrinkBuf = function(buf, size) {
                  if (buf.length === size) {
                    return buf;
                  }
                  if (buf.subarray) {
                    return buf.subarray(0, size);
                  }
                  buf.length = size;
                  return buf;
                };
                var fnTyped = {
                  arraySet: function(dest, src, src_offs, len, dest_offs) {
                    if (src.subarray && dest.subarray) {
                      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
                      return;
                    }
                    for (var i = 0; i < len; i++) {
                      dest[dest_offs + i] = src[src_offs + i];
                    }
                  },
                  // Join array of chunks to single array.
                  flattenChunks: function(chunks) {
                    var i, l, len, pos, chunk, result;
                    len = 0;
                    for (i = 0, l = chunks.length; i < l; i++) {
                      len += chunks[i].length;
                    }
                    result = new Uint8Array(len);
                    pos = 0;
                    for (i = 0, l = chunks.length; i < l; i++) {
                      chunk = chunks[i];
                      result.set(chunk, pos);
                      pos += chunk.length;
                    }
                    return result;
                  }
                };
                var fnUntyped = {
                  arraySet: function(dest, src, src_offs, len, dest_offs) {
                    for (var i = 0; i < len; i++) {
                      dest[dest_offs + i] = src[src_offs + i];
                    }
                  },
                  // Join array of chunks to single array.
                  flattenChunks: function(chunks) {
                    return [].concat.apply([], chunks);
                  }
                };
                exports2.setTyped = function(on) {
                  if (on) {
                    exports2.Buf8 = Uint8Array;
                    exports2.Buf16 = Uint16Array;
                    exports2.Buf32 = Int32Array;
                    exports2.assign(exports2, fnTyped);
                  } else {
                    exports2.Buf8 = Array;
                    exports2.Buf16 = Array;
                    exports2.Buf32 = Array;
                    exports2.assign(exports2, fnUntyped);
                  }
                };
                exports2.setTyped(TYPED_OK);
              }
            ),
            /***/
            6069: (
              /***/
              function(module2) {
                "use strict";
                function adler32(adler, buf, len, pos) {
                  var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
                  while (len !== 0) {
                    n = len > 2e3 ? 2e3 : len;
                    len -= n;
                    do {
                      s1 = s1 + buf[pos++] | 0;
                      s2 = s2 + s1 | 0;
                    } while (--n);
                    s1 %= 65521;
                    s2 %= 65521;
                  }
                  return s1 | s2 << 16 | 0;
                }
                module2.exports = adler32;
              }
            ),
            /***/
            1619: (
              /***/
              function(module2) {
                "use strict";
                module2.exports = {
                  /* Allowed flush values; see deflate() and inflate() below for details */
                  Z_NO_FLUSH: 0,
                  Z_PARTIAL_FLUSH: 1,
                  Z_SYNC_FLUSH: 2,
                  Z_FULL_FLUSH: 3,
                  Z_FINISH: 4,
                  Z_BLOCK: 5,
                  Z_TREES: 6,
                  /* Return codes for the compression/decompression functions. Negative values
                  * are errors, positive values are used for special but normal events.
                  */
                  Z_OK: 0,
                  Z_STREAM_END: 1,
                  Z_NEED_DICT: 2,
                  Z_ERRNO: -1,
                  Z_STREAM_ERROR: -2,
                  Z_DATA_ERROR: -3,
                  //Z_MEM_ERROR:     -4,
                  Z_BUF_ERROR: -5,
                  //Z_VERSION_ERROR: -6,
                  /* compression levels */
                  Z_NO_COMPRESSION: 0,
                  Z_BEST_SPEED: 1,
                  Z_BEST_COMPRESSION: 9,
                  Z_DEFAULT_COMPRESSION: -1,
                  Z_FILTERED: 1,
                  Z_HUFFMAN_ONLY: 2,
                  Z_RLE: 3,
                  Z_FIXED: 4,
                  Z_DEFAULT_STRATEGY: 0,
                  /* Possible values of the data_type field (though see inflate()) */
                  Z_BINARY: 0,
                  Z_TEXT: 1,
                  //Z_ASCII:                1, // = Z_TEXT (deprecated)
                  Z_UNKNOWN: 2,
                  /* The deflate compression method */
                  Z_DEFLATED: 8
                  //Z_NULL:                 null // Use -1 or null inline, depending on var type
                };
              }
            ),
            /***/
            2869: (
              /***/
              function(module2) {
                "use strict";
                function makeTable() {
                  var c, table = [];
                  for (var n = 0; n < 256; n++) {
                    c = n;
                    for (var k = 0; k < 8; k++) {
                      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
                    }
                    table[n] = c;
                  }
                  return table;
                }
                var crcTable = makeTable();
                function crc32(crc, buf, len, pos) {
                  var t = crcTable, end = pos + len;
                  crc ^= -1;
                  for (var i = pos; i < end; i++) {
                    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
                  }
                  return crc ^ -1;
                }
                module2.exports = crc32;
              }
            ),
            /***/
            405: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var utils = __webpack_require__2(4236);
                var trees = __webpack_require__2(342);
                var adler32 = __webpack_require__2(6069);
                var crc32 = __webpack_require__2(2869);
                var msg = __webpack_require__2(8898);
                var Z_NO_FLUSH = 0;
                var Z_PARTIAL_FLUSH = 1;
                var Z_FULL_FLUSH = 3;
                var Z_FINISH = 4;
                var Z_BLOCK = 5;
                var Z_OK = 0;
                var Z_STREAM_END = 1;
                var Z_STREAM_ERROR = -2;
                var Z_DATA_ERROR = -3;
                var Z_BUF_ERROR = -5;
                var Z_DEFAULT_COMPRESSION = -1;
                var Z_FILTERED = 1;
                var Z_HUFFMAN_ONLY = 2;
                var Z_RLE = 3;
                var Z_FIXED = 4;
                var Z_DEFAULT_STRATEGY = 0;
                var Z_UNKNOWN = 2;
                var Z_DEFLATED = 8;
                var MAX_MEM_LEVEL = 9;
                var MAX_WBITS = 15;
                var DEF_MEM_LEVEL = 8;
                var LENGTH_CODES = 29;
                var LITERALS = 256;
                var L_CODES = LITERALS + 1 + LENGTH_CODES;
                var D_CODES = 30;
                var BL_CODES = 19;
                var HEAP_SIZE = 2 * L_CODES + 1;
                var MAX_BITS = 15;
                var MIN_MATCH = 3;
                var MAX_MATCH = 258;
                var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
                var PRESET_DICT = 32;
                var INIT_STATE = 42;
                var EXTRA_STATE = 69;
                var NAME_STATE = 73;
                var COMMENT_STATE = 91;
                var HCRC_STATE = 103;
                var BUSY_STATE = 113;
                var FINISH_STATE = 666;
                var BS_NEED_MORE = 1;
                var BS_BLOCK_DONE = 2;
                var BS_FINISH_STARTED = 3;
                var BS_FINISH_DONE = 4;
                var OS_CODE = 3;
                function err(strm, errorCode) {
                  strm.msg = msg[errorCode];
                  return errorCode;
                }
                function rank(f) {
                  return (f << 1) - (f > 4 ? 9 : 0);
                }
                function zero(buf) {
                  var len = buf.length;
                  while (--len >= 0) {
                    buf[len] = 0;
                  }
                }
                function flush_pending(strm) {
                  var s = strm.state;
                  var len = s.pending;
                  if (len > strm.avail_out) {
                    len = strm.avail_out;
                  }
                  if (len === 0) {
                    return;
                  }
                  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
                  strm.next_out += len;
                  s.pending_out += len;
                  strm.total_out += len;
                  strm.avail_out -= len;
                  s.pending -= len;
                  if (s.pending === 0) {
                    s.pending_out = 0;
                  }
                }
                function flush_block_only(s, last) {
                  trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
                  s.block_start = s.strstart;
                  flush_pending(s.strm);
                }
                function put_byte(s, b) {
                  s.pending_buf[s.pending++] = b;
                }
                function putShortMSB(s, b) {
                  s.pending_buf[s.pending++] = b >>> 8 & 255;
                  s.pending_buf[s.pending++] = b & 255;
                }
                function read_buf(strm, buf, start, size) {
                  var len = strm.avail_in;
                  if (len > size) {
                    len = size;
                  }
                  if (len === 0) {
                    return 0;
                  }
                  strm.avail_in -= len;
                  utils.arraySet(buf, strm.input, strm.next_in, len, start);
                  if (strm.state.wrap === 1) {
                    strm.adler = adler32(strm.adler, buf, len, start);
                  } else if (strm.state.wrap === 2) {
                    strm.adler = crc32(strm.adler, buf, len, start);
                  }
                  strm.next_in += len;
                  strm.total_in += len;
                  return len;
                }
                function longest_match(s, cur_match) {
                  var chain_length = s.max_chain_length;
                  var scan = s.strstart;
                  var match;
                  var len;
                  var best_len = s.prev_length;
                  var nice_match = s.nice_match;
                  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
                  var _win = s.window;
                  var wmask = s.w_mask;
                  var prev = s.prev;
                  var strend = s.strstart + MAX_MATCH;
                  var scan_end1 = _win[scan + best_len - 1];
                  var scan_end = _win[scan + best_len];
                  if (s.prev_length >= s.good_match) {
                    chain_length >>= 2;
                  }
                  if (nice_match > s.lookahead) {
                    nice_match = s.lookahead;
                  }
                  do {
                    match = cur_match;
                    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
                      continue;
                    }
                    scan += 2;
                    match++;
                    do {
                    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
                    len = MAX_MATCH - (strend - scan);
                    scan = strend - MAX_MATCH;
                    if (len > best_len) {
                      s.match_start = cur_match;
                      best_len = len;
                      if (len >= nice_match) {
                        break;
                      }
                      scan_end1 = _win[scan + best_len - 1];
                      scan_end = _win[scan + best_len];
                    }
                  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
                  if (best_len <= s.lookahead) {
                    return best_len;
                  }
                  return s.lookahead;
                }
                function fill_window(s) {
                  var _w_size = s.w_size;
                  var p, n, m, more, str;
                  do {
                    more = s.window_size - s.lookahead - s.strstart;
                    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
                      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
                      s.match_start -= _w_size;
                      s.strstart -= _w_size;
                      s.block_start -= _w_size;
                      n = s.hash_size;
                      p = n;
                      do {
                        m = s.head[--p];
                        s.head[p] = m >= _w_size ? m - _w_size : 0;
                      } while (--n);
                      n = _w_size;
                      p = n;
                      do {
                        m = s.prev[--p];
                        s.prev[p] = m >= _w_size ? m - _w_size : 0;
                      } while (--n);
                      more += _w_size;
                    }
                    if (s.strm.avail_in === 0) {
                      break;
                    }
                    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
                    s.lookahead += n;
                    if (s.lookahead + s.insert >= MIN_MATCH) {
                      str = s.strstart - s.insert;
                      s.ins_h = s.window[str];
                      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
                      while (s.insert) {
                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                        s.prev[str & s.w_mask] = s.head[s.ins_h];
                        s.head[s.ins_h] = str;
                        str++;
                        s.insert--;
                        if (s.lookahead + s.insert < MIN_MATCH) {
                          break;
                        }
                      }
                    }
                  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
                }
                function deflate_stored(s, flush) {
                  var max_block_size = 65535;
                  if (max_block_size > s.pending_buf_size - 5) {
                    max_block_size = s.pending_buf_size - 5;
                  }
                  for (; ; ) {
                    if (s.lookahead <= 1) {
                      fill_window(s);
                      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
                        return BS_NEED_MORE;
                      }
                      if (s.lookahead === 0) {
                        break;
                      }
                    }
                    s.strstart += s.lookahead;
                    s.lookahead = 0;
                    var max_start = s.block_start + max_block_size;
                    if (s.strstart === 0 || s.strstart >= max_start) {
                      s.lookahead = s.strstart - max_start;
                      s.strstart = max_start;
                      flush_block_only(s, false);
                      if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                      }
                    }
                    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
                      flush_block_only(s, false);
                      if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                      }
                    }
                  }
                  s.insert = 0;
                  if (flush === Z_FINISH) {
                    flush_block_only(s, true);
                    if (s.strm.avail_out === 0) {
                      return BS_FINISH_STARTED;
                    }
                    return BS_FINISH_DONE;
                  }
                  if (s.strstart > s.block_start) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                      return BS_NEED_MORE;
                    }
                  }
                  return BS_NEED_MORE;
                }
                function deflate_fast(s, flush) {
                  var hash_head;
                  var bflush;
                  for (; ; ) {
                    if (s.lookahead < MIN_LOOKAHEAD) {
                      fill_window(s);
                      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                        return BS_NEED_MORE;
                      }
                      if (s.lookahead === 0) {
                        break;
                      }
                    }
                    hash_head = 0;
                    if (s.lookahead >= MIN_MATCH) {
                      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                      s.head[s.ins_h] = s.strstart;
                    }
                    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                      s.match_length = longest_match(s, hash_head);
                    }
                    if (s.match_length >= MIN_MATCH) {
                      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
                      s.lookahead -= s.match_length;
                      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
                        s.match_length--;
                        do {
                          s.strstart++;
                          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                          s.head[s.ins_h] = s.strstart;
                        } while (--s.match_length !== 0);
                        s.strstart++;
                      } else {
                        s.strstart += s.match_length;
                        s.match_length = 0;
                        s.ins_h = s.window[s.strstart];
                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
                      }
                    } else {
                      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                      s.lookahead--;
                      s.strstart++;
                    }
                    if (bflush) {
                      flush_block_only(s, false);
                      if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                      }
                    }
                  }
                  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
                  if (flush === Z_FINISH) {
                    flush_block_only(s, true);
                    if (s.strm.avail_out === 0) {
                      return BS_FINISH_STARTED;
                    }
                    return BS_FINISH_DONE;
                  }
                  if (s.last_lit) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                      return BS_NEED_MORE;
                    }
                  }
                  return BS_BLOCK_DONE;
                }
                function deflate_slow(s, flush) {
                  var hash_head;
                  var bflush;
                  var max_insert;
                  for (; ; ) {
                    if (s.lookahead < MIN_LOOKAHEAD) {
                      fill_window(s);
                      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                        return BS_NEED_MORE;
                      }
                      if (s.lookahead === 0) {
                        break;
                      }
                    }
                    hash_head = 0;
                    if (s.lookahead >= MIN_MATCH) {
                      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                      s.head[s.ins_h] = s.strstart;
                    }
                    s.prev_length = s.match_length;
                    s.prev_match = s.match_start;
                    s.match_length = MIN_MATCH - 1;
                    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                      s.match_length = longest_match(s, hash_head);
                      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
                        s.match_length = MIN_MATCH - 1;
                      }
                    }
                    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                      max_insert = s.strstart + s.lookahead - MIN_MATCH;
                      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
                      s.lookahead -= s.prev_length - 1;
                      s.prev_length -= 2;
                      do {
                        if (++s.strstart <= max_insert) {
                          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                          s.head[s.ins_h] = s.strstart;
                        }
                      } while (--s.prev_length !== 0);
                      s.match_available = 0;
                      s.match_length = MIN_MATCH - 1;
                      s.strstart++;
                      if (bflush) {
                        flush_block_only(s, false);
                        if (s.strm.avail_out === 0) {
                          return BS_NEED_MORE;
                        }
                      }
                    } else if (s.match_available) {
                      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
                      if (bflush) {
                        flush_block_only(s, false);
                      }
                      s.strstart++;
                      s.lookahead--;
                      if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                      }
                    } else {
                      s.match_available = 1;
                      s.strstart++;
                      s.lookahead--;
                    }
                  }
                  if (s.match_available) {
                    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
                    s.match_available = 0;
                  }
                  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
                  if (flush === Z_FINISH) {
                    flush_block_only(s, true);
                    if (s.strm.avail_out === 0) {
                      return BS_FINISH_STARTED;
                    }
                    return BS_FINISH_DONE;
                  }
                  if (s.last_lit) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                      return BS_NEED_MORE;
                    }
                  }
                  return BS_BLOCK_DONE;
                }
                function deflate_rle(s, flush) {
                  var bflush;
                  var prev;
                  var scan, strend;
                  var _win = s.window;
                  for (; ; ) {
                    if (s.lookahead <= MAX_MATCH) {
                      fill_window(s);
                      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
                        return BS_NEED_MORE;
                      }
                      if (s.lookahead === 0) {
                        break;
                      }
                    }
                    s.match_length = 0;
                    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
                      scan = s.strstart - 1;
                      prev = _win[scan];
                      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                        strend = s.strstart + MAX_MATCH;
                        do {
                        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                        s.match_length = MAX_MATCH - (strend - scan);
                        if (s.match_length > s.lookahead) {
                          s.match_length = s.lookahead;
                        }
                      }
                    }
                    if (s.match_length >= MIN_MATCH) {
                      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
                      s.lookahead -= s.match_length;
                      s.strstart += s.match_length;
                      s.match_length = 0;
                    } else {
                      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                      s.lookahead--;
                      s.strstart++;
                    }
                    if (bflush) {
                      flush_block_only(s, false);
                      if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                      }
                    }
                  }
                  s.insert = 0;
                  if (flush === Z_FINISH) {
                    flush_block_only(s, true);
                    if (s.strm.avail_out === 0) {
                      return BS_FINISH_STARTED;
                    }
                    return BS_FINISH_DONE;
                  }
                  if (s.last_lit) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                      return BS_NEED_MORE;
                    }
                  }
                  return BS_BLOCK_DONE;
                }
                function deflate_huff(s, flush) {
                  var bflush;
                  for (; ; ) {
                    if (s.lookahead === 0) {
                      fill_window(s);
                      if (s.lookahead === 0) {
                        if (flush === Z_NO_FLUSH) {
                          return BS_NEED_MORE;
                        }
                        break;
                      }
                    }
                    s.match_length = 0;
                    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                    s.lookahead--;
                    s.strstart++;
                    if (bflush) {
                      flush_block_only(s, false);
                      if (s.strm.avail_out === 0) {
                        return BS_NEED_MORE;
                      }
                    }
                  }
                  s.insert = 0;
                  if (flush === Z_FINISH) {
                    flush_block_only(s, true);
                    if (s.strm.avail_out === 0) {
                      return BS_FINISH_STARTED;
                    }
                    return BS_FINISH_DONE;
                  }
                  if (s.last_lit) {
                    flush_block_only(s, false);
                    if (s.strm.avail_out === 0) {
                      return BS_NEED_MORE;
                    }
                  }
                  return BS_BLOCK_DONE;
                }
                function Config(good_length, max_lazy, nice_length, max_chain, func) {
                  this.good_length = good_length;
                  this.max_lazy = max_lazy;
                  this.nice_length = nice_length;
                  this.max_chain = max_chain;
                  this.func = func;
                }
                var configuration_table;
                configuration_table = [
                  /*      good lazy nice chain */
                  new Config(0, 0, 0, 0, deflate_stored),
                  /* 0 store only */
                  new Config(4, 4, 8, 4, deflate_fast),
                  /* 1 max speed, no lazy matches */
                  new Config(4, 5, 16, 8, deflate_fast),
                  /* 2 */
                  new Config(4, 6, 32, 32, deflate_fast),
                  /* 3 */
                  new Config(4, 4, 16, 16, deflate_slow),
                  /* 4 lazy matches */
                  new Config(8, 16, 32, 32, deflate_slow),
                  /* 5 */
                  new Config(8, 16, 128, 128, deflate_slow),
                  /* 6 */
                  new Config(8, 32, 128, 256, deflate_slow),
                  /* 7 */
                  new Config(32, 128, 258, 1024, deflate_slow),
                  /* 8 */
                  new Config(32, 258, 258, 4096, deflate_slow)
                  /* 9 max compression */
                ];
                function lm_init(s) {
                  s.window_size = 2 * s.w_size;
                  zero(s.head);
                  s.max_lazy_match = configuration_table[s.level].max_lazy;
                  s.good_match = configuration_table[s.level].good_length;
                  s.nice_match = configuration_table[s.level].nice_length;
                  s.max_chain_length = configuration_table[s.level].max_chain;
                  s.strstart = 0;
                  s.block_start = 0;
                  s.lookahead = 0;
                  s.insert = 0;
                  s.match_length = s.prev_length = MIN_MATCH - 1;
                  s.match_available = 0;
                  s.ins_h = 0;
                }
                function DeflateState() {
                  this.strm = null;
                  this.status = 0;
                  this.pending_buf = null;
                  this.pending_buf_size = 0;
                  this.pending_out = 0;
                  this.pending = 0;
                  this.wrap = 0;
                  this.gzhead = null;
                  this.gzindex = 0;
                  this.method = Z_DEFLATED;
                  this.last_flush = -1;
                  this.w_size = 0;
                  this.w_bits = 0;
                  this.w_mask = 0;
                  this.window = null;
                  this.window_size = 0;
                  this.prev = null;
                  this.head = null;
                  this.ins_h = 0;
                  this.hash_size = 0;
                  this.hash_bits = 0;
                  this.hash_mask = 0;
                  this.hash_shift = 0;
                  this.block_start = 0;
                  this.match_length = 0;
                  this.prev_match = 0;
                  this.match_available = 0;
                  this.strstart = 0;
                  this.match_start = 0;
                  this.lookahead = 0;
                  this.prev_length = 0;
                  this.max_chain_length = 0;
                  this.max_lazy_match = 0;
                  this.level = 0;
                  this.strategy = 0;
                  this.good_match = 0;
                  this.nice_match = 0;
                  this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
                  this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
                  this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
                  zero(this.dyn_ltree);
                  zero(this.dyn_dtree);
                  zero(this.bl_tree);
                  this.l_desc = null;
                  this.d_desc = null;
                  this.bl_desc = null;
                  this.bl_count = new utils.Buf16(MAX_BITS + 1);
                  this.heap = new utils.Buf16(2 * L_CODES + 1);
                  zero(this.heap);
                  this.heap_len = 0;
                  this.heap_max = 0;
                  this.depth = new utils.Buf16(2 * L_CODES + 1);
                  zero(this.depth);
                  this.l_buf = 0;
                  this.lit_bufsize = 0;
                  this.last_lit = 0;
                  this.d_buf = 0;
                  this.opt_len = 0;
                  this.static_len = 0;
                  this.matches = 0;
                  this.insert = 0;
                  this.bi_buf = 0;
                  this.bi_valid = 0;
                }
                function deflateResetKeep(strm) {
                  var s;
                  if (!strm || !strm.state) {
                    return err(strm, Z_STREAM_ERROR);
                  }
                  strm.total_in = strm.total_out = 0;
                  strm.data_type = Z_UNKNOWN;
                  s = strm.state;
                  s.pending = 0;
                  s.pending_out = 0;
                  if (s.wrap < 0) {
                    s.wrap = -s.wrap;
                  }
                  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
                  strm.adler = s.wrap === 2 ? 0 : 1;
                  s.last_flush = Z_NO_FLUSH;
                  trees._tr_init(s);
                  return Z_OK;
                }
                function deflateReset(strm) {
                  var ret = deflateResetKeep(strm);
                  if (ret === Z_OK) {
                    lm_init(strm.state);
                  }
                  return ret;
                }
                function deflateSetHeader(strm, head) {
                  if (!strm || !strm.state) {
                    return Z_STREAM_ERROR;
                  }
                  if (strm.state.wrap !== 2) {
                    return Z_STREAM_ERROR;
                  }
                  strm.state.gzhead = head;
                  return Z_OK;
                }
                function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
                  if (!strm) {
                    return Z_STREAM_ERROR;
                  }
                  var wrap = 1;
                  if (level === Z_DEFAULT_COMPRESSION) {
                    level = 6;
                  }
                  if (windowBits < 0) {
                    wrap = 0;
                    windowBits = -windowBits;
                  } else if (windowBits > 15) {
                    wrap = 2;
                    windowBits -= 16;
                  }
                  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
                    return err(strm, Z_STREAM_ERROR);
                  }
                  if (windowBits === 8) {
                    windowBits = 9;
                  }
                  var s = new DeflateState();
                  strm.state = s;
                  s.strm = strm;
                  s.wrap = wrap;
                  s.gzhead = null;
                  s.w_bits = windowBits;
                  s.w_size = 1 << s.w_bits;
                  s.w_mask = s.w_size - 1;
                  s.hash_bits = memLevel + 7;
                  s.hash_size = 1 << s.hash_bits;
                  s.hash_mask = s.hash_size - 1;
                  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
                  s.window = new utils.Buf8(s.w_size * 2);
                  s.head = new utils.Buf16(s.hash_size);
                  s.prev = new utils.Buf16(s.w_size);
                  s.lit_bufsize = 1 << memLevel + 6;
                  s.pending_buf_size = s.lit_bufsize * 4;
                  s.pending_buf = new utils.Buf8(s.pending_buf_size);
                  s.d_buf = 1 * s.lit_bufsize;
                  s.l_buf = (1 + 2) * s.lit_bufsize;
                  s.level = level;
                  s.strategy = strategy;
                  s.method = method;
                  return deflateReset(strm);
                }
                function deflateInit(strm, level) {
                  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
                }
                function deflate(strm, flush) {
                  var old_flush, s;
                  var beg, val;
                  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
                    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
                  }
                  s = strm.state;
                  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
                    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
                  }
                  s.strm = strm;
                  old_flush = s.last_flush;
                  s.last_flush = flush;
                  if (s.status === INIT_STATE) {
                    if (s.wrap === 2) {
                      strm.adler = 0;
                      put_byte(s, 31);
                      put_byte(s, 139);
                      put_byte(s, 8);
                      if (!s.gzhead) {
                        put_byte(s, 0);
                        put_byte(s, 0);
                        put_byte(s, 0);
                        put_byte(s, 0);
                        put_byte(s, 0);
                        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                        put_byte(s, OS_CODE);
                        s.status = BUSY_STATE;
                      } else {
                        put_byte(
                          s,
                          (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
                        );
                        put_byte(s, s.gzhead.time & 255);
                        put_byte(s, s.gzhead.time >> 8 & 255);
                        put_byte(s, s.gzhead.time >> 16 & 255);
                        put_byte(s, s.gzhead.time >> 24 & 255);
                        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                        put_byte(s, s.gzhead.os & 255);
                        if (s.gzhead.extra && s.gzhead.extra.length) {
                          put_byte(s, s.gzhead.extra.length & 255);
                          put_byte(s, s.gzhead.extra.length >> 8 & 255);
                        }
                        if (s.gzhead.hcrc) {
                          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
                        }
                        s.gzindex = 0;
                        s.status = EXTRA_STATE;
                      }
                    } else {
                      var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
                      var level_flags = -1;
                      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                        level_flags = 0;
                      } else if (s.level < 6) {
                        level_flags = 1;
                      } else if (s.level === 6) {
                        level_flags = 2;
                      } else {
                        level_flags = 3;
                      }
                      header |= level_flags << 6;
                      if (s.strstart !== 0) {
                        header |= PRESET_DICT;
                      }
                      header += 31 - header % 31;
                      s.status = BUSY_STATE;
                      putShortMSB(s, header);
                      if (s.strstart !== 0) {
                        putShortMSB(s, strm.adler >>> 16);
                        putShortMSB(s, strm.adler & 65535);
                      }
                      strm.adler = 1;
                    }
                  }
                  if (s.status === EXTRA_STATE) {
                    if (s.gzhead.extra) {
                      beg = s.pending;
                      while (s.gzindex < (s.gzhead.extra.length & 65535)) {
                        if (s.pending === s.pending_buf_size) {
                          if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                          }
                          flush_pending(strm);
                          beg = s.pending;
                          if (s.pending === s.pending_buf_size) {
                            break;
                          }
                        }
                        put_byte(s, s.gzhead.extra[s.gzindex] & 255);
                        s.gzindex++;
                      }
                      if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                      }
                      if (s.gzindex === s.gzhead.extra.length) {
                        s.gzindex = 0;
                        s.status = NAME_STATE;
                      }
                    } else {
                      s.status = NAME_STATE;
                    }
                  }
                  if (s.status === NAME_STATE) {
                    if (s.gzhead.name) {
                      beg = s.pending;
                      do {
                        if (s.pending === s.pending_buf_size) {
                          if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                          }
                          flush_pending(strm);
                          beg = s.pending;
                          if (s.pending === s.pending_buf_size) {
                            val = 1;
                            break;
                          }
                        }
                        if (s.gzindex < s.gzhead.name.length) {
                          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
                        } else {
                          val = 0;
                        }
                        put_byte(s, val);
                      } while (val !== 0);
                      if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                      }
                      if (val === 0) {
                        s.gzindex = 0;
                        s.status = COMMENT_STATE;
                      }
                    } else {
                      s.status = COMMENT_STATE;
                    }
                  }
                  if (s.status === COMMENT_STATE) {
                    if (s.gzhead.comment) {
                      beg = s.pending;
                      do {
                        if (s.pending === s.pending_buf_size) {
                          if (s.gzhead.hcrc && s.pending > beg) {
                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                          }
                          flush_pending(strm);
                          beg = s.pending;
                          if (s.pending === s.pending_buf_size) {
                            val = 1;
                            break;
                          }
                        }
                        if (s.gzindex < s.gzhead.comment.length) {
                          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
                        } else {
                          val = 0;
                        }
                        put_byte(s, val);
                      } while (val !== 0);
                      if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                      }
                      if (val === 0) {
                        s.status = HCRC_STATE;
                      }
                    } else {
                      s.status = HCRC_STATE;
                    }
                  }
                  if (s.status === HCRC_STATE) {
                    if (s.gzhead.hcrc) {
                      if (s.pending + 2 > s.pending_buf_size) {
                        flush_pending(strm);
                      }
                      if (s.pending + 2 <= s.pending_buf_size) {
                        put_byte(s, strm.adler & 255);
                        put_byte(s, strm.adler >> 8 & 255);
                        strm.adler = 0;
                        s.status = BUSY_STATE;
                      }
                    } else {
                      s.status = BUSY_STATE;
                    }
                  }
                  if (s.pending !== 0) {
                    flush_pending(strm);
                    if (strm.avail_out === 0) {
                      s.last_flush = -1;
                      return Z_OK;
                    }
                  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
                    return err(strm, Z_BUF_ERROR);
                  }
                  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
                    return err(strm, Z_BUF_ERROR);
                  }
                  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
                    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
                    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
                      s.status = FINISH_STATE;
                    }
                    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
                      if (strm.avail_out === 0) {
                        s.last_flush = -1;
                      }
                      return Z_OK;
                    }
                    if (bstate === BS_BLOCK_DONE) {
                      if (flush === Z_PARTIAL_FLUSH) {
                        trees._tr_align(s);
                      } else if (flush !== Z_BLOCK) {
                        trees._tr_stored_block(s, 0, 0, false);
                        if (flush === Z_FULL_FLUSH) {
                          zero(s.head);
                          if (s.lookahead === 0) {
                            s.strstart = 0;
                            s.block_start = 0;
                            s.insert = 0;
                          }
                        }
                      }
                      flush_pending(strm);
                      if (strm.avail_out === 0) {
                        s.last_flush = -1;
                        return Z_OK;
                      }
                    }
                  }
                  if (flush !== Z_FINISH) {
                    return Z_OK;
                  }
                  if (s.wrap <= 0) {
                    return Z_STREAM_END;
                  }
                  if (s.wrap === 2) {
                    put_byte(s, strm.adler & 255);
                    put_byte(s, strm.adler >> 8 & 255);
                    put_byte(s, strm.adler >> 16 & 255);
                    put_byte(s, strm.adler >> 24 & 255);
                    put_byte(s, strm.total_in & 255);
                    put_byte(s, strm.total_in >> 8 & 255);
                    put_byte(s, strm.total_in >> 16 & 255);
                    put_byte(s, strm.total_in >> 24 & 255);
                  } else {
                    putShortMSB(s, strm.adler >>> 16);
                    putShortMSB(s, strm.adler & 65535);
                  }
                  flush_pending(strm);
                  if (s.wrap > 0) {
                    s.wrap = -s.wrap;
                  }
                  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
                }
                function deflateEnd(strm) {
                  var status;
                  if (!strm || !strm.state) {
                    return Z_STREAM_ERROR;
                  }
                  status = strm.state.status;
                  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
                    return err(strm, Z_STREAM_ERROR);
                  }
                  strm.state = null;
                  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
                }
                function deflateSetDictionary(strm, dictionary) {
                  var dictLength = dictionary.length;
                  var s;
                  var str, n;
                  var wrap;
                  var avail;
                  var next;
                  var input;
                  var tmpDict;
                  if (!strm || !strm.state) {
                    return Z_STREAM_ERROR;
                  }
                  s = strm.state;
                  wrap = s.wrap;
                  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
                    return Z_STREAM_ERROR;
                  }
                  if (wrap === 1) {
                    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
                  }
                  s.wrap = 0;
                  if (dictLength >= s.w_size) {
                    if (wrap === 0) {
                      zero(s.head);
                      s.strstart = 0;
                      s.block_start = 0;
                      s.insert = 0;
                    }
                    tmpDict = new utils.Buf8(s.w_size);
                    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
                    dictionary = tmpDict;
                    dictLength = s.w_size;
                  }
                  avail = strm.avail_in;
                  next = strm.next_in;
                  input = strm.input;
                  strm.avail_in = dictLength;
                  strm.next_in = 0;
                  strm.input = dictionary;
                  fill_window(s);
                  while (s.lookahead >= MIN_MATCH) {
                    str = s.strstart;
                    n = s.lookahead - (MIN_MATCH - 1);
                    do {
                      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                      s.prev[str & s.w_mask] = s.head[s.ins_h];
                      s.head[s.ins_h] = str;
                      str++;
                    } while (--n);
                    s.strstart = str;
                    s.lookahead = MIN_MATCH - 1;
                    fill_window(s);
                  }
                  s.strstart += s.lookahead;
                  s.block_start = s.strstart;
                  s.insert = s.lookahead;
                  s.lookahead = 0;
                  s.match_length = s.prev_length = MIN_MATCH - 1;
                  s.match_available = 0;
                  strm.next_in = next;
                  strm.input = input;
                  strm.avail_in = avail;
                  s.wrap = wrap;
                  return Z_OK;
                }
                exports2.deflateInit = deflateInit;
                exports2.deflateInit2 = deflateInit2;
                exports2.deflateReset = deflateReset;
                exports2.deflateResetKeep = deflateResetKeep;
                exports2.deflateSetHeader = deflateSetHeader;
                exports2.deflate = deflate;
                exports2.deflateEnd = deflateEnd;
                exports2.deflateSetDictionary = deflateSetDictionary;
                exports2.deflateInfo = "pako deflate (from Nodeca project)";
              }
            ),
            /***/
            4264: (
              /***/
              function(module2) {
                "use strict";
                var BAD = 30;
                var TYPE = 12;
                module2.exports = function inflate_fast(strm, start) {
                  var state;
                  var _in;
                  var last;
                  var _out;
                  var beg;
                  var end;
                  var dmax;
                  var wsize;
                  var whave;
                  var wnext;
                  var s_window;
                  var hold;
                  var bits;
                  var lcode;
                  var dcode;
                  var lmask;
                  var dmask;
                  var here;
                  var op;
                  var len;
                  var dist;
                  var from;
                  var from_source;
                  var input, output;
                  state = strm.state;
                  _in = strm.next_in;
                  input = strm.input;
                  last = _in + (strm.avail_in - 5);
                  _out = strm.next_out;
                  output = strm.output;
                  beg = _out - (start - strm.avail_out);
                  end = _out + (strm.avail_out - 257);
                  dmax = state.dmax;
                  wsize = state.wsize;
                  whave = state.whave;
                  wnext = state.wnext;
                  s_window = state.window;
                  hold = state.hold;
                  bits = state.bits;
                  lcode = state.lencode;
                  dcode = state.distcode;
                  lmask = (1 << state.lenbits) - 1;
                  dmask = (1 << state.distbits) - 1;
                  top:
                    do {
                      if (bits < 15) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                      here = lcode[hold & lmask];
                      dolen:
                        for (; ; ) {
                          op = here >>> 24;
                          hold >>>= op;
                          bits -= op;
                          op = here >>> 16 & 255;
                          if (op === 0) {
                            output[_out++] = here & 65535;
                          } else if (op & 16) {
                            len = here & 65535;
                            op &= 15;
                            if (op) {
                              if (bits < op) {
                                hold += input[_in++] << bits;
                                bits += 8;
                              }
                              len += hold & (1 << op) - 1;
                              hold >>>= op;
                              bits -= op;
                            }
                            if (bits < 15) {
                              hold += input[_in++] << bits;
                              bits += 8;
                              hold += input[_in++] << bits;
                              bits += 8;
                            }
                            here = dcode[hold & dmask];
                            dodist:
                              for (; ; ) {
                                op = here >>> 24;
                                hold >>>= op;
                                bits -= op;
                                op = here >>> 16 & 255;
                                if (op & 16) {
                                  dist = here & 65535;
                                  op &= 15;
                                  if (bits < op) {
                                    hold += input[_in++] << bits;
                                    bits += 8;
                                    if (bits < op) {
                                      hold += input[_in++] << bits;
                                      bits += 8;
                                    }
                                  }
                                  dist += hold & (1 << op) - 1;
                                  if (dist > dmax) {
                                    strm.msg = "invalid distance too far back";
                                    state.mode = BAD;
                                    break top;
                                  }
                                  hold >>>= op;
                                  bits -= op;
                                  op = _out - beg;
                                  if (dist > op) {
                                    op = dist - op;
                                    if (op > whave) {
                                      if (state.sane) {
                                        strm.msg = "invalid distance too far back";
                                        state.mode = BAD;
                                        break top;
                                      }
                                    }
                                    from = 0;
                                    from_source = s_window;
                                    if (wnext === 0) {
                                      from += wsize - op;
                                      if (op < len) {
                                        len -= op;
                                        do {
                                          output[_out++] = s_window[from++];
                                        } while (--op);
                                        from = _out - dist;
                                        from_source = output;
                                      }
                                    } else if (wnext < op) {
                                      from += wsize + wnext - op;
                                      op -= wnext;
                                      if (op < len) {
                                        len -= op;
                                        do {
                                          output[_out++] = s_window[from++];
                                        } while (--op);
                                        from = 0;
                                        if (wnext < len) {
                                          op = wnext;
                                          len -= op;
                                          do {
                                            output[_out++] = s_window[from++];
                                          } while (--op);
                                          from = _out - dist;
                                          from_source = output;
                                        }
                                      }
                                    } else {
                                      from += wnext - op;
                                      if (op < len) {
                                        len -= op;
                                        do {
                                          output[_out++] = s_window[from++];
                                        } while (--op);
                                        from = _out - dist;
                                        from_source = output;
                                      }
                                    }
                                    while (len > 2) {
                                      output[_out++] = from_source[from++];
                                      output[_out++] = from_source[from++];
                                      output[_out++] = from_source[from++];
                                      len -= 3;
                                    }
                                    if (len) {
                                      output[_out++] = from_source[from++];
                                      if (len > 1) {
                                        output[_out++] = from_source[from++];
                                      }
                                    }
                                  } else {
                                    from = _out - dist;
                                    do {
                                      output[_out++] = output[from++];
                                      output[_out++] = output[from++];
                                      output[_out++] = output[from++];
                                      len -= 3;
                                    } while (len > 2);
                                    if (len) {
                                      output[_out++] = output[from++];
                                      if (len > 1) {
                                        output[_out++] = output[from++];
                                      }
                                    }
                                  }
                                } else if ((op & 64) === 0) {
                                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                                  continue dodist;
                                } else {
                                  strm.msg = "invalid distance code";
                                  state.mode = BAD;
                                  break top;
                                }
                                break;
                              }
                          } else if ((op & 64) === 0) {
                            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                            continue dolen;
                          } else if (op & 32) {
                            state.mode = TYPE;
                            break top;
                          } else {
                            strm.msg = "invalid literal/length code";
                            state.mode = BAD;
                            break top;
                          }
                          break;
                        }
                    } while (_in < last && _out < end);
                  len = bits >> 3;
                  _in -= len;
                  bits -= len << 3;
                  hold &= (1 << bits) - 1;
                  strm.next_in = _in;
                  strm.next_out = _out;
                  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
                  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
                  state.hold = hold;
                  state.bits = bits;
                  return;
                };
              }
            ),
            /***/
            7948: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var utils = __webpack_require__2(4236);
                var adler32 = __webpack_require__2(6069);
                var crc32 = __webpack_require__2(2869);
                var inflate_fast = __webpack_require__2(4264);
                var inflate_table = __webpack_require__2(9241);
                var CODES = 0;
                var LENS = 1;
                var DISTS = 2;
                var Z_FINISH = 4;
                var Z_BLOCK = 5;
                var Z_TREES = 6;
                var Z_OK = 0;
                var Z_STREAM_END = 1;
                var Z_NEED_DICT = 2;
                var Z_STREAM_ERROR = -2;
                var Z_DATA_ERROR = -3;
                var Z_MEM_ERROR = -4;
                var Z_BUF_ERROR = -5;
                var Z_DEFLATED = 8;
                var HEAD = 1;
                var FLAGS = 2;
                var TIME = 3;
                var OS = 4;
                var EXLEN = 5;
                var EXTRA = 6;
                var NAME = 7;
                var COMMENT = 8;
                var HCRC = 9;
                var DICTID = 10;
                var DICT = 11;
                var TYPE = 12;
                var TYPEDO = 13;
                var STORED = 14;
                var COPY_ = 15;
                var COPY = 16;
                var TABLE = 17;
                var LENLENS = 18;
                var CODELENS = 19;
                var LEN_ = 20;
                var LEN = 21;
                var LENEXT = 22;
                var DIST = 23;
                var DISTEXT = 24;
                var MATCH = 25;
                var LIT = 26;
                var CHECK = 27;
                var LENGTH = 28;
                var DONE = 29;
                var BAD = 30;
                var MEM = 31;
                var SYNC = 32;
                var ENOUGH_LENS = 852;
                var ENOUGH_DISTS = 592;
                var MAX_WBITS = 15;
                var DEF_WBITS = MAX_WBITS;
                function zswap32(q) {
                  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
                }
                function InflateState() {
                  this.mode = 0;
                  this.last = false;
                  this.wrap = 0;
                  this.havedict = false;
                  this.flags = 0;
                  this.dmax = 0;
                  this.check = 0;
                  this.total = 0;
                  this.head = null;
                  this.wbits = 0;
                  this.wsize = 0;
                  this.whave = 0;
                  this.wnext = 0;
                  this.window = null;
                  this.hold = 0;
                  this.bits = 0;
                  this.length = 0;
                  this.offset = 0;
                  this.extra = 0;
                  this.lencode = null;
                  this.distcode = null;
                  this.lenbits = 0;
                  this.distbits = 0;
                  this.ncode = 0;
                  this.nlen = 0;
                  this.ndist = 0;
                  this.have = 0;
                  this.next = null;
                  this.lens = new utils.Buf16(320);
                  this.work = new utils.Buf16(288);
                  this.lendyn = null;
                  this.distdyn = null;
                  this.sane = 0;
                  this.back = 0;
                  this.was = 0;
                }
                function inflateResetKeep(strm) {
                  var state;
                  if (!strm || !strm.state) {
                    return Z_STREAM_ERROR;
                  }
                  state = strm.state;
                  strm.total_in = strm.total_out = state.total = 0;
                  strm.msg = "";
                  if (state.wrap) {
                    strm.adler = state.wrap & 1;
                  }
                  state.mode = HEAD;
                  state.last = 0;
                  state.havedict = 0;
                  state.dmax = 32768;
                  state.head = null;
                  state.hold = 0;
                  state.bits = 0;
                  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
                  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
                  state.sane = 1;
                  state.back = -1;
                  return Z_OK;
                }
                function inflateReset(strm) {
                  var state;
                  if (!strm || !strm.state) {
                    return Z_STREAM_ERROR;
                  }
                  state = strm.state;
                  state.wsize = 0;
                  state.whave = 0;
                  state.wnext = 0;
                  return inflateResetKeep(strm);
                }
                function inflateReset2(strm, windowBits) {
                  var wrap;
                  var state;
                  if (!strm || !strm.state) {
                    return Z_STREAM_ERROR;
                  }
                  state = strm.state;
                  if (windowBits < 0) {
                    wrap = 0;
                    windowBits = -windowBits;
                  } else {
                    wrap = (windowBits >> 4) + 1;
                    if (windowBits < 48) {
                      windowBits &= 15;
                    }
                  }
                  if (windowBits && (windowBits < 8 || windowBits > 15)) {
                    return Z_STREAM_ERROR;
                  }
                  if (state.window !== null && state.wbits !== windowBits) {
                    state.window = null;
                  }
                  state.wrap = wrap;
                  state.wbits = windowBits;
                  return inflateReset(strm);
                }
                function inflateInit2(strm, windowBits) {
                  var ret;
                  var state;
                  if (!strm) {
                    return Z_STREAM_ERROR;
                  }
                  state = new InflateState();
                  strm.state = state;
                  state.window = null;
                  ret = inflateReset2(strm, windowBits);
                  if (ret !== Z_OK) {
                    strm.state = null;
                  }
                  return ret;
                }
                function inflateInit(strm) {
                  return inflateInit2(strm, DEF_WBITS);
                }
                var virgin = true;
                var lenfix, distfix;
                function fixedtables(state) {
                  if (virgin) {
                    var sym;
                    lenfix = new utils.Buf32(512);
                    distfix = new utils.Buf32(32);
                    sym = 0;
                    while (sym < 144) {
                      state.lens[sym++] = 8;
                    }
                    while (sym < 256) {
                      state.lens[sym++] = 9;
                    }
                    while (sym < 280) {
                      state.lens[sym++] = 7;
                    }
                    while (sym < 288) {
                      state.lens[sym++] = 8;
                    }
                    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
                    sym = 0;
                    while (sym < 32) {
                      state.lens[sym++] = 5;
                    }
                    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
                    virgin = false;
                  }
                  state.lencode = lenfix;
                  state.lenbits = 9;
                  state.distcode = distfix;
                  state.distbits = 5;
                }
                function updatewindow(strm, src, end, copy) {
                  var dist;
                  var state = strm.state;
                  if (state.window === null) {
                    state.wsize = 1 << state.wbits;
                    state.wnext = 0;
                    state.whave = 0;
                    state.window = new utils.Buf8(state.wsize);
                  }
                  if (copy >= state.wsize) {
                    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
                    state.wnext = 0;
                    state.whave = state.wsize;
                  } else {
                    dist = state.wsize - state.wnext;
                    if (dist > copy) {
                      dist = copy;
                    }
                    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
                    copy -= dist;
                    if (copy) {
                      utils.arraySet(state.window, src, end - copy, copy, 0);
                      state.wnext = copy;
                      state.whave = state.wsize;
                    } else {
                      state.wnext += dist;
                      if (state.wnext === state.wsize) {
                        state.wnext = 0;
                      }
                      if (state.whave < state.wsize) {
                        state.whave += dist;
                      }
                    }
                  }
                  return 0;
                }
                function inflate(strm, flush) {
                  var state;
                  var input, output;
                  var next;
                  var put;
                  var have, left;
                  var hold;
                  var bits;
                  var _in, _out;
                  var copy;
                  var from;
                  var from_source;
                  var here = 0;
                  var here_bits, here_op, here_val;
                  var last_bits, last_op, last_val;
                  var len;
                  var ret;
                  var hbuf = new utils.Buf8(4);
                  var opts;
                  var n;
                  var order = (
                    /* permutation of code lengths */
                    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
                  );
                  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
                    return Z_STREAM_ERROR;
                  }
                  state = strm.state;
                  if (state.mode === TYPE) {
                    state.mode = TYPEDO;
                  }
                  put = strm.next_out;
                  output = strm.output;
                  left = strm.avail_out;
                  next = strm.next_in;
                  input = strm.input;
                  have = strm.avail_in;
                  hold = state.hold;
                  bits = state.bits;
                  _in = have;
                  _out = left;
                  ret = Z_OK;
                  inf_leave:
                    for (; ; ) {
                      switch (state.mode) {
                        case HEAD:
                          if (state.wrap === 0) {
                            state.mode = TYPEDO;
                            break;
                          }
                          while (bits < 16) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          if (state.wrap & 2 && hold === 35615) {
                            state.check = 0;
                            hbuf[0] = hold & 255;
                            hbuf[1] = hold >>> 8 & 255;
                            state.check = crc32(state.check, hbuf, 2, 0);
                            hold = 0;
                            bits = 0;
                            state.mode = FLAGS;
                            break;
                          }
                          state.flags = 0;
                          if (state.head) {
                            state.head.done = false;
                          }
                          if (!(state.wrap & 1) || /* check if zlib header allowed */
                          (((hold & 255) << 8) + (hold >> 8)) % 31) {
                            strm.msg = "incorrect header check";
                            state.mode = BAD;
                            break;
                          }
                          if ((hold & 15) !== Z_DEFLATED) {
                            strm.msg = "unknown compression method";
                            state.mode = BAD;
                            break;
                          }
                          hold >>>= 4;
                          bits -= 4;
                          len = (hold & 15) + 8;
                          if (state.wbits === 0) {
                            state.wbits = len;
                          } else if (len > state.wbits) {
                            strm.msg = "invalid window size";
                            state.mode = BAD;
                            break;
                          }
                          state.dmax = 1 << len;
                          strm.adler = state.check = 1;
                          state.mode = hold & 512 ? DICTID : TYPE;
                          hold = 0;
                          bits = 0;
                          break;
                        case FLAGS:
                          while (bits < 16) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          state.flags = hold;
                          if ((state.flags & 255) !== Z_DEFLATED) {
                            strm.msg = "unknown compression method";
                            state.mode = BAD;
                            break;
                          }
                          if (state.flags & 57344) {
                            strm.msg = "unknown header flags set";
                            state.mode = BAD;
                            break;
                          }
                          if (state.head) {
                            state.head.text = hold >> 8 & 1;
                          }
                          if (state.flags & 512) {
                            hbuf[0] = hold & 255;
                            hbuf[1] = hold >>> 8 & 255;
                            state.check = crc32(state.check, hbuf, 2, 0);
                          }
                          hold = 0;
                          bits = 0;
                          state.mode = TIME;
                        case TIME:
                          while (bits < 32) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          if (state.head) {
                            state.head.time = hold;
                          }
                          if (state.flags & 512) {
                            hbuf[0] = hold & 255;
                            hbuf[1] = hold >>> 8 & 255;
                            hbuf[2] = hold >>> 16 & 255;
                            hbuf[3] = hold >>> 24 & 255;
                            state.check = crc32(state.check, hbuf, 4, 0);
                          }
                          hold = 0;
                          bits = 0;
                          state.mode = OS;
                        case OS:
                          while (bits < 16) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          if (state.head) {
                            state.head.xflags = hold & 255;
                            state.head.os = hold >> 8;
                          }
                          if (state.flags & 512) {
                            hbuf[0] = hold & 255;
                            hbuf[1] = hold >>> 8 & 255;
                            state.check = crc32(state.check, hbuf, 2, 0);
                          }
                          hold = 0;
                          bits = 0;
                          state.mode = EXLEN;
                        case EXLEN:
                          if (state.flags & 1024) {
                            while (bits < 16) {
                              if (have === 0) {
                                break inf_leave;
                              }
                              have--;
                              hold += input[next++] << bits;
                              bits += 8;
                            }
                            state.length = hold;
                            if (state.head) {
                              state.head.extra_len = hold;
                            }
                            if (state.flags & 512) {
                              hbuf[0] = hold & 255;
                              hbuf[1] = hold >>> 8 & 255;
                              state.check = crc32(state.check, hbuf, 2, 0);
                            }
                            hold = 0;
                            bits = 0;
                          } else if (state.head) {
                            state.head.extra = null;
                          }
                          state.mode = EXTRA;
                        case EXTRA:
                          if (state.flags & 1024) {
                            copy = state.length;
                            if (copy > have) {
                              copy = have;
                            }
                            if (copy) {
                              if (state.head) {
                                len = state.head.extra_len - state.length;
                                if (!state.head.extra) {
                                  state.head.extra = new Array(state.head.extra_len);
                                }
                                utils.arraySet(
                                  state.head.extra,
                                  input,
                                  next,
                                  // extra field is limited to 65536 bytes
                                  // - no need for additional size check
                                  copy,
                                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                                  len
                                );
                              }
                              if (state.flags & 512) {
                                state.check = crc32(state.check, input, copy, next);
                              }
                              have -= copy;
                              next += copy;
                              state.length -= copy;
                            }
                            if (state.length) {
                              break inf_leave;
                            }
                          }
                          state.length = 0;
                          state.mode = NAME;
                        case NAME:
                          if (state.flags & 2048) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            copy = 0;
                            do {
                              len = input[next + copy++];
                              if (state.head && len && state.length < 65536) {
                                state.head.name += String.fromCharCode(len);
                              }
                            } while (len && copy < have);
                            if (state.flags & 512) {
                              state.check = crc32(state.check, input, copy, next);
                            }
                            have -= copy;
                            next += copy;
                            if (len) {
                              break inf_leave;
                            }
                          } else if (state.head) {
                            state.head.name = null;
                          }
                          state.length = 0;
                          state.mode = COMMENT;
                        case COMMENT:
                          if (state.flags & 4096) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            copy = 0;
                            do {
                              len = input[next + copy++];
                              if (state.head && len && state.length < 65536) {
                                state.head.comment += String.fromCharCode(len);
                              }
                            } while (len && copy < have);
                            if (state.flags & 512) {
                              state.check = crc32(state.check, input, copy, next);
                            }
                            have -= copy;
                            next += copy;
                            if (len) {
                              break inf_leave;
                            }
                          } else if (state.head) {
                            state.head.comment = null;
                          }
                          state.mode = HCRC;
                        case HCRC:
                          if (state.flags & 512) {
                            while (bits < 16) {
                              if (have === 0) {
                                break inf_leave;
                              }
                              have--;
                              hold += input[next++] << bits;
                              bits += 8;
                            }
                            if (hold !== (state.check & 65535)) {
                              strm.msg = "header crc mismatch";
                              state.mode = BAD;
                              break;
                            }
                            hold = 0;
                            bits = 0;
                          }
                          if (state.head) {
                            state.head.hcrc = state.flags >> 9 & 1;
                            state.head.done = true;
                          }
                          strm.adler = state.check = 0;
                          state.mode = TYPE;
                          break;
                        case DICTID:
                          while (bits < 32) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          strm.adler = state.check = zswap32(hold);
                          hold = 0;
                          bits = 0;
                          state.mode = DICT;
                        case DICT:
                          if (state.havedict === 0) {
                            strm.next_out = put;
                            strm.avail_out = left;
                            strm.next_in = next;
                            strm.avail_in = have;
                            state.hold = hold;
                            state.bits = bits;
                            return Z_NEED_DICT;
                          }
                          strm.adler = state.check = 1;
                          state.mode = TYPE;
                        case TYPE:
                          if (flush === Z_BLOCK || flush === Z_TREES) {
                            break inf_leave;
                          }
                        case TYPEDO:
                          if (state.last) {
                            hold >>>= bits & 7;
                            bits -= bits & 7;
                            state.mode = CHECK;
                            break;
                          }
                          while (bits < 3) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          state.last = hold & 1;
                          hold >>>= 1;
                          bits -= 1;
                          switch (hold & 3) {
                            case 0:
                              state.mode = STORED;
                              break;
                            case 1:
                              fixedtables(state);
                              state.mode = LEN_;
                              if (flush === Z_TREES) {
                                hold >>>= 2;
                                bits -= 2;
                                break inf_leave;
                              }
                              break;
                            case 2:
                              state.mode = TABLE;
                              break;
                            case 3:
                              strm.msg = "invalid block type";
                              state.mode = BAD;
                          }
                          hold >>>= 2;
                          bits -= 2;
                          break;
                        case STORED:
                          hold >>>= bits & 7;
                          bits -= bits & 7;
                          while (bits < 32) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                            strm.msg = "invalid stored block lengths";
                            state.mode = BAD;
                            break;
                          }
                          state.length = hold & 65535;
                          hold = 0;
                          bits = 0;
                          state.mode = COPY_;
                          if (flush === Z_TREES) {
                            break inf_leave;
                          }
                        case COPY_:
                          state.mode = COPY;
                        case COPY:
                          copy = state.length;
                          if (copy) {
                            if (copy > have) {
                              copy = have;
                            }
                            if (copy > left) {
                              copy = left;
                            }
                            if (copy === 0) {
                              break inf_leave;
                            }
                            utils.arraySet(output, input, next, copy, put);
                            have -= copy;
                            next += copy;
                            left -= copy;
                            put += copy;
                            state.length -= copy;
                            break;
                          }
                          state.mode = TYPE;
                          break;
                        case TABLE:
                          while (bits < 14) {
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          state.nlen = (hold & 31) + 257;
                          hold >>>= 5;
                          bits -= 5;
                          state.ndist = (hold & 31) + 1;
                          hold >>>= 5;
                          bits -= 5;
                          state.ncode = (hold & 15) + 4;
                          hold >>>= 4;
                          bits -= 4;
                          if (state.nlen > 286 || state.ndist > 30) {
                            strm.msg = "too many length or distance symbols";
                            state.mode = BAD;
                            break;
                          }
                          state.have = 0;
                          state.mode = LENLENS;
                        case LENLENS:
                          while (state.have < state.ncode) {
                            while (bits < 3) {
                              if (have === 0) {
                                break inf_leave;
                              }
                              have--;
                              hold += input[next++] << bits;
                              bits += 8;
                            }
                            state.lens[order[state.have++]] = hold & 7;
                            hold >>>= 3;
                            bits -= 3;
                          }
                          while (state.have < 19) {
                            state.lens[order[state.have++]] = 0;
                          }
                          state.lencode = state.lendyn;
                          state.lenbits = 7;
                          opts = { bits: state.lenbits };
                          ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                          state.lenbits = opts.bits;
                          if (ret) {
                            strm.msg = "invalid code lengths set";
                            state.mode = BAD;
                            break;
                          }
                          state.have = 0;
                          state.mode = CODELENS;
                        case CODELENS:
                          while (state.have < state.nlen + state.ndist) {
                            for (; ; ) {
                              here = state.lencode[hold & (1 << state.lenbits) - 1];
                              here_bits = here >>> 24;
                              here_op = here >>> 16 & 255;
                              here_val = here & 65535;
                              if (here_bits <= bits) {
                                break;
                              }
                              if (have === 0) {
                                break inf_leave;
                              }
                              have--;
                              hold += input[next++] << bits;
                              bits += 8;
                            }
                            if (here_val < 16) {
                              hold >>>= here_bits;
                              bits -= here_bits;
                              state.lens[state.have++] = here_val;
                            } else {
                              if (here_val === 16) {
                                n = here_bits + 2;
                                while (bits < n) {
                                  if (have === 0) {
                                    break inf_leave;
                                  }
                                  have--;
                                  hold += input[next++] << bits;
                                  bits += 8;
                                }
                                hold >>>= here_bits;
                                bits -= here_bits;
                                if (state.have === 0) {
                                  strm.msg = "invalid bit length repeat";
                                  state.mode = BAD;
                                  break;
                                }
                                len = state.lens[state.have - 1];
                                copy = 3 + (hold & 3);
                                hold >>>= 2;
                                bits -= 2;
                              } else if (here_val === 17) {
                                n = here_bits + 3;
                                while (bits < n) {
                                  if (have === 0) {
                                    break inf_leave;
                                  }
                                  have--;
                                  hold += input[next++] << bits;
                                  bits += 8;
                                }
                                hold >>>= here_bits;
                                bits -= here_bits;
                                len = 0;
                                copy = 3 + (hold & 7);
                                hold >>>= 3;
                                bits -= 3;
                              } else {
                                n = here_bits + 7;
                                while (bits < n) {
                                  if (have === 0) {
                                    break inf_leave;
                                  }
                                  have--;
                                  hold += input[next++] << bits;
                                  bits += 8;
                                }
                                hold >>>= here_bits;
                                bits -= here_bits;
                                len = 0;
                                copy = 11 + (hold & 127);
                                hold >>>= 7;
                                bits -= 7;
                              }
                              if (state.have + copy > state.nlen + state.ndist) {
                                strm.msg = "invalid bit length repeat";
                                state.mode = BAD;
                                break;
                              }
                              while (copy--) {
                                state.lens[state.have++] = len;
                              }
                            }
                          }
                          if (state.mode === BAD) {
                            break;
                          }
                          if (state.lens[256] === 0) {
                            strm.msg = "invalid code -- missing end-of-block";
                            state.mode = BAD;
                            break;
                          }
                          state.lenbits = 9;
                          opts = { bits: state.lenbits };
                          ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                          state.lenbits = opts.bits;
                          if (ret) {
                            strm.msg = "invalid literal/lengths set";
                            state.mode = BAD;
                            break;
                          }
                          state.distbits = 6;
                          state.distcode = state.distdyn;
                          opts = { bits: state.distbits };
                          ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                          state.distbits = opts.bits;
                          if (ret) {
                            strm.msg = "invalid distances set";
                            state.mode = BAD;
                            break;
                          }
                          state.mode = LEN_;
                          if (flush === Z_TREES) {
                            break inf_leave;
                          }
                        case LEN_:
                          state.mode = LEN;
                        case LEN:
                          if (have >= 6 && left >= 258) {
                            strm.next_out = put;
                            strm.avail_out = left;
                            strm.next_in = next;
                            strm.avail_in = have;
                            state.hold = hold;
                            state.bits = bits;
                            inflate_fast(strm, _out);
                            put = strm.next_out;
                            output = strm.output;
                            left = strm.avail_out;
                            next = strm.next_in;
                            input = strm.input;
                            have = strm.avail_in;
                            hold = state.hold;
                            bits = state.bits;
                            if (state.mode === TYPE) {
                              state.back = -1;
                            }
                            break;
                          }
                          state.back = 0;
                          for (; ; ) {
                            here = state.lencode[hold & (1 << state.lenbits) - 1];
                            here_bits = here >>> 24;
                            here_op = here >>> 16 & 255;
                            here_val = here & 65535;
                            if (here_bits <= bits) {
                              break;
                            }
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          if (here_op && (here_op & 240) === 0) {
                            last_bits = here_bits;
                            last_op = here_op;
                            last_val = here_val;
                            for (; ; ) {
                              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                              here_bits = here >>> 24;
                              here_op = here >>> 16 & 255;
                              here_val = here & 65535;
                              if (last_bits + here_bits <= bits) {
                                break;
                              }
                              if (have === 0) {
                                break inf_leave;
                              }
                              have--;
                              hold += input[next++] << bits;
                              bits += 8;
                            }
                            hold >>>= last_bits;
                            bits -= last_bits;
                            state.back += last_bits;
                          }
                          hold >>>= here_bits;
                          bits -= here_bits;
                          state.back += here_bits;
                          state.length = here_val;
                          if (here_op === 0) {
                            state.mode = LIT;
                            break;
                          }
                          if (here_op & 32) {
                            state.back = -1;
                            state.mode = TYPE;
                            break;
                          }
                          if (here_op & 64) {
                            strm.msg = "invalid literal/length code";
                            state.mode = BAD;
                            break;
                          }
                          state.extra = here_op & 15;
                          state.mode = LENEXT;
                        case LENEXT:
                          if (state.extra) {
                            n = state.extra;
                            while (bits < n) {
                              if (have === 0) {
                                break inf_leave;
                              }
                              have--;
                              hold += input[next++] << bits;
                              bits += 8;
                            }
                            state.length += hold & (1 << state.extra) - 1;
                            hold >>>= state.extra;
                            bits -= state.extra;
                            state.back += state.extra;
                          }
                          state.was = state.length;
                          state.mode = DIST;
                        case DIST:
                          for (; ; ) {
                            here = state.distcode[hold & (1 << state.distbits) - 1];
                            here_bits = here >>> 24;
                            here_op = here >>> 16 & 255;
                            here_val = here & 65535;
                            if (here_bits <= bits) {
                              break;
                            }
                            if (have === 0) {
                              break inf_leave;
                            }
                            have--;
                            hold += input[next++] << bits;
                            bits += 8;
                          }
                          if ((here_op & 240) === 0) {
                            last_bits = here_bits;
                            last_op = here_op;
                            last_val = here_val;
                            for (; ; ) {
                              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                              here_bits = here >>> 24;
                              here_op = here >>> 16 & 255;
                              here_val = here & 65535;
                              if (last_bits + here_bits <= bits) {
                                break;
                              }
                              if (have === 0) {
                                break inf_leave;
                              }
                              have--;
                              hold += input[next++] << bits;
                              bits += 8;
                            }
                            hold >>>= last_bits;
                            bits -= last_bits;
                            state.back += last_bits;
                          }
                          hold >>>= here_bits;
                          bits -= here_bits;
                          state.back += here_bits;
                          if (here_op & 64) {
                            strm.msg = "invalid distance code";
                            state.mode = BAD;
                            break;
                          }
                          state.offset = here_val;
                          state.extra = here_op & 15;
                          state.mode = DISTEXT;
                        case DISTEXT:
                          if (state.extra) {
                            n = state.extra;
                            while (bits < n) {
                              if (have === 0) {
                                break inf_leave;
                              }
                              have--;
                              hold += input[next++] << bits;
                              bits += 8;
                            }
                            state.offset += hold & (1 << state.extra) - 1;
                            hold >>>= state.extra;
                            bits -= state.extra;
                            state.back += state.extra;
                          }
                          if (state.offset > state.dmax) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break;
                          }
                          state.mode = MATCH;
                        case MATCH:
                          if (left === 0) {
                            break inf_leave;
                          }
                          copy = _out - left;
                          if (state.offset > copy) {
                            copy = state.offset - copy;
                            if (copy > state.whave) {
                              if (state.sane) {
                                strm.msg = "invalid distance too far back";
                                state.mode = BAD;
                                break;
                              }
                            }
                            if (copy > state.wnext) {
                              copy -= state.wnext;
                              from = state.wsize - copy;
                            } else {
                              from = state.wnext - copy;
                            }
                            if (copy > state.length) {
                              copy = state.length;
                            }
                            from_source = state.window;
                          } else {
                            from_source = output;
                            from = put - state.offset;
                            copy = state.length;
                          }
                          if (copy > left) {
                            copy = left;
                          }
                          left -= copy;
                          state.length -= copy;
                          do {
                            output[put++] = from_source[from++];
                          } while (--copy);
                          if (state.length === 0) {
                            state.mode = LEN;
                          }
                          break;
                        case LIT:
                          if (left === 0) {
                            break inf_leave;
                          }
                          output[put++] = state.length;
                          left--;
                          state.mode = LEN;
                          break;
                        case CHECK:
                          if (state.wrap) {
                            while (bits < 32) {
                              if (have === 0) {
                                break inf_leave;
                              }
                              have--;
                              hold |= input[next++] << bits;
                              bits += 8;
                            }
                            _out -= left;
                            strm.total_out += _out;
                            state.total += _out;
                            if (_out) {
                              strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                              state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                            }
                            _out = left;
                            if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                              strm.msg = "incorrect data check";
                              state.mode = BAD;
                              break;
                            }
                            hold = 0;
                            bits = 0;
                          }
                          state.mode = LENGTH;
                        case LENGTH:
                          if (state.wrap && state.flags) {
                            while (bits < 32) {
                              if (have === 0) {
                                break inf_leave;
                              }
                              have--;
                              hold += input[next++] << bits;
                              bits += 8;
                            }
                            if (hold !== (state.total & 4294967295)) {
                              strm.msg = "incorrect length check";
                              state.mode = BAD;
                              break;
                            }
                            hold = 0;
                            bits = 0;
                          }
                          state.mode = DONE;
                        case DONE:
                          ret = Z_STREAM_END;
                          break inf_leave;
                        case BAD:
                          ret = Z_DATA_ERROR;
                          break inf_leave;
                        case MEM:
                          return Z_MEM_ERROR;
                        case SYNC:
                        default:
                          return Z_STREAM_ERROR;
                      }
                    }
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
                    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
                      state.mode = MEM;
                      return Z_MEM_ERROR;
                    }
                  }
                  _in -= strm.avail_in;
                  _out -= strm.avail_out;
                  strm.total_in += _in;
                  strm.total_out += _out;
                  state.total += _out;
                  if (state.wrap && _out) {
                    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
                    state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
                  }
                  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
                  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
                    ret = Z_BUF_ERROR;
                  }
                  return ret;
                }
                function inflateEnd(strm) {
                  if (!strm || !strm.state) {
                    return Z_STREAM_ERROR;
                  }
                  var state = strm.state;
                  if (state.window) {
                    state.window = null;
                  }
                  strm.state = null;
                  return Z_OK;
                }
                function inflateGetHeader(strm, head) {
                  var state;
                  if (!strm || !strm.state) {
                    return Z_STREAM_ERROR;
                  }
                  state = strm.state;
                  if ((state.wrap & 2) === 0) {
                    return Z_STREAM_ERROR;
                  }
                  state.head = head;
                  head.done = false;
                  return Z_OK;
                }
                function inflateSetDictionary(strm, dictionary) {
                  var dictLength = dictionary.length;
                  var state;
                  var dictid;
                  var ret;
                  if (!strm || !strm.state) {
                    return Z_STREAM_ERROR;
                  }
                  state = strm.state;
                  if (state.wrap !== 0 && state.mode !== DICT) {
                    return Z_STREAM_ERROR;
                  }
                  if (state.mode === DICT) {
                    dictid = 1;
                    dictid = adler32(dictid, dictionary, dictLength, 0);
                    if (dictid !== state.check) {
                      return Z_DATA_ERROR;
                    }
                  }
                  ret = updatewindow(strm, dictionary, dictLength, dictLength);
                  if (ret) {
                    state.mode = MEM;
                    return Z_MEM_ERROR;
                  }
                  state.havedict = 1;
                  return Z_OK;
                }
                exports2.inflateReset = inflateReset;
                exports2.inflateReset2 = inflateReset2;
                exports2.inflateResetKeep = inflateResetKeep;
                exports2.inflateInit = inflateInit;
                exports2.inflateInit2 = inflateInit2;
                exports2.inflate = inflate;
                exports2.inflateEnd = inflateEnd;
                exports2.inflateGetHeader = inflateGetHeader;
                exports2.inflateSetDictionary = inflateSetDictionary;
                exports2.inflateInfo = "pako inflate (from Nodeca project)";
              }
            ),
            /***/
            9241: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var utils = __webpack_require__2(4236);
                var MAXBITS = 15;
                var ENOUGH_LENS = 852;
                var ENOUGH_DISTS = 592;
                var CODES = 0;
                var LENS = 1;
                var DISTS = 2;
                var lbase = [
                  /* Length codes 257..285 base */
                  3,
                  4,
                  5,
                  6,
                  7,
                  8,
                  9,
                  10,
                  11,
                  13,
                  15,
                  17,
                  19,
                  23,
                  27,
                  31,
                  35,
                  43,
                  51,
                  59,
                  67,
                  83,
                  99,
                  115,
                  131,
                  163,
                  195,
                  227,
                  258,
                  0,
                  0
                ];
                var lext = [
                  /* Length codes 257..285 extra */
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  16,
                  17,
                  17,
                  17,
                  17,
                  18,
                  18,
                  18,
                  18,
                  19,
                  19,
                  19,
                  19,
                  20,
                  20,
                  20,
                  20,
                  21,
                  21,
                  21,
                  21,
                  16,
                  72,
                  78
                ];
                var dbase = [
                  /* Distance codes 0..29 base */
                  1,
                  2,
                  3,
                  4,
                  5,
                  7,
                  9,
                  13,
                  17,
                  25,
                  33,
                  49,
                  65,
                  97,
                  129,
                  193,
                  257,
                  385,
                  513,
                  769,
                  1025,
                  1537,
                  2049,
                  3073,
                  4097,
                  6145,
                  8193,
                  12289,
                  16385,
                  24577,
                  0,
                  0
                ];
                var dext = [
                  /* Distance codes 0..29 extra */
                  16,
                  16,
                  16,
                  16,
                  17,
                  17,
                  18,
                  18,
                  19,
                  19,
                  20,
                  20,
                  21,
                  21,
                  22,
                  22,
                  23,
                  23,
                  24,
                  24,
                  25,
                  25,
                  26,
                  26,
                  27,
                  27,
                  28,
                  28,
                  29,
                  29,
                  64,
                  64
                ];
                module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
                  var bits = opts.bits;
                  var len = 0;
                  var sym = 0;
                  var min = 0, max = 0;
                  var root = 0;
                  var curr = 0;
                  var drop = 0;
                  var left = 0;
                  var used = 0;
                  var huff = 0;
                  var incr;
                  var fill;
                  var low;
                  var mask;
                  var next;
                  var base = null;
                  var base_index = 0;
                  var end;
                  var count = new utils.Buf16(MAXBITS + 1);
                  var offs = new utils.Buf16(MAXBITS + 1);
                  var extra = null;
                  var extra_index = 0;
                  var here_bits, here_op, here_val;
                  for (len = 0; len <= MAXBITS; len++) {
                    count[len] = 0;
                  }
                  for (sym = 0; sym < codes; sym++) {
                    count[lens[lens_index + sym]]++;
                  }
                  root = bits;
                  for (max = MAXBITS; max >= 1; max--) {
                    if (count[max] !== 0) {
                      break;
                    }
                  }
                  if (root > max) {
                    root = max;
                  }
                  if (max === 0) {
                    table[table_index++] = 1 << 24 | 64 << 16 | 0;
                    table[table_index++] = 1 << 24 | 64 << 16 | 0;
                    opts.bits = 1;
                    return 0;
                  }
                  for (min = 1; min < max; min++) {
                    if (count[min] !== 0) {
                      break;
                    }
                  }
                  if (root < min) {
                    root = min;
                  }
                  left = 1;
                  for (len = 1; len <= MAXBITS; len++) {
                    left <<= 1;
                    left -= count[len];
                    if (left < 0) {
                      return -1;
                    }
                  }
                  if (left > 0 && (type === CODES || max !== 1)) {
                    return -1;
                  }
                  offs[1] = 0;
                  for (len = 1; len < MAXBITS; len++) {
                    offs[len + 1] = offs[len] + count[len];
                  }
                  for (sym = 0; sym < codes; sym++) {
                    if (lens[lens_index + sym] !== 0) {
                      work[offs[lens[lens_index + sym]]++] = sym;
                    }
                  }
                  if (type === CODES) {
                    base = extra = work;
                    end = 19;
                  } else if (type === LENS) {
                    base = lbase;
                    base_index -= 257;
                    extra = lext;
                    extra_index -= 257;
                    end = 256;
                  } else {
                    base = dbase;
                    extra = dext;
                    end = -1;
                  }
                  huff = 0;
                  sym = 0;
                  len = min;
                  next = table_index;
                  curr = root;
                  drop = 0;
                  low = -1;
                  used = 1 << root;
                  mask = used - 1;
                  if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
                    return 1;
                  }
                  for (; ; ) {
                    here_bits = len - drop;
                    if (work[sym] < end) {
                      here_op = 0;
                      here_val = work[sym];
                    } else if (work[sym] > end) {
                      here_op = extra[extra_index + work[sym]];
                      here_val = base[base_index + work[sym]];
                    } else {
                      here_op = 32 + 64;
                      here_val = 0;
                    }
                    incr = 1 << len - drop;
                    fill = 1 << curr;
                    min = fill;
                    do {
                      fill -= incr;
                      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
                    } while (fill !== 0);
                    incr = 1 << len - 1;
                    while (huff & incr) {
                      incr >>= 1;
                    }
                    if (incr !== 0) {
                      huff &= incr - 1;
                      huff += incr;
                    } else {
                      huff = 0;
                    }
                    sym++;
                    if (--count[len] === 0) {
                      if (len === max) {
                        break;
                      }
                      len = lens[lens_index + work[sym]];
                    }
                    if (len > root && (huff & mask) !== low) {
                      if (drop === 0) {
                        drop = root;
                      }
                      next += min;
                      curr = len - drop;
                      left = 1 << curr;
                      while (curr + drop < max) {
                        left -= count[curr + drop];
                        if (left <= 0) {
                          break;
                        }
                        curr++;
                        left <<= 1;
                      }
                      used += 1 << curr;
                      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
                        return 1;
                      }
                      low = huff & mask;
                      table[low] = root << 24 | curr << 16 | next - table_index | 0;
                    }
                  }
                  if (huff !== 0) {
                    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
                  }
                  opts.bits = root;
                  return 0;
                };
              }
            ),
            /***/
            8898: (
              /***/
              function(module2) {
                "use strict";
                module2.exports = {
                  2: "need dictionary",
                  /* Z_NEED_DICT       2  */
                  1: "stream end",
                  /* Z_STREAM_END      1  */
                  0: "",
                  /* Z_OK              0  */
                  "-1": "file error",
                  /* Z_ERRNO         (-1) */
                  "-2": "stream error",
                  /* Z_STREAM_ERROR  (-2) */
                  "-3": "data error",
                  /* Z_DATA_ERROR    (-3) */
                  "-4": "insufficient memory",
                  /* Z_MEM_ERROR     (-4) */
                  "-5": "buffer error",
                  /* Z_BUF_ERROR     (-5) */
                  "-6": "incompatible version"
                  /* Z_VERSION_ERROR (-6) */
                };
              }
            ),
            /***/
            342: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var utils = __webpack_require__2(4236);
                var Z_FIXED = 4;
                var Z_BINARY = 0;
                var Z_TEXT = 1;
                var Z_UNKNOWN = 2;
                function zero(buf) {
                  var len = buf.length;
                  while (--len >= 0) {
                    buf[len] = 0;
                  }
                }
                var STORED_BLOCK = 0;
                var STATIC_TREES = 1;
                var DYN_TREES = 2;
                var MIN_MATCH = 3;
                var MAX_MATCH = 258;
                var LENGTH_CODES = 29;
                var LITERALS = 256;
                var L_CODES = LITERALS + 1 + LENGTH_CODES;
                var D_CODES = 30;
                var BL_CODES = 19;
                var HEAP_SIZE = 2 * L_CODES + 1;
                var MAX_BITS = 15;
                var Buf_size = 16;
                var MAX_BL_BITS = 7;
                var END_BLOCK = 256;
                var REP_3_6 = 16;
                var REPZ_3_10 = 17;
                var REPZ_11_138 = 18;
                var extra_lbits = (
                  /* extra bits for each length code */
                  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
                );
                var extra_dbits = (
                  /* extra bits for each distance code */
                  [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
                );
                var extra_blbits = (
                  /* extra bits for each bit length code */
                  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
                );
                var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
                var DIST_CODE_LEN = 512;
                var static_ltree = new Array((L_CODES + 2) * 2);
                zero(static_ltree);
                var static_dtree = new Array(D_CODES * 2);
                zero(static_dtree);
                var _dist_code = new Array(DIST_CODE_LEN);
                zero(_dist_code);
                var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
                zero(_length_code);
                var base_length = new Array(LENGTH_CODES);
                zero(base_length);
                var base_dist = new Array(D_CODES);
                zero(base_dist);
                function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
                  this.static_tree = static_tree;
                  this.extra_bits = extra_bits;
                  this.extra_base = extra_base;
                  this.elems = elems;
                  this.max_length = max_length;
                  this.has_stree = static_tree && static_tree.length;
                }
                var static_l_desc;
                var static_d_desc;
                var static_bl_desc;
                function TreeDesc(dyn_tree, stat_desc) {
                  this.dyn_tree = dyn_tree;
                  this.max_code = 0;
                  this.stat_desc = stat_desc;
                }
                function d_code(dist) {
                  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
                }
                function put_short(s, w) {
                  s.pending_buf[s.pending++] = w & 255;
                  s.pending_buf[s.pending++] = w >>> 8 & 255;
                }
                function send_bits(s, value, length) {
                  if (s.bi_valid > Buf_size - length) {
                    s.bi_buf |= value << s.bi_valid & 65535;
                    put_short(s, s.bi_buf);
                    s.bi_buf = value >> Buf_size - s.bi_valid;
                    s.bi_valid += length - Buf_size;
                  } else {
                    s.bi_buf |= value << s.bi_valid & 65535;
                    s.bi_valid += length;
                  }
                }
                function send_code(s, c, tree) {
                  send_bits(
                    s,
                    tree[c * 2],
                    tree[c * 2 + 1]
                    /*.Len*/
                  );
                }
                function bi_reverse(code, len) {
                  var res = 0;
                  do {
                    res |= code & 1;
                    code >>>= 1;
                    res <<= 1;
                  } while (--len > 0);
                  return res >>> 1;
                }
                function bi_flush(s) {
                  if (s.bi_valid === 16) {
                    put_short(s, s.bi_buf);
                    s.bi_buf = 0;
                    s.bi_valid = 0;
                  } else if (s.bi_valid >= 8) {
                    s.pending_buf[s.pending++] = s.bi_buf & 255;
                    s.bi_buf >>= 8;
                    s.bi_valid -= 8;
                  }
                }
                function gen_bitlen(s, desc) {
                  var tree = desc.dyn_tree;
                  var max_code = desc.max_code;
                  var stree = desc.stat_desc.static_tree;
                  var has_stree = desc.stat_desc.has_stree;
                  var extra = desc.stat_desc.extra_bits;
                  var base = desc.stat_desc.extra_base;
                  var max_length = desc.stat_desc.max_length;
                  var h;
                  var n, m;
                  var bits;
                  var xbits;
                  var f;
                  var overflow = 0;
                  for (bits = 0; bits <= MAX_BITS; bits++) {
                    s.bl_count[bits] = 0;
                  }
                  tree[s.heap[s.heap_max] * 2 + 1] = 0;
                  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
                    n = s.heap[h];
                    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
                    if (bits > max_length) {
                      bits = max_length;
                      overflow++;
                    }
                    tree[n * 2 + 1] = bits;
                    if (n > max_code) {
                      continue;
                    }
                    s.bl_count[bits]++;
                    xbits = 0;
                    if (n >= base) {
                      xbits = extra[n - base];
                    }
                    f = tree[n * 2];
                    s.opt_len += f * (bits + xbits);
                    if (has_stree) {
                      s.static_len += f * (stree[n * 2 + 1] + xbits);
                    }
                  }
                  if (overflow === 0) {
                    return;
                  }
                  do {
                    bits = max_length - 1;
                    while (s.bl_count[bits] === 0) {
                      bits--;
                    }
                    s.bl_count[bits]--;
                    s.bl_count[bits + 1] += 2;
                    s.bl_count[max_length]--;
                    overflow -= 2;
                  } while (overflow > 0);
                  for (bits = max_length; bits !== 0; bits--) {
                    n = s.bl_count[bits];
                    while (n !== 0) {
                      m = s.heap[--h];
                      if (m > max_code) {
                        continue;
                      }
                      if (tree[m * 2 + 1] !== bits) {
                        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                        tree[m * 2 + 1] = bits;
                      }
                      n--;
                    }
                  }
                }
                function gen_codes(tree, max_code, bl_count) {
                  var next_code = new Array(MAX_BITS + 1);
                  var code = 0;
                  var bits;
                  var n;
                  for (bits = 1; bits <= MAX_BITS; bits++) {
                    next_code[bits] = code = code + bl_count[bits - 1] << 1;
                  }
                  for (n = 0; n <= max_code; n++) {
                    var len = tree[n * 2 + 1];
                    if (len === 0) {
                      continue;
                    }
                    tree[n * 2] = bi_reverse(next_code[len]++, len);
                  }
                }
                function tr_static_init() {
                  var n;
                  var bits;
                  var length;
                  var code;
                  var dist;
                  var bl_count = new Array(MAX_BITS + 1);
                  length = 0;
                  for (code = 0; code < LENGTH_CODES - 1; code++) {
                    base_length[code] = length;
                    for (n = 0; n < 1 << extra_lbits[code]; n++) {
                      _length_code[length++] = code;
                    }
                  }
                  _length_code[length - 1] = code;
                  dist = 0;
                  for (code = 0; code < 16; code++) {
                    base_dist[code] = dist;
                    for (n = 0; n < 1 << extra_dbits[code]; n++) {
                      _dist_code[dist++] = code;
                    }
                  }
                  dist >>= 7;
                  for (; code < D_CODES; code++) {
                    base_dist[code] = dist << 7;
                    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
                      _dist_code[256 + dist++] = code;
                    }
                  }
                  for (bits = 0; bits <= MAX_BITS; bits++) {
                    bl_count[bits] = 0;
                  }
                  n = 0;
                  while (n <= 143) {
                    static_ltree[n * 2 + 1] = 8;
                    n++;
                    bl_count[8]++;
                  }
                  while (n <= 255) {
                    static_ltree[n * 2 + 1] = 9;
                    n++;
                    bl_count[9]++;
                  }
                  while (n <= 279) {
                    static_ltree[n * 2 + 1] = 7;
                    n++;
                    bl_count[7]++;
                  }
                  while (n <= 287) {
                    static_ltree[n * 2 + 1] = 8;
                    n++;
                    bl_count[8]++;
                  }
                  gen_codes(static_ltree, L_CODES + 1, bl_count);
                  for (n = 0; n < D_CODES; n++) {
                    static_dtree[n * 2 + 1] = 5;
                    static_dtree[n * 2] = bi_reverse(n, 5);
                  }
                  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
                  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
                  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
                }
                function init_block(s) {
                  var n;
                  for (n = 0; n < L_CODES; n++) {
                    s.dyn_ltree[n * 2] = 0;
                  }
                  for (n = 0; n < D_CODES; n++) {
                    s.dyn_dtree[n * 2] = 0;
                  }
                  for (n = 0; n < BL_CODES; n++) {
                    s.bl_tree[n * 2] = 0;
                  }
                  s.dyn_ltree[END_BLOCK * 2] = 1;
                  s.opt_len = s.static_len = 0;
                  s.last_lit = s.matches = 0;
                }
                function bi_windup(s) {
                  if (s.bi_valid > 8) {
                    put_short(s, s.bi_buf);
                  } else if (s.bi_valid > 0) {
                    s.pending_buf[s.pending++] = s.bi_buf;
                  }
                  s.bi_buf = 0;
                  s.bi_valid = 0;
                }
                function copy_block(s, buf, len, header) {
                  bi_windup(s);
                  if (header) {
                    put_short(s, len);
                    put_short(s, ~len);
                  }
                  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
                  s.pending += len;
                }
                function smaller(tree, n, m, depth) {
                  var _n2 = n * 2;
                  var _m2 = m * 2;
                  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
                }
                function pqdownheap(s, tree, k) {
                  var v = s.heap[k];
                  var j = k << 1;
                  while (j <= s.heap_len) {
                    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
                      j++;
                    }
                    if (smaller(tree, v, s.heap[j], s.depth)) {
                      break;
                    }
                    s.heap[k] = s.heap[j];
                    k = j;
                    j <<= 1;
                  }
                  s.heap[k] = v;
                }
                function compress_block(s, ltree, dtree) {
                  var dist;
                  var lc;
                  var lx = 0;
                  var code;
                  var extra;
                  if (s.last_lit !== 0) {
                    do {
                      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
                      lc = s.pending_buf[s.l_buf + lx];
                      lx++;
                      if (dist === 0) {
                        send_code(s, lc, ltree);
                      } else {
                        code = _length_code[lc];
                        send_code(s, code + LITERALS + 1, ltree);
                        extra = extra_lbits[code];
                        if (extra !== 0) {
                          lc -= base_length[code];
                          send_bits(s, lc, extra);
                        }
                        dist--;
                        code = d_code(dist);
                        send_code(s, code, dtree);
                        extra = extra_dbits[code];
                        if (extra !== 0) {
                          dist -= base_dist[code];
                          send_bits(s, dist, extra);
                        }
                      }
                    } while (lx < s.last_lit);
                  }
                  send_code(s, END_BLOCK, ltree);
                }
                function build_tree(s, desc) {
                  var tree = desc.dyn_tree;
                  var stree = desc.stat_desc.static_tree;
                  var has_stree = desc.stat_desc.has_stree;
                  var elems = desc.stat_desc.elems;
                  var n, m;
                  var max_code = -1;
                  var node;
                  s.heap_len = 0;
                  s.heap_max = HEAP_SIZE;
                  for (n = 0; n < elems; n++) {
                    if (tree[n * 2] !== 0) {
                      s.heap[++s.heap_len] = max_code = n;
                      s.depth[n] = 0;
                    } else {
                      tree[n * 2 + 1] = 0;
                    }
                  }
                  while (s.heap_len < 2) {
                    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
                    tree[node * 2] = 1;
                    s.depth[node] = 0;
                    s.opt_len--;
                    if (has_stree) {
                      s.static_len -= stree[node * 2 + 1];
                    }
                  }
                  desc.max_code = max_code;
                  for (n = s.heap_len >> 1; n >= 1; n--) {
                    pqdownheap(s, tree, n);
                  }
                  node = elems;
                  do {
                    n = s.heap[
                      1
                      /*SMALLEST*/
                    ];
                    s.heap[
                      1
                      /*SMALLEST*/
                    ] = s.heap[s.heap_len--];
                    pqdownheap(
                      s,
                      tree,
                      1
                      /*SMALLEST*/
                    );
                    m = s.heap[
                      1
                      /*SMALLEST*/
                    ];
                    s.heap[--s.heap_max] = n;
                    s.heap[--s.heap_max] = m;
                    tree[node * 2] = tree[n * 2] + tree[m * 2];
                    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
                    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
                    s.heap[
                      1
                      /*SMALLEST*/
                    ] = node++;
                    pqdownheap(
                      s,
                      tree,
                      1
                      /*SMALLEST*/
                    );
                  } while (s.heap_len >= 2);
                  s.heap[--s.heap_max] = s.heap[
                    1
                    /*SMALLEST*/
                  ];
                  gen_bitlen(s, desc);
                  gen_codes(tree, max_code, s.bl_count);
                }
                function scan_tree(s, tree, max_code) {
                  var n;
                  var prevlen = -1;
                  var curlen;
                  var nextlen = tree[0 * 2 + 1];
                  var count = 0;
                  var max_count = 7;
                  var min_count = 4;
                  if (nextlen === 0) {
                    max_count = 138;
                    min_count = 3;
                  }
                  tree[(max_code + 1) * 2 + 1] = 65535;
                  for (n = 0; n <= max_code; n++) {
                    curlen = nextlen;
                    nextlen = tree[(n + 1) * 2 + 1];
                    if (++count < max_count && curlen === nextlen) {
                      continue;
                    } else if (count < min_count) {
                      s.bl_tree[curlen * 2] += count;
                    } else if (curlen !== 0) {
                      if (curlen !== prevlen) {
                        s.bl_tree[curlen * 2]++;
                      }
                      s.bl_tree[REP_3_6 * 2]++;
                    } else if (count <= 10) {
                      s.bl_tree[REPZ_3_10 * 2]++;
                    } else {
                      s.bl_tree[REPZ_11_138 * 2]++;
                    }
                    count = 0;
                    prevlen = curlen;
                    if (nextlen === 0) {
                      max_count = 138;
                      min_count = 3;
                    } else if (curlen === nextlen) {
                      max_count = 6;
                      min_count = 3;
                    } else {
                      max_count = 7;
                      min_count = 4;
                    }
                  }
                }
                function send_tree(s, tree, max_code) {
                  var n;
                  var prevlen = -1;
                  var curlen;
                  var nextlen = tree[0 * 2 + 1];
                  var count = 0;
                  var max_count = 7;
                  var min_count = 4;
                  if (nextlen === 0) {
                    max_count = 138;
                    min_count = 3;
                  }
                  for (n = 0; n <= max_code; n++) {
                    curlen = nextlen;
                    nextlen = tree[(n + 1) * 2 + 1];
                    if (++count < max_count && curlen === nextlen) {
                      continue;
                    } else if (count < min_count) {
                      do {
                        send_code(s, curlen, s.bl_tree);
                      } while (--count !== 0);
                    } else if (curlen !== 0) {
                      if (curlen !== prevlen) {
                        send_code(s, curlen, s.bl_tree);
                        count--;
                      }
                      send_code(s, REP_3_6, s.bl_tree);
                      send_bits(s, count - 3, 2);
                    } else if (count <= 10) {
                      send_code(s, REPZ_3_10, s.bl_tree);
                      send_bits(s, count - 3, 3);
                    } else {
                      send_code(s, REPZ_11_138, s.bl_tree);
                      send_bits(s, count - 11, 7);
                    }
                    count = 0;
                    prevlen = curlen;
                    if (nextlen === 0) {
                      max_count = 138;
                      min_count = 3;
                    } else if (curlen === nextlen) {
                      max_count = 6;
                      min_count = 3;
                    } else {
                      max_count = 7;
                      min_count = 4;
                    }
                  }
                }
                function build_bl_tree(s) {
                  var max_blindex;
                  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
                  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
                  build_tree(s, s.bl_desc);
                  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
                    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
                      break;
                    }
                  }
                  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
                  return max_blindex;
                }
                function send_all_trees(s, lcodes, dcodes, blcodes) {
                  var rank;
                  send_bits(s, lcodes - 257, 5);
                  send_bits(s, dcodes - 1, 5);
                  send_bits(s, blcodes - 4, 4);
                  for (rank = 0; rank < blcodes; rank++) {
                    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
                  }
                  send_tree(s, s.dyn_ltree, lcodes - 1);
                  send_tree(s, s.dyn_dtree, dcodes - 1);
                }
                function detect_data_type(s) {
                  var black_mask = 4093624447;
                  var n;
                  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
                    if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
                      return Z_BINARY;
                    }
                  }
                  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
                    return Z_TEXT;
                  }
                  for (n = 32; n < LITERALS; n++) {
                    if (s.dyn_ltree[n * 2] !== 0) {
                      return Z_TEXT;
                    }
                  }
                  return Z_BINARY;
                }
                var static_init_done = false;
                function _tr_init(s) {
                  if (!static_init_done) {
                    tr_static_init();
                    static_init_done = true;
                  }
                  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
                  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
                  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
                  s.bi_buf = 0;
                  s.bi_valid = 0;
                  init_block(s);
                }
                function _tr_stored_block(s, buf, stored_len, last) {
                  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
                  copy_block(s, buf, stored_len, true);
                }
                function _tr_align(s) {
                  send_bits(s, STATIC_TREES << 1, 3);
                  send_code(s, END_BLOCK, static_ltree);
                  bi_flush(s);
                }
                function _tr_flush_block(s, buf, stored_len, last) {
                  var opt_lenb, static_lenb;
                  var max_blindex = 0;
                  if (s.level > 0) {
                    if (s.strm.data_type === Z_UNKNOWN) {
                      s.strm.data_type = detect_data_type(s);
                    }
                    build_tree(s, s.l_desc);
                    build_tree(s, s.d_desc);
                    max_blindex = build_bl_tree(s);
                    opt_lenb = s.opt_len + 3 + 7 >>> 3;
                    static_lenb = s.static_len + 3 + 7 >>> 3;
                    if (static_lenb <= opt_lenb) {
                      opt_lenb = static_lenb;
                    }
                  } else {
                    opt_lenb = static_lenb = stored_len + 5;
                  }
                  if (stored_len + 4 <= opt_lenb && buf !== -1) {
                    _tr_stored_block(s, buf, stored_len, last);
                  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
                    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
                    compress_block(s, static_ltree, static_dtree);
                  } else {
                    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
                    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
                    compress_block(s, s.dyn_ltree, s.dyn_dtree);
                  }
                  init_block(s);
                  if (last) {
                    bi_windup(s);
                  }
                }
                function _tr_tally(s, dist, lc) {
                  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
                  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
                  s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
                  s.last_lit++;
                  if (dist === 0) {
                    s.dyn_ltree[lc * 2]++;
                  } else {
                    s.matches++;
                    dist--;
                    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
                    s.dyn_dtree[d_code(dist) * 2]++;
                  }
                  return s.last_lit === s.lit_bufsize - 1;
                }
                exports2._tr_init = _tr_init;
                exports2._tr_stored_block = _tr_stored_block;
                exports2._tr_flush_block = _tr_flush_block;
                exports2._tr_tally = _tr_tally;
                exports2._tr_align = _tr_align;
              }
            ),
            /***/
            2292: (
              /***/
              function(module2) {
                "use strict";
                function ZStream() {
                  this.input = null;
                  this.next_in = 0;
                  this.avail_in = 0;
                  this.total_in = 0;
                  this.output = null;
                  this.next_out = 0;
                  this.avail_out = 0;
                  this.total_out = 0;
                  this.msg = "";
                  this.state = null;
                  this.data_type = 2;
                  this.adler = 0;
                }
                module2.exports = ZStream;
              }
            ),
            /***/
            4155: (
              /***/
              function(module2) {
                var process = module2.exports = {};
                var cachedSetTimeout;
                var cachedClearTimeout;
                function defaultSetTimout() {
                  throw new Error("setTimeout has not been defined");
                }
                function defaultClearTimeout() {
                  throw new Error("clearTimeout has not been defined");
                }
                (function() {
                  try {
                    if (typeof setTimeout === "function") {
                      cachedSetTimeout = setTimeout;
                    } else {
                      cachedSetTimeout = defaultSetTimout;
                    }
                  } catch (e) {
                    cachedSetTimeout = defaultSetTimout;
                  }
                  try {
                    if (typeof clearTimeout === "function") {
                      cachedClearTimeout = clearTimeout;
                    } else {
                      cachedClearTimeout = defaultClearTimeout;
                    }
                  } catch (e) {
                    cachedClearTimeout = defaultClearTimeout;
                  }
                })();
                function runTimeout(fun) {
                  if (cachedSetTimeout === setTimeout) {
                    return setTimeout(fun, 0);
                  }
                  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                    cachedSetTimeout = setTimeout;
                    return setTimeout(fun, 0);
                  }
                  try {
                    return cachedSetTimeout(fun, 0);
                  } catch (e) {
                    try {
                      return cachedSetTimeout.call(null, fun, 0);
                    } catch (e2) {
                      return cachedSetTimeout.call(this, fun, 0);
                    }
                  }
                }
                function runClearTimeout(marker) {
                  if (cachedClearTimeout === clearTimeout) {
                    return clearTimeout(marker);
                  }
                  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                    cachedClearTimeout = clearTimeout;
                    return clearTimeout(marker);
                  }
                  try {
                    return cachedClearTimeout(marker);
                  } catch (e) {
                    try {
                      return cachedClearTimeout.call(null, marker);
                    } catch (e2) {
                      return cachedClearTimeout.call(this, marker);
                    }
                  }
                }
                var queue = [];
                var draining = false;
                var currentQueue;
                var queueIndex = -1;
                function cleanUpNextTick() {
                  if (!draining || !currentQueue) {
                    return;
                  }
                  draining = false;
                  if (currentQueue.length) {
                    queue = currentQueue.concat(queue);
                  } else {
                    queueIndex = -1;
                  }
                  if (queue.length) {
                    drainQueue();
                  }
                }
                function drainQueue() {
                  if (draining) {
                    return;
                  }
                  var timeout = runTimeout(cleanUpNextTick);
                  draining = true;
                  var len = queue.length;
                  while (len) {
                    currentQueue = queue;
                    queue = [];
                    while (++queueIndex < len) {
                      if (currentQueue) {
                        currentQueue[queueIndex].run();
                      }
                    }
                    queueIndex = -1;
                    len = queue.length;
                  }
                  currentQueue = null;
                  draining = false;
                  runClearTimeout(timeout);
                }
                process.nextTick = function(fun) {
                  var args = new Array(arguments.length - 1);
                  if (arguments.length > 1) {
                    for (var i = 1; i < arguments.length; i++) {
                      args[i - 1] = arguments[i];
                    }
                  }
                  queue.push(new Item(fun, args));
                  if (queue.length === 1 && !draining) {
                    runTimeout(drainQueue);
                  }
                };
                function Item(fun, array) {
                  this.fun = fun;
                  this.array = array;
                }
                Item.prototype.run = function() {
                  this.fun.apply(null, this.array);
                };
                process.title = "browser";
                process.browser = true;
                process.env = {};
                process.argv = [];
                process.version = "";
                process.versions = {};
                function noop() {
                }
                process.on = noop;
                process.addListener = noop;
                process.once = noop;
                process.off = noop;
                process.removeListener = noop;
                process.removeAllListeners = noop;
                process.emit = noop;
                process.prependListener = noop;
                process.prependOnceListener = noop;
                process.listeners = function(name) {
                  return [];
                };
                process.binding = function(name) {
                  throw new Error("process.binding is not supported");
                };
                process.cwd = function() {
                  return "/";
                };
                process.chdir = function(dir) {
                  throw new Error("process.chdir is not supported");
                };
                process.umask = function() {
                  return 0;
                };
              }
            ),
            /***/
            3697: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var functionsHaveConfigurableNames = __webpack_require__2(5972).functionsHaveConfigurableNames();
                var $Object = Object;
                var $TypeError = TypeError;
                module2.exports = function flags() {
                  if (this != null && this !== $Object(this)) {
                    throw new $TypeError("RegExp.prototype.flags getter called on non-object");
                  }
                  var result = "";
                  if (this.hasIndices) {
                    result += "d";
                  }
                  if (this.global) {
                    result += "g";
                  }
                  if (this.ignoreCase) {
                    result += "i";
                  }
                  if (this.multiline) {
                    result += "m";
                  }
                  if (this.dotAll) {
                    result += "s";
                  }
                  if (this.unicode) {
                    result += "u";
                  }
                  if (this.sticky) {
                    result += "y";
                  }
                  return result;
                };
                if (functionsHaveConfigurableNames && Object.defineProperty) {
                  Object.defineProperty(module2.exports, "name", { value: "get flags" });
                }
              }
            ),
            /***/
            2847: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var define2 = __webpack_require__2(4289);
                var callBind = __webpack_require__2(5559);
                var implementation = __webpack_require__2(3697);
                var getPolyfill = __webpack_require__2(1721);
                var shim = __webpack_require__2(2753);
                var flagsBound = callBind(getPolyfill());
                define2(flagsBound, {
                  getPolyfill,
                  implementation,
                  shim
                });
                module2.exports = flagsBound;
              }
            ),
            /***/
            1721: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var implementation = __webpack_require__2(3697);
                var supportsDescriptors = __webpack_require__2(4289).supportsDescriptors;
                var $gOPD = Object.getOwnPropertyDescriptor;
                module2.exports = function getPolyfill() {
                  if (supportsDescriptors && /a/mig.flags === "gim") {
                    var descriptor = $gOPD(RegExp.prototype, "flags");
                    if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
                      var calls = "";
                      var o = {};
                      Object.defineProperty(o, "hasIndices", {
                        get: function() {
                          calls += "d";
                        }
                      });
                      Object.defineProperty(o, "sticky", {
                        get: function() {
                          calls += "y";
                        }
                      });
                      if (calls === "dy") {
                        return descriptor.get;
                      }
                    }
                  }
                  return implementation;
                };
              }
            ),
            /***/
            2753: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var supportsDescriptors = __webpack_require__2(4289).supportsDescriptors;
                var getPolyfill = __webpack_require__2(1721);
                var gOPD = Object.getOwnPropertyDescriptor;
                var defineProperty = Object.defineProperty;
                var TypeErr = TypeError;
                var getProto = Object.getPrototypeOf;
                var regex = /a/;
                module2.exports = function shimFlags() {
                  if (!supportsDescriptors || !getProto) {
                    throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
                  }
                  var polyfill = getPolyfill();
                  var proto = getProto(regex);
                  var descriptor = gOPD(proto, "flags");
                  if (!descriptor || descriptor.get !== polyfill) {
                    defineProperty(proto, "flags", {
                      configurable: true,
                      enumerable: false,
                      get: polyfill
                    });
                  }
                  return polyfill;
                };
              }
            ),
            /***/
            6099: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                var Buffer = __webpack_require__2(8823)["Buffer"];
                ;
                (function(sax) {
                  sax.parser = function(strict, opt) {
                    return new SAXParser(strict, opt);
                  };
                  sax.SAXParser = SAXParser;
                  sax.SAXStream = SAXStream;
                  sax.createStream = createStream;
                  sax.MAX_BUFFER_LENGTH = 64 * 1024;
                  var buffers = [
                    "comment",
                    "sgmlDecl",
                    "textNode",
                    "tagName",
                    "doctype",
                    "procInstName",
                    "procInstBody",
                    "entity",
                    "attribName",
                    "attribValue",
                    "cdata",
                    "script"
                  ];
                  sax.EVENTS = [
                    "text",
                    "processinginstruction",
                    "sgmldeclaration",
                    "doctype",
                    "comment",
                    "opentagstart",
                    "attribute",
                    "opentag",
                    "closetag",
                    "opencdata",
                    "cdata",
                    "closecdata",
                    "error",
                    "end",
                    "ready",
                    "script",
                    "opennamespace",
                    "closenamespace"
                  ];
                  function SAXParser(strict, opt) {
                    if (!(this instanceof SAXParser)) {
                      return new SAXParser(strict, opt);
                    }
                    var parser = this;
                    clearBuffers(parser);
                    parser.q = parser.c = "";
                    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
                    parser.opt = opt || {};
                    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
                    parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
                    parser.tags = [];
                    parser.closed = parser.closedRoot = parser.sawRoot = false;
                    parser.tag = parser.error = null;
                    parser.strict = !!strict;
                    parser.noscript = !!(strict || parser.opt.noscript);
                    parser.state = S.BEGIN;
                    parser.strictEntities = parser.opt.strictEntities;
                    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
                    parser.attribList = [];
                    if (parser.opt.xmlns) {
                      parser.ns = Object.create(rootNS);
                    }
                    parser.trackPosition = parser.opt.position !== false;
                    if (parser.trackPosition) {
                      parser.position = parser.line = parser.column = 0;
                    }
                    emit(parser, "onready");
                  }
                  if (!Object.create) {
                    Object.create = function(o) {
                      function F() {
                      }
                      F.prototype = o;
                      var newf = new F();
                      return newf;
                    };
                  }
                  if (!Object.keys) {
                    Object.keys = function(o) {
                      var a = [];
                      for (var i in o)
                        if (o.hasOwnProperty(i))
                          a.push(i);
                      return a;
                    };
                  }
                  function checkBufferLength(parser) {
                    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
                    var maxActual = 0;
                    for (var i = 0, l = buffers.length; i < l; i++) {
                      var len = parser[buffers[i]].length;
                      if (len > maxAllowed) {
                        switch (buffers[i]) {
                          case "textNode":
                            closeText(parser);
                            break;
                          case "cdata":
                            emitNode(parser, "oncdata", parser.cdata);
                            parser.cdata = "";
                            break;
                          case "script":
                            emitNode(parser, "onscript", parser.script);
                            parser.script = "";
                            break;
                          default:
                            error(parser, "Max buffer length exceeded: " + buffers[i]);
                        }
                      }
                      maxActual = Math.max(maxActual, len);
                    }
                    var m = sax.MAX_BUFFER_LENGTH - maxActual;
                    parser.bufferCheckPosition = m + parser.position;
                  }
                  function clearBuffers(parser) {
                    for (var i = 0, l = buffers.length; i < l; i++) {
                      parser[buffers[i]] = "";
                    }
                  }
                  function flushBuffers(parser) {
                    closeText(parser);
                    if (parser.cdata !== "") {
                      emitNode(parser, "oncdata", parser.cdata);
                      parser.cdata = "";
                    }
                    if (parser.script !== "") {
                      emitNode(parser, "onscript", parser.script);
                      parser.script = "";
                    }
                  }
                  SAXParser.prototype = {
                    end: function() {
                      end(this);
                    },
                    write,
                    resume: function() {
                      this.error = null;
                      return this;
                    },
                    close: function() {
                      return this.write(null);
                    },
                    flush: function() {
                      flushBuffers(this);
                    }
                  };
                  var Stream;
                  try {
                    Stream = __webpack_require__2(2830).Stream;
                  } catch (ex) {
                    Stream = function() {
                    };
                  }
                  var streamWraps = sax.EVENTS.filter(function(ev) {
                    return ev !== "error" && ev !== "end";
                  });
                  function createStream(strict, opt) {
                    return new SAXStream(strict, opt);
                  }
                  function SAXStream(strict, opt) {
                    if (!(this instanceof SAXStream)) {
                      return new SAXStream(strict, opt);
                    }
                    Stream.apply(this);
                    this._parser = new SAXParser(strict, opt);
                    this.writable = true;
                    this.readable = true;
                    var me = this;
                    this._parser.onend = function() {
                      me.emit("end");
                    };
                    this._parser.onerror = function(er) {
                      me.emit("error", er);
                      me._parser.error = null;
                    };
                    this._decoder = null;
                    streamWraps.forEach(function(ev) {
                      Object.defineProperty(me, "on" + ev, {
                        get: function() {
                          return me._parser["on" + ev];
                        },
                        set: function(h) {
                          if (!h) {
                            me.removeAllListeners(ev);
                            me._parser["on" + ev] = h;
                            return h;
                          }
                          me.on(ev, h);
                        },
                        enumerable: true,
                        configurable: false
                      });
                    });
                  }
                  SAXStream.prototype = Object.create(Stream.prototype, {
                    constructor: {
                      value: SAXStream
                    }
                  });
                  SAXStream.prototype.write = function(data) {
                    if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
                      if (!this._decoder) {
                        var SD = __webpack_require__2(2553).s;
                        this._decoder = new SD("utf8");
                      }
                      data = this._decoder.write(data);
                    }
                    this._parser.write(data.toString());
                    this.emit("data", data);
                    return true;
                  };
                  SAXStream.prototype.end = function(chunk) {
                    if (chunk && chunk.length) {
                      this.write(chunk);
                    }
                    this._parser.end();
                    return true;
                  };
                  SAXStream.prototype.on = function(ev, handler) {
                    var me = this;
                    if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
                      me._parser["on" + ev] = function() {
                        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
                        args.splice(0, 0, ev);
                        me.emit.apply(me, args);
                      };
                    }
                    return Stream.prototype.on.call(me, ev, handler);
                  };
                  var CDATA = "[CDATA[";
                  var DOCTYPE = "DOCTYPE";
                  var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
                  var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
                  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
                  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
                  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
                  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
                  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
                  function isWhitespace(c) {
                    return c === " " || c === "\n" || c === "\r" || c === "	";
                  }
                  function isQuote(c) {
                    return c === '"' || c === "'";
                  }
                  function isAttribEnd(c) {
                    return c === ">" || isWhitespace(c);
                  }
                  function isMatch(regex, c) {
                    return regex.test(c);
                  }
                  function notMatch(regex, c) {
                    return !isMatch(regex, c);
                  }
                  var S = 0;
                  sax.STATE = {
                    BEGIN: S++,
                    // leading byte order mark or whitespace
                    BEGIN_WHITESPACE: S++,
                    // leading whitespace
                    TEXT: S++,
                    // general stuff
                    TEXT_ENTITY: S++,
                    // &amp and such.
                    OPEN_WAKA: S++,
                    // <
                    SGML_DECL: S++,
                    // <!BLARG
                    SGML_DECL_QUOTED: S++,
                    // <!BLARG foo "bar
                    DOCTYPE: S++,
                    // <!DOCTYPE
                    DOCTYPE_QUOTED: S++,
                    // <!DOCTYPE "//blah
                    DOCTYPE_DTD: S++,
                    // <!DOCTYPE "//blah" [ ...
                    DOCTYPE_DTD_QUOTED: S++,
                    // <!DOCTYPE "//blah" [ "foo
                    COMMENT_STARTING: S++,
                    // <!-
                    COMMENT: S++,
                    // <!--
                    COMMENT_ENDING: S++,
                    // <!-- blah -
                    COMMENT_ENDED: S++,
                    // <!-- blah --
                    CDATA: S++,
                    // <![CDATA[ something
                    CDATA_ENDING: S++,
                    // ]
                    CDATA_ENDING_2: S++,
                    // ]]
                    PROC_INST: S++,
                    // <?hi
                    PROC_INST_BODY: S++,
                    // <?hi there
                    PROC_INST_ENDING: S++,
                    // <?hi "there" ?
                    OPEN_TAG: S++,
                    // <strong
                    OPEN_TAG_SLASH: S++,
                    // <strong /
                    ATTRIB: S++,
                    // <a
                    ATTRIB_NAME: S++,
                    // <a foo
                    ATTRIB_NAME_SAW_WHITE: S++,
                    // <a foo _
                    ATTRIB_VALUE: S++,
                    // <a foo=
                    ATTRIB_VALUE_QUOTED: S++,
                    // <a foo="bar
                    ATTRIB_VALUE_CLOSED: S++,
                    // <a foo="bar"
                    ATTRIB_VALUE_UNQUOTED: S++,
                    // <a foo=bar
                    ATTRIB_VALUE_ENTITY_Q: S++,
                    // <foo bar="&quot;"
                    ATTRIB_VALUE_ENTITY_U: S++,
                    // <foo bar=&quot
                    CLOSE_TAG: S++,
                    // </a
                    CLOSE_TAG_SAW_WHITE: S++,
                    // </a   >
                    SCRIPT: S++,
                    // <script> ...
                    SCRIPT_ENDING: S++
                    // <script> ... <
                  };
                  sax.XML_ENTITIES = {
                    "amp": "&",
                    "gt": ">",
                    "lt": "<",
                    "quot": '"',
                    "apos": "'"
                  };
                  sax.ENTITIES = {
                    "amp": "&",
                    "gt": ">",
                    "lt": "<",
                    "quot": '"',
                    "apos": "'",
                    "AElig": 198,
                    "Aacute": 193,
                    "Acirc": 194,
                    "Agrave": 192,
                    "Aring": 197,
                    "Atilde": 195,
                    "Auml": 196,
                    "Ccedil": 199,
                    "ETH": 208,
                    "Eacute": 201,
                    "Ecirc": 202,
                    "Egrave": 200,
                    "Euml": 203,
                    "Iacute": 205,
                    "Icirc": 206,
                    "Igrave": 204,
                    "Iuml": 207,
                    "Ntilde": 209,
                    "Oacute": 211,
                    "Ocirc": 212,
                    "Ograve": 210,
                    "Oslash": 216,
                    "Otilde": 213,
                    "Ouml": 214,
                    "THORN": 222,
                    "Uacute": 218,
                    "Ucirc": 219,
                    "Ugrave": 217,
                    "Uuml": 220,
                    "Yacute": 221,
                    "aacute": 225,
                    "acirc": 226,
                    "aelig": 230,
                    "agrave": 224,
                    "aring": 229,
                    "atilde": 227,
                    "auml": 228,
                    "ccedil": 231,
                    "eacute": 233,
                    "ecirc": 234,
                    "egrave": 232,
                    "eth": 240,
                    "euml": 235,
                    "iacute": 237,
                    "icirc": 238,
                    "igrave": 236,
                    "iuml": 239,
                    "ntilde": 241,
                    "oacute": 243,
                    "ocirc": 244,
                    "ograve": 242,
                    "oslash": 248,
                    "otilde": 245,
                    "ouml": 246,
                    "szlig": 223,
                    "thorn": 254,
                    "uacute": 250,
                    "ucirc": 251,
                    "ugrave": 249,
                    "uuml": 252,
                    "yacute": 253,
                    "yuml": 255,
                    "copy": 169,
                    "reg": 174,
                    "nbsp": 160,
                    "iexcl": 161,
                    "cent": 162,
                    "pound": 163,
                    "curren": 164,
                    "yen": 165,
                    "brvbar": 166,
                    "sect": 167,
                    "uml": 168,
                    "ordf": 170,
                    "laquo": 171,
                    "not": 172,
                    "shy": 173,
                    "macr": 175,
                    "deg": 176,
                    "plusmn": 177,
                    "sup1": 185,
                    "sup2": 178,
                    "sup3": 179,
                    "acute": 180,
                    "micro": 181,
                    "para": 182,
                    "middot": 183,
                    "cedil": 184,
                    "ordm": 186,
                    "raquo": 187,
                    "frac14": 188,
                    "frac12": 189,
                    "frac34": 190,
                    "iquest": 191,
                    "times": 215,
                    "divide": 247,
                    "OElig": 338,
                    "oelig": 339,
                    "Scaron": 352,
                    "scaron": 353,
                    "Yuml": 376,
                    "fnof": 402,
                    "circ": 710,
                    "tilde": 732,
                    "Alpha": 913,
                    "Beta": 914,
                    "Gamma": 915,
                    "Delta": 916,
                    "Epsilon": 917,
                    "Zeta": 918,
                    "Eta": 919,
                    "Theta": 920,
                    "Iota": 921,
                    "Kappa": 922,
                    "Lambda": 923,
                    "Mu": 924,
                    "Nu": 925,
                    "Xi": 926,
                    "Omicron": 927,
                    "Pi": 928,
                    "Rho": 929,
                    "Sigma": 931,
                    "Tau": 932,
                    "Upsilon": 933,
                    "Phi": 934,
                    "Chi": 935,
                    "Psi": 936,
                    "Omega": 937,
                    "alpha": 945,
                    "beta": 946,
                    "gamma": 947,
                    "delta": 948,
                    "epsilon": 949,
                    "zeta": 950,
                    "eta": 951,
                    "theta": 952,
                    "iota": 953,
                    "kappa": 954,
                    "lambda": 955,
                    "mu": 956,
                    "nu": 957,
                    "xi": 958,
                    "omicron": 959,
                    "pi": 960,
                    "rho": 961,
                    "sigmaf": 962,
                    "sigma": 963,
                    "tau": 964,
                    "upsilon": 965,
                    "phi": 966,
                    "chi": 967,
                    "psi": 968,
                    "omega": 969,
                    "thetasym": 977,
                    "upsih": 978,
                    "piv": 982,
                    "ensp": 8194,
                    "emsp": 8195,
                    "thinsp": 8201,
                    "zwnj": 8204,
                    "zwj": 8205,
                    "lrm": 8206,
                    "rlm": 8207,
                    "ndash": 8211,
                    "mdash": 8212,
                    "lsquo": 8216,
                    "rsquo": 8217,
                    "sbquo": 8218,
                    "ldquo": 8220,
                    "rdquo": 8221,
                    "bdquo": 8222,
                    "dagger": 8224,
                    "Dagger": 8225,
                    "bull": 8226,
                    "hellip": 8230,
                    "permil": 8240,
                    "prime": 8242,
                    "Prime": 8243,
                    "lsaquo": 8249,
                    "rsaquo": 8250,
                    "oline": 8254,
                    "frasl": 8260,
                    "euro": 8364,
                    "image": 8465,
                    "weierp": 8472,
                    "real": 8476,
                    "trade": 8482,
                    "alefsym": 8501,
                    "larr": 8592,
                    "uarr": 8593,
                    "rarr": 8594,
                    "darr": 8595,
                    "harr": 8596,
                    "crarr": 8629,
                    "lArr": 8656,
                    "uArr": 8657,
                    "rArr": 8658,
                    "dArr": 8659,
                    "hArr": 8660,
                    "forall": 8704,
                    "part": 8706,
                    "exist": 8707,
                    "empty": 8709,
                    "nabla": 8711,
                    "isin": 8712,
                    "notin": 8713,
                    "ni": 8715,
                    "prod": 8719,
                    "sum": 8721,
                    "minus": 8722,
                    "lowast": 8727,
                    "radic": 8730,
                    "prop": 8733,
                    "infin": 8734,
                    "ang": 8736,
                    "and": 8743,
                    "or": 8744,
                    "cap": 8745,
                    "cup": 8746,
                    "int": 8747,
                    "there4": 8756,
                    "sim": 8764,
                    "cong": 8773,
                    "asymp": 8776,
                    "ne": 8800,
                    "equiv": 8801,
                    "le": 8804,
                    "ge": 8805,
                    "sub": 8834,
                    "sup": 8835,
                    "nsub": 8836,
                    "sube": 8838,
                    "supe": 8839,
                    "oplus": 8853,
                    "otimes": 8855,
                    "perp": 8869,
                    "sdot": 8901,
                    "lceil": 8968,
                    "rceil": 8969,
                    "lfloor": 8970,
                    "rfloor": 8971,
                    "lang": 9001,
                    "rang": 9002,
                    "loz": 9674,
                    "spades": 9824,
                    "clubs": 9827,
                    "hearts": 9829,
                    "diams": 9830
                  };
                  Object.keys(sax.ENTITIES).forEach(function(key) {
                    var e = sax.ENTITIES[key];
                    var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
                    sax.ENTITIES[key] = s2;
                  });
                  for (var s in sax.STATE) {
                    sax.STATE[sax.STATE[s]] = s;
                  }
                  S = sax.STATE;
                  function emit(parser, event, data) {
                    parser[event] && parser[event](data);
                  }
                  function emitNode(parser, nodeType, data) {
                    if (parser.textNode)
                      closeText(parser);
                    emit(parser, nodeType, data);
                  }
                  function closeText(parser) {
                    parser.textNode = textopts(parser.opt, parser.textNode);
                    if (parser.textNode)
                      emit(parser, "ontext", parser.textNode);
                    parser.textNode = "";
                  }
                  function textopts(opt, text) {
                    if (opt.trim)
                      text = text.trim();
                    if (opt.normalize)
                      text = text.replace(/\s+/g, " ");
                    return text;
                  }
                  function error(parser, er) {
                    closeText(parser);
                    if (parser.trackPosition) {
                      er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
                    }
                    er = new Error(er);
                    parser.error = er;
                    emit(parser, "onerror", er);
                    return parser;
                  }
                  function end(parser) {
                    if (parser.sawRoot && !parser.closedRoot)
                      strictFail(parser, "Unclosed root tag");
                    if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
                      error(parser, "Unexpected end");
                    }
                    closeText(parser);
                    parser.c = "";
                    parser.closed = true;
                    emit(parser, "onend");
                    SAXParser.call(parser, parser.strict, parser.opt);
                    return parser;
                  }
                  function strictFail(parser, message) {
                    if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
                      throw new Error("bad call to strictFail");
                    }
                    if (parser.strict) {
                      error(parser, message);
                    }
                  }
                  function newTag(parser) {
                    if (!parser.strict)
                      parser.tagName = parser.tagName[parser.looseCase]();
                    var parent = parser.tags[parser.tags.length - 1] || parser;
                    var tag = parser.tag = { name: parser.tagName, attributes: {} };
                    if (parser.opt.xmlns) {
                      tag.ns = parent.ns;
                    }
                    parser.attribList.length = 0;
                    emitNode(parser, "onopentagstart", tag);
                  }
                  function qname(name, attribute) {
                    var i = name.indexOf(":");
                    var qualName = i < 0 ? ["", name] : name.split(":");
                    var prefix = qualName[0];
                    var local = qualName[1];
                    if (attribute && name === "xmlns") {
                      prefix = "xmlns";
                      local = "";
                    }
                    return { prefix, local };
                  }
                  function attrib(parser) {
                    if (!parser.strict) {
                      parser.attribName = parser.attribName[parser.looseCase]();
                    }
                    if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
                      parser.attribName = parser.attribValue = "";
                      return;
                    }
                    if (parser.opt.xmlns) {
                      var qn = qname(parser.attribName, true);
                      var prefix = qn.prefix;
                      var local = qn.local;
                      if (prefix === "xmlns") {
                        if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
                          strictFail(
                            parser,
                            "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
                          );
                        } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
                          strictFail(
                            parser,
                            "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
                          );
                        } else {
                          var tag = parser.tag;
                          var parent = parser.tags[parser.tags.length - 1] || parser;
                          if (tag.ns === parent.ns) {
                            tag.ns = Object.create(parent.ns);
                          }
                          tag.ns[local] = parser.attribValue;
                        }
                      }
                      parser.attribList.push([parser.attribName, parser.attribValue]);
                    } else {
                      parser.tag.attributes[parser.attribName] = parser.attribValue;
                      emitNode(parser, "onattribute", {
                        name: parser.attribName,
                        value: parser.attribValue
                      });
                    }
                    parser.attribName = parser.attribValue = "";
                  }
                  function openTag(parser, selfClosing) {
                    if (parser.opt.xmlns) {
                      var tag = parser.tag;
                      var qn = qname(parser.tagName);
                      tag.prefix = qn.prefix;
                      tag.local = qn.local;
                      tag.uri = tag.ns[qn.prefix] || "";
                      if (tag.prefix && !tag.uri) {
                        strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
                        tag.uri = qn.prefix;
                      }
                      var parent = parser.tags[parser.tags.length - 1] || parser;
                      if (tag.ns && parent.ns !== tag.ns) {
                        Object.keys(tag.ns).forEach(function(p) {
                          emitNode(parser, "onopennamespace", {
                            prefix: p,
                            uri: tag.ns[p]
                          });
                        });
                      }
                      for (var i = 0, l = parser.attribList.length; i < l; i++) {
                        var nv = parser.attribList[i];
                        var name = nv[0];
                        var value = nv[1];
                        var qualName = qname(name, true);
                        var prefix = qualName.prefix;
                        var local = qualName.local;
                        var uri = prefix === "" ? "" : tag.ns[prefix] || "";
                        var a = {
                          name,
                          value,
                          prefix,
                          local,
                          uri
                        };
                        if (prefix && prefix !== "xmlns" && !uri) {
                          strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
                          a.uri = prefix;
                        }
                        parser.tag.attributes[name] = a;
                        emitNode(parser, "onattribute", a);
                      }
                      parser.attribList.length = 0;
                    }
                    parser.tag.isSelfClosing = !!selfClosing;
                    parser.sawRoot = true;
                    parser.tags.push(parser.tag);
                    emitNode(parser, "onopentag", parser.tag);
                    if (!selfClosing) {
                      if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
                        parser.state = S.SCRIPT;
                      } else {
                        parser.state = S.TEXT;
                      }
                      parser.tag = null;
                      parser.tagName = "";
                    }
                    parser.attribName = parser.attribValue = "";
                    parser.attribList.length = 0;
                  }
                  function closeTag(parser) {
                    if (!parser.tagName) {
                      strictFail(parser, "Weird empty close tag.");
                      parser.textNode += "</>";
                      parser.state = S.TEXT;
                      return;
                    }
                    if (parser.script) {
                      if (parser.tagName !== "script") {
                        parser.script += "</" + parser.tagName + ">";
                        parser.tagName = "";
                        parser.state = S.SCRIPT;
                        return;
                      }
                      emitNode(parser, "onscript", parser.script);
                      parser.script = "";
                    }
                    var t = parser.tags.length;
                    var tagName = parser.tagName;
                    if (!parser.strict) {
                      tagName = tagName[parser.looseCase]();
                    }
                    var closeTo = tagName;
                    while (t--) {
                      var close = parser.tags[t];
                      if (close.name !== closeTo) {
                        strictFail(parser, "Unexpected close tag");
                      } else {
                        break;
                      }
                    }
                    if (t < 0) {
                      strictFail(parser, "Unmatched closing tag: " + parser.tagName);
                      parser.textNode += "</" + parser.tagName + ">";
                      parser.state = S.TEXT;
                      return;
                    }
                    parser.tagName = tagName;
                    var s2 = parser.tags.length;
                    while (s2-- > t) {
                      var tag = parser.tag = parser.tags.pop();
                      parser.tagName = parser.tag.name;
                      emitNode(parser, "onclosetag", parser.tagName);
                      var x = {};
                      for (var i in tag.ns) {
                        x[i] = tag.ns[i];
                      }
                      var parent = parser.tags[parser.tags.length - 1] || parser;
                      if (parser.opt.xmlns && tag.ns !== parent.ns) {
                        Object.keys(tag.ns).forEach(function(p) {
                          var n = tag.ns[p];
                          emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
                        });
                      }
                    }
                    if (t === 0)
                      parser.closedRoot = true;
                    parser.tagName = parser.attribValue = parser.attribName = "";
                    parser.attribList.length = 0;
                    parser.state = S.TEXT;
                  }
                  function parseEntity(parser) {
                    var entity = parser.entity;
                    var entityLC = entity.toLowerCase();
                    var num;
                    var numStr = "";
                    if (parser.ENTITIES[entity]) {
                      return parser.ENTITIES[entity];
                    }
                    if (parser.ENTITIES[entityLC]) {
                      return parser.ENTITIES[entityLC];
                    }
                    entity = entityLC;
                    if (entity.charAt(0) === "#") {
                      if (entity.charAt(1) === "x") {
                        entity = entity.slice(2);
                        num = parseInt(entity, 16);
                        numStr = num.toString(16);
                      } else {
                        entity = entity.slice(1);
                        num = parseInt(entity, 10);
                        numStr = num.toString(10);
                      }
                    }
                    entity = entity.replace(/^0+/, "");
                    if (isNaN(num) || numStr.toLowerCase() !== entity) {
                      strictFail(parser, "Invalid character entity");
                      return "&" + parser.entity + ";";
                    }
                    return String.fromCodePoint(num);
                  }
                  function beginWhiteSpace(parser, c) {
                    if (c === "<") {
                      parser.state = S.OPEN_WAKA;
                      parser.startTagPosition = parser.position;
                    } else if (!isWhitespace(c)) {
                      strictFail(parser, "Non-whitespace before first tag.");
                      parser.textNode = c;
                      parser.state = S.TEXT;
                    }
                  }
                  function charAt(chunk, i) {
                    var result = "";
                    if (i < chunk.length) {
                      result = chunk.charAt(i);
                    }
                    return result;
                  }
                  function write(chunk) {
                    var parser = this;
                    if (this.error) {
                      throw this.error;
                    }
                    if (parser.closed) {
                      return error(
                        parser,
                        "Cannot write after close. Assign an onready handler."
                      );
                    }
                    if (chunk === null) {
                      return end(parser);
                    }
                    if (typeof chunk === "object") {
                      chunk = chunk.toString();
                    }
                    var i = 0;
                    var c = "";
                    while (true) {
                      c = charAt(chunk, i++);
                      parser.c = c;
                      if (!c) {
                        break;
                      }
                      if (parser.trackPosition) {
                        parser.position++;
                        if (c === "\n") {
                          parser.line++;
                          parser.column = 0;
                        } else {
                          parser.column++;
                        }
                      }
                      switch (parser.state) {
                        case S.BEGIN:
                          parser.state = S.BEGIN_WHITESPACE;
                          if (c === "\uFEFF") {
                            continue;
                          }
                          beginWhiteSpace(parser, c);
                          continue;
                        case S.BEGIN_WHITESPACE:
                          beginWhiteSpace(parser, c);
                          continue;
                        case S.TEXT:
                          if (parser.sawRoot && !parser.closedRoot) {
                            var starti = i - 1;
                            while (c && c !== "<" && c !== "&") {
                              c = charAt(chunk, i++);
                              if (c && parser.trackPosition) {
                                parser.position++;
                                if (c === "\n") {
                                  parser.line++;
                                  parser.column = 0;
                                } else {
                                  parser.column++;
                                }
                              }
                            }
                            parser.textNode += chunk.substring(starti, i - 1);
                          }
                          if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                            parser.state = S.OPEN_WAKA;
                            parser.startTagPosition = parser.position;
                          } else {
                            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                              strictFail(parser, "Text data outside of root node.");
                            }
                            if (c === "&") {
                              parser.state = S.TEXT_ENTITY;
                            } else {
                              parser.textNode += c;
                            }
                          }
                          continue;
                        case S.SCRIPT:
                          if (c === "<") {
                            parser.state = S.SCRIPT_ENDING;
                          } else {
                            parser.script += c;
                          }
                          continue;
                        case S.SCRIPT_ENDING:
                          if (c === "/") {
                            parser.state = S.CLOSE_TAG;
                          } else {
                            parser.script += "<" + c;
                            parser.state = S.SCRIPT;
                          }
                          continue;
                        case S.OPEN_WAKA:
                          if (c === "!") {
                            parser.state = S.SGML_DECL;
                            parser.sgmlDecl = "";
                          } else if (isWhitespace(c)) {
                          } else if (isMatch(nameStart, c)) {
                            parser.state = S.OPEN_TAG;
                            parser.tagName = c;
                          } else if (c === "/") {
                            parser.state = S.CLOSE_TAG;
                            parser.tagName = "";
                          } else if (c === "?") {
                            parser.state = S.PROC_INST;
                            parser.procInstName = parser.procInstBody = "";
                          } else {
                            strictFail(parser, "Unencoded <");
                            if (parser.startTagPosition + 1 < parser.position) {
                              var pad = parser.position - parser.startTagPosition;
                              c = new Array(pad).join(" ") + c;
                            }
                            parser.textNode += "<" + c;
                            parser.state = S.TEXT;
                          }
                          continue;
                        case S.SGML_DECL:
                          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                            emitNode(parser, "onopencdata");
                            parser.state = S.CDATA;
                            parser.sgmlDecl = "";
                            parser.cdata = "";
                          } else if (parser.sgmlDecl + c === "--") {
                            parser.state = S.COMMENT;
                            parser.comment = "";
                            parser.sgmlDecl = "";
                          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                            parser.state = S.DOCTYPE;
                            if (parser.doctype || parser.sawRoot) {
                              strictFail(
                                parser,
                                "Inappropriately located doctype declaration"
                              );
                            }
                            parser.doctype = "";
                            parser.sgmlDecl = "";
                          } else if (c === ">") {
                            emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                            parser.sgmlDecl = "";
                            parser.state = S.TEXT;
                          } else if (isQuote(c)) {
                            parser.state = S.SGML_DECL_QUOTED;
                            parser.sgmlDecl += c;
                          } else {
                            parser.sgmlDecl += c;
                          }
                          continue;
                        case S.SGML_DECL_QUOTED:
                          if (c === parser.q) {
                            parser.state = S.SGML_DECL;
                            parser.q = "";
                          }
                          parser.sgmlDecl += c;
                          continue;
                        case S.DOCTYPE:
                          if (c === ">") {
                            parser.state = S.TEXT;
                            emitNode(parser, "ondoctype", parser.doctype);
                            parser.doctype = true;
                          } else {
                            parser.doctype += c;
                            if (c === "[") {
                              parser.state = S.DOCTYPE_DTD;
                            } else if (isQuote(c)) {
                              parser.state = S.DOCTYPE_QUOTED;
                              parser.q = c;
                            }
                          }
                          continue;
                        case S.DOCTYPE_QUOTED:
                          parser.doctype += c;
                          if (c === parser.q) {
                            parser.q = "";
                            parser.state = S.DOCTYPE;
                          }
                          continue;
                        case S.DOCTYPE_DTD:
                          parser.doctype += c;
                          if (c === "]") {
                            parser.state = S.DOCTYPE;
                          } else if (isQuote(c)) {
                            parser.state = S.DOCTYPE_DTD_QUOTED;
                            parser.q = c;
                          }
                          continue;
                        case S.DOCTYPE_DTD_QUOTED:
                          parser.doctype += c;
                          if (c === parser.q) {
                            parser.state = S.DOCTYPE_DTD;
                            parser.q = "";
                          }
                          continue;
                        case S.COMMENT:
                          if (c === "-") {
                            parser.state = S.COMMENT_ENDING;
                          } else {
                            parser.comment += c;
                          }
                          continue;
                        case S.COMMENT_ENDING:
                          if (c === "-") {
                            parser.state = S.COMMENT_ENDED;
                            parser.comment = textopts(parser.opt, parser.comment);
                            if (parser.comment) {
                              emitNode(parser, "oncomment", parser.comment);
                            }
                            parser.comment = "";
                          } else {
                            parser.comment += "-" + c;
                            parser.state = S.COMMENT;
                          }
                          continue;
                        case S.COMMENT_ENDED:
                          if (c !== ">") {
                            strictFail(parser, "Malformed comment");
                            parser.comment += "--" + c;
                            parser.state = S.COMMENT;
                          } else {
                            parser.state = S.TEXT;
                          }
                          continue;
                        case S.CDATA:
                          if (c === "]") {
                            parser.state = S.CDATA_ENDING;
                          } else {
                            parser.cdata += c;
                          }
                          continue;
                        case S.CDATA_ENDING:
                          if (c === "]") {
                            parser.state = S.CDATA_ENDING_2;
                          } else {
                            parser.cdata += "]" + c;
                            parser.state = S.CDATA;
                          }
                          continue;
                        case S.CDATA_ENDING_2:
                          if (c === ">") {
                            if (parser.cdata) {
                              emitNode(parser, "oncdata", parser.cdata);
                            }
                            emitNode(parser, "onclosecdata");
                            parser.cdata = "";
                            parser.state = S.TEXT;
                          } else if (c === "]") {
                            parser.cdata += "]";
                          } else {
                            parser.cdata += "]]" + c;
                            parser.state = S.CDATA;
                          }
                          continue;
                        case S.PROC_INST:
                          if (c === "?") {
                            parser.state = S.PROC_INST_ENDING;
                          } else if (isWhitespace(c)) {
                            parser.state = S.PROC_INST_BODY;
                          } else {
                            parser.procInstName += c;
                          }
                          continue;
                        case S.PROC_INST_BODY:
                          if (!parser.procInstBody && isWhitespace(c)) {
                            continue;
                          } else if (c === "?") {
                            parser.state = S.PROC_INST_ENDING;
                          } else {
                            parser.procInstBody += c;
                          }
                          continue;
                        case S.PROC_INST_ENDING:
                          if (c === ">") {
                            emitNode(parser, "onprocessinginstruction", {
                              name: parser.procInstName,
                              body: parser.procInstBody
                            });
                            parser.procInstName = parser.procInstBody = "";
                            parser.state = S.TEXT;
                          } else {
                            parser.procInstBody += "?" + c;
                            parser.state = S.PROC_INST_BODY;
                          }
                          continue;
                        case S.OPEN_TAG:
                          if (isMatch(nameBody, c)) {
                            parser.tagName += c;
                          } else {
                            newTag(parser);
                            if (c === ">") {
                              openTag(parser);
                            } else if (c === "/") {
                              parser.state = S.OPEN_TAG_SLASH;
                            } else {
                              if (!isWhitespace(c)) {
                                strictFail(parser, "Invalid character in tag name");
                              }
                              parser.state = S.ATTRIB;
                            }
                          }
                          continue;
                        case S.OPEN_TAG_SLASH:
                          if (c === ">") {
                            openTag(parser, true);
                            closeTag(parser);
                          } else {
                            strictFail(parser, "Forward-slash in opening tag not followed by >");
                            parser.state = S.ATTRIB;
                          }
                          continue;
                        case S.ATTRIB:
                          if (isWhitespace(c)) {
                            continue;
                          } else if (c === ">") {
                            openTag(parser);
                          } else if (c === "/") {
                            parser.state = S.OPEN_TAG_SLASH;
                          } else if (isMatch(nameStart, c)) {
                            parser.attribName = c;
                            parser.attribValue = "";
                            parser.state = S.ATTRIB_NAME;
                          } else {
                            strictFail(parser, "Invalid attribute name");
                          }
                          continue;
                        case S.ATTRIB_NAME:
                          if (c === "=") {
                            parser.state = S.ATTRIB_VALUE;
                          } else if (c === ">") {
                            strictFail(parser, "Attribute without value");
                            parser.attribValue = parser.attribName;
                            attrib(parser);
                            openTag(parser);
                          } else if (isWhitespace(c)) {
                            parser.state = S.ATTRIB_NAME_SAW_WHITE;
                          } else if (isMatch(nameBody, c)) {
                            parser.attribName += c;
                          } else {
                            strictFail(parser, "Invalid attribute name");
                          }
                          continue;
                        case S.ATTRIB_NAME_SAW_WHITE:
                          if (c === "=") {
                            parser.state = S.ATTRIB_VALUE;
                          } else if (isWhitespace(c)) {
                            continue;
                          } else {
                            strictFail(parser, "Attribute without value");
                            parser.tag.attributes[parser.attribName] = "";
                            parser.attribValue = "";
                            emitNode(parser, "onattribute", {
                              name: parser.attribName,
                              value: ""
                            });
                            parser.attribName = "";
                            if (c === ">") {
                              openTag(parser);
                            } else if (isMatch(nameStart, c)) {
                              parser.attribName = c;
                              parser.state = S.ATTRIB_NAME;
                            } else {
                              strictFail(parser, "Invalid attribute name");
                              parser.state = S.ATTRIB;
                            }
                          }
                          continue;
                        case S.ATTRIB_VALUE:
                          if (isWhitespace(c)) {
                            continue;
                          } else if (isQuote(c)) {
                            parser.q = c;
                            parser.state = S.ATTRIB_VALUE_QUOTED;
                          } else {
                            strictFail(parser, "Unquoted attribute value");
                            parser.state = S.ATTRIB_VALUE_UNQUOTED;
                            parser.attribValue = c;
                          }
                          continue;
                        case S.ATTRIB_VALUE_QUOTED:
                          if (c !== parser.q) {
                            if (c === "&") {
                              parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                            } else {
                              parser.attribValue += c;
                            }
                            continue;
                          }
                          attrib(parser);
                          parser.q = "";
                          parser.state = S.ATTRIB_VALUE_CLOSED;
                          continue;
                        case S.ATTRIB_VALUE_CLOSED:
                          if (isWhitespace(c)) {
                            parser.state = S.ATTRIB;
                          } else if (c === ">") {
                            openTag(parser);
                          } else if (c === "/") {
                            parser.state = S.OPEN_TAG_SLASH;
                          } else if (isMatch(nameStart, c)) {
                            strictFail(parser, "No whitespace between attributes");
                            parser.attribName = c;
                            parser.attribValue = "";
                            parser.state = S.ATTRIB_NAME;
                          } else {
                            strictFail(parser, "Invalid attribute name");
                          }
                          continue;
                        case S.ATTRIB_VALUE_UNQUOTED:
                          if (!isAttribEnd(c)) {
                            if (c === "&") {
                              parser.state = S.ATTRIB_VALUE_ENTITY_U;
                            } else {
                              parser.attribValue += c;
                            }
                            continue;
                          }
                          attrib(parser);
                          if (c === ">") {
                            openTag(parser);
                          } else {
                            parser.state = S.ATTRIB;
                          }
                          continue;
                        case S.CLOSE_TAG:
                          if (!parser.tagName) {
                            if (isWhitespace(c)) {
                              continue;
                            } else if (notMatch(nameStart, c)) {
                              if (parser.script) {
                                parser.script += "</" + c;
                                parser.state = S.SCRIPT;
                              } else {
                                strictFail(parser, "Invalid tagname in closing tag.");
                              }
                            } else {
                              parser.tagName = c;
                            }
                          } else if (c === ">") {
                            closeTag(parser);
                          } else if (isMatch(nameBody, c)) {
                            parser.tagName += c;
                          } else if (parser.script) {
                            parser.script += "</" + parser.tagName;
                            parser.tagName = "";
                            parser.state = S.SCRIPT;
                          } else {
                            if (!isWhitespace(c)) {
                              strictFail(parser, "Invalid tagname in closing tag");
                            }
                            parser.state = S.CLOSE_TAG_SAW_WHITE;
                          }
                          continue;
                        case S.CLOSE_TAG_SAW_WHITE:
                          if (isWhitespace(c)) {
                            continue;
                          }
                          if (c === ">") {
                            closeTag(parser);
                          } else {
                            strictFail(parser, "Invalid characters in closing tag");
                          }
                          continue;
                        case S.TEXT_ENTITY:
                        case S.ATTRIB_VALUE_ENTITY_Q:
                        case S.ATTRIB_VALUE_ENTITY_U:
                          var returnState;
                          var buffer;
                          switch (parser.state) {
                            case S.TEXT_ENTITY:
                              returnState = S.TEXT;
                              buffer = "textNode";
                              break;
                            case S.ATTRIB_VALUE_ENTITY_Q:
                              returnState = S.ATTRIB_VALUE_QUOTED;
                              buffer = "attribValue";
                              break;
                            case S.ATTRIB_VALUE_ENTITY_U:
                              returnState = S.ATTRIB_VALUE_UNQUOTED;
                              buffer = "attribValue";
                              break;
                          }
                          if (c === ";") {
                            parser[buffer] += parseEntity(parser);
                            parser.entity = "";
                            parser.state = returnState;
                          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                            parser.entity += c;
                          } else {
                            strictFail(parser, "Invalid character in entity name");
                            parser[buffer] += "&" + parser.entity + c;
                            parser.entity = "";
                            parser.state = returnState;
                          }
                          continue;
                        default:
                          throw new Error(parser, "Unknown state: " + parser.state);
                      }
                    }
                    if (parser.position >= parser.bufferCheckPosition) {
                      checkBufferLength(parser);
                    }
                    return parser;
                  }
                  if (!String.fromCodePoint) {
                    (function() {
                      var stringFromCharCode = String.fromCharCode;
                      var floor = Math.floor;
                      var fromCodePoint = function() {
                        var MAX_SIZE = 16384;
                        var codeUnits = [];
                        var highSurrogate;
                        var lowSurrogate;
                        var index = -1;
                        var length = arguments.length;
                        if (!length) {
                          return "";
                        }
                        var result = "";
                        while (++index < length) {
                          var codePoint = Number(arguments[index]);
                          if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                          codePoint < 0 || // not a valid Unicode code point
                          codePoint > 1114111 || // not a valid Unicode code point
                          floor(codePoint) !== codePoint) {
                            throw RangeError("Invalid code point: " + codePoint);
                          }
                          if (codePoint <= 65535) {
                            codeUnits.push(codePoint);
                          } else {
                            codePoint -= 65536;
                            highSurrogate = (codePoint >> 10) + 55296;
                            lowSurrogate = codePoint % 1024 + 56320;
                            codeUnits.push(highSurrogate, lowSurrogate);
                          }
                          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                            result += stringFromCharCode.apply(null, codeUnits);
                            codeUnits.length = 0;
                          }
                        }
                        return result;
                      };
                      if (Object.defineProperty) {
                        Object.defineProperty(String, "fromCodePoint", {
                          value: fromCodePoint,
                          configurable: true,
                          writable: true
                        });
                      } else {
                        String.fromCodePoint = fromCodePoint;
                      }
                    })();
                  }
                })(false ? 0 : exports2);
              }
            ),
            /***/
            2830: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                module2.exports = Stream;
                var EE = __webpack_require__2(7187).EventEmitter;
                var inherits = __webpack_require__2(5717);
                inherits(Stream, EE);
                Stream.Readable = __webpack_require__2(6577);
                Stream.Writable = __webpack_require__2(323);
                Stream.Duplex = __webpack_require__2(8656);
                Stream.Transform = __webpack_require__2(4473);
                Stream.PassThrough = __webpack_require__2(2366);
                Stream.finished = __webpack_require__2(1086);
                Stream.pipeline = __webpack_require__2(6472);
                Stream.Stream = Stream;
                function Stream() {
                  EE.call(this);
                }
                Stream.prototype.pipe = function(dest, options) {
                  var source = this;
                  function ondata(chunk) {
                    if (dest.writable) {
                      if (false === dest.write(chunk) && source.pause) {
                        source.pause();
                      }
                    }
                  }
                  source.on("data", ondata);
                  function ondrain() {
                    if (source.readable && source.resume) {
                      source.resume();
                    }
                  }
                  dest.on("drain", ondrain);
                  if (!dest._isStdio && (!options || options.end !== false)) {
                    source.on("end", onend);
                    source.on("close", onclose);
                  }
                  var didOnEnd = false;
                  function onend() {
                    if (didOnEnd)
                      return;
                    didOnEnd = true;
                    dest.end();
                  }
                  function onclose() {
                    if (didOnEnd)
                      return;
                    didOnEnd = true;
                    if (typeof dest.destroy === "function")
                      dest.destroy();
                  }
                  function onerror(er) {
                    cleanup();
                    if (EE.listenerCount(this, "error") === 0) {
                      throw er;
                    }
                  }
                  source.on("error", onerror);
                  dest.on("error", onerror);
                  function cleanup() {
                    source.removeListener("data", ondata);
                    dest.removeListener("drain", ondrain);
                    source.removeListener("end", onend);
                    source.removeListener("close", onclose);
                    source.removeListener("error", onerror);
                    dest.removeListener("error", onerror);
                    source.removeListener("end", cleanup);
                    source.removeListener("close", cleanup);
                    dest.removeListener("close", cleanup);
                  }
                  source.on("end", cleanup);
                  source.on("close", cleanup);
                  dest.on("close", cleanup);
                  dest.emit("pipe", source);
                  return dest;
                };
              }
            ),
            /***/
            8106: (
              /***/
              function(module2) {
                "use strict";
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  subClass.__proto__ = superClass;
                }
                var codes = {};
                function createErrorType(code, message, Base) {
                  if (!Base) {
                    Base = Error;
                  }
                  function getMessage(arg1, arg2, arg3) {
                    if (typeof message === "string") {
                      return message;
                    } else {
                      return message(arg1, arg2, arg3);
                    }
                  }
                  var NodeError = function(_Base) {
                    _inheritsLoose(NodeError2, _Base);
                    function NodeError2(arg1, arg2, arg3) {
                      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
                    }
                    return NodeError2;
                  }(Base);
                  NodeError.prototype.name = Base.name;
                  NodeError.prototype.code = code;
                  codes[code] = NodeError;
                }
                function oneOf(expected, thing) {
                  if (Array.isArray(expected)) {
                    var len = expected.length;
                    expected = expected.map(function(i) {
                      return String(i);
                    });
                    if (len > 2) {
                      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
                    } else if (len === 2) {
                      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
                    } else {
                      return "of ".concat(thing, " ").concat(expected[0]);
                    }
                  } else {
                    return "of ".concat(thing, " ").concat(String(expected));
                  }
                }
                function startsWith(str, search, pos) {
                  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
                }
                function endsWith(str, search, this_len) {
                  if (this_len === void 0 || this_len > str.length) {
                    this_len = str.length;
                  }
                  return str.substring(this_len - search.length, this_len) === search;
                }
                function includes(str, search, start) {
                  if (typeof start !== "number") {
                    start = 0;
                  }
                  if (start + search.length > str.length) {
                    return false;
                  } else {
                    return str.indexOf(search, start) !== -1;
                  }
                }
                createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
                  return 'The value "' + value + '" is invalid for option "' + name + '"';
                }, TypeError);
                createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
                  var determiner;
                  if (typeof expected === "string" && startsWith(expected, "not ")) {
                    determiner = "must not be";
                    expected = expected.replace(/^not /, "");
                  } else {
                    determiner = "must be";
                  }
                  var msg;
                  if (endsWith(name, " argument")) {
                    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
                  } else {
                    var type = includes(name, ".") ? "property" : "argument";
                    msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
                  }
                  msg += ". Received type ".concat(typeof actual);
                  return msg;
                }, TypeError);
                createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
                createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
                  return "The " + name + " method is not implemented";
                });
                createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
                createErrorType("ERR_STREAM_DESTROYED", function(name) {
                  return "Cannot call " + name + " after a stream was destroyed";
                });
                createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
                createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
                createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
                createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
                createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
                  return "Unknown encoding: " + arg;
                }, TypeError);
                createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
                module2.exports.q = codes;
              }
            ),
            /***/
            8656: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var process = __webpack_require__2(4155);
                var objectKeys = Object.keys || function(obj) {
                  var keys2 = [];
                  for (var key in obj) {
                    keys2.push(key);
                  }
                  return keys2;
                };
                module2.exports = Duplex;
                var Readable = __webpack_require__2(6577);
                var Writable = __webpack_require__2(323);
                __webpack_require__2(5717)(Duplex, Readable);
                {
                  var keys = objectKeys(Writable.prototype);
                  for (var v = 0; v < keys.length; v++) {
                    var method = keys[v];
                    if (!Duplex.prototype[method])
                      Duplex.prototype[method] = Writable.prototype[method];
                  }
                }
                function Duplex(options) {
                  if (!(this instanceof Duplex))
                    return new Duplex(options);
                  Readable.call(this, options);
                  Writable.call(this, options);
                  this.allowHalfOpen = true;
                  if (options) {
                    if (options.readable === false)
                      this.readable = false;
                    if (options.writable === false)
                      this.writable = false;
                    if (options.allowHalfOpen === false) {
                      this.allowHalfOpen = false;
                      this.once("end", onend);
                    }
                  }
                }
                Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._writableState.highWaterMark;
                  }
                });
                Object.defineProperty(Duplex.prototype, "writableBuffer", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._writableState && this._writableState.getBuffer();
                  }
                });
                Object.defineProperty(Duplex.prototype, "writableLength", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._writableState.length;
                  }
                });
                function onend() {
                  if (this._writableState.ended)
                    return;
                  process.nextTick(onEndNT, this);
                }
                function onEndNT(self2) {
                  self2.end();
                }
                Object.defineProperty(Duplex.prototype, "destroyed", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    if (this._readableState === void 0 || this._writableState === void 0) {
                      return false;
                    }
                    return this._readableState.destroyed && this._writableState.destroyed;
                  },
                  set: function set(value) {
                    if (this._readableState === void 0 || this._writableState === void 0) {
                      return;
                    }
                    this._readableState.destroyed = value;
                    this._writableState.destroyed = value;
                  }
                });
              }
            ),
            /***/
            2366: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                module2.exports = PassThrough;
                var Transform = __webpack_require__2(4473);
                __webpack_require__2(5717)(PassThrough, Transform);
                function PassThrough(options) {
                  if (!(this instanceof PassThrough))
                    return new PassThrough(options);
                  Transform.call(this, options);
                }
                PassThrough.prototype._transform = function(chunk, encoding, cb) {
                  cb(null, chunk);
                };
              }
            ),
            /***/
            6577: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var process = __webpack_require__2(4155);
                module2.exports = Readable;
                var Duplex;
                Readable.ReadableState = ReadableState;
                var EE = __webpack_require__2(7187).EventEmitter;
                var EElistenerCount = function EElistenerCount2(emitter, type) {
                  return emitter.listeners(type).length;
                };
                var Stream = __webpack_require__2(3194);
                var Buffer = __webpack_require__2(8823).Buffer;
                var OurUint8Array = __webpack_require__2.g.Uint8Array || function() {
                };
                function _uint8ArrayToBuffer(chunk) {
                  return Buffer.from(chunk);
                }
                function _isUint8Array(obj) {
                  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
                }
                var debugUtil = __webpack_require__2(964);
                var debug;
                if (debugUtil && debugUtil.debuglog) {
                  debug = debugUtil.debuglog("stream");
                } else {
                  debug = function debug2() {
                  };
                }
                var BufferList = __webpack_require__2(3361);
                var destroyImpl = __webpack_require__2(1029);
                var _require = __webpack_require__2(94), getHighWaterMark = _require.getHighWaterMark;
                var _require$codes = __webpack_require__2(8106).q, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
                var StringDecoder;
                var createReadableStreamAsyncIterator;
                var from;
                __webpack_require__2(5717)(Readable, Stream);
                var errorOrDestroy = destroyImpl.errorOrDestroy;
                var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
                function prependListener(emitter, event, fn) {
                  if (typeof emitter.prependListener === "function")
                    return emitter.prependListener(event, fn);
                  if (!emitter._events || !emitter._events[event])
                    emitter.on(event, fn);
                  else if (Array.isArray(emitter._events[event]))
                    emitter._events[event].unshift(fn);
                  else
                    emitter._events[event] = [fn, emitter._events[event]];
                }
                function ReadableState(options, stream, isDuplex) {
                  Duplex = Duplex || __webpack_require__2(8656);
                  options = options || {};
                  if (typeof isDuplex !== "boolean")
                    isDuplex = stream instanceof Duplex;
                  this.objectMode = !!options.objectMode;
                  if (isDuplex)
                    this.objectMode = this.objectMode || !!options.readableObjectMode;
                  this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
                  this.buffer = new BufferList();
                  this.length = 0;
                  this.pipes = null;
                  this.pipesCount = 0;
                  this.flowing = null;
                  this.ended = false;
                  this.endEmitted = false;
                  this.reading = false;
                  this.sync = true;
                  this.needReadable = false;
                  this.emittedReadable = false;
                  this.readableListening = false;
                  this.resumeScheduled = false;
                  this.paused = true;
                  this.emitClose = options.emitClose !== false;
                  this.autoDestroy = !!options.autoDestroy;
                  this.destroyed = false;
                  this.defaultEncoding = options.defaultEncoding || "utf8";
                  this.awaitDrain = 0;
                  this.readingMore = false;
                  this.decoder = null;
                  this.encoding = null;
                  if (options.encoding) {
                    if (!StringDecoder)
                      StringDecoder = __webpack_require__2(2553).s;
                    this.decoder = new StringDecoder(options.encoding);
                    this.encoding = options.encoding;
                  }
                }
                function Readable(options) {
                  Duplex = Duplex || __webpack_require__2(8656);
                  if (!(this instanceof Readable))
                    return new Readable(options);
                  var isDuplex = this instanceof Duplex;
                  this._readableState = new ReadableState(options, this, isDuplex);
                  this.readable = true;
                  if (options) {
                    if (typeof options.read === "function")
                      this._read = options.read;
                    if (typeof options.destroy === "function")
                      this._destroy = options.destroy;
                  }
                  Stream.call(this);
                }
                Object.defineProperty(Readable.prototype, "destroyed", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    if (this._readableState === void 0) {
                      return false;
                    }
                    return this._readableState.destroyed;
                  },
                  set: function set(value) {
                    if (!this._readableState) {
                      return;
                    }
                    this._readableState.destroyed = value;
                  }
                });
                Readable.prototype.destroy = destroyImpl.destroy;
                Readable.prototype._undestroy = destroyImpl.undestroy;
                Readable.prototype._destroy = function(err, cb) {
                  cb(err);
                };
                Readable.prototype.push = function(chunk, encoding) {
                  var state = this._readableState;
                  var skipChunkCheck;
                  if (!state.objectMode) {
                    if (typeof chunk === "string") {
                      encoding = encoding || state.defaultEncoding;
                      if (encoding !== state.encoding) {
                        chunk = Buffer.from(chunk, encoding);
                        encoding = "";
                      }
                      skipChunkCheck = true;
                    }
                  } else {
                    skipChunkCheck = true;
                  }
                  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
                };
                Readable.prototype.unshift = function(chunk) {
                  return readableAddChunk(this, chunk, null, true, false);
                };
                function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
                  debug("readableAddChunk", chunk);
                  var state = stream._readableState;
                  if (chunk === null) {
                    state.reading = false;
                    onEofChunk(stream, state);
                  } else {
                    var er;
                    if (!skipChunkCheck)
                      er = chunkInvalid(state, chunk);
                    if (er) {
                      errorOrDestroy(stream, er);
                    } else if (state.objectMode || chunk && chunk.length > 0) {
                      if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                        chunk = _uint8ArrayToBuffer(chunk);
                      }
                      if (addToFront) {
                        if (state.endEmitted)
                          errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                        else
                          addChunk(stream, state, chunk, true);
                      } else if (state.ended) {
                        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
                      } else if (state.destroyed) {
                        return false;
                      } else {
                        state.reading = false;
                        if (state.decoder && !encoding) {
                          chunk = state.decoder.write(chunk);
                          if (state.objectMode || chunk.length !== 0)
                            addChunk(stream, state, chunk, false);
                          else
                            maybeReadMore(stream, state);
                        } else {
                          addChunk(stream, state, chunk, false);
                        }
                      }
                    } else if (!addToFront) {
                      state.reading = false;
                      maybeReadMore(stream, state);
                    }
                  }
                  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
                }
                function addChunk(stream, state, chunk, addToFront) {
                  if (state.flowing && state.length === 0 && !state.sync) {
                    state.awaitDrain = 0;
                    stream.emit("data", chunk);
                  } else {
                    state.length += state.objectMode ? 1 : chunk.length;
                    if (addToFront)
                      state.buffer.unshift(chunk);
                    else
                      state.buffer.push(chunk);
                    if (state.needReadable)
                      emitReadable(stream);
                  }
                  maybeReadMore(stream, state);
                }
                function chunkInvalid(state, chunk) {
                  var er;
                  if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
                    er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
                  }
                  return er;
                }
                Readable.prototype.isPaused = function() {
                  return this._readableState.flowing === false;
                };
                Readable.prototype.setEncoding = function(enc) {
                  if (!StringDecoder)
                    StringDecoder = __webpack_require__2(2553).s;
                  var decoder = new StringDecoder(enc);
                  this._readableState.decoder = decoder;
                  this._readableState.encoding = this._readableState.decoder.encoding;
                  var p = this._readableState.buffer.head;
                  var content = "";
                  while (p !== null) {
                    content += decoder.write(p.data);
                    p = p.next;
                  }
                  this._readableState.buffer.clear();
                  if (content !== "")
                    this._readableState.buffer.push(content);
                  this._readableState.length = content.length;
                  return this;
                };
                var MAX_HWM = 1073741824;
                function computeNewHighWaterMark(n) {
                  if (n >= MAX_HWM) {
                    n = MAX_HWM;
                  } else {
                    n--;
                    n |= n >>> 1;
                    n |= n >>> 2;
                    n |= n >>> 4;
                    n |= n >>> 8;
                    n |= n >>> 16;
                    n++;
                  }
                  return n;
                }
                function howMuchToRead(n, state) {
                  if (n <= 0 || state.length === 0 && state.ended)
                    return 0;
                  if (state.objectMode)
                    return 1;
                  if (n !== n) {
                    if (state.flowing && state.length)
                      return state.buffer.head.data.length;
                    else
                      return state.length;
                  }
                  if (n > state.highWaterMark)
                    state.highWaterMark = computeNewHighWaterMark(n);
                  if (n <= state.length)
                    return n;
                  if (!state.ended) {
                    state.needReadable = true;
                    return 0;
                  }
                  return state.length;
                }
                Readable.prototype.read = function(n) {
                  debug("read", n);
                  n = parseInt(n, 10);
                  var state = this._readableState;
                  var nOrig = n;
                  if (n !== 0)
                    state.emittedReadable = false;
                  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
                    debug("read: emitReadable", state.length, state.ended);
                    if (state.length === 0 && state.ended)
                      endReadable(this);
                    else
                      emitReadable(this);
                    return null;
                  }
                  n = howMuchToRead(n, state);
                  if (n === 0 && state.ended) {
                    if (state.length === 0)
                      endReadable(this);
                    return null;
                  }
                  var doRead = state.needReadable;
                  debug("need readable", doRead);
                  if (state.length === 0 || state.length - n < state.highWaterMark) {
                    doRead = true;
                    debug("length less than watermark", doRead);
                  }
                  if (state.ended || state.reading) {
                    doRead = false;
                    debug("reading or ended", doRead);
                  } else if (doRead) {
                    debug("do read");
                    state.reading = true;
                    state.sync = true;
                    if (state.length === 0)
                      state.needReadable = true;
                    this._read(state.highWaterMark);
                    state.sync = false;
                    if (!state.reading)
                      n = howMuchToRead(nOrig, state);
                  }
                  var ret;
                  if (n > 0)
                    ret = fromList(n, state);
                  else
                    ret = null;
                  if (ret === null) {
                    state.needReadable = state.length <= state.highWaterMark;
                    n = 0;
                  } else {
                    state.length -= n;
                    state.awaitDrain = 0;
                  }
                  if (state.length === 0) {
                    if (!state.ended)
                      state.needReadable = true;
                    if (nOrig !== n && state.ended)
                      endReadable(this);
                  }
                  if (ret !== null)
                    this.emit("data", ret);
                  return ret;
                };
                function onEofChunk(stream, state) {
                  debug("onEofChunk");
                  if (state.ended)
                    return;
                  if (state.decoder) {
                    var chunk = state.decoder.end();
                    if (chunk && chunk.length) {
                      state.buffer.push(chunk);
                      state.length += state.objectMode ? 1 : chunk.length;
                    }
                  }
                  state.ended = true;
                  if (state.sync) {
                    emitReadable(stream);
                  } else {
                    state.needReadable = false;
                    if (!state.emittedReadable) {
                      state.emittedReadable = true;
                      emitReadable_(stream);
                    }
                  }
                }
                function emitReadable(stream) {
                  var state = stream._readableState;
                  debug("emitReadable", state.needReadable, state.emittedReadable);
                  state.needReadable = false;
                  if (!state.emittedReadable) {
                    debug("emitReadable", state.flowing);
                    state.emittedReadable = true;
                    process.nextTick(emitReadable_, stream);
                  }
                }
                function emitReadable_(stream) {
                  var state = stream._readableState;
                  debug("emitReadable_", state.destroyed, state.length, state.ended);
                  if (!state.destroyed && (state.length || state.ended)) {
                    stream.emit("readable");
                    state.emittedReadable = false;
                  }
                  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
                  flow(stream);
                }
                function maybeReadMore(stream, state) {
                  if (!state.readingMore) {
                    state.readingMore = true;
                    process.nextTick(maybeReadMore_, stream, state);
                  }
                }
                function maybeReadMore_(stream, state) {
                  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
                    var len = state.length;
                    debug("maybeReadMore read 0");
                    stream.read(0);
                    if (len === state.length)
                      break;
                  }
                  state.readingMore = false;
                }
                Readable.prototype._read = function(n) {
                  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
                };
                Readable.prototype.pipe = function(dest, pipeOpts) {
                  var src = this;
                  var state = this._readableState;
                  switch (state.pipesCount) {
                    case 0:
                      state.pipes = dest;
                      break;
                    case 1:
                      state.pipes = [state.pipes, dest];
                      break;
                    default:
                      state.pipes.push(dest);
                      break;
                  }
                  state.pipesCount += 1;
                  debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
                  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
                  var endFn = doEnd ? onend : unpipe;
                  if (state.endEmitted)
                    process.nextTick(endFn);
                  else
                    src.once("end", endFn);
                  dest.on("unpipe", onunpipe);
                  function onunpipe(readable, unpipeInfo) {
                    debug("onunpipe");
                    if (readable === src) {
                      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                        unpipeInfo.hasUnpiped = true;
                        cleanup();
                      }
                    }
                  }
                  function onend() {
                    debug("onend");
                    dest.end();
                  }
                  var ondrain = pipeOnDrain(src);
                  dest.on("drain", ondrain);
                  var cleanedUp = false;
                  function cleanup() {
                    debug("cleanup");
                    dest.removeListener("close", onclose);
                    dest.removeListener("finish", onfinish);
                    dest.removeListener("drain", ondrain);
                    dest.removeListener("error", onerror);
                    dest.removeListener("unpipe", onunpipe);
                    src.removeListener("end", onend);
                    src.removeListener("end", unpipe);
                    src.removeListener("data", ondata);
                    cleanedUp = true;
                    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                      ondrain();
                  }
                  src.on("data", ondata);
                  function ondata(chunk) {
                    debug("ondata");
                    var ret = dest.write(chunk);
                    debug("dest.write", ret);
                    if (ret === false) {
                      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                        debug("false write response, pause", state.awaitDrain);
                        state.awaitDrain++;
                      }
                      src.pause();
                    }
                  }
                  function onerror(er) {
                    debug("onerror", er);
                    unpipe();
                    dest.removeListener("error", onerror);
                    if (EElistenerCount(dest, "error") === 0)
                      errorOrDestroy(dest, er);
                  }
                  prependListener(dest, "error", onerror);
                  function onclose() {
                    dest.removeListener("finish", onfinish);
                    unpipe();
                  }
                  dest.once("close", onclose);
                  function onfinish() {
                    debug("onfinish");
                    dest.removeListener("close", onclose);
                    unpipe();
                  }
                  dest.once("finish", onfinish);
                  function unpipe() {
                    debug("unpipe");
                    src.unpipe(dest);
                  }
                  dest.emit("pipe", src);
                  if (!state.flowing) {
                    debug("pipe resume");
                    src.resume();
                  }
                  return dest;
                };
                function pipeOnDrain(src) {
                  return function pipeOnDrainFunctionResult() {
                    var state = src._readableState;
                    debug("pipeOnDrain", state.awaitDrain);
                    if (state.awaitDrain)
                      state.awaitDrain--;
                    if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                      state.flowing = true;
                      flow(src);
                    }
                  };
                }
                Readable.prototype.unpipe = function(dest) {
                  var state = this._readableState;
                  var unpipeInfo = {
                    hasUnpiped: false
                  };
                  if (state.pipesCount === 0)
                    return this;
                  if (state.pipesCount === 1) {
                    if (dest && dest !== state.pipes)
                      return this;
                    if (!dest)
                      dest = state.pipes;
                    state.pipes = null;
                    state.pipesCount = 0;
                    state.flowing = false;
                    if (dest)
                      dest.emit("unpipe", this, unpipeInfo);
                    return this;
                  }
                  if (!dest) {
                    var dests = state.pipes;
                    var len = state.pipesCount;
                    state.pipes = null;
                    state.pipesCount = 0;
                    state.flowing = false;
                    for (var i = 0; i < len; i++) {
                      dests[i].emit("unpipe", this, {
                        hasUnpiped: false
                      });
                    }
                    return this;
                  }
                  var index = indexOf(state.pipes, dest);
                  if (index === -1)
                    return this;
                  state.pipes.splice(index, 1);
                  state.pipesCount -= 1;
                  if (state.pipesCount === 1)
                    state.pipes = state.pipes[0];
                  dest.emit("unpipe", this, unpipeInfo);
                  return this;
                };
                Readable.prototype.on = function(ev, fn) {
                  var res = Stream.prototype.on.call(this, ev, fn);
                  var state = this._readableState;
                  if (ev === "data") {
                    state.readableListening = this.listenerCount("readable") > 0;
                    if (state.flowing !== false)
                      this.resume();
                  } else if (ev === "readable") {
                    if (!state.endEmitted && !state.readableListening) {
                      state.readableListening = state.needReadable = true;
                      state.flowing = false;
                      state.emittedReadable = false;
                      debug("on readable", state.length, state.reading);
                      if (state.length) {
                        emitReadable(this);
                      } else if (!state.reading) {
                        process.nextTick(nReadingNextTick, this);
                      }
                    }
                  }
                  return res;
                };
                Readable.prototype.addListener = Readable.prototype.on;
                Readable.prototype.removeListener = function(ev, fn) {
                  var res = Stream.prototype.removeListener.call(this, ev, fn);
                  if (ev === "readable") {
                    process.nextTick(updateReadableListening, this);
                  }
                  return res;
                };
                Readable.prototype.removeAllListeners = function(ev) {
                  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
                  if (ev === "readable" || ev === void 0) {
                    process.nextTick(updateReadableListening, this);
                  }
                  return res;
                };
                function updateReadableListening(self2) {
                  var state = self2._readableState;
                  state.readableListening = self2.listenerCount("readable") > 0;
                  if (state.resumeScheduled && !state.paused) {
                    state.flowing = true;
                  } else if (self2.listenerCount("data") > 0) {
                    self2.resume();
                  }
                }
                function nReadingNextTick(self2) {
                  debug("readable nexttick read 0");
                  self2.read(0);
                }
                Readable.prototype.resume = function() {
                  var state = this._readableState;
                  if (!state.flowing) {
                    debug("resume");
                    state.flowing = !state.readableListening;
                    resume(this, state);
                  }
                  state.paused = false;
                  return this;
                };
                function resume(stream, state) {
                  if (!state.resumeScheduled) {
                    state.resumeScheduled = true;
                    process.nextTick(resume_, stream, state);
                  }
                }
                function resume_(stream, state) {
                  debug("resume", state.reading);
                  if (!state.reading) {
                    stream.read(0);
                  }
                  state.resumeScheduled = false;
                  stream.emit("resume");
                  flow(stream);
                  if (state.flowing && !state.reading)
                    stream.read(0);
                }
                Readable.prototype.pause = function() {
                  debug("call pause flowing=%j", this._readableState.flowing);
                  if (this._readableState.flowing !== false) {
                    debug("pause");
                    this._readableState.flowing = false;
                    this.emit("pause");
                  }
                  this._readableState.paused = true;
                  return this;
                };
                function flow(stream) {
                  var state = stream._readableState;
                  debug("flow", state.flowing);
                  while (state.flowing && stream.read() !== null) {
                    ;
                  }
                }
                Readable.prototype.wrap = function(stream) {
                  var _this = this;
                  var state = this._readableState;
                  var paused = false;
                  stream.on("end", function() {
                    debug("wrapped end");
                    if (state.decoder && !state.ended) {
                      var chunk = state.decoder.end();
                      if (chunk && chunk.length)
                        _this.push(chunk);
                    }
                    _this.push(null);
                  });
                  stream.on("data", function(chunk) {
                    debug("wrapped data");
                    if (state.decoder)
                      chunk = state.decoder.write(chunk);
                    if (state.objectMode && (chunk === null || chunk === void 0))
                      return;
                    else if (!state.objectMode && (!chunk || !chunk.length))
                      return;
                    var ret = _this.push(chunk);
                    if (!ret) {
                      paused = true;
                      stream.pause();
                    }
                  });
                  for (var i in stream) {
                    if (this[i] === void 0 && typeof stream[i] === "function") {
                      this[i] = function methodWrap(method) {
                        return function methodWrapReturnFunction() {
                          return stream[method].apply(stream, arguments);
                        };
                      }(i);
                    }
                  }
                  for (var n = 0; n < kProxyEvents.length; n++) {
                    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
                  }
                  this._read = function(n2) {
                    debug("wrapped _read", n2);
                    if (paused) {
                      paused = false;
                      stream.resume();
                    }
                  };
                  return this;
                };
                if (typeof Symbol === "function") {
                  Readable.prototype[Symbol.asyncIterator] = function() {
                    if (createReadableStreamAsyncIterator === void 0) {
                      createReadableStreamAsyncIterator = __webpack_require__2(828);
                    }
                    return createReadableStreamAsyncIterator(this);
                  };
                }
                Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._readableState.highWaterMark;
                  }
                });
                Object.defineProperty(Readable.prototype, "readableBuffer", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._readableState && this._readableState.buffer;
                  }
                });
                Object.defineProperty(Readable.prototype, "readableFlowing", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._readableState.flowing;
                  },
                  set: function set(state) {
                    if (this._readableState) {
                      this._readableState.flowing = state;
                    }
                  }
                });
                Readable._fromList = fromList;
                Object.defineProperty(Readable.prototype, "readableLength", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._readableState.length;
                  }
                });
                function fromList(n, state) {
                  if (state.length === 0)
                    return null;
                  var ret;
                  if (state.objectMode)
                    ret = state.buffer.shift();
                  else if (!n || n >= state.length) {
                    if (state.decoder)
                      ret = state.buffer.join("");
                    else if (state.buffer.length === 1)
                      ret = state.buffer.first();
                    else
                      ret = state.buffer.concat(state.length);
                    state.buffer.clear();
                  } else {
                    ret = state.buffer.consume(n, state.decoder);
                  }
                  return ret;
                }
                function endReadable(stream) {
                  var state = stream._readableState;
                  debug("endReadable", state.endEmitted);
                  if (!state.endEmitted) {
                    state.ended = true;
                    process.nextTick(endReadableNT, state, stream);
                  }
                }
                function endReadableNT(state, stream) {
                  debug("endReadableNT", state.endEmitted, state.length);
                  if (!state.endEmitted && state.length === 0) {
                    state.endEmitted = true;
                    stream.readable = false;
                    stream.emit("end");
                    if (state.autoDestroy) {
                      var wState = stream._writableState;
                      if (!wState || wState.autoDestroy && wState.finished) {
                        stream.destroy();
                      }
                    }
                  }
                }
                if (typeof Symbol === "function") {
                  Readable.from = function(iterable, opts) {
                    if (from === void 0) {
                      from = __webpack_require__2(1265);
                    }
                    return from(Readable, iterable, opts);
                  };
                }
                function indexOf(xs, x) {
                  for (var i = 0, l = xs.length; i < l; i++) {
                    if (xs[i] === x)
                      return i;
                  }
                  return -1;
                }
              }
            ),
            /***/
            4473: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                module2.exports = Transform;
                var _require$codes = __webpack_require__2(8106).q, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
                var Duplex = __webpack_require__2(8656);
                __webpack_require__2(5717)(Transform, Duplex);
                function afterTransform(er, data) {
                  var ts = this._transformState;
                  ts.transforming = false;
                  var cb = ts.writecb;
                  if (cb === null) {
                    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
                  }
                  ts.writechunk = null;
                  ts.writecb = null;
                  if (data != null)
                    this.push(data);
                  cb(er);
                  var rs = this._readableState;
                  rs.reading = false;
                  if (rs.needReadable || rs.length < rs.highWaterMark) {
                    this._read(rs.highWaterMark);
                  }
                }
                function Transform(options) {
                  if (!(this instanceof Transform))
                    return new Transform(options);
                  Duplex.call(this, options);
                  this._transformState = {
                    afterTransform: afterTransform.bind(this),
                    needTransform: false,
                    transforming: false,
                    writecb: null,
                    writechunk: null,
                    writeencoding: null
                  };
                  this._readableState.needReadable = true;
                  this._readableState.sync = false;
                  if (options) {
                    if (typeof options.transform === "function")
                      this._transform = options.transform;
                    if (typeof options.flush === "function")
                      this._flush = options.flush;
                  }
                  this.on("prefinish", prefinish);
                }
                function prefinish() {
                  var _this = this;
                  if (typeof this._flush === "function" && !this._readableState.destroyed) {
                    this._flush(function(er, data) {
                      done(_this, er, data);
                    });
                  } else {
                    done(this, null, null);
                  }
                }
                Transform.prototype.push = function(chunk, encoding) {
                  this._transformState.needTransform = false;
                  return Duplex.prototype.push.call(this, chunk, encoding);
                };
                Transform.prototype._transform = function(chunk, encoding, cb) {
                  cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
                };
                Transform.prototype._write = function(chunk, encoding, cb) {
                  var ts = this._transformState;
                  ts.writecb = cb;
                  ts.writechunk = chunk;
                  ts.writeencoding = encoding;
                  if (!ts.transforming) {
                    var rs = this._readableState;
                    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
                      this._read(rs.highWaterMark);
                  }
                };
                Transform.prototype._read = function(n) {
                  var ts = this._transformState;
                  if (ts.writechunk !== null && !ts.transforming) {
                    ts.transforming = true;
                    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
                  } else {
                    ts.needTransform = true;
                  }
                };
                Transform.prototype._destroy = function(err, cb) {
                  Duplex.prototype._destroy.call(this, err, function(err2) {
                    cb(err2);
                  });
                };
                function done(stream, er, data) {
                  if (er)
                    return stream.emit("error", er);
                  if (data != null)
                    stream.push(data);
                  if (stream._writableState.length)
                    throw new ERR_TRANSFORM_WITH_LENGTH_0();
                  if (stream._transformState.transforming)
                    throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
                  return stream.push(null);
                }
              }
            ),
            /***/
            323: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var process = __webpack_require__2(4155);
                module2.exports = Writable;
                function WriteReq(chunk, encoding, cb) {
                  this.chunk = chunk;
                  this.encoding = encoding;
                  this.callback = cb;
                  this.next = null;
                }
                function CorkedRequest(state) {
                  var _this = this;
                  this.next = null;
                  this.entry = null;
                  this.finish = function() {
                    onCorkedFinish(_this, state);
                  };
                }
                var Duplex;
                Writable.WritableState = WritableState;
                var internalUtil = {
                  deprecate: __webpack_require__2(4927)
                };
                var Stream = __webpack_require__2(3194);
                var Buffer = __webpack_require__2(8823).Buffer;
                var OurUint8Array = __webpack_require__2.g.Uint8Array || function() {
                };
                function _uint8ArrayToBuffer(chunk) {
                  return Buffer.from(chunk);
                }
                function _isUint8Array(obj) {
                  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
                }
                var destroyImpl = __webpack_require__2(1029);
                var _require = __webpack_require__2(94), getHighWaterMark = _require.getHighWaterMark;
                var _require$codes = __webpack_require__2(8106).q, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
                var errorOrDestroy = destroyImpl.errorOrDestroy;
                __webpack_require__2(5717)(Writable, Stream);
                function nop() {
                }
                function WritableState(options, stream, isDuplex) {
                  Duplex = Duplex || __webpack_require__2(8656);
                  options = options || {};
                  if (typeof isDuplex !== "boolean")
                    isDuplex = stream instanceof Duplex;
                  this.objectMode = !!options.objectMode;
                  if (isDuplex)
                    this.objectMode = this.objectMode || !!options.writableObjectMode;
                  this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
                  this.finalCalled = false;
                  this.needDrain = false;
                  this.ending = false;
                  this.ended = false;
                  this.finished = false;
                  this.destroyed = false;
                  var noDecode = options.decodeStrings === false;
                  this.decodeStrings = !noDecode;
                  this.defaultEncoding = options.defaultEncoding || "utf8";
                  this.length = 0;
                  this.writing = false;
                  this.corked = 0;
                  this.sync = true;
                  this.bufferProcessing = false;
                  this.onwrite = function(er) {
                    onwrite(stream, er);
                  };
                  this.writecb = null;
                  this.writelen = 0;
                  this.bufferedRequest = null;
                  this.lastBufferedRequest = null;
                  this.pendingcb = 0;
                  this.prefinished = false;
                  this.errorEmitted = false;
                  this.emitClose = options.emitClose !== false;
                  this.autoDestroy = !!options.autoDestroy;
                  this.bufferedRequestCount = 0;
                  this.corkedRequestsFree = new CorkedRequest(this);
                }
                WritableState.prototype.getBuffer = function getBuffer() {
                  var current = this.bufferedRequest;
                  var out = [];
                  while (current) {
                    out.push(current);
                    current = current.next;
                  }
                  return out;
                };
                (function() {
                  try {
                    Object.defineProperty(WritableState.prototype, "buffer", {
                      get: internalUtil.deprecate(function writableStateBufferGetter() {
                        return this.getBuffer();
                      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                    });
                  } catch (_) {
                  }
                })();
                var realHasInstance;
                if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
                  realHasInstance = Function.prototype[Symbol.hasInstance];
                  Object.defineProperty(Writable, Symbol.hasInstance, {
                    value: function value(object) {
                      if (realHasInstance.call(this, object))
                        return true;
                      if (this !== Writable)
                        return false;
                      return object && object._writableState instanceof WritableState;
                    }
                  });
                } else {
                  realHasInstance = function realHasInstance2(object) {
                    return object instanceof this;
                  };
                }
                function Writable(options) {
                  Duplex = Duplex || __webpack_require__2(8656);
                  var isDuplex = this instanceof Duplex;
                  if (!isDuplex && !realHasInstance.call(Writable, this))
                    return new Writable(options);
                  this._writableState = new WritableState(options, this, isDuplex);
                  this.writable = true;
                  if (options) {
                    if (typeof options.write === "function")
                      this._write = options.write;
                    if (typeof options.writev === "function")
                      this._writev = options.writev;
                    if (typeof options.destroy === "function")
                      this._destroy = options.destroy;
                    if (typeof options.final === "function")
                      this._final = options.final;
                  }
                  Stream.call(this);
                }
                Writable.prototype.pipe = function() {
                  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
                };
                function writeAfterEnd(stream, cb) {
                  var er = new ERR_STREAM_WRITE_AFTER_END();
                  errorOrDestroy(stream, er);
                  process.nextTick(cb, er);
                }
                function validChunk(stream, state, chunk, cb) {
                  var er;
                  if (chunk === null) {
                    er = new ERR_STREAM_NULL_VALUES();
                  } else if (typeof chunk !== "string" && !state.objectMode) {
                    er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
                  }
                  if (er) {
                    errorOrDestroy(stream, er);
                    process.nextTick(cb, er);
                    return false;
                  }
                  return true;
                }
                Writable.prototype.write = function(chunk, encoding, cb) {
                  var state = this._writableState;
                  var ret = false;
                  var isBuf = !state.objectMode && _isUint8Array(chunk);
                  if (isBuf && !Buffer.isBuffer(chunk)) {
                    chunk = _uint8ArrayToBuffer(chunk);
                  }
                  if (typeof encoding === "function") {
                    cb = encoding;
                    encoding = null;
                  }
                  if (isBuf)
                    encoding = "buffer";
                  else if (!encoding)
                    encoding = state.defaultEncoding;
                  if (typeof cb !== "function")
                    cb = nop;
                  if (state.ending)
                    writeAfterEnd(this, cb);
                  else if (isBuf || validChunk(this, state, chunk, cb)) {
                    state.pendingcb++;
                    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
                  }
                  return ret;
                };
                Writable.prototype.cork = function() {
                  this._writableState.corked++;
                };
                Writable.prototype.uncork = function() {
                  var state = this._writableState;
                  if (state.corked) {
                    state.corked--;
                    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
                      clearBuffer(this, state);
                  }
                };
                Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
                  if (typeof encoding === "string")
                    encoding = encoding.toLowerCase();
                  if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
                    throw new ERR_UNKNOWN_ENCODING(encoding);
                  this._writableState.defaultEncoding = encoding;
                  return this;
                };
                Object.defineProperty(Writable.prototype, "writableBuffer", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._writableState && this._writableState.getBuffer();
                  }
                });
                function decodeChunk(state, chunk, encoding) {
                  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
                    chunk = Buffer.from(chunk, encoding);
                  }
                  return chunk;
                }
                Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._writableState.highWaterMark;
                  }
                });
                function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
                  if (!isBuf) {
                    var newChunk = decodeChunk(state, chunk, encoding);
                    if (chunk !== newChunk) {
                      isBuf = true;
                      encoding = "buffer";
                      chunk = newChunk;
                    }
                  }
                  var len = state.objectMode ? 1 : chunk.length;
                  state.length += len;
                  var ret = state.length < state.highWaterMark;
                  if (!ret)
                    state.needDrain = true;
                  if (state.writing || state.corked) {
                    var last = state.lastBufferedRequest;
                    state.lastBufferedRequest = {
                      chunk,
                      encoding,
                      isBuf,
                      callback: cb,
                      next: null
                    };
                    if (last) {
                      last.next = state.lastBufferedRequest;
                    } else {
                      state.bufferedRequest = state.lastBufferedRequest;
                    }
                    state.bufferedRequestCount += 1;
                  } else {
                    doWrite(stream, state, false, len, chunk, encoding, cb);
                  }
                  return ret;
                }
                function doWrite(stream, state, writev, len, chunk, encoding, cb) {
                  state.writelen = len;
                  state.writecb = cb;
                  state.writing = true;
                  state.sync = true;
                  if (state.destroyed)
                    state.onwrite(new ERR_STREAM_DESTROYED("write"));
                  else if (writev)
                    stream._writev(chunk, state.onwrite);
                  else
                    stream._write(chunk, encoding, state.onwrite);
                  state.sync = false;
                }
                function onwriteError(stream, state, sync, er, cb) {
                  --state.pendingcb;
                  if (sync) {
                    process.nextTick(cb, er);
                    process.nextTick(finishMaybe, stream, state);
                    stream._writableState.errorEmitted = true;
                    errorOrDestroy(stream, er);
                  } else {
                    cb(er);
                    stream._writableState.errorEmitted = true;
                    errorOrDestroy(stream, er);
                    finishMaybe(stream, state);
                  }
                }
                function onwriteStateUpdate(state) {
                  state.writing = false;
                  state.writecb = null;
                  state.length -= state.writelen;
                  state.writelen = 0;
                }
                function onwrite(stream, er) {
                  var state = stream._writableState;
                  var sync = state.sync;
                  var cb = state.writecb;
                  if (typeof cb !== "function")
                    throw new ERR_MULTIPLE_CALLBACK();
                  onwriteStateUpdate(state);
                  if (er)
                    onwriteError(stream, state, sync, er, cb);
                  else {
                    var finished = needFinish(state) || stream.destroyed;
                    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                      clearBuffer(stream, state);
                    }
                    if (sync) {
                      process.nextTick(afterWrite, stream, state, finished, cb);
                    } else {
                      afterWrite(stream, state, finished, cb);
                    }
                  }
                }
                function afterWrite(stream, state, finished, cb) {
                  if (!finished)
                    onwriteDrain(stream, state);
                  state.pendingcb--;
                  cb();
                  finishMaybe(stream, state);
                }
                function onwriteDrain(stream, state) {
                  if (state.length === 0 && state.needDrain) {
                    state.needDrain = false;
                    stream.emit("drain");
                  }
                }
                function clearBuffer(stream, state) {
                  state.bufferProcessing = true;
                  var entry = state.bufferedRequest;
                  if (stream._writev && entry && entry.next) {
                    var l = state.bufferedRequestCount;
                    var buffer = new Array(l);
                    var holder = state.corkedRequestsFree;
                    holder.entry = entry;
                    var count = 0;
                    var allBuffers = true;
                    while (entry) {
                      buffer[count] = entry;
                      if (!entry.isBuf)
                        allBuffers = false;
                      entry = entry.next;
                      count += 1;
                    }
                    buffer.allBuffers = allBuffers;
                    doWrite(stream, state, true, state.length, buffer, "", holder.finish);
                    state.pendingcb++;
                    state.lastBufferedRequest = null;
                    if (holder.next) {
                      state.corkedRequestsFree = holder.next;
                      holder.next = null;
                    } else {
                      state.corkedRequestsFree = new CorkedRequest(state);
                    }
                    state.bufferedRequestCount = 0;
                  } else {
                    while (entry) {
                      var chunk = entry.chunk;
                      var encoding = entry.encoding;
                      var cb = entry.callback;
                      var len = state.objectMode ? 1 : chunk.length;
                      doWrite(stream, state, false, len, chunk, encoding, cb);
                      entry = entry.next;
                      state.bufferedRequestCount--;
                      if (state.writing) {
                        break;
                      }
                    }
                    if (entry === null)
                      state.lastBufferedRequest = null;
                  }
                  state.bufferedRequest = entry;
                  state.bufferProcessing = false;
                }
                Writable.prototype._write = function(chunk, encoding, cb) {
                  cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
                };
                Writable.prototype._writev = null;
                Writable.prototype.end = function(chunk, encoding, cb) {
                  var state = this._writableState;
                  if (typeof chunk === "function") {
                    cb = chunk;
                    chunk = null;
                    encoding = null;
                  } else if (typeof encoding === "function") {
                    cb = encoding;
                    encoding = null;
                  }
                  if (chunk !== null && chunk !== void 0)
                    this.write(chunk, encoding);
                  if (state.corked) {
                    state.corked = 1;
                    this.uncork();
                  }
                  if (!state.ending)
                    endWritable(this, state, cb);
                  return this;
                };
                Object.defineProperty(Writable.prototype, "writableLength", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._writableState.length;
                  }
                });
                function needFinish(state) {
                  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
                }
                function callFinal(stream, state) {
                  stream._final(function(err) {
                    state.pendingcb--;
                    if (err) {
                      errorOrDestroy(stream, err);
                    }
                    state.prefinished = true;
                    stream.emit("prefinish");
                    finishMaybe(stream, state);
                  });
                }
                function prefinish(stream, state) {
                  if (!state.prefinished && !state.finalCalled) {
                    if (typeof stream._final === "function" && !state.destroyed) {
                      state.pendingcb++;
                      state.finalCalled = true;
                      process.nextTick(callFinal, stream, state);
                    } else {
                      state.prefinished = true;
                      stream.emit("prefinish");
                    }
                  }
                }
                function finishMaybe(stream, state) {
                  var need = needFinish(state);
                  if (need) {
                    prefinish(stream, state);
                    if (state.pendingcb === 0) {
                      state.finished = true;
                      stream.emit("finish");
                      if (state.autoDestroy) {
                        var rState = stream._readableState;
                        if (!rState || rState.autoDestroy && rState.endEmitted) {
                          stream.destroy();
                        }
                      }
                    }
                  }
                  return need;
                }
                function endWritable(stream, state, cb) {
                  state.ending = true;
                  finishMaybe(stream, state);
                  if (cb) {
                    if (state.finished)
                      process.nextTick(cb);
                    else
                      stream.once("finish", cb);
                  }
                  state.ended = true;
                  stream.writable = false;
                }
                function onCorkedFinish(corkReq, state, err) {
                  var entry = corkReq.entry;
                  corkReq.entry = null;
                  while (entry) {
                    var cb = entry.callback;
                    state.pendingcb--;
                    cb(err);
                    entry = entry.next;
                  }
                  state.corkedRequestsFree.next = corkReq;
                }
                Object.defineProperty(Writable.prototype, "destroyed", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    if (this._writableState === void 0) {
                      return false;
                    }
                    return this._writableState.destroyed;
                  },
                  set: function set(value) {
                    if (!this._writableState) {
                      return;
                    }
                    this._writableState.destroyed = value;
                  }
                });
                Writable.prototype.destroy = destroyImpl.destroy;
                Writable.prototype._undestroy = destroyImpl.undestroy;
                Writable.prototype._destroy = function(err, cb) {
                  cb(err);
                };
              }
            ),
            /***/
            828: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var process = __webpack_require__2(4155);
                var _Object$setPrototypeO;
                function _defineProperty(obj, key, value) {
                  if (key in obj) {
                    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                  } else {
                    obj[key] = value;
                  }
                  return obj;
                }
                var finished = __webpack_require__2(1086);
                var kLastResolve = Symbol("lastResolve");
                var kLastReject = Symbol("lastReject");
                var kError = Symbol("error");
                var kEnded = Symbol("ended");
                var kLastPromise = Symbol("lastPromise");
                var kHandlePromise = Symbol("handlePromise");
                var kStream = Symbol("stream");
                function createIterResult(value, done) {
                  return {
                    value,
                    done
                  };
                }
                function readAndResolve(iter) {
                  var resolve = iter[kLastResolve];
                  if (resolve !== null) {
                    var data = iter[kStream].read();
                    if (data !== null) {
                      iter[kLastPromise] = null;
                      iter[kLastResolve] = null;
                      iter[kLastReject] = null;
                      resolve(createIterResult(data, false));
                    }
                  }
                }
                function onReadable(iter) {
                  process.nextTick(readAndResolve, iter);
                }
                function wrapForNext(lastPromise, iter) {
                  return function(resolve, reject) {
                    lastPromise.then(function() {
                      if (iter[kEnded]) {
                        resolve(createIterResult(void 0, true));
                        return;
                      }
                      iter[kHandlePromise](resolve, reject);
                    }, reject);
                  };
                }
                var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
                });
                var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
                  get stream() {
                    return this[kStream];
                  },
                  next: function next() {
                    var _this = this;
                    var error = this[kError];
                    if (error !== null) {
                      return Promise.reject(error);
                    }
                    if (this[kEnded]) {
                      return Promise.resolve(createIterResult(void 0, true));
                    }
                    if (this[kStream].destroyed) {
                      return new Promise(function(resolve, reject) {
                        process.nextTick(function() {
                          if (_this[kError]) {
                            reject(_this[kError]);
                          } else {
                            resolve(createIterResult(void 0, true));
                          }
                        });
                      });
                    }
                    var lastPromise = this[kLastPromise];
                    var promise;
                    if (lastPromise) {
                      promise = new Promise(wrapForNext(lastPromise, this));
                    } else {
                      var data = this[kStream].read();
                      if (data !== null) {
                        return Promise.resolve(createIterResult(data, false));
                      }
                      promise = new Promise(this[kHandlePromise]);
                    }
                    this[kLastPromise] = promise;
                    return promise;
                  }
                }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
                  return this;
                }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
                  var _this2 = this;
                  return new Promise(function(resolve, reject) {
                    _this2[kStream].destroy(null, function(err) {
                      if (err) {
                        reject(err);
                        return;
                      }
                      resolve(createIterResult(void 0, true));
                    });
                  });
                }), _Object$setPrototypeO), AsyncIteratorPrototype);
                var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
                  var _Object$create;
                  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
                    value: stream,
                    writable: true
                  }), _defineProperty(_Object$create, kLastResolve, {
                    value: null,
                    writable: true
                  }), _defineProperty(_Object$create, kLastReject, {
                    value: null,
                    writable: true
                  }), _defineProperty(_Object$create, kError, {
                    value: null,
                    writable: true
                  }), _defineProperty(_Object$create, kEnded, {
                    value: stream._readableState.endEmitted,
                    writable: true
                  }), _defineProperty(_Object$create, kHandlePromise, {
                    value: function value(resolve, reject) {
                      var data = iterator[kStream].read();
                      if (data) {
                        iterator[kLastPromise] = null;
                        iterator[kLastResolve] = null;
                        iterator[kLastReject] = null;
                        resolve(createIterResult(data, false));
                      } else {
                        iterator[kLastResolve] = resolve;
                        iterator[kLastReject] = reject;
                      }
                    },
                    writable: true
                  }), _Object$create));
                  iterator[kLastPromise] = null;
                  finished(stream, function(err) {
                    if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                      var reject = iterator[kLastReject];
                      if (reject !== null) {
                        iterator[kLastPromise] = null;
                        iterator[kLastResolve] = null;
                        iterator[kLastReject] = null;
                        reject(err);
                      }
                      iterator[kError] = err;
                      return;
                    }
                    var resolve = iterator[kLastResolve];
                    if (resolve !== null) {
                      iterator[kLastPromise] = null;
                      iterator[kLastResolve] = null;
                      iterator[kLastReject] = null;
                      resolve(createIterResult(void 0, true));
                    }
                    iterator[kEnded] = true;
                  });
                  stream.on("readable", onReadable.bind(null, iterator));
                  return iterator;
                };
                module2.exports = createReadableStreamAsyncIterator;
              }
            ),
            /***/
            1029: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var process = __webpack_require__2(4155);
                function destroy(err, cb) {
                  var _this = this;
                  var readableDestroyed = this._readableState && this._readableState.destroyed;
                  var writableDestroyed = this._writableState && this._writableState.destroyed;
                  if (readableDestroyed || writableDestroyed) {
                    if (cb) {
                      cb(err);
                    } else if (err) {
                      if (!this._writableState) {
                        process.nextTick(emitErrorNT, this, err);
                      } else if (!this._writableState.errorEmitted) {
                        this._writableState.errorEmitted = true;
                        process.nextTick(emitErrorNT, this, err);
                      }
                    }
                    return this;
                  }
                  if (this._readableState) {
                    this._readableState.destroyed = true;
                  }
                  if (this._writableState) {
                    this._writableState.destroyed = true;
                  }
                  this._destroy(err || null, function(err2) {
                    if (!cb && err2) {
                      if (!_this._writableState) {
                        process.nextTick(emitErrorAndCloseNT, _this, err2);
                      } else if (!_this._writableState.errorEmitted) {
                        _this._writableState.errorEmitted = true;
                        process.nextTick(emitErrorAndCloseNT, _this, err2);
                      } else {
                        process.nextTick(emitCloseNT, _this);
                      }
                    } else if (cb) {
                      process.nextTick(emitCloseNT, _this);
                      cb(err2);
                    } else {
                      process.nextTick(emitCloseNT, _this);
                    }
                  });
                  return this;
                }
                function emitErrorAndCloseNT(self2, err) {
                  emitErrorNT(self2, err);
                  emitCloseNT(self2);
                }
                function emitCloseNT(self2) {
                  if (self2._writableState && !self2._writableState.emitClose)
                    return;
                  if (self2._readableState && !self2._readableState.emitClose)
                    return;
                  self2.emit("close");
                }
                function undestroy() {
                  if (this._readableState) {
                    this._readableState.destroyed = false;
                    this._readableState.reading = false;
                    this._readableState.ended = false;
                    this._readableState.endEmitted = false;
                  }
                  if (this._writableState) {
                    this._writableState.destroyed = false;
                    this._writableState.ended = false;
                    this._writableState.ending = false;
                    this._writableState.finalCalled = false;
                    this._writableState.prefinished = false;
                    this._writableState.finished = false;
                    this._writableState.errorEmitted = false;
                  }
                }
                function emitErrorNT(self2, err) {
                  self2.emit("error", err);
                }
                function errorOrDestroy(stream, err) {
                  var rState = stream._readableState;
                  var wState = stream._writableState;
                  if (rState && rState.autoDestroy || wState && wState.autoDestroy)
                    stream.destroy(err);
                  else
                    stream.emit("error", err);
                }
                module2.exports = {
                  destroy,
                  undestroy,
                  errorOrDestroy
                };
              }
            ),
            /***/
            1086: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ERR_STREAM_PREMATURE_CLOSE = __webpack_require__2(8106).q.ERR_STREAM_PREMATURE_CLOSE;
                function once(callback) {
                  var called = false;
                  return function() {
                    if (called)
                      return;
                    called = true;
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                      args[_key] = arguments[_key];
                    }
                    callback.apply(this, args);
                  };
                }
                function noop() {
                }
                function isRequest(stream) {
                  return stream.setHeader && typeof stream.abort === "function";
                }
                function eos(stream, opts, callback) {
                  if (typeof opts === "function")
                    return eos(stream, null, opts);
                  if (!opts)
                    opts = {};
                  callback = once(callback || noop);
                  var readable = opts.readable || opts.readable !== false && stream.readable;
                  var writable = opts.writable || opts.writable !== false && stream.writable;
                  var onlegacyfinish = function onlegacyfinish2() {
                    if (!stream.writable)
                      onfinish();
                  };
                  var writableEnded = stream._writableState && stream._writableState.finished;
                  var onfinish = function onfinish2() {
                    writable = false;
                    writableEnded = true;
                    if (!readable)
                      callback.call(stream);
                  };
                  var readableEnded = stream._readableState && stream._readableState.endEmitted;
                  var onend = function onend2() {
                    readable = false;
                    readableEnded = true;
                    if (!writable)
                      callback.call(stream);
                  };
                  var onerror = function onerror2(err) {
                    callback.call(stream, err);
                  };
                  var onclose = function onclose2() {
                    var err;
                    if (readable && !readableEnded) {
                      if (!stream._readableState || !stream._readableState.ended)
                        err = new ERR_STREAM_PREMATURE_CLOSE();
                      return callback.call(stream, err);
                    }
                    if (writable && !writableEnded) {
                      if (!stream._writableState || !stream._writableState.ended)
                        err = new ERR_STREAM_PREMATURE_CLOSE();
                      return callback.call(stream, err);
                    }
                  };
                  var onrequest = function onrequest2() {
                    stream.req.on("finish", onfinish);
                  };
                  if (isRequest(stream)) {
                    stream.on("complete", onfinish);
                    stream.on("abort", onclose);
                    if (stream.req)
                      onrequest();
                    else
                      stream.on("request", onrequest);
                  } else if (writable && !stream._writableState) {
                    stream.on("end", onlegacyfinish);
                    stream.on("close", onlegacyfinish);
                  }
                  stream.on("end", onend);
                  stream.on("finish", onfinish);
                  if (opts.error !== false)
                    stream.on("error", onerror);
                  stream.on("close", onclose);
                  return function() {
                    stream.removeListener("complete", onfinish);
                    stream.removeListener("abort", onclose);
                    stream.removeListener("request", onrequest);
                    if (stream.req)
                      stream.req.removeListener("finish", onfinish);
                    stream.removeListener("end", onlegacyfinish);
                    stream.removeListener("close", onlegacyfinish);
                    stream.removeListener("finish", onfinish);
                    stream.removeListener("end", onend);
                    stream.removeListener("error", onerror);
                    stream.removeListener("close", onclose);
                  };
                }
                module2.exports = eos;
              }
            ),
            /***/
            1265: (
              /***/
              function(module2) {
                module2.exports = function() {
                  throw new Error("Readable.from is not available in the browser");
                };
              }
            ),
            /***/
            6472: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var eos;
                function once(callback) {
                  var called = false;
                  return function() {
                    if (called)
                      return;
                    called = true;
                    callback.apply(void 0, arguments);
                  };
                }
                var _require$codes = __webpack_require__2(8106).q, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
                function noop(err) {
                  if (err)
                    throw err;
                }
                function isRequest(stream) {
                  return stream.setHeader && typeof stream.abort === "function";
                }
                function destroyer(stream, reading, writing, callback) {
                  callback = once(callback);
                  var closed = false;
                  stream.on("close", function() {
                    closed = true;
                  });
                  if (eos === void 0)
                    eos = __webpack_require__2(1086);
                  eos(stream, {
                    readable: reading,
                    writable: writing
                  }, function(err) {
                    if (err)
                      return callback(err);
                    closed = true;
                    callback();
                  });
                  var destroyed = false;
                  return function(err) {
                    if (closed)
                      return;
                    if (destroyed)
                      return;
                    destroyed = true;
                    if (isRequest(stream))
                      return stream.abort();
                    if (typeof stream.destroy === "function")
                      return stream.destroy();
                    callback(err || new ERR_STREAM_DESTROYED("pipe"));
                  };
                }
                function call(fn) {
                  fn();
                }
                function pipe(from, to) {
                  return from.pipe(to);
                }
                function popCallback(streams) {
                  if (!streams.length)
                    return noop;
                  if (typeof streams[streams.length - 1] !== "function")
                    return noop;
                  return streams.pop();
                }
                function pipeline() {
                  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
                    streams[_key] = arguments[_key];
                  }
                  var callback = popCallback(streams);
                  if (Array.isArray(streams[0]))
                    streams = streams[0];
                  if (streams.length < 2) {
                    throw new ERR_MISSING_ARGS("streams");
                  }
                  var error;
                  var destroys = streams.map(function(stream, i) {
                    var reading = i < streams.length - 1;
                    var writing = i > 0;
                    return destroyer(stream, reading, writing, function(err) {
                      if (!error)
                        error = err;
                      if (err)
                        destroys.forEach(call);
                      if (reading)
                        return;
                      destroys.forEach(call);
                      callback(error);
                    });
                  });
                  return streams.reduce(pipe);
                }
                module2.exports = pipeline;
              }
            ),
            /***/
            94: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ERR_INVALID_OPT_VALUE = __webpack_require__2(8106).q.ERR_INVALID_OPT_VALUE;
                function highWaterMarkFrom(options, isDuplex, duplexKey) {
                  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
                }
                function getHighWaterMark(state, options, duplexKey, isDuplex) {
                  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
                  if (hwm != null) {
                    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
                      var name = isDuplex ? duplexKey : "highWaterMark";
                      throw new ERR_INVALID_OPT_VALUE(name, hwm);
                    }
                    return Math.floor(hwm);
                  }
                  return state.objectMode ? 16 : 16 * 1024;
                }
                module2.exports = {
                  getHighWaterMark
                };
              }
            ),
            /***/
            3194: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                module2.exports = __webpack_require__2(7187).EventEmitter;
              }
            ),
            /***/
            2984: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
                (function(a, b) {
                  if (true)
                    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = b, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                  else {
                  }
                })(this, function() {
                  "use strict";
                  function b(a2, b2) {
                    return "undefined" == typeof b2 ? b2 = { autoBom: false } : "object" != typeof b2 && (console.warn("Deprecated: Expected third argument to be a object"), b2 = { autoBom: !b2 }), b2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a2.type) ? new Blob(["\uFEFF", a2], { type: a2.type }) : a2;
                  }
                  function c(a2, b2, c2) {
                    var d2 = new XMLHttpRequest();
                    d2.open("GET", a2), d2.responseType = "blob", d2.onload = function() {
                      g(d2.response, b2, c2);
                    }, d2.onerror = function() {
                      console.error("could not download file");
                    }, d2.send();
                  }
                  function d(a2) {
                    var b2 = new XMLHttpRequest();
                    b2.open("HEAD", a2, false);
                    try {
                      b2.send();
                    } catch (a3) {
                    }
                    return 200 <= b2.status && 299 >= b2.status;
                  }
                  function e(a2) {
                    try {
                      a2.dispatchEvent(new MouseEvent("click"));
                    } catch (c2) {
                      var b2 = document.createEvent("MouseEvents");
                      b2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a2.dispatchEvent(b2);
                    }
                  }
                  var f = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof __webpack_require__2.g && __webpack_require__2.g.global === __webpack_require__2.g ? __webpack_require__2.g : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || ("object" != typeof window || window !== f ? function() {
                  } : typeof HTMLAnchorElement !== "undefined" && "download" in HTMLAnchorElement.prototype && !a ? function(b2, g2, h) {
                    var i = f.URL || f.webkitURL, j = document.createElement("a");
                    g2 = g2 || b2.name || "download", j.download = g2, j.rel = "noopener", "string" == typeof b2 ? (j.href = b2, j.origin === location.origin ? e(j) : d(j.href) ? c(b2, g2, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b2), setTimeout(function() {
                      i.revokeObjectURL(j.href);
                    }, 4e4), setTimeout(function() {
                      e(j);
                    }, 0));
                  } : "msSaveOrOpenBlob" in navigator ? function(f2, g2, h) {
                    if (g2 = g2 || f2.name || "download", "string" != typeof f2)
                      navigator.msSaveOrOpenBlob(b(f2, h), g2);
                    else if (d(f2))
                      c(f2, g2, h);
                    else {
                      var i = document.createElement("a");
                      i.href = f2, i.target = "_blank", setTimeout(function() {
                        e(i);
                      });
                    }
                  } : function(b2, d2, e2, g2) {
                    if (g2 = g2 || open("", "_blank"), g2 && (g2.document.title = g2.document.body.innerText = "downloading..."), "string" == typeof b2)
                      return c(b2, d2, e2);
                    var h = "application/octet-stream" === b2.type, i = /constructor/i.test(f.HTMLElement) || f.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
                    if ((j || h && i || a) && "undefined" != typeof FileReader) {
                      var k = new FileReader();
                      k.onloadend = function() {
                        var a2 = k.result;
                        a2 = j ? a2 : a2.replace(/^data:[^;]*;/, "data:attachment/file;"), g2 ? g2.location.href = a2 : location = a2, g2 = null;
                      }, k.readAsDataURL(b2);
                    } else {
                      var l = f.URL || f.webkitURL, m = l.createObjectURL(b2);
                      g2 ? g2.location = m : location.href = m, g2 = null, setTimeout(function() {
                        l.revokeObjectURL(m);
                      }, 4e4);
                    }
                  });
                  f.saveAs = g.saveAs = g, module2.exports = g;
                });
              }
            ),
            /***/
            2553: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var Buffer = __webpack_require__2(4559).Buffer;
                var isEncoding = Buffer.isEncoding || function(encoding) {
                  encoding = "" + encoding;
                  switch (encoding && encoding.toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                    case "raw":
                      return true;
                    default:
                      return false;
                  }
                };
                function _normalizeEncoding(enc) {
                  if (!enc)
                    return "utf8";
                  var retried;
                  while (true) {
                    switch (enc) {
                      case "utf8":
                      case "utf-8":
                        return "utf8";
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return "utf16le";
                      case "latin1":
                      case "binary":
                        return "latin1";
                      case "base64":
                      case "ascii":
                      case "hex":
                        return enc;
                      default:
                        if (retried)
                          return;
                        enc = ("" + enc).toLowerCase();
                        retried = true;
                    }
                  }
                }
                ;
                function normalizeEncoding(enc) {
                  var nenc = _normalizeEncoding(enc);
                  if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc)))
                    throw new Error("Unknown encoding: " + enc);
                  return nenc || enc;
                }
                exports2.s = StringDecoder;
                function StringDecoder(encoding) {
                  this.encoding = normalizeEncoding(encoding);
                  var nb;
                  switch (this.encoding) {
                    case "utf16le":
                      this.text = utf16Text;
                      this.end = utf16End;
                      nb = 4;
                      break;
                    case "utf8":
                      this.fillLast = utf8FillLast;
                      nb = 4;
                      break;
                    case "base64":
                      this.text = base64Text;
                      this.end = base64End;
                      nb = 3;
                      break;
                    default:
                      this.write = simpleWrite;
                      this.end = simpleEnd;
                      return;
                  }
                  this.lastNeed = 0;
                  this.lastTotal = 0;
                  this.lastChar = Buffer.allocUnsafe(nb);
                }
                StringDecoder.prototype.write = function(buf) {
                  if (buf.length === 0)
                    return "";
                  var r;
                  var i;
                  if (this.lastNeed) {
                    r = this.fillLast(buf);
                    if (r === void 0)
                      return "";
                    i = this.lastNeed;
                    this.lastNeed = 0;
                  } else {
                    i = 0;
                  }
                  if (i < buf.length)
                    return r ? r + this.text(buf, i) : this.text(buf, i);
                  return r || "";
                };
                StringDecoder.prototype.end = utf8End;
                StringDecoder.prototype.text = utf8Text;
                StringDecoder.prototype.fillLast = function(buf) {
                  if (this.lastNeed <= buf.length) {
                    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
                    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
                  }
                  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
                  this.lastNeed -= buf.length;
                };
                function utf8CheckByte(byte) {
                  if (byte <= 127)
                    return 0;
                  else if (byte >> 5 === 6)
                    return 2;
                  else if (byte >> 4 === 14)
                    return 3;
                  else if (byte >> 3 === 30)
                    return 4;
                  return byte >> 6 === 2 ? -1 : -2;
                }
                function utf8CheckIncomplete(self2, buf, i) {
                  var j = buf.length - 1;
                  if (j < i)
                    return 0;
                  var nb = utf8CheckByte(buf[j]);
                  if (nb >= 0) {
                    if (nb > 0)
                      self2.lastNeed = nb - 1;
                    return nb;
                  }
                  if (--j < i || nb === -2)
                    return 0;
                  nb = utf8CheckByte(buf[j]);
                  if (nb >= 0) {
                    if (nb > 0)
                      self2.lastNeed = nb - 2;
                    return nb;
                  }
                  if (--j < i || nb === -2)
                    return 0;
                  nb = utf8CheckByte(buf[j]);
                  if (nb >= 0) {
                    if (nb > 0) {
                      if (nb === 2)
                        nb = 0;
                      else
                        self2.lastNeed = nb - 3;
                    }
                    return nb;
                  }
                  return 0;
                }
                function utf8CheckExtraBytes(self2, buf, p) {
                  if ((buf[0] & 192) !== 128) {
                    self2.lastNeed = 0;
                    return "";
                  }
                  if (self2.lastNeed > 1 && buf.length > 1) {
                    if ((buf[1] & 192) !== 128) {
                      self2.lastNeed = 1;
                      return "";
                    }
                    if (self2.lastNeed > 2 && buf.length > 2) {
                      if ((buf[2] & 192) !== 128) {
                        self2.lastNeed = 2;
                        return "";
                      }
                    }
                  }
                }
                function utf8FillLast(buf) {
                  var p = this.lastTotal - this.lastNeed;
                  var r = utf8CheckExtraBytes(this, buf, p);
                  if (r !== void 0)
                    return r;
                  if (this.lastNeed <= buf.length) {
                    buf.copy(this.lastChar, p, 0, this.lastNeed);
                    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
                  }
                  buf.copy(this.lastChar, p, 0, buf.length);
                  this.lastNeed -= buf.length;
                }
                function utf8Text(buf, i) {
                  var total = utf8CheckIncomplete(this, buf, i);
                  if (!this.lastNeed)
                    return buf.toString("utf8", i);
                  this.lastTotal = total;
                  var end = buf.length - (total - this.lastNeed);
                  buf.copy(this.lastChar, 0, end);
                  return buf.toString("utf8", i, end);
                }
                function utf8End(buf) {
                  var r = buf && buf.length ? this.write(buf) : "";
                  if (this.lastNeed)
                    return r + "";
                  return r;
                }
                function utf16Text(buf, i) {
                  if ((buf.length - i) % 2 === 0) {
                    var r = buf.toString("utf16le", i);
                    if (r) {
                      var c = r.charCodeAt(r.length - 1);
                      if (c >= 55296 && c <= 56319) {
                        this.lastNeed = 2;
                        this.lastTotal = 4;
                        this.lastChar[0] = buf[buf.length - 2];
                        this.lastChar[1] = buf[buf.length - 1];
                        return r.slice(0, -1);
                      }
                    }
                    return r;
                  }
                  this.lastNeed = 1;
                  this.lastTotal = 2;
                  this.lastChar[0] = buf[buf.length - 1];
                  return buf.toString("utf16le", i, buf.length - 1);
                }
                function utf16End(buf) {
                  var r = buf && buf.length ? this.write(buf) : "";
                  if (this.lastNeed) {
                    var end = this.lastTotal - this.lastNeed;
                    return r + this.lastChar.toString("utf16le", 0, end);
                  }
                  return r;
                }
                function base64Text(buf, i) {
                  var n = (buf.length - i) % 3;
                  if (n === 0)
                    return buf.toString("base64", i);
                  this.lastNeed = 3 - n;
                  this.lastTotal = 3;
                  if (n === 1) {
                    this.lastChar[0] = buf[buf.length - 1];
                  } else {
                    this.lastChar[0] = buf[buf.length - 2];
                    this.lastChar[1] = buf[buf.length - 1];
                  }
                  return buf.toString("base64", i, buf.length - n);
                }
                function base64End(buf) {
                  var r = buf && buf.length ? this.write(buf) : "";
                  if (this.lastNeed)
                    return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
                  return r;
                }
                function simpleWrite(buf) {
                  return buf.toString(this.encoding);
                }
                function simpleEnd(buf) {
                  return buf && buf.length ? this.write(buf) : "";
                }
              }
            ),
            /***/
            311: (
              /***/
              function(module2) {
                var TINF_OK = 0;
                var TINF_DATA_ERROR = -3;
                function Tree() {
                  this.table = new Uint16Array(16);
                  this.trans = new Uint16Array(288);
                }
                function Data(source, dest) {
                  this.source = source;
                  this.sourceIndex = 0;
                  this.tag = 0;
                  this.bitcount = 0;
                  this.dest = dest;
                  this.destLen = 0;
                  this.ltree = new Tree();
                  this.dtree = new Tree();
                }
                var sltree = new Tree();
                var sdtree = new Tree();
                var length_bits = new Uint8Array(30);
                var length_base = new Uint16Array(30);
                var dist_bits = new Uint8Array(30);
                var dist_base = new Uint16Array(30);
                var clcidx = new Uint8Array([
                  16,
                  17,
                  18,
                  0,
                  8,
                  7,
                  9,
                  6,
                  10,
                  5,
                  11,
                  4,
                  12,
                  3,
                  13,
                  2,
                  14,
                  1,
                  15
                ]);
                var code_tree = new Tree();
                var lengths = new Uint8Array(288 + 32);
                function tinf_build_bits_base(bits, base, delta, first) {
                  var i, sum;
                  for (i = 0; i < delta; ++i)
                    bits[i] = 0;
                  for (i = 0; i < 30 - delta; ++i)
                    bits[i + delta] = i / delta | 0;
                  for (sum = first, i = 0; i < 30; ++i) {
                    base[i] = sum;
                    sum += 1 << bits[i];
                  }
                }
                function tinf_build_fixed_trees(lt, dt) {
                  var i;
                  for (i = 0; i < 7; ++i)
                    lt.table[i] = 0;
                  lt.table[7] = 24;
                  lt.table[8] = 152;
                  lt.table[9] = 112;
                  for (i = 0; i < 24; ++i)
                    lt.trans[i] = 256 + i;
                  for (i = 0; i < 144; ++i)
                    lt.trans[24 + i] = i;
                  for (i = 0; i < 8; ++i)
                    lt.trans[24 + 144 + i] = 280 + i;
                  for (i = 0; i < 112; ++i)
                    lt.trans[24 + 144 + 8 + i] = 144 + i;
                  for (i = 0; i < 5; ++i)
                    dt.table[i] = 0;
                  dt.table[5] = 32;
                  for (i = 0; i < 32; ++i)
                    dt.trans[i] = i;
                }
                var offs = new Uint16Array(16);
                function tinf_build_tree(t, lengths2, off, num) {
                  var i, sum;
                  for (i = 0; i < 16; ++i)
                    t.table[i] = 0;
                  for (i = 0; i < num; ++i)
                    t.table[lengths2[off + i]]++;
                  t.table[0] = 0;
                  for (sum = 0, i = 0; i < 16; ++i) {
                    offs[i] = sum;
                    sum += t.table[i];
                  }
                  for (i = 0; i < num; ++i) {
                    if (lengths2[off + i])
                      t.trans[offs[lengths2[off + i]]++] = i;
                  }
                }
                function tinf_getbit(d) {
                  if (!d.bitcount--) {
                    d.tag = d.source[d.sourceIndex++];
                    d.bitcount = 7;
                  }
                  var bit = d.tag & 1;
                  d.tag >>>= 1;
                  return bit;
                }
                function tinf_read_bits(d, num, base) {
                  if (!num)
                    return base;
                  while (d.bitcount < 24) {
                    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
                    d.bitcount += 8;
                  }
                  var val = d.tag & 65535 >>> 16 - num;
                  d.tag >>>= num;
                  d.bitcount -= num;
                  return val + base;
                }
                function tinf_decode_symbol(d, t) {
                  while (d.bitcount < 24) {
                    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
                    d.bitcount += 8;
                  }
                  var sum = 0, cur = 0, len = 0;
                  var tag = d.tag;
                  do {
                    cur = 2 * cur + (tag & 1);
                    tag >>>= 1;
                    ++len;
                    sum += t.table[len];
                    cur -= t.table[len];
                  } while (cur >= 0);
                  d.tag = tag;
                  d.bitcount -= len;
                  return t.trans[sum + cur];
                }
                function tinf_decode_trees(d, lt, dt) {
                  var hlit, hdist, hclen;
                  var i, num, length;
                  hlit = tinf_read_bits(d, 5, 257);
                  hdist = tinf_read_bits(d, 5, 1);
                  hclen = tinf_read_bits(d, 4, 4);
                  for (i = 0; i < 19; ++i)
                    lengths[i] = 0;
                  for (i = 0; i < hclen; ++i) {
                    var clen = tinf_read_bits(d, 3, 0);
                    lengths[clcidx[i]] = clen;
                  }
                  tinf_build_tree(code_tree, lengths, 0, 19);
                  for (num = 0; num < hlit + hdist; ) {
                    var sym = tinf_decode_symbol(d, code_tree);
                    switch (sym) {
                      case 16:
                        var prev = lengths[num - 1];
                        for (length = tinf_read_bits(d, 2, 3); length; --length) {
                          lengths[num++] = prev;
                        }
                        break;
                      case 17:
                        for (length = tinf_read_bits(d, 3, 3); length; --length) {
                          lengths[num++] = 0;
                        }
                        break;
                      case 18:
                        for (length = tinf_read_bits(d, 7, 11); length; --length) {
                          lengths[num++] = 0;
                        }
                        break;
                      default:
                        lengths[num++] = sym;
                        break;
                    }
                  }
                  tinf_build_tree(lt, lengths, 0, hlit);
                  tinf_build_tree(dt, lengths, hlit, hdist);
                }
                function tinf_inflate_block_data(d, lt, dt) {
                  while (1) {
                    var sym = tinf_decode_symbol(d, lt);
                    if (sym === 256) {
                      return TINF_OK;
                    }
                    if (sym < 256) {
                      d.dest[d.destLen++] = sym;
                    } else {
                      var length, dist, offs2;
                      var i;
                      sym -= 257;
                      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);
                      dist = tinf_decode_symbol(d, dt);
                      offs2 = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
                      for (i = offs2; i < offs2 + length; ++i) {
                        d.dest[d.destLen++] = d.dest[i];
                      }
                    }
                  }
                }
                function tinf_inflate_uncompressed_block(d) {
                  var length, invlength;
                  var i;
                  while (d.bitcount > 8) {
                    d.sourceIndex--;
                    d.bitcount -= 8;
                  }
                  length = d.source[d.sourceIndex + 1];
                  length = 256 * length + d.source[d.sourceIndex];
                  invlength = d.source[d.sourceIndex + 3];
                  invlength = 256 * invlength + d.source[d.sourceIndex + 2];
                  if (length !== (~invlength & 65535))
                    return TINF_DATA_ERROR;
                  d.sourceIndex += 4;
                  for (i = length; i; --i)
                    d.dest[d.destLen++] = d.source[d.sourceIndex++];
                  d.bitcount = 0;
                  return TINF_OK;
                }
                function tinf_uncompress(source, dest) {
                  var d = new Data(source, dest);
                  var bfinal, btype, res;
                  do {
                    bfinal = tinf_getbit(d);
                    btype = tinf_read_bits(d, 2, 0);
                    switch (btype) {
                      case 0:
                        res = tinf_inflate_uncompressed_block(d);
                        break;
                      case 1:
                        res = tinf_inflate_block_data(d, sltree, sdtree);
                        break;
                      case 2:
                        tinf_decode_trees(d, d.ltree, d.dtree);
                        res = tinf_inflate_block_data(d, d.ltree, d.dtree);
                        break;
                      default:
                        res = TINF_DATA_ERROR;
                    }
                    if (res !== TINF_OK)
                      throw new Error("Data error");
                  } while (!bfinal);
                  if (d.destLen < d.dest.length) {
                    if (typeof d.dest.slice === "function")
                      return d.dest.slice(0, d.destLen);
                    else
                      return d.dest.subarray(0, d.destLen);
                  }
                  return d.dest;
                }
                tinf_build_fixed_trees(sltree, sdtree);
                tinf_build_bits_base(length_bits, length_base, 4, 3);
                tinf_build_bits_base(dist_bits, dist_base, 2, 1);
                length_bits[28] = 0;
                length_base[28] = 258;
                module2.exports = tinf_uncompress;
              }
            ),
            /***/
            1917: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var Buffer = __webpack_require__2(8823)["Buffer"];
                __webpack_require__2(2526);
                __webpack_require__2(1817);
                __webpack_require__2(2165);
                __webpack_require__2(6649);
                __webpack_require__2(6078);
                __webpack_require__2(1539);
                __webpack_require__2(4747);
                __webpack_require__2(7941);
                __webpack_require__2(7042);
                __webpack_require__2(6992);
                __webpack_require__2(1532);
                __webpack_require__2(8783);
                __webpack_require__2(3948);
                __webpack_require__2(2222);
                __webpack_require__2(9653);
                __webpack_require__2(1249);
                __webpack_require__2(2087);
                __webpack_require__2(8309);
                __webpack_require__2(9601);
                __webpack_require__2(4953);
                __webpack_require__2(8674);
                __webpack_require__2(5003);
                __webpack_require__2(189);
                __webpack_require__2(561);
                __webpack_require__2(2481);
                __webpack_require__2(2707);
                __webpack_require__2(4916);
                __webpack_require__2(4723);
                __webpack_require__2(1038);
                __webpack_require__2(9600);
                __webpack_require__2(3371);
                __webpack_require__2(3290);
                __webpack_require__2(3299);
                __webpack_require__2(8255);
                __webpack_require__2(2990);
                __webpack_require__2(8927);
                __webpack_require__2(3105);
                __webpack_require__2(5035);
                __webpack_require__2(4345);
                __webpack_require__2(7174);
                __webpack_require__2(2846);
                __webpack_require__2(4731);
                __webpack_require__2(7209);
                __webpack_require__2(6319);
                __webpack_require__2(8867);
                __webpack_require__2(7789);
                __webpack_require__2(3739);
                __webpack_require__2(9368);
                __webpack_require__2(4483);
                __webpack_require__2(2056);
                __webpack_require__2(3462);
                __webpack_require__2(678);
                __webpack_require__2(7462);
                __webpack_require__2(3824);
                __webpack_require__2(5021);
                __webpack_require__2(2974);
                __webpack_require__2(5016);
                __webpack_require__2(5109);
                __webpack_require__2(9714);
                __webpack_require__2(3210);
                var _;
                function _defineProperties(target, props) {
                  for (var i2 = 0; i2 < props.length; i2++) {
                    var descriptor = props[i2];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  Object.defineProperty(Constructor, "prototype", { writable: false });
                  return Constructor;
                }
                function _toPropertyKey(arg) {
                  var key = _toPrimitive(arg, "string");
                  return typeof key === "symbol" ? key : String(key);
                }
                function _toPrimitive(input, hint) {
                  if (typeof input !== "object" || input === null)
                    return input;
                  var prim = input[Symbol.toPrimitive];
                  if (prim !== void 0) {
                    var res = prim.call(input, hint || "default");
                    if (typeof res !== "object")
                      return res;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return (hint === "string" ? String : Number)(input);
                }
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                    o2.__proto__ = p2;
                    return o2;
                  };
                  return _setPrototypeOf(o, p);
                }
                function _createForOfIteratorHelperLoose(o, allowArrayLike) {
                  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                  if (it)
                    return (it = it.call(o)).next.bind(it);
                  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                      o = it;
                    var i2 = 0;
                    return function() {
                      if (i2 >= o.length)
                        return { done: true };
                      return { done: false, value: o[i2++] };
                    };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                function _unsupportedIterableToArray(o, minLen) {
                  if (!o)
                    return;
                  if (typeof o === "string")
                    return _arrayLikeToArray(o, minLen);
                  var n = Object.prototype.toString.call(o).slice(8, -1);
                  if (n === "Object" && o.constructor)
                    n = o.constructor.name;
                  if (n === "Map" || n === "Set")
                    return Array.from(o);
                  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                    return _arrayLikeToArray(o, minLen);
                }
                function _arrayLikeToArray(arr, len) {
                  if (len == null || len > arr.length)
                    len = arr.length;
                  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
                    arr2[i2] = arr[i2];
                  }
                  return arr2;
                }
                function _interopDefault(ex) {
                  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
                }
                var r = _interopDefault(__webpack_require__2(5106));
                var utils = __webpack_require__2(6610);
                var isEqual = _interopDefault(__webpack_require__2(251));
                var unicode = _interopDefault(__webpack_require__2(3631));
                var UnicodeTrie = _interopDefault(__webpack_require__2(4781));
                var StateMachine = _interopDefault(__webpack_require__2(9811));
                var cloneDeep = _interopDefault(__webpack_require__2(6313));
                var inflate = _interopDefault(__webpack_require__2(311));
                var brotli = _interopDefault(__webpack_require__2(7709));
                var fs = __webpack_require__2(3857);
                var fontkit = {};
                fontkit.logErrors = false;
                var formats = [];
                fontkit.registerFormat = function(format) {
                  formats.push(format);
                };
                fontkit.openSync = function(filename, postscriptName) {
                  var buffer = fs.readFileSync(filename);
                  return fontkit.create(buffer, postscriptName);
                };
                fontkit.open = function(filename, postscriptName, callback) {
                  if (typeof postscriptName === "function") {
                    callback = postscriptName;
                    postscriptName = null;
                  }
                  fs.readFile(filename, function(err, buffer) {
                    if (err) {
                      return callback(err);
                    }
                    try {
                      var font = fontkit.create(buffer, postscriptName);
                    } catch (e) {
                      return callback(e);
                    }
                    return callback(null, font);
                  });
                  return;
                };
                fontkit.create = function(buffer, postscriptName) {
                  for (var i2 = 0; i2 < formats.length; i2++) {
                    var format = formats[i2];
                    if (format.probe(buffer)) {
                      var font = new format(new r.DecodeStream(buffer));
                      if (postscriptName) {
                        return font.getFont(postscriptName);
                      }
                      return font;
                    }
                  }
                  throw new Error("Unknown font format");
                };
                fontkit.defaultLanguage = "en";
                fontkit.setDefaultLanguage = function(lang) {
                  if (lang === void 0) {
                    lang = "en";
                  }
                  fontkit.defaultLanguage = lang;
                };
                function _defineProperty(obj, key, value) {
                  if (key in obj) {
                    Object.defineProperty(obj, key, {
                      value,
                      enumerable: true,
                      configurable: true,
                      writable: true
                    });
                  } else {
                    obj[key] = value;
                  }
                  return obj;
                }
                function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
                  var desc = {};
                  Object.keys(descriptor).forEach(function(key) {
                    desc[key] = descriptor[key];
                  });
                  desc.enumerable = !!desc.enumerable;
                  desc.configurable = !!desc.configurable;
                  if ("value" in desc || desc.initializer) {
                    desc.writable = true;
                  }
                  desc = decorators.slice().reverse().reduce(function(desc2, decorator) {
                    return decorator(target, property, desc2) || desc2;
                  }, desc);
                  if (context && desc.initializer !== void 0) {
                    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
                    desc.initializer = void 0;
                  }
                  if (desc.initializer === void 0) {
                    Object.defineProperty(target, property, desc);
                    desc = null;
                  }
                  return desc;
                }
                function cache(target, key, descriptor) {
                  if (descriptor.get) {
                    var get = descriptor.get;
                    descriptor.get = function() {
                      var value = get.call(this);
                      Object.defineProperty(this, key, {
                        value
                      });
                      return value;
                    };
                  } else if (typeof descriptor.value === "function") {
                    var fn = descriptor.value;
                    return {
                      get: function get2() {
                        var cache2 = /* @__PURE__ */ new Map();
                        function memoized() {
                          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                            args[_key] = arguments[_key];
                          }
                          var key2 = args.length > 0 ? args[0] : "value";
                          if (cache2.has(key2)) {
                            return cache2.get(key2);
                          }
                          var result = fn.apply(this, args);
                          cache2.set(key2, result);
                          return result;
                        }
                        Object.defineProperty(this, key, {
                          value: memoized
                        });
                        return memoized;
                      }
                    };
                  }
                }
                var SubHeader = new r.Struct({
                  firstCode: r.uint16,
                  entryCount: r.uint16,
                  idDelta: r.int16,
                  idRangeOffset: r.uint16
                });
                var CmapGroup = new r.Struct({
                  startCharCode: r.uint32,
                  endCharCode: r.uint32,
                  glyphID: r.uint32
                });
                var UnicodeValueRange = new r.Struct({
                  startUnicodeValue: r.uint24,
                  additionalCount: r.uint8
                });
                var UVSMapping = new r.Struct({
                  unicodeValue: r.uint24,
                  glyphID: r.uint16
                });
                var DefaultUVS = new r.Array(UnicodeValueRange, r.uint32);
                var NonDefaultUVS = new r.Array(UVSMapping, r.uint32);
                var VarSelectorRecord = new r.Struct({
                  varSelector: r.uint24,
                  defaultUVS: new r.Pointer(r.uint32, DefaultUVS, {
                    type: "parent"
                  }),
                  nonDefaultUVS: new r.Pointer(r.uint32, NonDefaultUVS, {
                    type: "parent"
                  })
                });
                var CmapSubtable = new r.VersionedStruct(r.uint16, {
                  0: {
                    // Byte encoding
                    length: r.uint16,
                    // Total table length in bytes (set to 262 for format 0)
                    language: r.uint16,
                    // Language code for this encoding subtable, or zero if language-independent
                    codeMap: new r.LazyArray(r.uint8, 256)
                  },
                  2: {
                    // High-byte mapping (CJK)
                    length: r.uint16,
                    language: r.uint16,
                    subHeaderKeys: new r.Array(r.uint16, 256),
                    subHeaderCount: function subHeaderCount(t2) {
                      return Math.max.apply(Math, t2.subHeaderKeys);
                    },
                    subHeaders: new r.LazyArray(SubHeader, "subHeaderCount"),
                    glyphIndexArray: new r.LazyArray(r.uint16, "subHeaderCount")
                  },
                  4: {
                    // Segment mapping to delta values
                    length: r.uint16,
                    // Total table length in bytes
                    language: r.uint16,
                    // Language code
                    segCountX2: r.uint16,
                    segCount: function segCount(t2) {
                      return t2.segCountX2 >> 1;
                    },
                    searchRange: r.uint16,
                    entrySelector: r.uint16,
                    rangeShift: r.uint16,
                    endCode: new r.LazyArray(r.uint16, "segCount"),
                    reservedPad: new r.Reserved(r.uint16),
                    // This value should be zero
                    startCode: new r.LazyArray(r.uint16, "segCount"),
                    idDelta: new r.LazyArray(r.int16, "segCount"),
                    idRangeOffset: new r.LazyArray(r.uint16, "segCount"),
                    glyphIndexArray: new r.LazyArray(r.uint16, function(t2) {
                      return (t2.length - t2._currentOffset) / 2;
                    })
                  },
                  6: {
                    // Trimmed table
                    length: r.uint16,
                    language: r.uint16,
                    firstCode: r.uint16,
                    entryCount: r.uint16,
                    glyphIndices: new r.LazyArray(r.uint16, "entryCount")
                  },
                  8: {
                    // mixed 16-bit and 32-bit coverage
                    reserved: new r.Reserved(r.uint16),
                    length: r.uint32,
                    language: r.uint16,
                    is32: new r.LazyArray(r.uint8, 8192),
                    nGroups: r.uint32,
                    groups: new r.LazyArray(CmapGroup, "nGroups")
                  },
                  10: {
                    // Trimmed Array
                    reserved: new r.Reserved(r.uint16),
                    length: r.uint32,
                    language: r.uint32,
                    firstCode: r.uint32,
                    entryCount: r.uint32,
                    glyphIndices: new r.LazyArray(r.uint16, "numChars")
                  },
                  12: {
                    // Segmented coverage
                    reserved: new r.Reserved(r.uint16),
                    length: r.uint32,
                    language: r.uint32,
                    nGroups: r.uint32,
                    groups: new r.LazyArray(CmapGroup, "nGroups")
                  },
                  13: {
                    // Many-to-one range mappings (same as 12 except for group.startGlyphID)
                    reserved: new r.Reserved(r.uint16),
                    length: r.uint32,
                    language: r.uint32,
                    nGroups: r.uint32,
                    groups: new r.LazyArray(CmapGroup, "nGroups")
                  },
                  14: {
                    // Unicode Variation Sequences
                    length: r.uint32,
                    numRecords: r.uint32,
                    varSelectors: new r.LazyArray(VarSelectorRecord, "numRecords")
                  }
                });
                var CmapEntry = new r.Struct({
                  platformID: r.uint16,
                  // Platform identifier
                  encodingID: r.uint16,
                  // Platform-specific encoding identifier
                  table: new r.Pointer(r.uint32, CmapSubtable, {
                    type: "parent",
                    lazy: true
                  })
                });
                var cmap = new r.Struct({
                  version: r.uint16,
                  numSubtables: r.uint16,
                  tables: new r.Array(CmapEntry, "numSubtables")
                });
                var head = new r.Struct({
                  version: r.int32,
                  // 0x00010000 (version 1.0)
                  revision: r.int32,
                  // set by font manufacturer
                  checkSumAdjustment: r.uint32,
                  magicNumber: r.uint32,
                  // set to 0x5F0F3CF5
                  flags: r.uint16,
                  unitsPerEm: r.uint16,
                  // range from 64 to 16384
                  created: new r.Array(r.int32, 2),
                  modified: new r.Array(r.int32, 2),
                  xMin: r.int16,
                  // for all glyph bounding boxes
                  yMin: r.int16,
                  // for all glyph bounding boxes
                  xMax: r.int16,
                  // for all glyph bounding boxes
                  yMax: r.int16,
                  // for all glyph bounding boxes
                  macStyle: new r.Bitfield(r.uint16, ["bold", "italic", "underline", "outline", "shadow", "condensed", "extended"]),
                  lowestRecPPEM: r.uint16,
                  // smallest readable size in pixels
                  fontDirectionHint: r.int16,
                  indexToLocFormat: r.int16,
                  // 0 for short offsets, 1 for long
                  glyphDataFormat: r.int16
                  // 0 for current format
                });
                var hhea = new r.Struct({
                  version: r.int32,
                  ascent: r.int16,
                  // Distance from baseline of highest ascender
                  descent: r.int16,
                  // Distance from baseline of lowest descender
                  lineGap: r.int16,
                  // Typographic line gap
                  advanceWidthMax: r.uint16,
                  // Maximum advance width value in 'hmtx' table
                  minLeftSideBearing: r.int16,
                  // Maximum advance width value in 'hmtx' table
                  minRightSideBearing: r.int16,
                  // Minimum right sidebearing value
                  xMaxExtent: r.int16,
                  caretSlopeRise: r.int16,
                  // Used to calculate the slope of the cursor (rise/run); 1 for vertical
                  caretSlopeRun: r.int16,
                  // 0 for vertical
                  caretOffset: r.int16,
                  // Set to 0 for non-slanted fonts
                  reserved: new r.Reserved(r.int16, 4),
                  metricDataFormat: r.int16,
                  // 0 for current format
                  numberOfMetrics: r.uint16
                  // Number of advance widths in 'hmtx' table
                });
                var HmtxEntry = new r.Struct({
                  advance: r.uint16,
                  bearing: r.int16
                });
                var hmtx = new r.Struct({
                  metrics: new r.LazyArray(HmtxEntry, function(t2) {
                    return t2.parent.hhea.numberOfMetrics;
                  }),
                  bearings: new r.LazyArray(r.int16, function(t2) {
                    return t2.parent.maxp.numGlyphs - t2.parent.hhea.numberOfMetrics;
                  })
                });
                var maxp = new r.Struct({
                  version: r.int32,
                  numGlyphs: r.uint16,
                  // The number of glyphs in the font
                  maxPoints: r.uint16,
                  // Maximum points in a non-composite glyph
                  maxContours: r.uint16,
                  // Maximum contours in a non-composite glyph
                  maxComponentPoints: r.uint16,
                  // Maximum points in a composite glyph
                  maxComponentContours: r.uint16,
                  // Maximum contours in a composite glyph
                  maxZones: r.uint16,
                  // 1 if instructions do not use the twilight zone, 2 otherwise
                  maxTwilightPoints: r.uint16,
                  // Maximum points used in Z0
                  maxStorage: r.uint16,
                  // Number of Storage Area locations
                  maxFunctionDefs: r.uint16,
                  // Number of FDEFs
                  maxInstructionDefs: r.uint16,
                  // Number of IDEFs
                  maxStackElements: r.uint16,
                  // Maximum stack depth
                  maxSizeOfInstructions: r.uint16,
                  // Maximum byte count for glyph instructions
                  maxComponentElements: r.uint16,
                  // Maximum number of components referenced at top level for any composite glyph
                  maxComponentDepth: r.uint16
                  // Maximum levels of recursion; 1 for simple components
                });
                function getEncoding(platformID, encodingID, languageID) {
                  if (languageID === void 0) {
                    languageID = 0;
                  }
                  if (platformID === 1 && MAC_LANGUAGE_ENCODINGS[languageID]) {
                    return MAC_LANGUAGE_ENCODINGS[languageID];
                  }
                  return ENCODINGS[platformID][encodingID];
                }
                var ENCODINGS = [
                  // unicode
                  ["utf16be", "utf16be", "utf16be", "utf16be", "utf16be", "utf16be"],
                  // macintosh
                  // Mappings available at http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/
                  // 0	Roman                 17	Malayalam
                  // 1	Japanese	            18	Sinhalese
                  // 2	Traditional Chinese	  19	Burmese
                  // 3	Korean	              20	Khmer
                  // 4	Arabic	              21	Thai
                  // 5	Hebrew	              22	Laotian
                  // 6	Greek	                23	Georgian
                  // 7	Russian	              24	Armenian
                  // 8	RSymbol	              25	Simplified Chinese
                  // 9	Devanagari	          26	Tibetan
                  // 10	Gurmukhi	            27	Mongolian
                  // 11	Gujarati	            28	Geez
                  // 12	Oriya	                29	Slavic
                  // 13	Bengali	              30	Vietnamese
                  // 14	Tamil	                31	Sindhi
                  // 15	Telugu	              32	(Uninterpreted)
                  // 16	Kannada
                  ["macroman", "shift-jis", "big5", "euc-kr", "iso-8859-6", "iso-8859-8", "macgreek", "maccyrillic", "symbol", "Devanagari", "Gurmukhi", "Gujarati", "Oriya", "Bengali", "Tamil", "Telugu", "Kannada", "Malayalam", "Sinhalese", "Burmese", "Khmer", "macthai", "Laotian", "Georgian", "Armenian", "gb-2312-80", "Tibetan", "Mongolian", "Geez", "maccenteuro", "Vietnamese", "Sindhi"],
                  // ISO (deprecated)
                  ["ascii"],
                  // windows
                  // Docs here: http://msdn.microsoft.com/en-us/library/system.text.encoding(v=vs.110).aspx
                  ["symbol", "utf16be", "shift-jis", "gb18030", "big5", "wansung", "johab", null, null, null, "utf16be"]
                ];
                var MAC_LANGUAGE_ENCODINGS = {
                  15: "maciceland",
                  17: "macturkish",
                  18: "maccroatian",
                  24: "maccenteuro",
                  25: "maccenteuro",
                  26: "maccenteuro",
                  27: "maccenteuro",
                  28: "maccenteuro",
                  30: "maciceland",
                  37: "macromania",
                  38: "maccenteuro",
                  39: "maccenteuro",
                  40: "maccenteuro",
                  143: "macinuit",
                  // Unsupported by iconv-lite
                  146: "macgaelic"
                  // Unsupported by iconv-lite
                };
                var LANGUAGES = [
                  // unicode
                  [],
                  {
                    // macintosh
                    0: "en",
                    30: "fo",
                    60: "ks",
                    90: "rw",
                    1: "fr",
                    31: "fa",
                    61: "ku",
                    91: "rn",
                    2: "de",
                    32: "ru",
                    62: "sd",
                    92: "ny",
                    3: "it",
                    33: "zh",
                    63: "bo",
                    93: "mg",
                    4: "nl",
                    34: "nl-BE",
                    64: "ne",
                    94: "eo",
                    5: "sv",
                    35: "ga",
                    65: "sa",
                    128: "cy",
                    6: "es",
                    36: "sq",
                    66: "mr",
                    129: "eu",
                    7: "da",
                    37: "ro",
                    67: "bn",
                    130: "ca",
                    8: "pt",
                    38: "cz",
                    68: "as",
                    131: "la",
                    9: "no",
                    39: "sk",
                    69: "gu",
                    132: "qu",
                    10: "he",
                    40: "si",
                    70: "pa",
                    133: "gn",
                    11: "ja",
                    41: "yi",
                    71: "or",
                    134: "ay",
                    12: "ar",
                    42: "sr",
                    72: "ml",
                    135: "tt",
                    13: "fi",
                    43: "mk",
                    73: "kn",
                    136: "ug",
                    14: "el",
                    44: "bg",
                    74: "ta",
                    137: "dz",
                    15: "is",
                    45: "uk",
                    75: "te",
                    138: "jv",
                    16: "mt",
                    46: "be",
                    76: "si",
                    139: "su",
                    17: "tr",
                    47: "uz",
                    77: "my",
                    140: "gl",
                    18: "hr",
                    48: "kk",
                    78: "km",
                    141: "af",
                    19: "zh-Hant",
                    49: "az-Cyrl",
                    79: "lo",
                    142: "br",
                    20: "ur",
                    50: "az-Arab",
                    80: "vi",
                    143: "iu",
                    21: "hi",
                    51: "hy",
                    81: "id",
                    144: "gd",
                    22: "th",
                    52: "ka",
                    82: "tl",
                    145: "gv",
                    23: "ko",
                    53: "mo",
                    83: "ms",
                    146: "ga",
                    24: "lt",
                    54: "ky",
                    84: "ms-Arab",
                    147: "to",
                    25: "pl",
                    55: "tg",
                    85: "am",
                    148: "el-polyton",
                    26: "hu",
                    56: "tk",
                    86: "ti",
                    149: "kl",
                    27: "es",
                    57: "mn-CN",
                    87: "om",
                    150: "az",
                    28: "lv",
                    58: "mn",
                    88: "so",
                    151: "nn",
                    29: "se",
                    59: "ps",
                    89: "sw"
                  },
                  // ISO (deprecated)
                  [],
                  {
                    // windows                                        
                    1078: "af",
                    16393: "en-IN",
                    1159: "rw",
                    1074: "tn",
                    1052: "sq",
                    6153: "en-IE",
                    1089: "sw",
                    1115: "si",
                    1156: "gsw",
                    8201: "en-JM",
                    1111: "kok",
                    1051: "sk",
                    1118: "am",
                    17417: "en-MY",
                    1042: "ko",
                    1060: "sl",
                    5121: "ar-DZ",
                    5129: "en-NZ",
                    1088: "ky",
                    11274: "es-AR",
                    15361: "ar-BH",
                    13321: "en-PH",
                    1108: "lo",
                    16394: "es-BO",
                    3073: "ar",
                    18441: "en-SG",
                    1062: "lv",
                    13322: "es-CL",
                    2049: "ar-IQ",
                    7177: "en-ZA",
                    1063: "lt",
                    9226: "es-CO",
                    11265: "ar-JO",
                    11273: "en-TT",
                    2094: "dsb",
                    5130: "es-CR",
                    13313: "ar-KW",
                    2057: "en-GB",
                    1134: "lb",
                    7178: "es-DO",
                    12289: "ar-LB",
                    1033: "en",
                    1071: "mk",
                    12298: "es-EC",
                    4097: "ar-LY",
                    12297: "en-ZW",
                    2110: "ms-BN",
                    17418: "es-SV",
                    6145: "ary",
                    1061: "et",
                    1086: "ms",
                    4106: "es-GT",
                    8193: "ar-OM",
                    1080: "fo",
                    1100: "ml",
                    18442: "es-HN",
                    16385: "ar-QA",
                    1124: "fil",
                    1082: "mt",
                    2058: "es-MX",
                    1025: "ar-SA",
                    1035: "fi",
                    1153: "mi",
                    19466: "es-NI",
                    10241: "ar-SY",
                    2060: "fr-BE",
                    1146: "arn",
                    6154: "es-PA",
                    7169: "aeb",
                    3084: "fr-CA",
                    1102: "mr",
                    15370: "es-PY",
                    14337: "ar-AE",
                    1036: "fr",
                    1148: "moh",
                    10250: "es-PE",
                    9217: "ar-YE",
                    5132: "fr-LU",
                    1104: "mn",
                    20490: "es-PR",
                    1067: "hy",
                    6156: "fr-MC",
                    2128: "mn-CN",
                    3082: "es",
                    1101: "as",
                    4108: "fr-CH",
                    1121: "ne",
                    1034: "es",
                    2092: "az-Cyrl",
                    1122: "fy",
                    1044: "nb",
                    21514: "es-US",
                    1068: "az",
                    1110: "gl",
                    2068: "nn",
                    14346: "es-UY",
                    1133: "ba",
                    1079: "ka",
                    1154: "oc",
                    8202: "es-VE",
                    1069: "eu",
                    3079: "de-AT",
                    1096: "or",
                    2077: "sv-FI",
                    1059: "be",
                    1031: "de",
                    1123: "ps",
                    1053: "sv",
                    2117: "bn",
                    5127: "de-LI",
                    1045: "pl",
                    1114: "syr",
                    1093: "bn-IN",
                    4103: "de-LU",
                    1046: "pt",
                    1064: "tg",
                    8218: "bs-Cyrl",
                    2055: "de-CH",
                    2070: "pt-PT",
                    2143: "tzm",
                    5146: "bs",
                    1032: "el",
                    1094: "pa",
                    1097: "ta",
                    1150: "br",
                    1135: "kl",
                    1131: "qu-BO",
                    1092: "tt",
                    1026: "bg",
                    1095: "gu",
                    2155: "qu-EC",
                    1098: "te",
                    1027: "ca",
                    1128: "ha",
                    3179: "qu",
                    1054: "th",
                    3076: "zh-HK",
                    1037: "he",
                    1048: "ro",
                    1105: "bo",
                    5124: "zh-MO",
                    1081: "hi",
                    1047: "rm",
                    1055: "tr",
                    2052: "zh",
                    1038: "hu",
                    1049: "ru",
                    1090: "tk",
                    4100: "zh-SG",
                    1039: "is",
                    9275: "smn",
                    1152: "ug",
                    1028: "zh-TW",
                    1136: "ig",
                    4155: "smj-NO",
                    1058: "uk",
                    1155: "co",
                    1057: "id",
                    5179: "smj",
                    1070: "hsb",
                    1050: "hr",
                    1117: "iu",
                    3131: "se-FI",
                    1056: "ur",
                    4122: "hr-BA",
                    2141: "iu-Latn",
                    1083: "se",
                    2115: "uz-Cyrl",
                    1029: "cs",
                    2108: "ga",
                    2107: "se-SE",
                    1091: "uz",
                    1030: "da",
                    1076: "xh",
                    8251: "sms",
                    1066: "vi",
                    1164: "prs",
                    1077: "zu",
                    6203: "sma-NO",
                    1106: "cy",
                    1125: "dv",
                    1040: "it",
                    7227: "sms",
                    1160: "wo",
                    2067: "nl-BE",
                    2064: "it-CH",
                    1103: "sa",
                    1157: "sah",
                    1043: "nl",
                    1041: "ja",
                    7194: "sr-Cyrl-BA",
                    1144: "ii",
                    3081: "en-AU",
                    1099: "kn",
                    3098: "sr",
                    1130: "yo",
                    10249: "en-BZ",
                    1087: "kk",
                    6170: "sr-Latn-BA",
                    4105: "en-CA",
                    1107: "km",
                    2074: "sr-Latn",
                    9225: "en-029",
                    1158: "quc",
                    1132: "nso"
                  }
                ];
                var NameRecord = new r.Struct({
                  platformID: r.uint16,
                  encodingID: r.uint16,
                  languageID: r.uint16,
                  nameID: r.uint16,
                  length: r.uint16,
                  string: new r.Pointer(r.uint16, new r.String("length", function(t2) {
                    return getEncoding(t2.platformID, t2.encodingID, t2.languageID);
                  }), {
                    type: "parent",
                    relativeTo: function relativeTo(ctx) {
                      return ctx.parent.stringOffset;
                    },
                    allowNull: false
                  })
                });
                var LangTagRecord = new r.Struct({
                  length: r.uint16,
                  tag: new r.Pointer(r.uint16, new r.String("length", "utf16be"), {
                    type: "parent",
                    relativeTo: function relativeTo(ctx) {
                      return ctx.stringOffset;
                    }
                  })
                });
                var NameTable = new r.VersionedStruct(r.uint16, {
                  0: {
                    count: r.uint16,
                    stringOffset: r.uint16,
                    records: new r.Array(NameRecord, "count")
                  },
                  1: {
                    count: r.uint16,
                    stringOffset: r.uint16,
                    records: new r.Array(NameRecord, "count"),
                    langTagCount: r.uint16,
                    langTags: new r.Array(LangTagRecord, "langTagCount")
                  }
                });
                var NAMES = [
                  "copyright",
                  "fontFamily",
                  "fontSubfamily",
                  "uniqueSubfamily",
                  "fullName",
                  "version",
                  "postscriptName",
                  // Note: A font may have only one PostScript name and that name must be ASCII.
                  "trademark",
                  "manufacturer",
                  "designer",
                  "description",
                  "vendorURL",
                  "designerURL",
                  "license",
                  "licenseURL",
                  null,
                  // reserved
                  "preferredFamily",
                  "preferredSubfamily",
                  "compatibleFull",
                  "sampleText",
                  "postscriptCIDFontName",
                  "wwsFamilyName",
                  "wwsSubfamilyName"
                ];
                NameTable.process = function(stream) {
                  var records = {};
                  for (var _iterator = _createForOfIteratorHelperLoose(this.records), _step; !(_step = _iterator()).done; ) {
                    var record = _step.value;
                    var language = LANGUAGES[record.platformID][record.languageID];
                    if (language == null && this.langTags != null && record.languageID >= 32768) {
                      language = this.langTags[record.languageID - 32768].tag;
                    }
                    if (language == null) {
                      language = record.platformID + "-" + record.languageID;
                    }
                    var key = record.nameID >= 256 ? "fontFeatures" : NAMES[record.nameID] || record.nameID;
                    if (records[key] == null) {
                      records[key] = {};
                    }
                    var obj = records[key];
                    if (record.nameID >= 256) {
                      obj = obj[record.nameID] || (obj[record.nameID] = {});
                    }
                    if (typeof record.string === "string" || typeof obj[language] !== "string") {
                      obj[language] = record.string;
                    }
                  }
                  this.records = records;
                };
                NameTable.preEncode = function() {
                  if (Array.isArray(this.records))
                    return;
                  this.version = 0;
                  var records = [];
                  for (var key in this.records) {
                    var val = this.records[key];
                    if (key === "fontFeatures")
                      continue;
                    records.push({
                      platformID: 3,
                      encodingID: 1,
                      languageID: 1033,
                      nameID: NAMES.indexOf(key),
                      length: Buffer.byteLength(val.en, "utf16le"),
                      string: val.en
                    });
                    if (key === "postscriptName") {
                      records.push({
                        platformID: 1,
                        encodingID: 0,
                        languageID: 0,
                        nameID: NAMES.indexOf(key),
                        length: val.en.length,
                        string: val.en
                      });
                    }
                  }
                  this.records = records;
                  this.count = records.length;
                  this.stringOffset = NameTable.size(this, null, false);
                };
                var OS2 = new r.VersionedStruct(r.uint16, {
                  header: {
                    xAvgCharWidth: r.int16,
                    // average weighted advance width of lower case letters and space
                    usWeightClass: r.uint16,
                    // visual weight of stroke in glyphs
                    usWidthClass: r.uint16,
                    // relative change from the normal aspect ratio (width to height ratio)
                    fsType: new r.Bitfield(r.uint16, [
                      // Indicates font embedding licensing rights
                      null,
                      "noEmbedding",
                      "viewOnly",
                      "editable",
                      null,
                      null,
                      null,
                      null,
                      "noSubsetting",
                      "bitmapOnly"
                    ]),
                    ySubscriptXSize: r.int16,
                    // recommended horizontal size in pixels for subscripts
                    ySubscriptYSize: r.int16,
                    // recommended vertical size in pixels for subscripts
                    ySubscriptXOffset: r.int16,
                    // recommended horizontal offset for subscripts
                    ySubscriptYOffset: r.int16,
                    // recommended vertical offset form the baseline for subscripts
                    ySuperscriptXSize: r.int16,
                    // recommended horizontal size in pixels for superscripts
                    ySuperscriptYSize: r.int16,
                    // recommended vertical size in pixels for superscripts
                    ySuperscriptXOffset: r.int16,
                    // recommended horizontal offset for superscripts
                    ySuperscriptYOffset: r.int16,
                    // recommended vertical offset from the baseline for superscripts
                    yStrikeoutSize: r.int16,
                    // width of the strikeout stroke
                    yStrikeoutPosition: r.int16,
                    // position of the strikeout stroke relative to the baseline
                    sFamilyClass: r.int16,
                    // classification of font-family design
                    panose: new r.Array(r.uint8, 10),
                    // describe the visual characteristics of a given typeface
                    ulCharRange: new r.Array(r.uint32, 4),
                    vendorID: new r.String(4),
                    // four character identifier for the font vendor
                    fsSelection: new r.Bitfield(r.uint16, [
                      // bit field containing information about the font
                      "italic",
                      "underscore",
                      "negative",
                      "outlined",
                      "strikeout",
                      "bold",
                      "regular",
                      "useTypoMetrics",
                      "wws",
                      "oblique"
                    ]),
                    usFirstCharIndex: r.uint16,
                    // The minimum Unicode index in this font
                    usLastCharIndex: r.uint16
                    // The maximum Unicode index in this font
                  },
                  // The Apple version of this table ends here, but the Microsoft one continues on...
                  0: {},
                  1: {
                    typoAscender: r.int16,
                    typoDescender: r.int16,
                    typoLineGap: r.int16,
                    winAscent: r.uint16,
                    winDescent: r.uint16,
                    codePageRange: new r.Array(r.uint32, 2)
                  },
                  2: {
                    // these should be common with version 1 somehow
                    typoAscender: r.int16,
                    typoDescender: r.int16,
                    typoLineGap: r.int16,
                    winAscent: r.uint16,
                    winDescent: r.uint16,
                    codePageRange: new r.Array(r.uint32, 2),
                    xHeight: r.int16,
                    capHeight: r.int16,
                    defaultChar: r.uint16,
                    breakChar: r.uint16,
                    maxContent: r.uint16
                  },
                  5: {
                    typoAscender: r.int16,
                    typoDescender: r.int16,
                    typoLineGap: r.int16,
                    winAscent: r.uint16,
                    winDescent: r.uint16,
                    codePageRange: new r.Array(r.uint32, 2),
                    xHeight: r.int16,
                    capHeight: r.int16,
                    defaultChar: r.uint16,
                    breakChar: r.uint16,
                    maxContent: r.uint16,
                    usLowerOpticalPointSize: r.uint16,
                    usUpperOpticalPointSize: r.uint16
                  }
                });
                var versions = OS2.versions;
                versions[3] = versions[4] = versions[2];
                var post = new r.VersionedStruct(r.fixed32, {
                  header: {
                    // these fields exist at the top of all versions
                    italicAngle: r.fixed32,
                    // Italic angle in counter-clockwise degrees from the vertical.
                    underlinePosition: r.int16,
                    // Suggested distance of the top of the underline from the baseline
                    underlineThickness: r.int16,
                    // Suggested values for the underline thickness
                    isFixedPitch: r.uint32,
                    // Whether the font is monospaced
                    minMemType42: r.uint32,
                    // Minimum memory usage when a TrueType font is downloaded as a Type 42 font
                    maxMemType42: r.uint32,
                    // Maximum memory usage when a TrueType font is downloaded as a Type 42 font
                    minMemType1: r.uint32,
                    // Minimum memory usage when a TrueType font is downloaded as a Type 1 font
                    maxMemType1: r.uint32
                    // Maximum memory usage when a TrueType font is downloaded as a Type 1 font
                  },
                  1: {},
                  // version 1 has no additional fields
                  2: {
                    numberOfGlyphs: r.uint16,
                    glyphNameIndex: new r.Array(r.uint16, "numberOfGlyphs"),
                    names: new r.Array(new r.String(r.uint8))
                  },
                  2.5: {
                    numberOfGlyphs: r.uint16,
                    offsets: new r.Array(r.uint8, "numberOfGlyphs")
                  },
                  3: {},
                  // version 3 has no additional fields
                  4: {
                    map: new r.Array(r.uint32, function(t2) {
                      return t2.parent.maxp.numGlyphs;
                    })
                  }
                });
                var cvt = new r.Struct({
                  controlValues: new r.Array(r.int16)
                });
                var fpgm = new r.Struct({
                  instructions: new r.Array(r.uint8)
                });
                var loca = new r.VersionedStruct("head.indexToLocFormat", {
                  0: {
                    offsets: new r.Array(r.uint16)
                  },
                  1: {
                    offsets: new r.Array(r.uint32)
                  }
                });
                loca.process = function() {
                  if (this.version === 0) {
                    for (var i2 = 0; i2 < this.offsets.length; i2++) {
                      this.offsets[i2] <<= 1;
                    }
                  }
                };
                loca.preEncode = function() {
                  if (this.version === 0) {
                    for (var i2 = 0; i2 < this.offsets.length; i2++) {
                      this.offsets[i2] >>>= 1;
                    }
                  }
                };
                var prep = new r.Struct({
                  controlValueProgram: new r.Array(r.uint8)
                });
                var glyf = new r.Array(new r.Buffer());
                var CFFIndex = function() {
                  function CFFIndex2(type) {
                    this.type = type;
                  }
                  var _proto = CFFIndex2.prototype;
                  _proto.getCFFVersion = function getCFFVersion(ctx) {
                    while (ctx && !ctx.hdrSize) {
                      ctx = ctx.parent;
                    }
                    return ctx ? ctx.version : -1;
                  };
                  _proto.decode = function decode(stream, parent) {
                    var version = this.getCFFVersion(parent);
                    var count = version >= 2 ? stream.readUInt32BE() : stream.readUInt16BE();
                    if (count === 0) {
                      return [];
                    }
                    var offSize = stream.readUInt8();
                    var offsetType;
                    if (offSize === 1) {
                      offsetType = r.uint8;
                    } else if (offSize === 2) {
                      offsetType = r.uint16;
                    } else if (offSize === 3) {
                      offsetType = r.uint24;
                    } else if (offSize === 4) {
                      offsetType = r.uint32;
                    } else {
                      throw new Error("Bad offset size in CFFIndex: ".concat(offSize, " ").concat(stream.pos));
                    }
                    var ret = [];
                    var startPos = stream.pos + (count + 1) * offSize - 1;
                    var start = offsetType.decode(stream);
                    for (var i2 = 0; i2 < count; i2++) {
                      var end = offsetType.decode(stream);
                      if (this.type != null) {
                        var pos = stream.pos;
                        stream.pos = startPos + start;
                        parent.length = end - start;
                        ret.push(this.type.decode(stream, parent));
                        stream.pos = pos;
                      } else {
                        ret.push({
                          offset: startPos + start,
                          length: end - start
                        });
                      }
                      start = end;
                    }
                    stream.pos = startPos + start;
                    return ret;
                  };
                  _proto.size = function size(arr, parent) {
                    var size2 = 2;
                    if (arr.length === 0) {
                      return size2;
                    }
                    var type = this.type || new r.Buffer();
                    var offset = 1;
                    for (var i2 = 0; i2 < arr.length; i2++) {
                      var item = arr[i2];
                      offset += type.size(item, parent);
                    }
                    var offsetType;
                    if (offset <= 255) {
                      offsetType = r.uint8;
                    } else if (offset <= 65535) {
                      offsetType = r.uint16;
                    } else if (offset <= 16777215) {
                      offsetType = r.uint24;
                    } else if (offset <= 4294967295) {
                      offsetType = r.uint32;
                    } else {
                      throw new Error("Bad offset in CFFIndex");
                    }
                    size2 += 1 + offsetType.size() * (arr.length + 1);
                    size2 += offset - 1;
                    return size2;
                  };
                  _proto.encode = function encode(stream, arr, parent) {
                    stream.writeUInt16BE(arr.length);
                    if (arr.length === 0) {
                      return;
                    }
                    var type = this.type || new r.Buffer();
                    var sizes = [];
                    var offset = 1;
                    for (var _iterator2 = _createForOfIteratorHelperLoose(arr), _step2; !(_step2 = _iterator2()).done; ) {
                      var item = _step2.value;
                      var s = type.size(item, parent);
                      sizes.push(s);
                      offset += s;
                    }
                    var offsetType;
                    if (offset <= 255) {
                      offsetType = r.uint8;
                    } else if (offset <= 65535) {
                      offsetType = r.uint16;
                    } else if (offset <= 16777215) {
                      offsetType = r.uint24;
                    } else if (offset <= 4294967295) {
                      offsetType = r.uint32;
                    } else {
                      throw new Error("Bad offset in CFFIndex");
                    }
                    stream.writeUInt8(offsetType.size());
                    offset = 1;
                    offsetType.encode(stream, offset);
                    for (var _i22 = 0, _sizes = sizes; _i22 < _sizes.length; _i22++) {
                      var size = _sizes[_i22];
                      offset += size;
                      offsetType.encode(stream, offset);
                    }
                    for (var _iterator3 = _createForOfIteratorHelperLoose(arr), _step3; !(_step3 = _iterator3()).done; ) {
                      var _item = _step3.value;
                      type.encode(stream, _item, parent);
                    }
                    return;
                  };
                  return CFFIndex2;
                }();
                var FLOAT_EOF = 15;
                var FLOAT_LOOKUP = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];
                var FLOAT_ENCODE_LOOKUP = {
                  ".": 10,
                  "E": 11,
                  "E-": 12,
                  "-": 14
                };
                var CFFOperand = function() {
                  function CFFOperand2() {
                  }
                  CFFOperand2.decode = function decode(stream, value) {
                    if (32 <= value && value <= 246) {
                      return value - 139;
                    }
                    if (247 <= value && value <= 250) {
                      return (value - 247) * 256 + stream.readUInt8() + 108;
                    }
                    if (251 <= value && value <= 254) {
                      return -(value - 251) * 256 - stream.readUInt8() - 108;
                    }
                    if (value === 28) {
                      return stream.readInt16BE();
                    }
                    if (value === 29) {
                      return stream.readInt32BE();
                    }
                    if (value === 30) {
                      var str = "";
                      while (true) {
                        var b = stream.readUInt8();
                        var n1 = b >> 4;
                        if (n1 === FLOAT_EOF) {
                          break;
                        }
                        str += FLOAT_LOOKUP[n1];
                        var n2 = b & 15;
                        if (n2 === FLOAT_EOF) {
                          break;
                        }
                        str += FLOAT_LOOKUP[n2];
                      }
                      return parseFloat(str);
                    }
                    return null;
                  };
                  CFFOperand2.size = function size(value) {
                    if (value.forceLarge) {
                      value = 32768;
                    }
                    if ((value | 0) !== value) {
                      var str = "" + value;
                      return 1 + Math.ceil((str.length + 1) / 2);
                    } else if (-107 <= value && value <= 107) {
                      return 1;
                    } else if (108 <= value && value <= 1131 || -1131 <= value && value <= -108) {
                      return 2;
                    } else if (-32768 <= value && value <= 32767) {
                      return 3;
                    } else {
                      return 5;
                    }
                  };
                  CFFOperand2.encode = function encode(stream, value) {
                    var val = Number(value);
                    if (value.forceLarge) {
                      stream.writeUInt8(29);
                      return stream.writeInt32BE(val);
                    } else if ((val | 0) !== val) {
                      stream.writeUInt8(30);
                      var str = "" + val;
                      for (var i2 = 0; i2 < str.length; i2 += 2) {
                        var c1 = str[i2];
                        var n1 = FLOAT_ENCODE_LOOKUP[c1] || +c1;
                        if (i2 === str.length - 1) {
                          var n2 = FLOAT_EOF;
                        } else {
                          var c2 = str[i2 + 1];
                          var n2 = FLOAT_ENCODE_LOOKUP[c2] || +c2;
                        }
                        stream.writeUInt8(n1 << 4 | n2 & 15);
                      }
                      if (n2 !== FLOAT_EOF) {
                        return stream.writeUInt8(FLOAT_EOF << 4);
                      }
                    } else if (-107 <= val && val <= 107) {
                      return stream.writeUInt8(val + 139);
                    } else if (108 <= val && val <= 1131) {
                      val -= 108;
                      stream.writeUInt8((val >> 8) + 247);
                      return stream.writeUInt8(val & 255);
                    } else if (-1131 <= val && val <= -108) {
                      val = -val - 108;
                      stream.writeUInt8((val >> 8) + 251);
                      return stream.writeUInt8(val & 255);
                    } else if (-32768 <= val && val <= 32767) {
                      stream.writeUInt8(28);
                      return stream.writeInt16BE(val);
                    } else {
                      stream.writeUInt8(29);
                      return stream.writeInt32BE(val);
                    }
                  };
                  return CFFOperand2;
                }();
                var CFFDict = function() {
                  function CFFDict2(ops) {
                    if (ops === void 0) {
                      ops = [];
                    }
                    this.ops = ops;
                    this.fields = {};
                    for (var _iterator4 = _createForOfIteratorHelperLoose(ops), _step4; !(_step4 = _iterator4()).done; ) {
                      var field = _step4.value;
                      var key = Array.isArray(field[0]) ? field[0][0] << 8 | field[0][1] : field[0];
                      this.fields[key] = field;
                    }
                  }
                  var _proto2 = CFFDict2.prototype;
                  _proto2.decodeOperands = function decodeOperands(type, stream, ret, operands) {
                    var _this = this;
                    if (Array.isArray(type)) {
                      return operands.map(function(op, i2) {
                        return _this.decodeOperands(type[i2], stream, ret, [op]);
                      });
                    } else if (type.decode != null) {
                      return type.decode(stream, ret, operands);
                    } else {
                      switch (type) {
                        case "number":
                        case "offset":
                        case "sid":
                          return operands[0];
                        case "boolean":
                          return !!operands[0];
                        default:
                          return operands;
                      }
                    }
                  };
                  _proto2.encodeOperands = function encodeOperands(type, stream, ctx, operands) {
                    var _this2 = this;
                    if (Array.isArray(type)) {
                      return operands.map(function(op, i2) {
                        return _this2.encodeOperands(type[i2], stream, ctx, op)[0];
                      });
                    } else if (type.encode != null) {
                      return type.encode(stream, operands, ctx);
                    } else if (typeof operands === "number") {
                      return [operands];
                    } else if (typeof operands === "boolean") {
                      return [+operands];
                    } else if (Array.isArray(operands)) {
                      return operands;
                    } else {
                      return [operands];
                    }
                  };
                  _proto2.decode = function decode(stream, parent) {
                    var end = stream.pos + parent.length;
                    var ret = {};
                    var operands = [];
                    Object.defineProperties(ret, {
                      parent: {
                        value: parent
                      },
                      _startOffset: {
                        value: stream.pos
                      }
                    });
                    for (var key in this.fields) {
                      var field = this.fields[key];
                      ret[field[1]] = field[3];
                    }
                    while (stream.pos < end) {
                      var b = stream.readUInt8();
                      if (b < 28) {
                        if (b === 12) {
                          b = b << 8 | stream.readUInt8();
                        }
                        var _field = this.fields[b];
                        if (!_field) {
                          throw new Error("Unknown operator ".concat(b));
                        }
                        var val = this.decodeOperands(_field[2], stream, ret, operands);
                        if (val != null) {
                          if (val instanceof utils.PropertyDescriptor) {
                            Object.defineProperty(ret, _field[1], val);
                          } else {
                            ret[_field[1]] = val;
                          }
                        }
                        operands = [];
                      } else {
                        operands.push(CFFOperand.decode(stream, b));
                      }
                    }
                    return ret;
                  };
                  _proto2.size = function size(dict, parent, includePointers) {
                    if (includePointers === void 0) {
                      includePointers = true;
                    }
                    var ctx = {
                      parent,
                      val: dict,
                      pointerSize: 0,
                      startOffset: parent.startOffset || 0
                    };
                    var len = 0;
                    for (var k in this.fields) {
                      var field = this.fields[k];
                      var val = dict[field[1]];
                      if (val == null || isEqual(val, field[3])) {
                        continue;
                      }
                      var operands = this.encodeOperands(field[2], null, ctx, val);
                      for (var _iterator5 = _createForOfIteratorHelperLoose(operands), _step5; !(_step5 = _iterator5()).done; ) {
                        var op = _step5.value;
                        len += CFFOperand.size(op);
                      }
                      var key = Array.isArray(field[0]) ? field[0] : [field[0]];
                      len += key.length;
                    }
                    if (includePointers) {
                      len += ctx.pointerSize;
                    }
                    return len;
                  };
                  _proto2.encode = function encode(stream, dict, parent) {
                    var ctx = {
                      pointers: [],
                      startOffset: stream.pos,
                      parent,
                      val: dict,
                      pointerSize: 0
                    };
                    ctx.pointerOffset = stream.pos + this.size(dict, ctx, false);
                    for (var _iterator6 = _createForOfIteratorHelperLoose(this.ops), _step6; !(_step6 = _iterator6()).done; ) {
                      var field = _step6.value;
                      var val = dict[field[1]];
                      if (val == null || isEqual(val, field[3])) {
                        continue;
                      }
                      var operands = this.encodeOperands(field[2], stream, ctx, val);
                      for (var _iterator7 = _createForOfIteratorHelperLoose(operands), _step7; !(_step7 = _iterator7()).done; ) {
                        var op = _step7.value;
                        CFFOperand.encode(stream, op);
                      }
                      var key = Array.isArray(field[0]) ? field[0] : [field[0]];
                      for (var _iterator8 = _createForOfIteratorHelperLoose(key), _step8; !(_step8 = _iterator8()).done; ) {
                        var _op = _step8.value;
                        stream.writeUInt8(_op);
                      }
                    }
                    var i2 = 0;
                    while (i2 < ctx.pointers.length) {
                      var ptr2 = ctx.pointers[i2++];
                      ptr2.type.encode(stream, ptr2.val, ptr2.parent);
                    }
                    return;
                  };
                  return CFFDict2;
                }();
                var CFFPointer = function(_r$Pointer) {
                  _inheritsLoose(CFFPointer2, _r$Pointer);
                  function CFFPointer2(type, options) {
                    if (options === void 0) {
                      options = {};
                    }
                    if (options.type == null) {
                      options.type = "global";
                    }
                    return _r$Pointer.call(this, null, type, options) || this;
                  }
                  var _proto3 = CFFPointer2.prototype;
                  _proto3.decode = function decode(stream, parent, operands) {
                    this.offsetType = {
                      decode: function decode2() {
                        return operands[0];
                      }
                    };
                    return _r$Pointer.prototype.decode.call(this, stream, parent, operands);
                  };
                  _proto3.encode = function encode(stream, value, ctx) {
                    if (!stream) {
                      this.offsetType = {
                        size: function size() {
                          return 0;
                        }
                      };
                      this.size(value, ctx);
                      return [new Ptr(0)];
                    }
                    var ptr2 = null;
                    this.offsetType = {
                      encode: function encode2(stream2, val) {
                        return ptr2 = val;
                      }
                    };
                    _r$Pointer.prototype.encode.call(this, stream, value, ctx);
                    return [new Ptr(ptr2)];
                  };
                  return CFFPointer2;
                }(r.Pointer);
                var Ptr = function() {
                  function Ptr2(val) {
                    this.val = val;
                    this.forceLarge = true;
                  }
                  var _proto4 = Ptr2.prototype;
                  _proto4.valueOf = function valueOf() {
                    return this.val;
                  };
                  return Ptr2;
                }();
                var CFFBlendOp = function() {
                  function CFFBlendOp2() {
                  }
                  CFFBlendOp2.decode = function decode(stream, parent, operands) {
                    var numBlends = operands.pop();
                    while (operands.length > numBlends) {
                      operands.pop();
                    }
                  };
                  return CFFBlendOp2;
                }();
                var CFFPrivateDict = new CFFDict([
                  // key       name                    type                                          default
                  [6, "BlueValues", "delta", null],
                  [7, "OtherBlues", "delta", null],
                  [8, "FamilyBlues", "delta", null],
                  [9, "FamilyOtherBlues", "delta", null],
                  [[12, 9], "BlueScale", "number", 0.039625],
                  [[12, 10], "BlueShift", "number", 7],
                  [[12, 11], "BlueFuzz", "number", 1],
                  [10, "StdHW", "number", null],
                  [11, "StdVW", "number", null],
                  [[12, 12], "StemSnapH", "delta", null],
                  [[12, 13], "StemSnapV", "delta", null],
                  [[12, 14], "ForceBold", "boolean", false],
                  [[12, 17], "LanguageGroup", "number", 0],
                  [[12, 18], "ExpansionFactor", "number", 0.06],
                  [[12, 19], "initialRandomSeed", "number", 0],
                  [20, "defaultWidthX", "number", 0],
                  [21, "nominalWidthX", "number", 0],
                  [22, "vsindex", "number", 0],
                  [23, "blend", CFFBlendOp, null],
                  [19, "Subrs", new CFFPointer(new CFFIndex(), {
                    type: "local"
                  }), null]
                ]);
                var standardStrings = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
                var StandardEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls"];
                var ExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
                var ISOAdobeCharset = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
                var ExpertCharset = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
                var ExpertSubsetCharset = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
                var LangSysTable = new r.Struct({
                  reserved: new r.Reserved(r.uint16),
                  reqFeatureIndex: r.uint16,
                  featureCount: r.uint16,
                  featureIndexes: new r.Array(r.uint16, "featureCount")
                });
                var LangSysRecord = new r.Struct({
                  tag: new r.String(4),
                  langSys: new r.Pointer(r.uint16, LangSysTable, {
                    type: "parent"
                  })
                });
                var Script = new r.Struct({
                  defaultLangSys: new r.Pointer(r.uint16, LangSysTable),
                  count: r.uint16,
                  langSysRecords: new r.Array(LangSysRecord, "count")
                });
                var ScriptRecord = new r.Struct({
                  tag: new r.String(4),
                  script: new r.Pointer(r.uint16, Script, {
                    type: "parent"
                  })
                });
                var ScriptList = new r.Array(ScriptRecord, r.uint16);
                var Feature = new r.Struct({
                  featureParams: r.uint16,
                  // pointer
                  lookupCount: r.uint16,
                  lookupListIndexes: new r.Array(r.uint16, "lookupCount")
                });
                var FeatureRecord = new r.Struct({
                  tag: new r.String(4),
                  feature: new r.Pointer(r.uint16, Feature, {
                    type: "parent"
                  })
                });
                var FeatureList = new r.Array(FeatureRecord, r.uint16);
                var LookupFlags = new r.Struct({
                  markAttachmentType: r.uint8,
                  flags: new r.Bitfield(r.uint8, ["rightToLeft", "ignoreBaseGlyphs", "ignoreLigatures", "ignoreMarks", "useMarkFilteringSet"])
                });
                function LookupList(SubTable) {
                  var Lookup = new r.Struct({
                    lookupType: r.uint16,
                    flags: LookupFlags,
                    subTableCount: r.uint16,
                    subTables: new r.Array(new r.Pointer(r.uint16, SubTable), "subTableCount"),
                    markFilteringSet: new r.Optional(r.uint16, function(t2) {
                      return t2.flags.flags.useMarkFilteringSet;
                    })
                  });
                  return new r.LazyArray(new r.Pointer(r.uint16, Lookup), r.uint16);
                }
                var RangeRecord = new r.Struct({
                  start: r.uint16,
                  end: r.uint16,
                  startCoverageIndex: r.uint16
                });
                var Coverage = new r.VersionedStruct(r.uint16, {
                  1: {
                    glyphCount: r.uint16,
                    glyphs: new r.Array(r.uint16, "glyphCount")
                  },
                  2: {
                    rangeCount: r.uint16,
                    rangeRecords: new r.Array(RangeRecord, "rangeCount")
                  }
                });
                var ClassRangeRecord = new r.Struct({
                  start: r.uint16,
                  end: r.uint16,
                  class: r.uint16
                });
                var ClassDef = new r.VersionedStruct(r.uint16, {
                  1: {
                    // Class array
                    startGlyph: r.uint16,
                    glyphCount: r.uint16,
                    classValueArray: new r.Array(r.uint16, "glyphCount")
                  },
                  2: {
                    // Class ranges
                    classRangeCount: r.uint16,
                    classRangeRecord: new r.Array(ClassRangeRecord, "classRangeCount")
                  }
                });
                var Device = new r.Struct({
                  a: r.uint16,
                  // startSize for hinting Device, outerIndex for VariationIndex
                  b: r.uint16,
                  // endSize for Device, innerIndex for VariationIndex
                  deltaFormat: r.uint16
                });
                var LookupRecord = new r.Struct({
                  sequenceIndex: r.uint16,
                  lookupListIndex: r.uint16
                });
                var Rule = new r.Struct({
                  glyphCount: r.uint16,
                  lookupCount: r.uint16,
                  input: new r.Array(r.uint16, function(t2) {
                    return t2.glyphCount - 1;
                  }),
                  lookupRecords: new r.Array(LookupRecord, "lookupCount")
                });
                var RuleSet = new r.Array(new r.Pointer(r.uint16, Rule), r.uint16);
                var ClassRule = new r.Struct({
                  glyphCount: r.uint16,
                  lookupCount: r.uint16,
                  classes: new r.Array(r.uint16, function(t2) {
                    return t2.glyphCount - 1;
                  }),
                  lookupRecords: new r.Array(LookupRecord, "lookupCount")
                });
                var ClassSet = new r.Array(new r.Pointer(r.uint16, ClassRule), r.uint16);
                var Context = new r.VersionedStruct(r.uint16, {
                  1: {
                    // Simple context
                    coverage: new r.Pointer(r.uint16, Coverage),
                    ruleSetCount: r.uint16,
                    ruleSets: new r.Array(new r.Pointer(r.uint16, RuleSet), "ruleSetCount")
                  },
                  2: {
                    // Class-based context
                    coverage: new r.Pointer(r.uint16, Coverage),
                    classDef: new r.Pointer(r.uint16, ClassDef),
                    classSetCnt: r.uint16,
                    classSet: new r.Array(new r.Pointer(r.uint16, ClassSet), "classSetCnt")
                  },
                  3: {
                    glyphCount: r.uint16,
                    lookupCount: r.uint16,
                    coverages: new r.Array(new r.Pointer(r.uint16, Coverage), "glyphCount"),
                    lookupRecords: new r.Array(LookupRecord, "lookupCount")
                  }
                });
                var ChainRule = new r.Struct({
                  backtrackGlyphCount: r.uint16,
                  backtrack: new r.Array(r.uint16, "backtrackGlyphCount"),
                  inputGlyphCount: r.uint16,
                  input: new r.Array(r.uint16, function(t2) {
                    return t2.inputGlyphCount - 1;
                  }),
                  lookaheadGlyphCount: r.uint16,
                  lookahead: new r.Array(r.uint16, "lookaheadGlyphCount"),
                  lookupCount: r.uint16,
                  lookupRecords: new r.Array(LookupRecord, "lookupCount")
                });
                var ChainRuleSet = new r.Array(new r.Pointer(r.uint16, ChainRule), r.uint16);
                var ChainingContext = new r.VersionedStruct(r.uint16, {
                  1: {
                    // Simple context glyph substitution
                    coverage: new r.Pointer(r.uint16, Coverage),
                    chainCount: r.uint16,
                    chainRuleSets: new r.Array(new r.Pointer(r.uint16, ChainRuleSet), "chainCount")
                  },
                  2: {
                    // Class-based chaining context
                    coverage: new r.Pointer(r.uint16, Coverage),
                    backtrackClassDef: new r.Pointer(r.uint16, ClassDef),
                    inputClassDef: new r.Pointer(r.uint16, ClassDef),
                    lookaheadClassDef: new r.Pointer(r.uint16, ClassDef),
                    chainCount: r.uint16,
                    chainClassSet: new r.Array(new r.Pointer(r.uint16, ChainRuleSet), "chainCount")
                  },
                  3: {
                    // Coverage-based chaining context
                    backtrackGlyphCount: r.uint16,
                    backtrackCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), "backtrackGlyphCount"),
                    inputGlyphCount: r.uint16,
                    inputCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), "inputGlyphCount"),
                    lookaheadGlyphCount: r.uint16,
                    lookaheadCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), "lookaheadGlyphCount"),
                    lookupCount: r.uint16,
                    lookupRecords: new r.Array(LookupRecord, "lookupCount")
                  }
                });
                var F2DOT14 = new r.Fixed(16, "BE", 14);
                var RegionAxisCoordinates = new r.Struct({
                  startCoord: F2DOT14,
                  peakCoord: F2DOT14,
                  endCoord: F2DOT14
                });
                var VariationRegionList = new r.Struct({
                  axisCount: r.uint16,
                  regionCount: r.uint16,
                  variationRegions: new r.Array(new r.Array(RegionAxisCoordinates, "axisCount"), "regionCount")
                });
                var DeltaSet = new r.Struct({
                  shortDeltas: new r.Array(r.int16, function(t2) {
                    return t2.parent.shortDeltaCount;
                  }),
                  regionDeltas: new r.Array(r.int8, function(t2) {
                    return t2.parent.regionIndexCount - t2.parent.shortDeltaCount;
                  }),
                  deltas: function deltas(t2) {
                    return t2.shortDeltas.concat(t2.regionDeltas);
                  }
                });
                var ItemVariationData = new r.Struct({
                  itemCount: r.uint16,
                  shortDeltaCount: r.uint16,
                  regionIndexCount: r.uint16,
                  regionIndexes: new r.Array(r.uint16, "regionIndexCount"),
                  deltaSets: new r.Array(DeltaSet, "itemCount")
                });
                var ItemVariationStore = new r.Struct({
                  format: r.uint16,
                  variationRegionList: new r.Pointer(r.uint32, VariationRegionList),
                  variationDataCount: r.uint16,
                  itemVariationData: new r.Array(new r.Pointer(r.uint32, ItemVariationData), "variationDataCount")
                });
                var ConditionTable = new r.VersionedStruct(r.uint16, {
                  1: (_ = {
                    axisIndex: r.uint16
                  }, _["axisIndex"] = r.uint16, _.filterRangeMinValue = F2DOT14, _.filterRangeMaxValue = F2DOT14, _)
                });
                var ConditionSet = new r.Struct({
                  conditionCount: r.uint16,
                  conditionTable: new r.Array(new r.Pointer(r.uint32, ConditionTable), "conditionCount")
                });
                var FeatureTableSubstitutionRecord = new r.Struct({
                  featureIndex: r.uint16,
                  alternateFeatureTable: new r.Pointer(r.uint32, Feature, {
                    type: "parent"
                  })
                });
                var FeatureTableSubstitution = new r.Struct({
                  version: r.fixed32,
                  substitutionCount: r.uint16,
                  substitutions: new r.Array(FeatureTableSubstitutionRecord, "substitutionCount")
                });
                var FeatureVariationRecord = new r.Struct({
                  conditionSet: new r.Pointer(r.uint32, ConditionSet, {
                    type: "parent"
                  }),
                  featureTableSubstitution: new r.Pointer(r.uint32, FeatureTableSubstitution, {
                    type: "parent"
                  })
                });
                var FeatureVariations = new r.Struct({
                  majorVersion: r.uint16,
                  minorVersion: r.uint16,
                  featureVariationRecordCount: r.uint32,
                  featureVariationRecords: new r.Array(FeatureVariationRecord, "featureVariationRecordCount")
                });
                var PredefinedOp = function() {
                  function PredefinedOp2(predefinedOps, type) {
                    this.predefinedOps = predefinedOps;
                    this.type = type;
                  }
                  var _proto5 = PredefinedOp2.prototype;
                  _proto5.decode = function decode(stream, parent, operands) {
                    if (this.predefinedOps[operands[0]]) {
                      return this.predefinedOps[operands[0]];
                    }
                    return this.type.decode(stream, parent, operands);
                  };
                  _proto5.size = function size(value, ctx) {
                    return this.type.size(value, ctx);
                  };
                  _proto5.encode = function encode(stream, value, ctx) {
                    var index = this.predefinedOps.indexOf(value);
                    if (index !== -1) {
                      return index;
                    }
                    return this.type.encode(stream, value, ctx);
                  };
                  return PredefinedOp2;
                }();
                var CFFEncodingVersion = function(_r$Number) {
                  _inheritsLoose(CFFEncodingVersion2, _r$Number);
                  function CFFEncodingVersion2() {
                    return _r$Number.call(this, "UInt8") || this;
                  }
                  var _proto6 = CFFEncodingVersion2.prototype;
                  _proto6.decode = function decode(stream) {
                    return r.uint8.decode(stream) & 127;
                  };
                  return CFFEncodingVersion2;
                }(r.Number);
                var Range1 = new r.Struct({
                  first: r.uint16,
                  nLeft: r.uint8
                });
                var Range2 = new r.Struct({
                  first: r.uint16,
                  nLeft: r.uint16
                });
                var CFFCustomEncoding = new r.VersionedStruct(new CFFEncodingVersion(), {
                  0: {
                    nCodes: r.uint8,
                    codes: new r.Array(r.uint8, "nCodes")
                  },
                  1: {
                    nRanges: r.uint8,
                    ranges: new r.Array(Range1, "nRanges")
                  }
                  // TODO: supplement?
                });
                var CFFEncoding = new PredefinedOp([StandardEncoding, ExpertEncoding], new CFFPointer(CFFCustomEncoding, {
                  lazy: true
                }));
                var RangeArray = function(_r$Array) {
                  _inheritsLoose(RangeArray2, _r$Array);
                  function RangeArray2() {
                    return _r$Array.apply(this, arguments) || this;
                  }
                  var _proto7 = RangeArray2.prototype;
                  _proto7.decode = function decode(stream, parent) {
                    var length = utils.resolveLength(this.length, stream, parent);
                    var count = 0;
                    var res = [];
                    while (count < length) {
                      var range2 = this.type.decode(stream, parent);
                      range2.offset = count;
                      count += range2.nLeft + 1;
                      res.push(range2);
                    }
                    return res;
                  };
                  return RangeArray2;
                }(r.Array);
                var CFFCustomCharset = new r.VersionedStruct(r.uint8, {
                  0: {
                    glyphs: new r.Array(r.uint16, function(t2) {
                      return t2.parent.CharStrings.length - 1;
                    })
                  },
                  1: {
                    ranges: new RangeArray(Range1, function(t2) {
                      return t2.parent.CharStrings.length - 1;
                    })
                  },
                  2: {
                    ranges: new RangeArray(Range2, function(t2) {
                      return t2.parent.CharStrings.length - 1;
                    })
                  }
                });
                var CFFCharset = new PredefinedOp([ISOAdobeCharset, ExpertCharset, ExpertSubsetCharset], new CFFPointer(CFFCustomCharset, {
                  lazy: true
                }));
                var FDRange3 = new r.Struct({
                  first: r.uint16,
                  fd: r.uint8
                });
                var FDRange4 = new r.Struct({
                  first: r.uint32,
                  fd: r.uint16
                });
                var FDSelect = new r.VersionedStruct(r.uint8, {
                  0: {
                    fds: new r.Array(r.uint8, function(t2) {
                      return t2.parent.CharStrings.length;
                    })
                  },
                  3: {
                    nRanges: r.uint16,
                    ranges: new r.Array(FDRange3, "nRanges"),
                    sentinel: r.uint16
                  },
                  4: {
                    nRanges: r.uint32,
                    ranges: new r.Array(FDRange4, "nRanges"),
                    sentinel: r.uint32
                  }
                });
                var ptr = new CFFPointer(CFFPrivateDict);
                var CFFPrivateOp = function() {
                  function CFFPrivateOp2() {
                  }
                  var _proto8 = CFFPrivateOp2.prototype;
                  _proto8.decode = function decode(stream, parent, operands) {
                    parent.length = operands[0];
                    return ptr.decode(stream, parent, [operands[1]]);
                  };
                  _proto8.size = function size(dict, ctx) {
                    return [CFFPrivateDict.size(dict, ctx, false), ptr.size(dict, ctx)[0]];
                  };
                  _proto8.encode = function encode(stream, dict, ctx) {
                    return [CFFPrivateDict.size(dict, ctx, false), ptr.encode(stream, dict, ctx)[0]];
                  };
                  return CFFPrivateOp2;
                }();
                var FontDict = new CFFDict([
                  // key       name                   type(s)                                 default
                  [18, "Private", new CFFPrivateOp(), null],
                  [[12, 38], "FontName", "sid", null],
                  [[12, 7], "FontMatrix", "array", [1e-3, 0, 0, 1e-3, 0, 0]],
                  [[12, 5], "PaintType", "number", 0]
                ]);
                var CFFTopDict = new CFFDict([
                  // key       name                   type(s)                                 default
                  [[12, 30], "ROS", ["sid", "sid", "number"], null],
                  [0, "version", "sid", null],
                  [1, "Notice", "sid", null],
                  [[12, 0], "Copyright", "sid", null],
                  [2, "FullName", "sid", null],
                  [3, "FamilyName", "sid", null],
                  [4, "Weight", "sid", null],
                  [[12, 1], "isFixedPitch", "boolean", false],
                  [[12, 2], "ItalicAngle", "number", 0],
                  [[12, 3], "UnderlinePosition", "number", -100],
                  [[12, 4], "UnderlineThickness", "number", 50],
                  [[12, 5], "PaintType", "number", 0],
                  [[12, 6], "CharstringType", "number", 2],
                  [[12, 7], "FontMatrix", "array", [1e-3, 0, 0, 1e-3, 0, 0]],
                  [13, "UniqueID", "number", null],
                  [5, "FontBBox", "array", [0, 0, 0, 0]],
                  [[12, 8], "StrokeWidth", "number", 0],
                  [14, "XUID", "array", null],
                  [15, "charset", CFFCharset, ISOAdobeCharset],
                  [16, "Encoding", CFFEncoding, StandardEncoding],
                  [17, "CharStrings", new CFFPointer(new CFFIndex()), null],
                  [18, "Private", new CFFPrivateOp(), null],
                  [[12, 20], "SyntheticBase", "number", null],
                  [[12, 21], "PostScript", "sid", null],
                  [[12, 22], "BaseFontName", "sid", null],
                  [[12, 23], "BaseFontBlend", "delta", null],
                  // CID font specific
                  [[12, 31], "CIDFontVersion", "number", 0],
                  [[12, 32], "CIDFontRevision", "number", 0],
                  [[12, 33], "CIDFontType", "number", 0],
                  [[12, 34], "CIDCount", "number", 8720],
                  [[12, 35], "UIDBase", "number", null],
                  [[12, 37], "FDSelect", new CFFPointer(FDSelect), null],
                  [[12, 36], "FDArray", new CFFPointer(new CFFIndex(FontDict)), null],
                  [[12, 38], "FontName", "sid", null]
                ]);
                var VariationStore = new r.Struct({
                  length: r.uint16,
                  itemVariationStore: ItemVariationStore
                });
                var CFF2TopDict = new CFFDict([[[12, 7], "FontMatrix", "array", [1e-3, 0, 0, 1e-3, 0, 0]], [17, "CharStrings", new CFFPointer(new CFFIndex()), null], [[12, 37], "FDSelect", new CFFPointer(FDSelect), null], [[12, 36], "FDArray", new CFFPointer(new CFFIndex(FontDict)), null], [24, "vstore", new CFFPointer(VariationStore), null], [25, "maxstack", "number", 193]]);
                var CFFTop = new r.VersionedStruct(r.fixed16, {
                  1: {
                    hdrSize: r.uint8,
                    offSize: r.uint8,
                    nameIndex: new CFFIndex(new r.String("length")),
                    topDictIndex: new CFFIndex(CFFTopDict),
                    stringIndex: new CFFIndex(new r.String("length")),
                    globalSubrIndex: new CFFIndex()
                  },
                  2: {
                    hdrSize: r.uint8,
                    length: r.uint16,
                    topDict: CFF2TopDict,
                    globalSubrIndex: new CFFIndex()
                  }
                });
                var CFFFont = function() {
                  function CFFFont2(stream) {
                    this.stream = stream;
                    this.decode();
                  }
                  CFFFont2.decode = function decode(stream) {
                    return new CFFFont2(stream);
                  };
                  var _proto9 = CFFFont2.prototype;
                  _proto9.decode = function decode() {
                    var start = this.stream.pos;
                    var top = CFFTop.decode(this.stream);
                    for (var key in top) {
                      var val = top[key];
                      this[key] = val;
                    }
                    if (this.version < 2) {
                      if (this.topDictIndex.length !== 1) {
                        throw new Error("Only a single font is allowed in CFF");
                      }
                      this.topDict = this.topDictIndex[0];
                    }
                    this.isCIDFont = this.topDict.ROS != null;
                    return this;
                  };
                  _proto9.string = function string(sid) {
                    if (this.version >= 2) {
                      return null;
                    }
                    if (sid < standardStrings.length) {
                      return standardStrings[sid];
                    }
                    return this.stringIndex[sid - standardStrings.length];
                  };
                  _proto9.getCharString = function getCharString(glyph2) {
                    this.stream.pos = this.topDict.CharStrings[glyph2].offset;
                    return this.stream.readBuffer(this.topDict.CharStrings[glyph2].length);
                  };
                  _proto9.getGlyphName = function getGlyphName(gid) {
                    if (this.version >= 2) {
                      return null;
                    }
                    if (this.isCIDFont) {
                      return null;
                    }
                    var charset = this.topDict.charset;
                    if (Array.isArray(charset)) {
                      return charset[gid];
                    }
                    if (gid === 0) {
                      return ".notdef";
                    }
                    gid -= 1;
                    switch (charset.version) {
                      case 0:
                        return this.string(charset.glyphs[gid]);
                      case 1:
                      case 2:
                        for (var i2 = 0; i2 < charset.ranges.length; i2++) {
                          var range2 = charset.ranges[i2];
                          if (range2.offset <= gid && gid <= range2.offset + range2.nLeft) {
                            return this.string(range2.first + (gid - range2.offset));
                          }
                        }
                        break;
                    }
                    return null;
                  };
                  _proto9.fdForGlyph = function fdForGlyph(gid) {
                    if (!this.topDict.FDSelect) {
                      return null;
                    }
                    switch (this.topDict.FDSelect.version) {
                      case 0:
                        return this.topDict.FDSelect.fds[gid];
                      case 3:
                      case 4:
                        var ranges = this.topDict.FDSelect.ranges;
                        var low = 0;
                        var high = ranges.length - 1;
                        while (low <= high) {
                          var mid = low + high >> 1;
                          if (gid < ranges[mid].first) {
                            high = mid - 1;
                          } else if (mid < high && gid >= ranges[mid + 1].first) {
                            low = mid + 1;
                          } else {
                            return ranges[mid].fd;
                          }
                        }
                      default:
                        throw new Error("Unknown FDSelect version: ".concat(this.topDict.FDSelect.version));
                    }
                  };
                  _proto9.privateDictForGlyph = function privateDictForGlyph(gid) {
                    if (this.topDict.FDSelect) {
                      var fd = this.fdForGlyph(gid);
                      if (this.topDict.FDArray[fd]) {
                        return this.topDict.FDArray[fd].Private;
                      }
                      return null;
                    }
                    if (this.version < 2) {
                      return this.topDict.Private;
                    }
                    return this.topDict.FDArray[0].Private;
                  };
                  _createClass(CFFFont2, [{
                    key: "postscriptName",
                    get: function get() {
                      if (this.version < 2) {
                        return this.nameIndex[0];
                      }
                      return null;
                    }
                  }, {
                    key: "fullName",
                    get: function get() {
                      return this.string(this.topDict.FullName);
                    }
                  }, {
                    key: "familyName",
                    get: function get() {
                      return this.string(this.topDict.FamilyName);
                    }
                  }]);
                  return CFFFont2;
                }();
                var VerticalOrigin = new r.Struct({
                  glyphIndex: r.uint16,
                  vertOriginY: r.int16
                });
                var VORG = new r.Struct({
                  majorVersion: r.uint16,
                  minorVersion: r.uint16,
                  defaultVertOriginY: r.int16,
                  numVertOriginYMetrics: r.uint16,
                  metrics: new r.Array(VerticalOrigin, "numVertOriginYMetrics")
                });
                var BigMetrics = new r.Struct({
                  height: r.uint8,
                  width: r.uint8,
                  horiBearingX: r.int8,
                  horiBearingY: r.int8,
                  horiAdvance: r.uint8,
                  vertBearingX: r.int8,
                  vertBearingY: r.int8,
                  vertAdvance: r.uint8
                });
                var SmallMetrics = new r.Struct({
                  height: r.uint8,
                  width: r.uint8,
                  bearingX: r.int8,
                  bearingY: r.int8,
                  advance: r.uint8
                });
                var EBDTComponent = new r.Struct({
                  glyph: r.uint16,
                  xOffset: r.int8,
                  yOffset: r.int8
                });
                var ByteAligned = function ByteAligned2() {
                };
                var BitAligned = function BitAligned2() {
                };
                var glyph = new r.VersionedStruct("version", {
                  1: {
                    metrics: SmallMetrics,
                    data: ByteAligned
                  },
                  2: {
                    metrics: SmallMetrics,
                    data: BitAligned
                  },
                  // format 3 is deprecated
                  // format 4 is not supported by Microsoft
                  5: {
                    data: BitAligned
                  },
                  6: {
                    metrics: BigMetrics,
                    data: ByteAligned
                  },
                  7: {
                    metrics: BigMetrics,
                    data: BitAligned
                  },
                  8: {
                    metrics: SmallMetrics,
                    pad: new r.Reserved(r.uint8),
                    numComponents: r.uint16,
                    components: new r.Array(EBDTComponent, "numComponents")
                  },
                  9: {
                    metrics: BigMetrics,
                    pad: new r.Reserved(r.uint8),
                    numComponents: r.uint16,
                    components: new r.Array(EBDTComponent, "numComponents")
                  },
                  17: {
                    metrics: SmallMetrics,
                    dataLen: r.uint32,
                    data: new r.Buffer("dataLen")
                  },
                  18: {
                    metrics: BigMetrics,
                    dataLen: r.uint32,
                    data: new r.Buffer("dataLen")
                  },
                  19: {
                    dataLen: r.uint32,
                    data: new r.Buffer("dataLen")
                  }
                });
                var SBitLineMetrics = new r.Struct({
                  ascender: r.int8,
                  descender: r.int8,
                  widthMax: r.uint8,
                  caretSlopeNumerator: r.int8,
                  caretSlopeDenominator: r.int8,
                  caretOffset: r.int8,
                  minOriginSB: r.int8,
                  minAdvanceSB: r.int8,
                  maxBeforeBL: r.int8,
                  minAfterBL: r.int8,
                  pad: new r.Reserved(r.int8, 2)
                });
                var CodeOffsetPair = new r.Struct({
                  glyphCode: r.uint16,
                  offset: r.uint16
                });
                var IndexSubtable = new r.VersionedStruct(r.uint16, {
                  header: {
                    imageFormat: r.uint16,
                    imageDataOffset: r.uint32
                  },
                  1: {
                    offsetArray: new r.Array(r.uint32, function(t2) {
                      return t2.parent.lastGlyphIndex - t2.parent.firstGlyphIndex + 1;
                    })
                  },
                  2: {
                    imageSize: r.uint32,
                    bigMetrics: BigMetrics
                  },
                  3: {
                    offsetArray: new r.Array(r.uint16, function(t2) {
                      return t2.parent.lastGlyphIndex - t2.parent.firstGlyphIndex + 1;
                    })
                  },
                  4: {
                    numGlyphs: r.uint32,
                    glyphArray: new r.Array(CodeOffsetPair, function(t2) {
                      return t2.numGlyphs + 1;
                    })
                  },
                  5: {
                    imageSize: r.uint32,
                    bigMetrics: BigMetrics,
                    numGlyphs: r.uint32,
                    glyphCodeArray: new r.Array(r.uint16, "numGlyphs")
                  }
                });
                var IndexSubtableArray = new r.Struct({
                  firstGlyphIndex: r.uint16,
                  lastGlyphIndex: r.uint16,
                  subtable: new r.Pointer(r.uint32, IndexSubtable)
                });
                var BitmapSizeTable = new r.Struct({
                  indexSubTableArray: new r.Pointer(r.uint32, new r.Array(IndexSubtableArray, 1), {
                    type: "parent"
                  }),
                  indexTablesSize: r.uint32,
                  numberOfIndexSubTables: r.uint32,
                  colorRef: r.uint32,
                  hori: SBitLineMetrics,
                  vert: SBitLineMetrics,
                  startGlyphIndex: r.uint16,
                  endGlyphIndex: r.uint16,
                  ppemX: r.uint8,
                  ppemY: r.uint8,
                  bitDepth: r.uint8,
                  flags: new r.Bitfield(r.uint8, ["horizontal", "vertical"])
                });
                var EBLC = new r.Struct({
                  version: r.uint32,
                  // 0x00020000
                  numSizes: r.uint32,
                  sizes: new r.Array(BitmapSizeTable, "numSizes")
                });
                var ImageTable = new r.Struct({
                  ppem: r.uint16,
                  resolution: r.uint16,
                  imageOffsets: new r.Array(new r.Pointer(r.uint32, "void"), function(t2) {
                    return t2.parent.parent.maxp.numGlyphs + 1;
                  })
                });
                var sbix = new r.Struct({
                  version: r.uint16,
                  flags: new r.Bitfield(r.uint16, ["renderOutlines"]),
                  numImgTables: r.uint32,
                  imageTables: new r.Array(new r.Pointer(r.uint32, ImageTable), "numImgTables")
                });
                var LayerRecord = new r.Struct({
                  gid: r.uint16,
                  // Glyph ID of layer glyph (must be in z-order from bottom to top).
                  paletteIndex: r.uint16
                  // Index value to use in the appropriate palette. This value must
                });
                var BaseGlyphRecord = new r.Struct({
                  gid: r.uint16,
                  // Glyph ID of reference glyph. This glyph is for reference only
                  // and is not rendered for color.
                  firstLayerIndex: r.uint16,
                  // Index (from beginning of the Layer Records) to the layer record.
                  // There will be numLayers consecutive entries for this base glyph.
                  numLayers: r.uint16
                });
                var COLR = new r.Struct({
                  version: r.uint16,
                  numBaseGlyphRecords: r.uint16,
                  baseGlyphRecord: new r.Pointer(r.uint32, new r.Array(BaseGlyphRecord, "numBaseGlyphRecords")),
                  layerRecords: new r.Pointer(r.uint32, new r.Array(LayerRecord, "numLayerRecords"), {
                    lazy: true
                  }),
                  numLayerRecords: r.uint16
                });
                var ColorRecord = new r.Struct({
                  blue: r.uint8,
                  green: r.uint8,
                  red: r.uint8,
                  alpha: r.uint8
                });
                var CPAL = new r.VersionedStruct(r.uint16, {
                  header: {
                    numPaletteEntries: r.uint16,
                    numPalettes: r.uint16,
                    numColorRecords: r.uint16,
                    colorRecords: new r.Pointer(r.uint32, new r.Array(ColorRecord, "numColorRecords")),
                    colorRecordIndices: new r.Array(r.uint16, "numPalettes")
                  },
                  0: {},
                  1: {
                    offsetPaletteTypeArray: new r.Pointer(r.uint32, new r.Array(r.uint32, "numPalettes")),
                    offsetPaletteLabelArray: new r.Pointer(r.uint32, new r.Array(r.uint16, "numPalettes")),
                    offsetPaletteEntryLabelArray: new r.Pointer(r.uint32, new r.Array(r.uint16, "numPaletteEntries"))
                  }
                });
                var BaseCoord = new r.VersionedStruct(r.uint16, {
                  1: {
                    // Design units only
                    coordinate: r.int16
                    // X or Y value, in design units
                  },
                  2: {
                    // Design units plus contour point
                    coordinate: r.int16,
                    // X or Y value, in design units
                    referenceGlyph: r.uint16,
                    // GlyphID of control glyph
                    baseCoordPoint: r.uint16
                    // Index of contour point on the referenceGlyph
                  },
                  3: {
                    // Design units plus Device table
                    coordinate: r.int16,
                    // X or Y value, in design units
                    deviceTable: new r.Pointer(r.uint16, Device)
                    // Device table for X or Y value
                  }
                });
                var BaseValues = new r.Struct({
                  defaultIndex: r.uint16,
                  // Index of default baseline for this script-same index in the BaseTagList
                  baseCoordCount: r.uint16,
                  baseCoords: new r.Array(new r.Pointer(r.uint16, BaseCoord), "baseCoordCount")
                });
                var FeatMinMaxRecord = new r.Struct({
                  tag: new r.String(4),
                  // 4-byte feature identification tag-must match FeatureTag in FeatureList
                  minCoord: new r.Pointer(r.uint16, BaseCoord, {
                    type: "parent"
                  }),
                  // May be NULL
                  maxCoord: new r.Pointer(r.uint16, BaseCoord, {
                    type: "parent"
                  })
                  // May be NULL
                });
                var MinMax = new r.Struct({
                  minCoord: new r.Pointer(r.uint16, BaseCoord),
                  // May be NULL
                  maxCoord: new r.Pointer(r.uint16, BaseCoord),
                  // May be NULL
                  featMinMaxCount: r.uint16,
                  // May be 0
                  featMinMaxRecords: new r.Array(FeatMinMaxRecord, "featMinMaxCount")
                  // In alphabetical order
                });
                var BaseLangSysRecord = new r.Struct({
                  tag: new r.String(4),
                  // 4-byte language system identification tag
                  minMax: new r.Pointer(r.uint16, MinMax, {
                    type: "parent"
                  })
                });
                var BaseScript = new r.Struct({
                  baseValues: new r.Pointer(r.uint16, BaseValues),
                  // May be NULL
                  defaultMinMax: new r.Pointer(r.uint16, MinMax),
                  // May be NULL
                  baseLangSysCount: r.uint16,
                  // May be 0
                  baseLangSysRecords: new r.Array(BaseLangSysRecord, "baseLangSysCount")
                  // in alphabetical order by BaseLangSysTag
                });
                var BaseScriptRecord = new r.Struct({
                  tag: new r.String(4),
                  // 4-byte script identification tag
                  script: new r.Pointer(r.uint16, BaseScript, {
                    type: "parent"
                  })
                });
                var BaseScriptList = new r.Array(BaseScriptRecord, r.uint16);
                var BaseTagList = new r.Array(new r.String(4), r.uint16);
                var Axis = new r.Struct({
                  baseTagList: new r.Pointer(r.uint16, BaseTagList),
                  // May be NULL
                  baseScriptList: new r.Pointer(r.uint16, BaseScriptList)
                });
                var BASE = new r.VersionedStruct(r.uint32, {
                  header: {
                    horizAxis: new r.Pointer(r.uint16, Axis),
                    // May be NULL
                    vertAxis: new r.Pointer(r.uint16, Axis)
                    // May be NULL
                  },
                  65536: {},
                  65537: {
                    itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore)
                  }
                });
                var AttachPoint = new r.Array(r.uint16, r.uint16);
                var AttachList = new r.Struct({
                  coverage: new r.Pointer(r.uint16, Coverage),
                  glyphCount: r.uint16,
                  attachPoints: new r.Array(new r.Pointer(r.uint16, AttachPoint), "glyphCount")
                });
                var CaretValue = new r.VersionedStruct(r.uint16, {
                  1: {
                    // Design units only
                    coordinate: r.int16
                  },
                  2: {
                    // Contour point
                    caretValuePoint: r.uint16
                  },
                  3: {
                    // Design units plus Device table
                    coordinate: r.int16,
                    deviceTable: new r.Pointer(r.uint16, Device)
                  }
                });
                var LigGlyph = new r.Array(new r.Pointer(r.uint16, CaretValue), r.uint16);
                var LigCaretList = new r.Struct({
                  coverage: new r.Pointer(r.uint16, Coverage),
                  ligGlyphCount: r.uint16,
                  ligGlyphs: new r.Array(new r.Pointer(r.uint16, LigGlyph), "ligGlyphCount")
                });
                var MarkGlyphSetsDef = new r.Struct({
                  markSetTableFormat: r.uint16,
                  markSetCount: r.uint16,
                  coverage: new r.Array(new r.Pointer(r.uint32, Coverage), "markSetCount")
                });
                var GDEF = new r.VersionedStruct(r.uint32, {
                  header: {
                    glyphClassDef: new r.Pointer(r.uint16, ClassDef),
                    attachList: new r.Pointer(r.uint16, AttachList),
                    ligCaretList: new r.Pointer(r.uint16, LigCaretList),
                    markAttachClassDef: new r.Pointer(r.uint16, ClassDef)
                  },
                  65536: {},
                  65538: {
                    markGlyphSetsDef: new r.Pointer(r.uint16, MarkGlyphSetsDef)
                  },
                  65539: {
                    markGlyphSetsDef: new r.Pointer(r.uint16, MarkGlyphSetsDef),
                    itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore)
                  }
                });
                var ValueFormat = new r.Bitfield(r.uint16, ["xPlacement", "yPlacement", "xAdvance", "yAdvance", "xPlaDevice", "yPlaDevice", "xAdvDevice", "yAdvDevice"]);
                var types = {
                  xPlacement: r.int16,
                  yPlacement: r.int16,
                  xAdvance: r.int16,
                  yAdvance: r.int16,
                  xPlaDevice: new r.Pointer(r.uint16, Device, {
                    type: "global",
                    relativeTo: function relativeTo(ctx) {
                      return ctx.rel;
                    }
                  }),
                  yPlaDevice: new r.Pointer(r.uint16, Device, {
                    type: "global",
                    relativeTo: function relativeTo(ctx) {
                      return ctx.rel;
                    }
                  }),
                  xAdvDevice: new r.Pointer(r.uint16, Device, {
                    type: "global",
                    relativeTo: function relativeTo(ctx) {
                      return ctx.rel;
                    }
                  }),
                  yAdvDevice: new r.Pointer(r.uint16, Device, {
                    type: "global",
                    relativeTo: function relativeTo(ctx) {
                      return ctx.rel;
                    }
                  })
                };
                var ValueRecord = function() {
                  function ValueRecord2(key) {
                    if (key === void 0) {
                      key = "valueFormat";
                    }
                    this.key = key;
                  }
                  var _proto10 = ValueRecord2.prototype;
                  _proto10.buildStruct = function buildStruct(parent) {
                    var struct = parent;
                    while (!struct[this.key] && struct.parent) {
                      struct = struct.parent;
                    }
                    if (!struct[this.key])
                      return;
                    var fields = {};
                    fields.rel = function() {
                      return struct._startOffset;
                    };
                    var format = struct[this.key];
                    for (var key in format) {
                      if (format[key]) {
                        fields[key] = types[key];
                      }
                    }
                    return new r.Struct(fields);
                  };
                  _proto10.size = function size(val, ctx) {
                    return this.buildStruct(ctx).size(val, ctx);
                  };
                  _proto10.decode = function decode(stream, parent) {
                    var res = this.buildStruct(parent).decode(stream, parent);
                    delete res.rel;
                    return res;
                  };
                  return ValueRecord2;
                }();
                var PairValueRecord = new r.Struct({
                  secondGlyph: r.uint16,
                  value1: new ValueRecord("valueFormat1"),
                  value2: new ValueRecord("valueFormat2")
                });
                var PairSet = new r.Array(PairValueRecord, r.uint16);
                var Class2Record = new r.Struct({
                  value1: new ValueRecord("valueFormat1"),
                  value2: new ValueRecord("valueFormat2")
                });
                var Anchor = new r.VersionedStruct(r.uint16, {
                  1: {
                    // Design units only
                    xCoordinate: r.int16,
                    yCoordinate: r.int16
                  },
                  2: {
                    // Design units plus contour point
                    xCoordinate: r.int16,
                    yCoordinate: r.int16,
                    anchorPoint: r.uint16
                  },
                  3: {
                    // Design units plus Device tables
                    xCoordinate: r.int16,
                    yCoordinate: r.int16,
                    xDeviceTable: new r.Pointer(r.uint16, Device),
                    yDeviceTable: new r.Pointer(r.uint16, Device)
                  }
                });
                var EntryExitRecord = new r.Struct({
                  entryAnchor: new r.Pointer(r.uint16, Anchor, {
                    type: "parent"
                  }),
                  exitAnchor: new r.Pointer(r.uint16, Anchor, {
                    type: "parent"
                  })
                });
                var MarkRecord = new r.Struct({
                  class: r.uint16,
                  markAnchor: new r.Pointer(r.uint16, Anchor, {
                    type: "parent"
                  })
                });
                var MarkArray = new r.Array(MarkRecord, r.uint16);
                var BaseRecord = new r.Array(new r.Pointer(r.uint16, Anchor), function(t2) {
                  return t2.parent.classCount;
                });
                var BaseArray = new r.Array(BaseRecord, r.uint16);
                var ComponentRecord = new r.Array(new r.Pointer(r.uint16, Anchor), function(t2) {
                  return t2.parent.parent.classCount;
                });
                var LigatureAttach = new r.Array(ComponentRecord, r.uint16);
                var LigatureArray = new r.Array(new r.Pointer(r.uint16, LigatureAttach), r.uint16);
                var GPOSLookup = new r.VersionedStruct("lookupType", {
                  1: new r.VersionedStruct(r.uint16, {
                    // Single Adjustment
                    1: {
                      // Single positioning value
                      coverage: new r.Pointer(r.uint16, Coverage),
                      valueFormat: ValueFormat,
                      value: new ValueRecord()
                    },
                    2: {
                      coverage: new r.Pointer(r.uint16, Coverage),
                      valueFormat: ValueFormat,
                      valueCount: r.uint16,
                      values: new r.LazyArray(new ValueRecord(), "valueCount")
                    }
                  }),
                  2: new r.VersionedStruct(r.uint16, {
                    // Pair Adjustment Positioning
                    1: {
                      // Adjustments for glyph pairs
                      coverage: new r.Pointer(r.uint16, Coverage),
                      valueFormat1: ValueFormat,
                      valueFormat2: ValueFormat,
                      pairSetCount: r.uint16,
                      pairSets: new r.LazyArray(new r.Pointer(r.uint16, PairSet), "pairSetCount")
                    },
                    2: {
                      // Class pair adjustment
                      coverage: new r.Pointer(r.uint16, Coverage),
                      valueFormat1: ValueFormat,
                      valueFormat2: ValueFormat,
                      classDef1: new r.Pointer(r.uint16, ClassDef),
                      classDef2: new r.Pointer(r.uint16, ClassDef),
                      class1Count: r.uint16,
                      class2Count: r.uint16,
                      classRecords: new r.LazyArray(new r.LazyArray(Class2Record, "class2Count"), "class1Count")
                    }
                  }),
                  3: {
                    // Cursive Attachment Positioning
                    format: r.uint16,
                    coverage: new r.Pointer(r.uint16, Coverage),
                    entryExitCount: r.uint16,
                    entryExitRecords: new r.Array(EntryExitRecord, "entryExitCount")
                  },
                  4: {
                    // MarkToBase Attachment Positioning
                    format: r.uint16,
                    markCoverage: new r.Pointer(r.uint16, Coverage),
                    baseCoverage: new r.Pointer(r.uint16, Coverage),
                    classCount: r.uint16,
                    markArray: new r.Pointer(r.uint16, MarkArray),
                    baseArray: new r.Pointer(r.uint16, BaseArray)
                  },
                  5: {
                    // MarkToLigature Attachment Positioning
                    format: r.uint16,
                    markCoverage: new r.Pointer(r.uint16, Coverage),
                    ligatureCoverage: new r.Pointer(r.uint16, Coverage),
                    classCount: r.uint16,
                    markArray: new r.Pointer(r.uint16, MarkArray),
                    ligatureArray: new r.Pointer(r.uint16, LigatureArray)
                  },
                  6: {
                    // MarkToMark Attachment Positioning
                    format: r.uint16,
                    mark1Coverage: new r.Pointer(r.uint16, Coverage),
                    mark2Coverage: new r.Pointer(r.uint16, Coverage),
                    classCount: r.uint16,
                    mark1Array: new r.Pointer(r.uint16, MarkArray),
                    mark2Array: new r.Pointer(r.uint16, BaseArray)
                  },
                  7: Context,
                  // Contextual positioning
                  8: ChainingContext,
                  // Chaining contextual positioning
                  9: {
                    // Extension Positioning
                    posFormat: r.uint16,
                    lookupType: r.uint16,
                    // cannot also be 9
                    extension: new r.Pointer(r.uint32, GPOSLookup)
                  }
                });
                GPOSLookup.versions[9].extension.type = GPOSLookup;
                var GPOS = new r.VersionedStruct(r.uint32, {
                  header: {
                    scriptList: new r.Pointer(r.uint16, ScriptList),
                    featureList: new r.Pointer(r.uint16, FeatureList),
                    lookupList: new r.Pointer(r.uint16, new LookupList(GPOSLookup))
                  },
                  65536: {},
                  65537: {
                    featureVariations: new r.Pointer(r.uint32, FeatureVariations)
                  }
                });
                var Sequence = new r.Array(r.uint16, r.uint16);
                var AlternateSet = Sequence;
                var Ligature = new r.Struct({
                  glyph: r.uint16,
                  compCount: r.uint16,
                  components: new r.Array(r.uint16, function(t2) {
                    return t2.compCount - 1;
                  })
                });
                var LigatureSet = new r.Array(new r.Pointer(r.uint16, Ligature), r.uint16);
                var GSUBLookup = new r.VersionedStruct("lookupType", {
                  1: new r.VersionedStruct(r.uint16, {
                    // Single Substitution
                    1: {
                      coverage: new r.Pointer(r.uint16, Coverage),
                      deltaGlyphID: r.int16
                    },
                    2: {
                      coverage: new r.Pointer(r.uint16, Coverage),
                      glyphCount: r.uint16,
                      substitute: new r.LazyArray(r.uint16, "glyphCount")
                    }
                  }),
                  2: {
                    // Multiple Substitution
                    substFormat: r.uint16,
                    coverage: new r.Pointer(r.uint16, Coverage),
                    count: r.uint16,
                    sequences: new r.LazyArray(new r.Pointer(r.uint16, Sequence), "count")
                  },
                  3: {
                    // Alternate Substitution
                    substFormat: r.uint16,
                    coverage: new r.Pointer(r.uint16, Coverage),
                    count: r.uint16,
                    alternateSet: new r.LazyArray(new r.Pointer(r.uint16, AlternateSet), "count")
                  },
                  4: {
                    // Ligature Substitution
                    substFormat: r.uint16,
                    coverage: new r.Pointer(r.uint16, Coverage),
                    count: r.uint16,
                    ligatureSets: new r.LazyArray(new r.Pointer(r.uint16, LigatureSet), "count")
                  },
                  5: Context,
                  // Contextual Substitution
                  6: ChainingContext,
                  // Chaining Contextual Substitution
                  7: {
                    // Extension Substitution
                    substFormat: r.uint16,
                    lookupType: r.uint16,
                    // cannot also be 7
                    extension: new r.Pointer(r.uint32, GSUBLookup)
                  },
                  8: {
                    // Reverse Chaining Contextual Single Substitution
                    substFormat: r.uint16,
                    coverage: new r.Pointer(r.uint16, Coverage),
                    backtrackCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), "backtrackGlyphCount"),
                    lookaheadGlyphCount: r.uint16,
                    lookaheadCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), "lookaheadGlyphCount"),
                    glyphCount: r.uint16,
                    substitutes: new r.Array(r.uint16, "glyphCount")
                  }
                });
                GSUBLookup.versions[7].extension.type = GSUBLookup;
                var GSUB = new r.VersionedStruct(r.uint32, {
                  header: {
                    scriptList: new r.Pointer(r.uint16, ScriptList),
                    featureList: new r.Pointer(r.uint16, FeatureList),
                    lookupList: new r.Pointer(r.uint16, new LookupList(GSUBLookup))
                  },
                  65536: {},
                  65537: {
                    featureVariations: new r.Pointer(r.uint32, FeatureVariations)
                  }
                });
                var JstfGSUBModList = new r.Array(r.uint16, r.uint16);
                var JstfPriority = new r.Struct({
                  shrinkageEnableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),
                  shrinkageDisableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),
                  shrinkageEnableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),
                  shrinkageDisableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),
                  shrinkageJstfMax: new r.Pointer(r.uint16, new LookupList(GPOSLookup)),
                  extensionEnableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),
                  extensionDisableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),
                  extensionEnableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),
                  extensionDisableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),
                  extensionJstfMax: new r.Pointer(r.uint16, new LookupList(GPOSLookup))
                });
                var JstfLangSys = new r.Array(new r.Pointer(r.uint16, JstfPriority), r.uint16);
                var JstfLangSysRecord = new r.Struct({
                  tag: new r.String(4),
                  jstfLangSys: new r.Pointer(r.uint16, JstfLangSys)
                });
                var JstfScript = new r.Struct({
                  extenderGlyphs: new r.Pointer(r.uint16, new r.Array(r.uint16, r.uint16)),
                  // array of glyphs to extend line length
                  defaultLangSys: new r.Pointer(r.uint16, JstfLangSys),
                  langSysCount: r.uint16,
                  langSysRecords: new r.Array(JstfLangSysRecord, "langSysCount")
                });
                var JstfScriptRecord = new r.Struct({
                  tag: new r.String(4),
                  script: new r.Pointer(r.uint16, JstfScript, {
                    type: "parent"
                  })
                });
                var JSTF = new r.Struct({
                  version: r.uint32,
                  // should be 0x00010000
                  scriptCount: r.uint16,
                  scriptList: new r.Array(JstfScriptRecord, "scriptCount")
                });
                var VariableSizeNumber = function() {
                  function VariableSizeNumber2(size) {
                    this._size = size;
                  }
                  var _proto11 = VariableSizeNumber2.prototype;
                  _proto11.decode = function decode(stream, parent) {
                    switch (this.size(0, parent)) {
                      case 1:
                        return stream.readUInt8();
                      case 2:
                        return stream.readUInt16BE();
                      case 3:
                        return stream.readUInt24BE();
                      case 4:
                        return stream.readUInt32BE();
                    }
                  };
                  _proto11.size = function size(val, parent) {
                    return utils.resolveLength(this._size, null, parent);
                  };
                  return VariableSizeNumber2;
                }();
                var MapDataEntry = new r.Struct({
                  entry: new VariableSizeNumber(function(t2) {
                    return ((t2.parent.entryFormat & 48) >> 4) + 1;
                  }),
                  outerIndex: function outerIndex(t2) {
                    return t2.entry >> (t2.parent.entryFormat & 15) + 1;
                  },
                  innerIndex: function innerIndex(t2) {
                    return t2.entry & (1 << (t2.parent.entryFormat & 15) + 1) - 1;
                  }
                });
                var DeltaSetIndexMap = new r.Struct({
                  entryFormat: r.uint16,
                  mapCount: r.uint16,
                  mapData: new r.Array(MapDataEntry, "mapCount")
                });
                var HVAR = new r.Struct({
                  majorVersion: r.uint16,
                  minorVersion: r.uint16,
                  itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore),
                  advanceWidthMapping: new r.Pointer(r.uint32, DeltaSetIndexMap),
                  LSBMapping: new r.Pointer(r.uint32, DeltaSetIndexMap),
                  RSBMapping: new r.Pointer(r.uint32, DeltaSetIndexMap)
                });
                var Signature = new r.Struct({
                  format: r.uint32,
                  length: r.uint32,
                  offset: r.uint32
                });
                var SignatureBlock = new r.Struct({
                  reserved: new r.Reserved(r.uint16, 2),
                  cbSignature: r.uint32,
                  // Length (in bytes) of the PKCS#7 packet in pbSignature
                  signature: new r.Buffer("cbSignature")
                });
                var DSIG = new r.Struct({
                  ulVersion: r.uint32,
                  // Version number of the DSIG table (0x00000001)
                  usNumSigs: r.uint16,
                  // Number of signatures in the table
                  usFlag: r.uint16,
                  // Permission flags
                  signatures: new r.Array(Signature, "usNumSigs"),
                  signatureBlocks: new r.Array(SignatureBlock, "usNumSigs")
                });
                var GaspRange = new r.Struct({
                  rangeMaxPPEM: r.uint16,
                  // Upper limit of range, in ppem
                  rangeGaspBehavior: new r.Bitfield(r.uint16, [
                    // Flags describing desired rasterizer behavior
                    "grayscale",
                    "gridfit",
                    "symmetricSmoothing",
                    "symmetricGridfit"
                    // only in version 1, for ClearType
                  ])
                });
                var gasp = new r.Struct({
                  version: r.uint16,
                  // set to 0
                  numRanges: r.uint16,
                  gaspRanges: new r.Array(GaspRange, "numRanges")
                  // Sorted by ppem
                });
                var DeviceRecord = new r.Struct({
                  pixelSize: r.uint8,
                  maximumWidth: r.uint8,
                  widths: new r.Array(r.uint8, function(t2) {
                    return t2.parent.parent.maxp.numGlyphs;
                  })
                });
                var hdmx = new r.Struct({
                  version: r.uint16,
                  numRecords: r.int16,
                  sizeDeviceRecord: r.int32,
                  records: new r.Array(DeviceRecord, "numRecords")
                });
                var KernPair = new r.Struct({
                  left: r.uint16,
                  right: r.uint16,
                  value: r.int16
                });
                var ClassTable = new r.Struct({
                  firstGlyph: r.uint16,
                  nGlyphs: r.uint16,
                  offsets: new r.Array(r.uint16, "nGlyphs"),
                  max: function max(t2) {
                    return t2.offsets.length && Math.max.apply(Math, t2.offsets);
                  }
                });
                var Kern2Array = new r.Struct({
                  off: function off(t2) {
                    return t2._startOffset - t2.parent.parent._startOffset;
                  },
                  len: function len(t2) {
                    return ((t2.parent.leftTable.max - t2.off) / t2.parent.rowWidth + 1) * (t2.parent.rowWidth / 2);
                  },
                  values: new r.LazyArray(r.int16, "len")
                });
                var KernSubtable = new r.VersionedStruct("format", {
                  0: {
                    nPairs: r.uint16,
                    searchRange: r.uint16,
                    entrySelector: r.uint16,
                    rangeShift: r.uint16,
                    pairs: new r.Array(KernPair, "nPairs")
                  },
                  2: {
                    rowWidth: r.uint16,
                    leftTable: new r.Pointer(r.uint16, ClassTable, {
                      type: "parent"
                    }),
                    rightTable: new r.Pointer(r.uint16, ClassTable, {
                      type: "parent"
                    }),
                    array: new r.Pointer(r.uint16, Kern2Array, {
                      type: "parent"
                    })
                  },
                  3: {
                    glyphCount: r.uint16,
                    kernValueCount: r.uint8,
                    leftClassCount: r.uint8,
                    rightClassCount: r.uint8,
                    flags: r.uint8,
                    kernValue: new r.Array(r.int16, "kernValueCount"),
                    leftClass: new r.Array(r.uint8, "glyphCount"),
                    rightClass: new r.Array(r.uint8, "glyphCount"),
                    kernIndex: new r.Array(r.uint8, function(t2) {
                      return t2.leftClassCount * t2.rightClassCount;
                    })
                  }
                });
                var KernTable = new r.VersionedStruct("version", {
                  0: {
                    // Microsoft uses this format
                    subVersion: r.uint16,
                    // Microsoft has an extra sub-table version number
                    length: r.uint16,
                    // Length of the subtable, in bytes
                    format: r.uint8,
                    // Format of subtable
                    coverage: new r.Bitfield(r.uint8, [
                      "horizontal",
                      // 1 if table has horizontal data, 0 if vertical
                      "minimum",
                      // If set to 1, the table has minimum values. If set to 0, the table has kerning values.
                      "crossStream",
                      // If set to 1, kerning is perpendicular to the flow of the text
                      "override"
                      // If set to 1 the value in this table replaces the accumulated value
                    ]),
                    subtable: KernSubtable,
                    padding: new r.Reserved(r.uint8, function(t2) {
                      return t2.length - t2._currentOffset;
                    })
                  },
                  1: {
                    // Apple uses this format
                    length: r.uint32,
                    coverage: new r.Bitfield(r.uint8, [
                      null,
                      null,
                      null,
                      null,
                      null,
                      "variation",
                      // Set if table has variation kerning values
                      "crossStream",
                      // Set if table has cross-stream kerning values
                      "vertical"
                      // Set if table has vertical kerning values
                    ]),
                    format: r.uint8,
                    tupleIndex: r.uint16,
                    subtable: KernSubtable,
                    padding: new r.Reserved(r.uint8, function(t2) {
                      return t2.length - t2._currentOffset;
                    })
                  }
                });
                var kern = new r.VersionedStruct(r.uint16, {
                  0: {
                    // Microsoft Version
                    nTables: r.uint16,
                    tables: new r.Array(KernTable, "nTables")
                  },
                  1: {
                    // Apple Version
                    reserved: new r.Reserved(r.uint16),
                    // the other half of the version number
                    nTables: r.uint32,
                    tables: new r.Array(KernTable, "nTables")
                  }
                });
                var LTSH = new r.Struct({
                  version: r.uint16,
                  numGlyphs: r.uint16,
                  yPels: new r.Array(r.uint8, "numGlyphs")
                });
                var PCLT = new r.Struct({
                  version: r.uint16,
                  fontNumber: r.uint32,
                  pitch: r.uint16,
                  xHeight: r.uint16,
                  style: r.uint16,
                  typeFamily: r.uint16,
                  capHeight: r.uint16,
                  symbolSet: r.uint16,
                  typeface: new r.String(16),
                  characterComplement: new r.String(8),
                  fileName: new r.String(6),
                  strokeWeight: new r.String(1),
                  widthType: new r.String(1),
                  serifStyle: r.uint8,
                  reserved: new r.Reserved(r.uint8)
                });
                var Ratio = new r.Struct({
                  bCharSet: r.uint8,
                  // Character set
                  xRatio: r.uint8,
                  // Value to use for x-Ratio
                  yStartRatio: r.uint8,
                  // Starting y-Ratio value
                  yEndRatio: r.uint8
                  // Ending y-Ratio value
                });
                var vTable = new r.Struct({
                  yPelHeight: r.uint16,
                  // yPelHeight to which values apply
                  yMax: r.int16,
                  // Maximum value (in pels) for this yPelHeight
                  yMin: r.int16
                  // Minimum value (in pels) for this yPelHeight
                });
                var VdmxGroup = new r.Struct({
                  recs: r.uint16,
                  // Number of height records in this group
                  startsz: r.uint8,
                  // Starting yPelHeight
                  endsz: r.uint8,
                  // Ending yPelHeight
                  entries: new r.Array(vTable, "recs")
                  // The VDMX records
                });
                var VDMX = new r.Struct({
                  version: r.uint16,
                  // Version number (0 or 1)
                  numRecs: r.uint16,
                  // Number of VDMX groups present
                  numRatios: r.uint16,
                  // Number of aspect ratio groupings
                  ratioRanges: new r.Array(Ratio, "numRatios"),
                  // Ratio ranges
                  offsets: new r.Array(r.uint16, "numRatios"),
                  // Offset to the VDMX group for this ratio range
                  groups: new r.Array(VdmxGroup, "numRecs")
                  // The actual VDMX groupings
                });
                var vhea = new r.Struct({
                  version: r.uint16,
                  // Version number of the Vertical Header Table
                  ascent: r.int16,
                  // The vertical typographic ascender for this font
                  descent: r.int16,
                  // The vertical typographic descender for this font
                  lineGap: r.int16,
                  // The vertical typographic line gap for this font
                  advanceHeightMax: r.int16,
                  // The maximum advance height measurement found in the font
                  minTopSideBearing: r.int16,
                  // The minimum top side bearing measurement found in the font
                  minBottomSideBearing: r.int16,
                  // The minimum bottom side bearing measurement found in the font
                  yMaxExtent: r.int16,
                  caretSlopeRise: r.int16,
                  // Caret slope (rise/run)
                  caretSlopeRun: r.int16,
                  caretOffset: r.int16,
                  // Set value equal to 0 for nonslanted fonts
                  reserved: new r.Reserved(r.int16, 4),
                  metricDataFormat: r.int16,
                  // Set to 0
                  numberOfMetrics: r.uint16
                  // Number of advance heights in the Vertical Metrics table
                });
                var VmtxEntry = new r.Struct({
                  advance: r.uint16,
                  // The advance height of the glyph
                  bearing: r.int16
                  // The top sidebearing of the glyph
                });
                var vmtx = new r.Struct({
                  metrics: new r.LazyArray(VmtxEntry, function(t2) {
                    return t2.parent.vhea.numberOfMetrics;
                  }),
                  bearings: new r.LazyArray(r.int16, function(t2) {
                    return t2.parent.maxp.numGlyphs - t2.parent.vhea.numberOfMetrics;
                  })
                });
                var shortFrac = new r.Fixed(16, "BE", 14);
                var Correspondence = new r.Struct({
                  fromCoord: shortFrac,
                  toCoord: shortFrac
                });
                var Segment = new r.Struct({
                  pairCount: r.uint16,
                  correspondence: new r.Array(Correspondence, "pairCount")
                });
                var avar = new r.Struct({
                  version: r.fixed32,
                  axisCount: r.uint32,
                  segment: new r.Array(Segment, "axisCount")
                });
                var UnboundedArrayAccessor = function() {
                  function UnboundedArrayAccessor2(type, stream, parent) {
                    this.type = type;
                    this.stream = stream;
                    this.parent = parent;
                    this.base = this.stream.pos;
                    this._items = [];
                  }
                  var _proto12 = UnboundedArrayAccessor2.prototype;
                  _proto12.getItem = function getItem(index) {
                    if (this._items[index] == null) {
                      var pos = this.stream.pos;
                      this.stream.pos = this.base + this.type.size(null, this.parent) * index;
                      this._items[index] = this.type.decode(this.stream, this.parent);
                      this.stream.pos = pos;
                    }
                    return this._items[index];
                  };
                  _proto12.inspect = function inspect() {
                    return "[UnboundedArray ".concat(this.type.constructor.name, "]");
                  };
                  return UnboundedArrayAccessor2;
                }();
                var UnboundedArray = function(_r$Array2) {
                  _inheritsLoose(UnboundedArray2, _r$Array2);
                  function UnboundedArray2(type) {
                    return _r$Array2.call(this, type, 0) || this;
                  }
                  var _proto13 = UnboundedArray2.prototype;
                  _proto13.decode = function decode(stream, parent) {
                    return new UnboundedArrayAccessor(this.type, stream, parent);
                  };
                  return UnboundedArray2;
                }(r.Array);
                var LookupTable = function LookupTable2(ValueType) {
                  if (ValueType === void 0) {
                    ValueType = r.uint16;
                  }
                  var Shadow = function() {
                    function Shadow2(type) {
                      this.type = type;
                    }
                    var _proto14 = Shadow2.prototype;
                    _proto14.decode = function decode(stream, ctx) {
                      ctx = ctx.parent.parent;
                      return this.type.decode(stream, ctx);
                    };
                    _proto14.size = function size(val, ctx) {
                      ctx = ctx.parent.parent;
                      return this.type.size(val, ctx);
                    };
                    _proto14.encode = function encode(stream, val, ctx) {
                      ctx = ctx.parent.parent;
                      return this.type.encode(stream, val, ctx);
                    };
                    return Shadow2;
                  }();
                  ValueType = new Shadow(ValueType);
                  var BinarySearchHeader = new r.Struct({
                    unitSize: r.uint16,
                    nUnits: r.uint16,
                    searchRange: r.uint16,
                    entrySelector: r.uint16,
                    rangeShift: r.uint16
                  });
                  var LookupSegmentSingle = new r.Struct({
                    lastGlyph: r.uint16,
                    firstGlyph: r.uint16,
                    value: ValueType
                  });
                  var LookupSegmentArray = new r.Struct({
                    lastGlyph: r.uint16,
                    firstGlyph: r.uint16,
                    values: new r.Pointer(r.uint16, new r.Array(ValueType, function(t2) {
                      return t2.lastGlyph - t2.firstGlyph + 1;
                    }), {
                      type: "parent"
                    })
                  });
                  var LookupSingle = new r.Struct({
                    glyph: r.uint16,
                    value: ValueType
                  });
                  return new r.VersionedStruct(r.uint16, {
                    0: {
                      values: new UnboundedArray(ValueType)
                      // length == number of glyphs maybe?
                    },
                    2: {
                      binarySearchHeader: BinarySearchHeader,
                      segments: new r.Array(LookupSegmentSingle, function(t2) {
                        return t2.binarySearchHeader.nUnits;
                      })
                    },
                    4: {
                      binarySearchHeader: BinarySearchHeader,
                      segments: new r.Array(LookupSegmentArray, function(t2) {
                        return t2.binarySearchHeader.nUnits;
                      })
                    },
                    6: {
                      binarySearchHeader: BinarySearchHeader,
                      segments: new r.Array(LookupSingle, function(t2) {
                        return t2.binarySearchHeader.nUnits;
                      })
                    },
                    8: {
                      firstGlyph: r.uint16,
                      count: r.uint16,
                      values: new r.Array(ValueType, "count")
                    }
                  });
                };
                function StateTable(entryData, lookupType) {
                  if (entryData === void 0) {
                    entryData = {};
                  }
                  if (lookupType === void 0) {
                    lookupType = r.uint16;
                  }
                  var entry = Object.assign({
                    newState: r.uint16,
                    flags: r.uint16
                  }, entryData);
                  var Entry = new r.Struct(entry);
                  var StateArray = new UnboundedArray(new r.Array(r.uint16, function(t2) {
                    return t2.nClasses;
                  }));
                  var StateHeader = new r.Struct({
                    nClasses: r.uint32,
                    classTable: new r.Pointer(r.uint32, new LookupTable(lookupType)),
                    stateArray: new r.Pointer(r.uint32, StateArray),
                    entryTable: new r.Pointer(r.uint32, new UnboundedArray(Entry))
                  });
                  return StateHeader;
                }
                function StateTable1(entryData, lookupType) {
                  if (entryData === void 0) {
                    entryData = {};
                  }
                  if (lookupType === void 0) {
                    lookupType = r.uint16;
                  }
                  var ClassLookupTable = new r.Struct({
                    version: function version() {
                      return 8;
                    },
                    // simulate LookupTable
                    firstGlyph: r.uint16,
                    values: new r.Array(r.uint8, r.uint16)
                  });
                  var entry = Object.assign({
                    newStateOffset: r.uint16,
                    // convert offset to stateArray index
                    newState: function newState(t2) {
                      return (t2.newStateOffset - (t2.parent.stateArray.base - t2.parent._startOffset)) / t2.parent.nClasses;
                    },
                    flags: r.uint16
                  }, entryData);
                  var Entry = new r.Struct(entry);
                  var StateArray = new UnboundedArray(new r.Array(r.uint8, function(t2) {
                    return t2.nClasses;
                  }));
                  var StateHeader1 = new r.Struct({
                    nClasses: r.uint16,
                    classTable: new r.Pointer(r.uint16, ClassLookupTable),
                    stateArray: new r.Pointer(r.uint16, StateArray),
                    entryTable: new r.Pointer(r.uint16, new UnboundedArray(Entry))
                  });
                  return StateHeader1;
                }
                var BslnSubtable = new r.VersionedStruct("format", {
                  0: {
                    // Distance-based, no mapping
                    deltas: new r.Array(r.int16, 32)
                  },
                  1: {
                    // Distance-based, with mapping
                    deltas: new r.Array(r.int16, 32),
                    mappingData: new LookupTable(r.uint16)
                  },
                  2: {
                    // Control point-based, no mapping
                    standardGlyph: r.uint16,
                    controlPoints: new r.Array(r.uint16, 32)
                  },
                  3: {
                    // Control point-based, with mapping
                    standardGlyph: r.uint16,
                    controlPoints: new r.Array(r.uint16, 32),
                    mappingData: new LookupTable(r.uint16)
                  }
                });
                var bsln = new r.Struct({
                  version: r.fixed32,
                  format: r.uint16,
                  defaultBaseline: r.uint16,
                  subtable: BslnSubtable
                });
                var Setting = new r.Struct({
                  setting: r.uint16,
                  nameIndex: r.int16,
                  name: function name(t2) {
                    return t2.parent.parent.parent.name.records.fontFeatures[t2.nameIndex];
                  }
                });
                var FeatureName = new r.Struct({
                  feature: r.uint16,
                  nSettings: r.uint16,
                  settingTable: new r.Pointer(r.uint32, new r.Array(Setting, "nSettings"), {
                    type: "parent"
                  }),
                  featureFlags: new r.Bitfield(r.uint8, [null, null, null, null, null, null, "hasDefault", "exclusive"]),
                  defaultSetting: r.uint8,
                  nameIndex: r.int16,
                  name: function name(t2) {
                    return t2.parent.parent.name.records.fontFeatures[t2.nameIndex];
                  }
                });
                var feat = new r.Struct({
                  version: r.fixed32,
                  featureNameCount: r.uint16,
                  reserved1: new r.Reserved(r.uint16),
                  reserved2: new r.Reserved(r.uint32),
                  featureNames: new r.Array(FeatureName, "featureNameCount")
                });
                var Axis$1 = new r.Struct({
                  axisTag: new r.String(4),
                  minValue: r.fixed32,
                  defaultValue: r.fixed32,
                  maxValue: r.fixed32,
                  flags: r.uint16,
                  nameID: r.uint16,
                  name: function name(t2) {
                    return t2.parent.parent.name.records.fontFeatures[t2.nameID];
                  }
                });
                var Instance = new r.Struct({
                  nameID: r.uint16,
                  name: function name(t2) {
                    return t2.parent.parent.name.records.fontFeatures[t2.nameID];
                  },
                  flags: r.uint16,
                  coord: new r.Array(r.fixed32, function(t2) {
                    return t2.parent.axisCount;
                  }),
                  postscriptNameID: new r.Optional(r.uint16, function(t2) {
                    return t2.parent.instanceSize - t2._currentOffset > 0;
                  })
                });
                var fvar = new r.Struct({
                  version: r.fixed32,
                  offsetToData: r.uint16,
                  countSizePairs: r.uint16,
                  axisCount: r.uint16,
                  axisSize: r.uint16,
                  instanceCount: r.uint16,
                  instanceSize: r.uint16,
                  axis: new r.Array(Axis$1, "axisCount"),
                  instance: new r.Array(Instance, "instanceCount")
                });
                var shortFrac$1 = new r.Fixed(16, "BE", 14);
                var Offset = function() {
                  function Offset2() {
                  }
                  Offset2.decode = function decode(stream, parent) {
                    return parent.flags ? stream.readUInt32BE() : stream.readUInt16BE() * 2;
                  };
                  return Offset2;
                }();
                var gvar = new r.Struct({
                  version: r.uint16,
                  reserved: new r.Reserved(r.uint16),
                  axisCount: r.uint16,
                  globalCoordCount: r.uint16,
                  globalCoords: new r.Pointer(r.uint32, new r.Array(new r.Array(shortFrac$1, "axisCount"), "globalCoordCount")),
                  glyphCount: r.uint16,
                  flags: r.uint16,
                  offsetToData: r.uint32,
                  offsets: new r.Array(new r.Pointer(Offset, "void", {
                    relativeTo: function relativeTo(ctx) {
                      return ctx.offsetToData;
                    },
                    allowNull: false
                  }), function(t2) {
                    return t2.glyphCount + 1;
                  })
                });
                var ClassTable$1 = new r.Struct({
                  length: r.uint16,
                  coverage: r.uint16,
                  subFeatureFlags: r.uint32,
                  stateTable: new StateTable1()
                });
                var WidthDeltaRecord = new r.Struct({
                  justClass: r.uint32,
                  beforeGrowLimit: r.fixed32,
                  beforeShrinkLimit: r.fixed32,
                  afterGrowLimit: r.fixed32,
                  afterShrinkLimit: r.fixed32,
                  growFlags: r.uint16,
                  shrinkFlags: r.uint16
                });
                var WidthDeltaCluster = new r.Array(WidthDeltaRecord, r.uint32);
                var ActionData = new r.VersionedStruct("actionType", {
                  0: {
                    // Decomposition action
                    lowerLimit: r.fixed32,
                    upperLimit: r.fixed32,
                    order: r.uint16,
                    glyphs: new r.Array(r.uint16, r.uint16)
                  },
                  1: {
                    // Unconditional add glyph action
                    addGlyph: r.uint16
                  },
                  2: {
                    // Conditional add glyph action
                    substThreshold: r.fixed32,
                    addGlyph: r.uint16,
                    substGlyph: r.uint16
                  },
                  3: {},
                  // Stretch glyph action (no data, not supported by CoreText)
                  4: {
                    // Ductile glyph action (not supported by CoreText)
                    variationAxis: r.uint32,
                    minimumLimit: r.fixed32,
                    noStretchValue: r.fixed32,
                    maximumLimit: r.fixed32
                  },
                  5: {
                    // Repeated add glyph action
                    flags: r.uint16,
                    glyph: r.uint16
                  }
                });
                var Action = new r.Struct({
                  actionClass: r.uint16,
                  actionType: r.uint16,
                  actionLength: r.uint32,
                  actionData: ActionData,
                  padding: new r.Reserved(r.uint8, function(t2) {
                    return t2.actionLength - t2._currentOffset;
                  })
                });
                var PostcompensationAction = new r.Array(Action, r.uint32);
                var PostCompensationTable = new r.Struct({
                  lookupTable: new LookupTable(new r.Pointer(r.uint16, PostcompensationAction))
                });
                var JustificationTable = new r.Struct({
                  classTable: new r.Pointer(r.uint16, ClassTable$1, {
                    type: "parent"
                  }),
                  wdcOffset: r.uint16,
                  postCompensationTable: new r.Pointer(r.uint16, PostCompensationTable, {
                    type: "parent"
                  }),
                  widthDeltaClusters: new LookupTable(new r.Pointer(r.uint16, WidthDeltaCluster, {
                    type: "parent",
                    relativeTo: function relativeTo(ctx) {
                      return ctx.wdcOffset;
                    }
                  }))
                });
                var just = new r.Struct({
                  version: r.uint32,
                  format: r.uint16,
                  horizontal: new r.Pointer(r.uint16, JustificationTable),
                  vertical: new r.Pointer(r.uint16, JustificationTable)
                });
                var LigatureData = {
                  action: r.uint16
                };
                var ContextualData = {
                  markIndex: r.uint16,
                  currentIndex: r.uint16
                };
                var InsertionData = {
                  currentInsertIndex: r.uint16,
                  markedInsertIndex: r.uint16
                };
                var SubstitutionTable = new r.Struct({
                  items: new UnboundedArray(new r.Pointer(r.uint32, new LookupTable()))
                });
                var SubtableData = new r.VersionedStruct("type", {
                  0: {
                    // Indic Rearrangement Subtable
                    stateTable: new StateTable()
                  },
                  1: {
                    // Contextual Glyph Substitution Subtable
                    stateTable: new StateTable(ContextualData),
                    substitutionTable: new r.Pointer(r.uint32, SubstitutionTable)
                  },
                  2: {
                    // Ligature subtable
                    stateTable: new StateTable(LigatureData),
                    ligatureActions: new r.Pointer(r.uint32, new UnboundedArray(r.uint32)),
                    components: new r.Pointer(r.uint32, new UnboundedArray(r.uint16)),
                    ligatureList: new r.Pointer(r.uint32, new UnboundedArray(r.uint16))
                  },
                  4: {
                    // Non-contextual Glyph Substitution Subtable
                    lookupTable: new LookupTable()
                  },
                  5: {
                    // Glyph Insertion Subtable
                    stateTable: new StateTable(InsertionData),
                    insertionActions: new r.Pointer(r.uint32, new UnboundedArray(r.uint16))
                  }
                });
                var Subtable = new r.Struct({
                  length: r.uint32,
                  coverage: r.uint24,
                  type: r.uint8,
                  subFeatureFlags: r.uint32,
                  table: SubtableData,
                  padding: new r.Reserved(r.uint8, function(t2) {
                    return t2.length - t2._currentOffset;
                  })
                });
                var FeatureEntry = new r.Struct({
                  featureType: r.uint16,
                  featureSetting: r.uint16,
                  enableFlags: r.uint32,
                  disableFlags: r.uint32
                });
                var MorxChain = new r.Struct({
                  defaultFlags: r.uint32,
                  chainLength: r.uint32,
                  nFeatureEntries: r.uint32,
                  nSubtables: r.uint32,
                  features: new r.Array(FeatureEntry, "nFeatureEntries"),
                  subtables: new r.Array(Subtable, "nSubtables")
                });
                var morx = new r.Struct({
                  version: r.uint16,
                  unused: new r.Reserved(r.uint16),
                  nChains: r.uint32,
                  chains: new r.Array(MorxChain, "nChains")
                });
                var OpticalBounds = new r.Struct({
                  left: r.int16,
                  top: r.int16,
                  right: r.int16,
                  bottom: r.int16
                });
                var opbd = new r.Struct({
                  version: r.fixed32,
                  format: r.uint16,
                  lookupTable: new LookupTable(OpticalBounds)
                });
                var tables = {};
                tables.cmap = cmap;
                tables.head = head;
                tables.hhea = hhea;
                tables.hmtx = hmtx;
                tables.maxp = maxp;
                tables.name = NameTable;
                tables["OS/2"] = OS2;
                tables.post = post;
                tables.fpgm = fpgm;
                tables.loca = loca;
                tables.prep = prep;
                tables["cvt "] = cvt;
                tables.glyf = glyf;
                tables["CFF "] = CFFFont;
                tables["CFF2"] = CFFFont;
                tables.VORG = VORG;
                tables.EBLC = EBLC;
                tables.CBLC = tables.EBLC;
                tables.sbix = sbix;
                tables.COLR = COLR;
                tables.CPAL = CPAL;
                tables.BASE = BASE;
                tables.GDEF = GDEF;
                tables.GPOS = GPOS;
                tables.GSUB = GSUB;
                tables.JSTF = JSTF;
                tables.HVAR = HVAR;
                tables.DSIG = DSIG;
                tables.gasp = gasp;
                tables.hdmx = hdmx;
                tables.kern = kern;
                tables.LTSH = LTSH;
                tables.PCLT = PCLT;
                tables.VDMX = VDMX;
                tables.vhea = vhea;
                tables.vmtx = vmtx;
                tables.avar = avar;
                tables.bsln = bsln;
                tables.feat = feat;
                tables.fvar = fvar;
                tables.gvar = gvar;
                tables.just = just;
                tables.morx = morx;
                tables.opbd = opbd;
                var TableEntry = new r.Struct({
                  tag: new r.String(4),
                  checkSum: r.uint32,
                  offset: new r.Pointer(r.uint32, "void", {
                    type: "global"
                  }),
                  length: r.uint32
                });
                var Directory = new r.Struct({
                  tag: new r.String(4),
                  numTables: r.uint16,
                  searchRange: r.uint16,
                  entrySelector: r.uint16,
                  rangeShift: r.uint16,
                  tables: new r.Array(TableEntry, "numTables")
                });
                Directory.process = function() {
                  var tables2 = {};
                  for (var _iterator9 = _createForOfIteratorHelperLoose(this.tables), _step9; !(_step9 = _iterator9()).done; ) {
                    var table = _step9.value;
                    tables2[table.tag] = table;
                  }
                  this.tables = tables2;
                };
                Directory.preEncode = function(stream) {
                  var tables$1 = [];
                  for (var tag2 in this.tables) {
                    var table = this.tables[tag2];
                    if (table) {
                      tables$1.push({
                        tag: tag2,
                        checkSum: 0,
                        offset: new r.VoidPointer(tables[tag2], table),
                        length: tables[tag2].size(table)
                      });
                    }
                  }
                  this.tag = "true";
                  this.numTables = tables$1.length;
                  this.tables = tables$1;
                  var maxExponentFor2 = Math.floor(Math.log(this.numTables) / Math.LN2);
                  var maxPowerOf2 = Math.pow(2, maxExponentFor2);
                  this.searchRange = maxPowerOf2 * 16;
                  this.entrySelector = Math.log(maxPowerOf2) / Math.LN2;
                  this.rangeShift = this.numTables * 16 - this.searchRange;
                };
                function binarySearch(arr, cmp) {
                  var min = 0;
                  var max = arr.length - 1;
                  while (min <= max) {
                    var mid = min + max >> 1;
                    var res = cmp(arr[mid]);
                    if (res < 0) {
                      max = mid - 1;
                    } else if (res > 0) {
                      min = mid + 1;
                    } else {
                      return mid;
                    }
                  }
                  return -1;
                }
                function range(index, end) {
                  var range2 = [];
                  while (index < end) {
                    range2.push(index++);
                  }
                  return range2;
                }
                var _class;
                try {
                  var iconv = __webpack_require__2(4914);
                } catch (err) {
                }
                var CmapProcessor = (_class = function() {
                  function CmapProcessor2(cmapTable) {
                    this.encoding = null;
                    this.cmap = this.findSubtable(cmapTable, [
                      // 32-bit subtables
                      [3, 10],
                      [0, 6],
                      [0, 4],
                      // 16-bit subtables
                      [3, 1],
                      [0, 3],
                      [0, 2],
                      [0, 1],
                      [0, 0]
                    ]);
                    if (!this.cmap && iconv) {
                      for (var _iterator10 = _createForOfIteratorHelperLoose(cmapTable.tables), _step10; !(_step10 = _iterator10()).done; ) {
                        var cmap2 = _step10.value;
                        var encoding = getEncoding(cmap2.platformID, cmap2.encodingID, cmap2.table.language - 1);
                        if (iconv.encodingExists(encoding)) {
                          this.cmap = cmap2.table;
                          this.encoding = encoding;
                        }
                      }
                    }
                    if (!this.cmap) {
                      throw new Error("Could not find a supported cmap table");
                    }
                    this.uvs = this.findSubtable(cmapTable, [[0, 5]]);
                    if (this.uvs && this.uvs.version !== 14) {
                      this.uvs = null;
                    }
                  }
                  var _proto15 = CmapProcessor2.prototype;
                  _proto15.findSubtable = function findSubtable(cmapTable, pairs) {
                    for (var _iterator11 = _createForOfIteratorHelperLoose(pairs), _step11; !(_step11 = _iterator11()).done; ) {
                      var _step11$value = _step11.value, platformID = _step11$value[0], encodingID = _step11$value[1];
                      for (var _iterator12 = _createForOfIteratorHelperLoose(cmapTable.tables), _step12; !(_step12 = _iterator12()).done; ) {
                        var cmap2 = _step12.value;
                        if (cmap2.platformID === platformID && cmap2.encodingID === encodingID) {
                          return cmap2.table;
                        }
                      }
                    }
                    return null;
                  };
                  _proto15.lookup = function lookup(codepoint, variationSelector) {
                    if (this.encoding) {
                      var buf = iconv.encode(String.fromCodePoint(codepoint), this.encoding);
                      codepoint = 0;
                      for (var i2 = 0; i2 < buf.length; i2++) {
                        codepoint = codepoint << 8 | buf[i2];
                      }
                    } else if (variationSelector) {
                      var gid = this.getVariationSelector(codepoint, variationSelector);
                      if (gid) {
                        return gid;
                      }
                    }
                    var cmap2 = this.cmap;
                    switch (cmap2.version) {
                      case 0:
                        return cmap2.codeMap.get(codepoint) || 0;
                      case 4: {
                        var min = 0;
                        var max = cmap2.segCount - 1;
                        while (min <= max) {
                          var mid = min + max >> 1;
                          if (codepoint < cmap2.startCode.get(mid)) {
                            max = mid - 1;
                          } else if (codepoint > cmap2.endCode.get(mid)) {
                            min = mid + 1;
                          } else {
                            var rangeOffset = cmap2.idRangeOffset.get(mid);
                            var _gid = void 0;
                            if (rangeOffset === 0) {
                              _gid = codepoint + cmap2.idDelta.get(mid);
                            } else {
                              var index = rangeOffset / 2 + (codepoint - cmap2.startCode.get(mid)) - (cmap2.segCount - mid);
                              _gid = cmap2.glyphIndexArray.get(index) || 0;
                              if (_gid !== 0) {
                                _gid += cmap2.idDelta.get(mid);
                              }
                            }
                            return _gid & 65535;
                          }
                        }
                        return 0;
                      }
                      case 8:
                        throw new Error("TODO: cmap format 8");
                      case 6:
                      case 10:
                        return cmap2.glyphIndices.get(codepoint - cmap2.firstCode) || 0;
                      case 12:
                      case 13: {
                        var _min = 0;
                        var _max = cmap2.nGroups - 1;
                        while (_min <= _max) {
                          var _mid = _min + _max >> 1;
                          var group = cmap2.groups.get(_mid);
                          if (codepoint < group.startCharCode) {
                            _max = _mid - 1;
                          } else if (codepoint > group.endCharCode) {
                            _min = _mid + 1;
                          } else {
                            if (cmap2.version === 12) {
                              return group.glyphID + (codepoint - group.startCharCode);
                            } else {
                              return group.glyphID;
                            }
                          }
                        }
                        return 0;
                      }
                      case 14:
                        throw new Error("TODO: cmap format 14");
                      default:
                        throw new Error("Unknown cmap format ".concat(cmap2.version));
                    }
                  };
                  _proto15.getVariationSelector = function getVariationSelector(codepoint, variationSelector) {
                    if (!this.uvs) {
                      return 0;
                    }
                    var selectors = this.uvs.varSelectors.toArray();
                    var i2 = binarySearch(selectors, function(x) {
                      return variationSelector - x.varSelector;
                    });
                    var sel = selectors[i2];
                    if (i2 !== -1 && sel.defaultUVS) {
                      i2 = binarySearch(sel.defaultUVS, function(x) {
                        return codepoint < x.startUnicodeValue ? -1 : codepoint > x.startUnicodeValue + x.additionalCount ? 1 : 0;
                      });
                    }
                    if (i2 !== -1 && sel.nonDefaultUVS) {
                      i2 = binarySearch(sel.nonDefaultUVS, function(x) {
                        return codepoint - x.unicodeValue;
                      });
                      if (i2 !== -1) {
                        return sel.nonDefaultUVS[i2].glyphID;
                      }
                    }
                    return 0;
                  };
                  _proto15.getCharacterSet = function getCharacterSet() {
                    var cmap2 = this.cmap;
                    switch (cmap2.version) {
                      case 0:
                        return range(0, cmap2.codeMap.length);
                      case 4: {
                        var res = [];
                        var endCodes = cmap2.endCode.toArray();
                        for (var i2 = 0; i2 < endCodes.length; i2++) {
                          var tail = endCodes[i2] + 1;
                          var start = cmap2.startCode.get(i2);
                          res.push.apply(res, range(start, tail));
                        }
                        return res;
                      }
                      case 8:
                        throw new Error("TODO: cmap format 8");
                      case 6:
                      case 10:
                        return range(cmap2.firstCode, cmap2.firstCode + cmap2.glyphIndices.length);
                      case 12:
                      case 13: {
                        var _res = [];
                        for (var _iterator13 = _createForOfIteratorHelperLoose(cmap2.groups.toArray()), _step13; !(_step13 = _iterator13()).done; ) {
                          var group = _step13.value;
                          _res.push.apply(_res, range(group.startCharCode, group.endCharCode + 1));
                        }
                        return _res;
                      }
                      case 14:
                        throw new Error("TODO: cmap format 14");
                      default:
                        throw new Error("Unknown cmap format ".concat(cmap2.version));
                    }
                  };
                  _proto15.codePointsForGlyph = function codePointsForGlyph(gid) {
                    var cmap2 = this.cmap;
                    switch (cmap2.version) {
                      case 0: {
                        var res = [];
                        for (var i2 = 0; i2 < 256; i2++) {
                          if (cmap2.codeMap.get(i2) === gid) {
                            res.push(i2);
                          }
                        }
                        return res;
                      }
                      case 4: {
                        var _res2 = [];
                        for (var _i = 0; _i < cmap2.segCount; _i++) {
                          var end = cmap2.endCode.get(_i);
                          var start = cmap2.startCode.get(_i);
                          var rangeOffset = cmap2.idRangeOffset.get(_i);
                          var delta = cmap2.idDelta.get(_i);
                          for (var c = start; c <= end; c++) {
                            var g = 0;
                            if (rangeOffset === 0) {
                              g = c + delta;
                            } else {
                              var index = rangeOffset / 2 + (c - start) - (cmap2.segCount - _i);
                              g = cmap2.glyphIndexArray.get(index) || 0;
                              if (g !== 0) {
                                g += delta;
                              }
                            }
                            if (g === gid) {
                              _res2.push(c);
                            }
                          }
                        }
                        return _res2;
                      }
                      case 12: {
                        var _res3 = [];
                        for (var _iterator14 = _createForOfIteratorHelperLoose(cmap2.groups.toArray()), _step14; !(_step14 = _iterator14()).done; ) {
                          var group = _step14.value;
                          if (gid >= group.glyphID && gid <= group.glyphID + (group.endCharCode - group.startCharCode)) {
                            _res3.push(group.startCharCode + (gid - group.glyphID));
                          }
                        }
                        return _res3;
                      }
                      case 13: {
                        var _res4 = [];
                        for (var _iterator15 = _createForOfIteratorHelperLoose(cmap2.groups.toArray()), _step15; !(_step15 = _iterator15()).done; ) {
                          var _group = _step15.value;
                          if (gid === _group.glyphID) {
                            _res4.push.apply(_res4, range(_group.startCharCode, _group.endCharCode + 1));
                          }
                        }
                        return _res4;
                      }
                      default:
                        throw new Error("Unknown cmap format ".concat(cmap2.version));
                    }
                  };
                  return CmapProcessor2;
                }(), _applyDecoratedDescriptor(_class.prototype, "getCharacterSet", [cache], Object.getOwnPropertyDescriptor(_class.prototype, "getCharacterSet"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "codePointsForGlyph", [cache], Object.getOwnPropertyDescriptor(_class.prototype, "codePointsForGlyph"), _class.prototype), _class);
                var KernProcessor = function() {
                  function KernProcessor2(font) {
                    this.kern = font.kern;
                  }
                  var _proto16 = KernProcessor2.prototype;
                  _proto16.process = function process(glyphs, positions) {
                    for (var glyphIndex = 0; glyphIndex < glyphs.length - 1; glyphIndex++) {
                      var left = glyphs[glyphIndex].id;
                      var right = glyphs[glyphIndex + 1].id;
                      positions[glyphIndex].xAdvance += this.getKerning(left, right);
                    }
                  };
                  _proto16.getKerning = function getKerning(left, right) {
                    var res = 0;
                    for (var _iterator16 = _createForOfIteratorHelperLoose(this.kern.tables), _step16; !(_step16 = _iterator16()).done; ) {
                      var table = _step16.value;
                      if (table.coverage.crossStream) {
                        continue;
                      }
                      switch (table.version) {
                        case 0:
                          if (!table.coverage.horizontal) {
                            continue;
                          }
                          break;
                        case 1:
                          if (table.coverage.vertical || table.coverage.variation) {
                            continue;
                          }
                          break;
                        default:
                          throw new Error("Unsupported kerning table version ".concat(table.version));
                      }
                      var val = 0;
                      var s = table.subtable;
                      switch (table.format) {
                        case 0:
                          var pairIdx = binarySearch(s.pairs, function(pair) {
                            return left - pair.left || right - pair.right;
                          });
                          if (pairIdx >= 0) {
                            val = s.pairs[pairIdx].value;
                          }
                          break;
                        case 2:
                          var leftOffset = 0, rightOffset = 0;
                          if (left >= s.leftTable.firstGlyph && left < s.leftTable.firstGlyph + s.leftTable.nGlyphs) {
                            leftOffset = s.leftTable.offsets[left - s.leftTable.firstGlyph];
                          } else {
                            leftOffset = s.array.off;
                          }
                          if (right >= s.rightTable.firstGlyph && right < s.rightTable.firstGlyph + s.rightTable.nGlyphs) {
                            rightOffset = s.rightTable.offsets[right - s.rightTable.firstGlyph];
                          }
                          var index = (leftOffset + rightOffset - s.array.off) / 2;
                          val = s.array.values.get(index);
                          break;
                        case 3:
                          if (left >= s.glyphCount || right >= s.glyphCount) {
                            return 0;
                          }
                          val = s.kernValue[s.kernIndex[s.leftClass[left] * s.rightClassCount + s.rightClass[right]]];
                          break;
                        default:
                          throw new Error("Unsupported kerning sub-table format ".concat(table.format));
                      }
                      if (table.coverage.override) {
                        res = val;
                      } else {
                        res += val;
                      }
                    }
                    return res;
                  };
                  return KernProcessor2;
                }();
                var UnicodeLayoutEngine = function() {
                  function UnicodeLayoutEngine2(font) {
                    this.font = font;
                  }
                  var _proto17 = UnicodeLayoutEngine2.prototype;
                  _proto17.positionGlyphs = function positionGlyphs(glyphs, positions) {
                    var clusterStart = 0;
                    var clusterEnd = 0;
                    for (var index = 0; index < glyphs.length; index++) {
                      var glyph2 = glyphs[index];
                      if (glyph2.isMark) {
                        clusterEnd = index;
                      } else {
                        if (clusterStart !== clusterEnd) {
                          this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
                        }
                        clusterStart = clusterEnd = index;
                      }
                    }
                    if (clusterStart !== clusterEnd) {
                      this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
                    }
                    return positions;
                  };
                  _proto17.positionCluster = function positionCluster(glyphs, positions, clusterStart, clusterEnd) {
                    var base = glyphs[clusterStart];
                    var baseBox = base.cbox.copy();
                    if (base.codePoints.length > 1) {
                      baseBox.minX += (base.codePoints.length - 1) * baseBox.width / base.codePoints.length;
                    }
                    var xOffset = -positions[clusterStart].xAdvance;
                    var yOffset = 0;
                    var yGap = this.font.unitsPerEm / 16;
                    for (var index = clusterStart + 1; index <= clusterEnd; index++) {
                      var mark = glyphs[index];
                      var markBox = mark.cbox;
                      var position = positions[index];
                      var combiningClass = this.getCombiningClass(mark.codePoints[0]);
                      if (combiningClass !== "Not_Reordered") {
                        position.xOffset = position.yOffset = 0;
                        switch (combiningClass) {
                          case "Double_Above":
                          case "Double_Below":
                            position.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;
                            break;
                          case "Attached_Below_Left":
                          case "Below_Left":
                          case "Above_Left":
                            position.xOffset += baseBox.minX - markBox.minX;
                            break;
                          case "Attached_Above_Right":
                          case "Below_Right":
                          case "Above_Right":
                            position.xOffset += baseBox.maxX - markBox.width - markBox.minX;
                            break;
                          default:
                            position.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX;
                        }
                        switch (combiningClass) {
                          case "Double_Below":
                          case "Below_Left":
                          case "Below":
                          case "Below_Right":
                          case "Attached_Below_Left":
                          case "Attached_Below":
                            if (combiningClass === "Attached_Below_Left" || combiningClass === "Attached_Below") {
                              baseBox.minY += yGap;
                            }
                            position.yOffset = -baseBox.minY - markBox.maxY;
                            baseBox.minY += markBox.height;
                            break;
                          case "Double_Above":
                          case "Above_Left":
                          case "Above":
                          case "Above_Right":
                          case "Attached_Above":
                          case "Attached_Above_Right":
                            if (combiningClass === "Attached_Above" || combiningClass === "Attached_Above_Right") {
                              baseBox.maxY += yGap;
                            }
                            position.yOffset = baseBox.maxY - markBox.minY;
                            baseBox.maxY += markBox.height;
                            break;
                        }
                        position.xAdvance = position.yAdvance = 0;
                        position.xOffset += xOffset;
                        position.yOffset += yOffset;
                      } else {
                        xOffset -= position.xAdvance;
                        yOffset -= position.yAdvance;
                      }
                    }
                    return;
                  };
                  _proto17.getCombiningClass = function getCombiningClass(codePoint) {
                    var combiningClass = unicode.getCombiningClass(codePoint);
                    if ((codePoint & ~255) === 3584) {
                      if (combiningClass === "Not_Reordered") {
                        switch (codePoint) {
                          case 3633:
                          case 3636:
                          case 3637:
                          case 3638:
                          case 3639:
                          case 3655:
                          case 3660:
                          case 3645:
                          case 3662:
                            return "Above_Right";
                          case 3761:
                          case 3764:
                          case 3765:
                          case 3766:
                          case 3767:
                          case 3771:
                          case 3788:
                          case 3789:
                            return "Above";
                          case 3772:
                            return "Below";
                        }
                      } else if (codePoint === 3642) {
                        return "Below_Right";
                      }
                    }
                    switch (combiningClass) {
                      case "CCC10":
                      case "CCC11":
                      case "CCC12":
                      case "CCC13":
                      case "CCC14":
                      case "CCC15":
                      case "CCC16":
                      case "CCC17":
                      case "CCC18":
                      case "CCC20":
                      case "CCC22":
                        return "Below";
                      case "CCC23":
                        return "Attached_Above";
                      case "CCC24":
                        return "Above_Right";
                      case "CCC25":
                      case "CCC19":
                        return "Above_Left";
                      case "CCC26":
                        return "Above";
                      case "CCC21":
                        break;
                      case "CCC27":
                      case "CCC28":
                      case "CCC30":
                      case "CCC31":
                      case "CCC33":
                      case "CCC34":
                      case "CCC35":
                      case "CCC36":
                        return "Above";
                      case "CCC29":
                      case "CCC32":
                        return "Below";
                      case "CCC103":
                        return "Below_Right";
                      case "CCC107":
                        return "Above_Right";
                      case "CCC118":
                        return "Below";
                      case "CCC122":
                        return "Above";
                      case "CCC129":
                      case "CCC132":
                        return "Below";
                      case "CCC130":
                        return "Above";
                    }
                    return combiningClass;
                  };
                  return UnicodeLayoutEngine2;
                }();
                var BBox = function() {
                  function BBox2(minX, minY, maxX, maxY) {
                    if (minX === void 0) {
                      minX = Infinity;
                    }
                    if (minY === void 0) {
                      minY = Infinity;
                    }
                    if (maxX === void 0) {
                      maxX = -Infinity;
                    }
                    if (maxY === void 0) {
                      maxY = -Infinity;
                    }
                    this.minX = minX;
                    this.minY = minY;
                    this.maxX = maxX;
                    this.maxY = maxY;
                  }
                  var _proto18 = BBox2.prototype;
                  _proto18.addPoint = function addPoint(x, y) {
                    if (Math.abs(x) !== Infinity) {
                      if (x < this.minX) {
                        this.minX = x;
                      }
                      if (x > this.maxX) {
                        this.maxX = x;
                      }
                    }
                    if (Math.abs(y) !== Infinity) {
                      if (y < this.minY) {
                        this.minY = y;
                      }
                      if (y > this.maxY) {
                        this.maxY = y;
                      }
                    }
                  };
                  _proto18.copy = function copy() {
                    return new BBox2(this.minX, this.minY, this.maxX, this.maxY);
                  };
                  _createClass(BBox2, [{
                    key: "width",
                    get: function get() {
                      return this.maxX - this.minX;
                    }
                    /**
                     * The height of the bounding box
                     * @type {number}
                     */
                  }, {
                    key: "height",
                    get: function get() {
                      return this.maxY - this.minY;
                    }
                  }]);
                  return BBox2;
                }();
                var UNICODE_SCRIPTS = {
                  Caucasian_Albanian: "aghb",
                  Arabic: "arab",
                  Imperial_Aramaic: "armi",
                  Armenian: "armn",
                  Avestan: "avst",
                  Balinese: "bali",
                  Bamum: "bamu",
                  Bassa_Vah: "bass",
                  Batak: "batk",
                  Bengali: ["bng2", "beng"],
                  Bopomofo: "bopo",
                  Brahmi: "brah",
                  Braille: "brai",
                  Buginese: "bugi",
                  Buhid: "buhd",
                  Chakma: "cakm",
                  Canadian_Aboriginal: "cans",
                  Carian: "cari",
                  Cham: "cham",
                  Cherokee: "cher",
                  Coptic: "copt",
                  Cypriot: "cprt",
                  Cyrillic: "cyrl",
                  Devanagari: ["dev2", "deva"],
                  Deseret: "dsrt",
                  Duployan: "dupl",
                  Egyptian_Hieroglyphs: "egyp",
                  Elbasan: "elba",
                  Ethiopic: "ethi",
                  Georgian: "geor",
                  Glagolitic: "glag",
                  Gothic: "goth",
                  Grantha: "gran",
                  Greek: "grek",
                  Gujarati: ["gjr2", "gujr"],
                  Gurmukhi: ["gur2", "guru"],
                  Hangul: "hang",
                  Han: "hani",
                  Hanunoo: "hano",
                  Hebrew: "hebr",
                  Hiragana: "hira",
                  Pahawh_Hmong: "hmng",
                  Katakana_Or_Hiragana: "hrkt",
                  Old_Italic: "ital",
                  Javanese: "java",
                  Kayah_Li: "kali",
                  Katakana: "kana",
                  Kharoshthi: "khar",
                  Khmer: "khmr",
                  Khojki: "khoj",
                  Kannada: ["knd2", "knda"],
                  Kaithi: "kthi",
                  Tai_Tham: "lana",
                  Lao: "lao ",
                  Latin: "latn",
                  Lepcha: "lepc",
                  Limbu: "limb",
                  Linear_A: "lina",
                  Linear_B: "linb",
                  Lisu: "lisu",
                  Lycian: "lyci",
                  Lydian: "lydi",
                  Mahajani: "mahj",
                  Mandaic: "mand",
                  Manichaean: "mani",
                  Mende_Kikakui: "mend",
                  Meroitic_Cursive: "merc",
                  Meroitic_Hieroglyphs: "mero",
                  Malayalam: ["mlm2", "mlym"],
                  Modi: "modi",
                  Mongolian: "mong",
                  Mro: "mroo",
                  Meetei_Mayek: "mtei",
                  Myanmar: ["mym2", "mymr"],
                  Old_North_Arabian: "narb",
                  Nabataean: "nbat",
                  Nko: "nko ",
                  Ogham: "ogam",
                  Ol_Chiki: "olck",
                  Old_Turkic: "orkh",
                  Oriya: ["ory2", "orya"],
                  Osmanya: "osma",
                  Palmyrene: "palm",
                  Pau_Cin_Hau: "pauc",
                  Old_Permic: "perm",
                  Phags_Pa: "phag",
                  Inscriptional_Pahlavi: "phli",
                  Psalter_Pahlavi: "phlp",
                  Phoenician: "phnx",
                  Miao: "plrd",
                  Inscriptional_Parthian: "prti",
                  Rejang: "rjng",
                  Runic: "runr",
                  Samaritan: "samr",
                  Old_South_Arabian: "sarb",
                  Saurashtra: "saur",
                  Shavian: "shaw",
                  Sharada: "shrd",
                  Siddham: "sidd",
                  Khudawadi: "sind",
                  Sinhala: "sinh",
                  Sora_Sompeng: "sora",
                  Sundanese: "sund",
                  Syloti_Nagri: "sylo",
                  Syriac: "syrc",
                  Tagbanwa: "tagb",
                  Takri: "takr",
                  Tai_Le: "tale",
                  New_Tai_Lue: "talu",
                  Tamil: ["tml2", "taml"],
                  Tai_Viet: "tavt",
                  Telugu: ["tel2", "telu"],
                  Tifinagh: "tfng",
                  Tagalog: "tglg",
                  Thaana: "thaa",
                  Thai: "thai",
                  Tibetan: "tibt",
                  Tirhuta: "tirh",
                  Ugaritic: "ugar",
                  Vai: "vai ",
                  Warang_Citi: "wara",
                  Old_Persian: "xpeo",
                  Cuneiform: "xsux",
                  Yi: "yi  ",
                  Inherited: "zinh",
                  Common: "zyyy",
                  Unknown: "zzzz"
                };
                var OPENTYPE_SCRIPTS = {};
                for (var script in UNICODE_SCRIPTS) {
                  var tag = UNICODE_SCRIPTS[script];
                  if (Array.isArray(tag)) {
                    for (var _iterator17 = _createForOfIteratorHelperLoose(tag), _step17; !(_step17 = _iterator17()).done; ) {
                      var t = _step17.value;
                      OPENTYPE_SCRIPTS[t] = script;
                    }
                  } else {
                    OPENTYPE_SCRIPTS[tag] = script;
                  }
                }
                function fromOpenType(tag2) {
                  return OPENTYPE_SCRIPTS[tag2];
                }
                function forString(string) {
                  var len = string.length;
                  var idx = 0;
                  while (idx < len) {
                    var code = string.charCodeAt(idx++);
                    if (55296 <= code && code <= 56319 && idx < len) {
                      var next = string.charCodeAt(idx);
                      if (56320 <= next && next <= 57343) {
                        idx++;
                        code = ((code & 1023) << 10) + (next & 1023) + 65536;
                      }
                    }
                    var _script = unicode.getScript(code);
                    if (_script !== "Common" && _script !== "Inherited" && _script !== "Unknown") {
                      return UNICODE_SCRIPTS[_script];
                    }
                  }
                  return UNICODE_SCRIPTS.Unknown;
                }
                function forCodePoints(codePoints) {
                  for (var i2 = 0; i2 < codePoints.length; i2++) {
                    var codePoint = codePoints[i2];
                    var _script2 = unicode.getScript(codePoint);
                    if (_script2 !== "Common" && _script2 !== "Inherited" && _script2 !== "Unknown") {
                      return UNICODE_SCRIPTS[_script2];
                    }
                  }
                  return UNICODE_SCRIPTS.Unknown;
                }
                var RTL = {
                  arab: true,
                  // Arabic
                  hebr: true,
                  // Hebrew
                  syrc: true,
                  // Syriac
                  thaa: true,
                  // Thaana
                  cprt: true,
                  // Cypriot Syllabary
                  khar: true,
                  // Kharosthi
                  phnx: true,
                  // Phoenician
                  "nko ": true,
                  // N'Ko
                  lydi: true,
                  // Lydian
                  avst: true,
                  // Avestan
                  armi: true,
                  // Imperial Aramaic
                  phli: true,
                  // Inscriptional Pahlavi
                  prti: true,
                  // Inscriptional Parthian
                  sarb: true,
                  // Old South Arabian
                  orkh: true,
                  // Old Turkic, Orkhon Runic
                  samr: true,
                  // Samaritan
                  mand: true,
                  // Mandaic, Mandaean
                  merc: true,
                  // Meroitic Cursive
                  mero: true,
                  // Meroitic Hieroglyphs
                  // Unicode 7.0 (not listed on http://www.microsoft.com/typography/otspec/scripttags.htm)
                  mani: true,
                  // Manichaean
                  mend: true,
                  // Mende Kikakui
                  nbat: true,
                  // Nabataean
                  narb: true,
                  // Old North Arabian
                  palm: true,
                  // Palmyrene
                  phlp: true
                  // Psalter Pahlavi
                };
                function direction(script2) {
                  if (RTL[script2]) {
                    return "rtl";
                  }
                  return "ltr";
                }
                var GlyphRun = function() {
                  function GlyphRun2(glyphs, features2, script2, language, direction$1) {
                    this.glyphs = glyphs;
                    this.positions = null;
                    this.script = script2;
                    this.language = language || null;
                    this.direction = direction$1 || direction(script2);
                    this.features = {};
                    if (Array.isArray(features2)) {
                      for (var _iterator18 = _createForOfIteratorHelperLoose(features2), _step18; !(_step18 = _iterator18()).done; ) {
                        var tag2 = _step18.value;
                        this.features[tag2] = true;
                      }
                    } else if (typeof features2 === "object") {
                      this.features = features2;
                    }
                  }
                  _createClass(GlyphRun2, [{
                    key: "advanceWidth",
                    get: function get() {
                      var width = 0;
                      for (var _iterator19 = _createForOfIteratorHelperLoose(this.positions), _step19; !(_step19 = _iterator19()).done; ) {
                        var position = _step19.value;
                        width += position.xAdvance;
                      }
                      return width;
                    }
                    /**
                     * The total advance height of the run.
                     * @type {number}
                     */
                  }, {
                    key: "advanceHeight",
                    get: function get() {
                      var height = 0;
                      for (var _iterator20 = _createForOfIteratorHelperLoose(this.positions), _step20; !(_step20 = _iterator20()).done; ) {
                        var position = _step20.value;
                        height += position.yAdvance;
                      }
                      return height;
                    }
                    /**
                     * The bounding box containing all glyphs in the run.
                     * @type {BBox}
                     */
                  }, {
                    key: "bbox",
                    get: function get() {
                      var bbox = new BBox();
                      var x = 0;
                      var y = 0;
                      for (var index = 0; index < this.glyphs.length; index++) {
                        var glyph2 = this.glyphs[index];
                        var p = this.positions[index];
                        var b = glyph2.bbox;
                        bbox.addPoint(b.minX + x + p.xOffset, b.minY + y + p.yOffset);
                        bbox.addPoint(b.maxX + x + p.xOffset, b.maxY + y + p.yOffset);
                        x += p.xAdvance;
                        y += p.yAdvance;
                      }
                      return bbox;
                    }
                  }]);
                  return GlyphRun2;
                }();
                var GlyphPosition = function GlyphPosition2(xAdvance, yAdvance, xOffset, yOffset) {
                  if (xAdvance === void 0) {
                    xAdvance = 0;
                  }
                  if (yAdvance === void 0) {
                    yAdvance = 0;
                  }
                  if (xOffset === void 0) {
                    xOffset = 0;
                  }
                  if (yOffset === void 0) {
                    yOffset = 0;
                  }
                  this.xAdvance = xAdvance;
                  this.yAdvance = yAdvance;
                  this.xOffset = xOffset;
                  this.yOffset = yOffset;
                };
                var features = {
                  allTypographicFeatures: {
                    code: 0,
                    exclusive: false,
                    allTypeFeatures: 0
                  },
                  ligatures: {
                    code: 1,
                    exclusive: false,
                    requiredLigatures: 0,
                    commonLigatures: 2,
                    rareLigatures: 4,
                    // logos: 6
                    rebusPictures: 8,
                    diphthongLigatures: 10,
                    squaredLigatures: 12,
                    abbrevSquaredLigatures: 14,
                    symbolLigatures: 16,
                    contextualLigatures: 18,
                    historicalLigatures: 20
                  },
                  cursiveConnection: {
                    code: 2,
                    exclusive: true,
                    unconnected: 0,
                    partiallyConnected: 1,
                    cursive: 2
                  },
                  letterCase: {
                    code: 3,
                    exclusive: true
                  },
                  // upperAndLowerCase: 0          # deprecated
                  // allCaps: 1                    # deprecated
                  // allLowerCase: 2               # deprecated
                  // smallCaps: 3                  # deprecated
                  // initialCaps: 4                # deprecated
                  // initialCapsAndSmallCaps: 5    # deprecated
                  verticalSubstitution: {
                    code: 4,
                    exclusive: false,
                    substituteVerticalForms: 0
                  },
                  linguisticRearrangement: {
                    code: 5,
                    exclusive: false,
                    linguisticRearrangement: 0
                  },
                  numberSpacing: {
                    code: 6,
                    exclusive: true,
                    monospacedNumbers: 0,
                    proportionalNumbers: 1,
                    thirdWidthNumbers: 2,
                    quarterWidthNumbers: 3
                  },
                  smartSwash: {
                    code: 8,
                    exclusive: false,
                    wordInitialSwashes: 0,
                    wordFinalSwashes: 2,
                    // lineInitialSwashes: 4
                    // lineFinalSwashes: 6
                    nonFinalSwashes: 8
                  },
                  diacritics: {
                    code: 9,
                    exclusive: true,
                    showDiacritics: 0,
                    hideDiacritics: 1,
                    decomposeDiacritics: 2
                  },
                  verticalPosition: {
                    code: 10,
                    exclusive: true,
                    normalPosition: 0,
                    superiors: 1,
                    inferiors: 2,
                    ordinals: 3,
                    scientificInferiors: 4
                  },
                  fractions: {
                    code: 11,
                    exclusive: true,
                    noFractions: 0,
                    verticalFractions: 1,
                    diagonalFractions: 2
                  },
                  overlappingCharacters: {
                    code: 13,
                    exclusive: false,
                    preventOverlap: 0
                  },
                  typographicExtras: {
                    code: 14,
                    exclusive: false,
                    // hyphensToEmDash: 0
                    // hyphenToEnDash: 2
                    slashedZero: 4
                  },
                  // formInterrobang: 6
                  // smartQuotes: 8
                  // periodsToEllipsis: 10
                  mathematicalExtras: {
                    code: 15,
                    exclusive: false,
                    // hyphenToMinus: 0
                    // asteristoMultiply: 2
                    // slashToDivide: 4
                    // inequalityLigatures: 6
                    // exponents: 8
                    mathematicalGreek: 10
                  },
                  ornamentSets: {
                    code: 16,
                    exclusive: true,
                    noOrnaments: 0,
                    dingbats: 1,
                    piCharacters: 2,
                    fleurons: 3,
                    decorativeBorders: 4,
                    internationalSymbols: 5,
                    mathSymbols: 6
                  },
                  characterAlternatives: {
                    code: 17,
                    exclusive: true,
                    noAlternates: 0
                  },
                  // user defined options
                  designComplexity: {
                    code: 18,
                    exclusive: true,
                    designLevel1: 0,
                    designLevel2: 1,
                    designLevel3: 2,
                    designLevel4: 3,
                    designLevel5: 4
                  },
                  styleOptions: {
                    code: 19,
                    exclusive: true,
                    noStyleOptions: 0,
                    displayText: 1,
                    engravedText: 2,
                    illuminatedCaps: 3,
                    titlingCaps: 4,
                    tallCaps: 5
                  },
                  characterShape: {
                    code: 20,
                    exclusive: true,
                    traditionalCharacters: 0,
                    simplifiedCharacters: 1,
                    JIS1978Characters: 2,
                    JIS1983Characters: 3,
                    JIS1990Characters: 4,
                    traditionalAltOne: 5,
                    traditionalAltTwo: 6,
                    traditionalAltThree: 7,
                    traditionalAltFour: 8,
                    traditionalAltFive: 9,
                    expertCharacters: 10,
                    JIS2004Characters: 11,
                    hojoCharacters: 12,
                    NLCCharacters: 13,
                    traditionalNamesCharacters: 14
                  },
                  numberCase: {
                    code: 21,
                    exclusive: true,
                    lowerCaseNumbers: 0,
                    upperCaseNumbers: 1
                  },
                  textSpacing: {
                    code: 22,
                    exclusive: true,
                    proportionalText: 0,
                    monospacedText: 1,
                    halfWidthText: 2,
                    thirdWidthText: 3,
                    quarterWidthText: 4,
                    altProportionalText: 5,
                    altHalfWidthText: 6
                  },
                  transliteration: {
                    code: 23,
                    exclusive: true,
                    noTransliteration: 0
                  },
                  // hanjaToHangul: 1
                  // hiraganaToKatakana: 2
                  // katakanaToHiragana: 3
                  // kanaToRomanization: 4
                  // romanizationToHiragana: 5
                  // romanizationToKatakana: 6
                  // hanjaToHangulAltOne: 7
                  // hanjaToHangulAltTwo: 8
                  // hanjaToHangulAltThree: 9
                  annotation: {
                    code: 24,
                    exclusive: true,
                    noAnnotation: 0,
                    boxAnnotation: 1,
                    roundedBoxAnnotation: 2,
                    circleAnnotation: 3,
                    invertedCircleAnnotation: 4,
                    parenthesisAnnotation: 5,
                    periodAnnotation: 6,
                    romanNumeralAnnotation: 7,
                    diamondAnnotation: 8,
                    invertedBoxAnnotation: 9,
                    invertedRoundedBoxAnnotation: 10
                  },
                  kanaSpacing: {
                    code: 25,
                    exclusive: true,
                    fullWidthKana: 0,
                    proportionalKana: 1
                  },
                  ideographicSpacing: {
                    code: 26,
                    exclusive: true,
                    fullWidthIdeographs: 0,
                    proportionalIdeographs: 1,
                    halfWidthIdeographs: 2
                  },
                  unicodeDecomposition: {
                    code: 27,
                    exclusive: false,
                    canonicalComposition: 0,
                    compatibilityComposition: 2,
                    transcodingComposition: 4
                  },
                  rubyKana: {
                    code: 28,
                    exclusive: false,
                    // noRubyKana: 0     # deprecated - use rubyKanaOff instead
                    // rubyKana: 1     # deprecated - use rubyKanaOn instead
                    rubyKana: 2
                  },
                  CJKSymbolAlternatives: {
                    code: 29,
                    exclusive: true,
                    noCJKSymbolAlternatives: 0,
                    CJKSymbolAltOne: 1,
                    CJKSymbolAltTwo: 2,
                    CJKSymbolAltThree: 3,
                    CJKSymbolAltFour: 4,
                    CJKSymbolAltFive: 5
                  },
                  ideographicAlternatives: {
                    code: 30,
                    exclusive: true,
                    noIdeographicAlternatives: 0,
                    ideographicAltOne: 1,
                    ideographicAltTwo: 2,
                    ideographicAltThree: 3,
                    ideographicAltFour: 4,
                    ideographicAltFive: 5
                  },
                  CJKVerticalRomanPlacement: {
                    code: 31,
                    exclusive: true,
                    CJKVerticalRomanCentered: 0,
                    CJKVerticalRomanHBaseline: 1
                  },
                  italicCJKRoman: {
                    code: 32,
                    exclusive: false,
                    // noCJKItalicRoman: 0     # deprecated - use CJKItalicRomanOff instead
                    // CJKItalicRoman: 1     # deprecated - use CJKItalicRomanOn instead
                    CJKItalicRoman: 2
                  },
                  caseSensitiveLayout: {
                    code: 33,
                    exclusive: false,
                    caseSensitiveLayout: 0,
                    caseSensitiveSpacing: 2
                  },
                  alternateKana: {
                    code: 34,
                    exclusive: false,
                    alternateHorizKana: 0,
                    alternateVertKana: 2
                  },
                  stylisticAlternatives: {
                    code: 35,
                    exclusive: false,
                    noStylisticAlternates: 0,
                    stylisticAltOne: 2,
                    stylisticAltTwo: 4,
                    stylisticAltThree: 6,
                    stylisticAltFour: 8,
                    stylisticAltFive: 10,
                    stylisticAltSix: 12,
                    stylisticAltSeven: 14,
                    stylisticAltEight: 16,
                    stylisticAltNine: 18,
                    stylisticAltTen: 20,
                    stylisticAltEleven: 22,
                    stylisticAltTwelve: 24,
                    stylisticAltThirteen: 26,
                    stylisticAltFourteen: 28,
                    stylisticAltFifteen: 30,
                    stylisticAltSixteen: 32,
                    stylisticAltSeventeen: 34,
                    stylisticAltEighteen: 36,
                    stylisticAltNineteen: 38,
                    stylisticAltTwenty: 40
                  },
                  contextualAlternates: {
                    code: 36,
                    exclusive: false,
                    contextualAlternates: 0,
                    swashAlternates: 2,
                    contextualSwashAlternates: 4
                  },
                  lowerCase: {
                    code: 37,
                    exclusive: true,
                    defaultLowerCase: 0,
                    lowerCaseSmallCaps: 1,
                    lowerCasePetiteCaps: 2
                  },
                  upperCase: {
                    code: 38,
                    exclusive: true,
                    defaultUpperCase: 0,
                    upperCaseSmallCaps: 1,
                    upperCasePetiteCaps: 2
                  },
                  languageTag: {
                    // indices into ltag table
                    code: 39,
                    exclusive: true
                  },
                  CJKRomanSpacing: {
                    code: 103,
                    exclusive: true,
                    halfWidthCJKRoman: 0,
                    proportionalCJKRoman: 1,
                    defaultCJKRoman: 2,
                    fullWidthCJKRoman: 3
                  }
                };
                var feature = function feature2(name, selector) {
                  return [features[name].code, features[name][selector]];
                };
                var OTMapping = {
                  rlig: feature("ligatures", "requiredLigatures"),
                  clig: feature("ligatures", "contextualLigatures"),
                  dlig: feature("ligatures", "rareLigatures"),
                  hlig: feature("ligatures", "historicalLigatures"),
                  liga: feature("ligatures", "commonLigatures"),
                  hist: feature("ligatures", "historicalLigatures"),
                  // ??
                  smcp: feature("lowerCase", "lowerCaseSmallCaps"),
                  pcap: feature("lowerCase", "lowerCasePetiteCaps"),
                  frac: feature("fractions", "diagonalFractions"),
                  dnom: feature("fractions", "diagonalFractions"),
                  // ??
                  numr: feature("fractions", "diagonalFractions"),
                  // ??
                  afrc: feature("fractions", "verticalFractions"),
                  // aalt
                  // abvf, abvm, abvs, akhn, blwf, blwm, blws, cfar, cjct, cpsp, falt, isol, jalt, ljmo, mset?
                  // ltra, ltrm, nukt, pref, pres, pstf, psts, rand, rkrf, rphf, rtla, rtlm, size, tjmo, tnum?
                  // unic, vatu, vhal, vjmo, vpal, vrt2
                  // dist -> trak table?
                  // kern, vkrn -> kern table
                  // lfbd + opbd + rtbd -> opbd table?
                  // mark, mkmk -> acnt table?
                  // locl -> languageTag + ltag table
                  case: feature("caseSensitiveLayout", "caseSensitiveLayout"),
                  // also caseSensitiveSpacing
                  ccmp: feature("unicodeDecomposition", "canonicalComposition"),
                  // compatibilityComposition?
                  cpct: feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
                  // guess..., probably not given below
                  valt: feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
                  swsh: feature("contextualAlternates", "swashAlternates"),
                  cswh: feature("contextualAlternates", "contextualSwashAlternates"),
                  curs: feature("cursiveConnection", "cursive"),
                  // ??
                  c2pc: feature("upperCase", "upperCasePetiteCaps"),
                  c2sc: feature("upperCase", "upperCaseSmallCaps"),
                  init: feature("smartSwash", "wordInitialSwashes"),
                  // ??
                  fin2: feature("smartSwash", "wordFinalSwashes"),
                  // ??
                  medi: feature("smartSwash", "nonFinalSwashes"),
                  // ??
                  med2: feature("smartSwash", "nonFinalSwashes"),
                  // ??
                  fin3: feature("smartSwash", "wordFinalSwashes"),
                  // ??
                  fina: feature("smartSwash", "wordFinalSwashes"),
                  // ??
                  pkna: feature("kanaSpacing", "proportionalKana"),
                  half: feature("textSpacing", "halfWidthText"),
                  // also HalfWidthCJKRoman, HalfWidthIdeographs?
                  halt: feature("textSpacing", "altHalfWidthText"),
                  hkna: feature("alternateKana", "alternateHorizKana"),
                  vkna: feature("alternateKana", "alternateVertKana"),
                  // hngl: feature 'transliteration', 'hanjaToHangulSelector' # deprecated
                  ital: feature("italicCJKRoman", "CJKItalicRoman"),
                  lnum: feature("numberCase", "upperCaseNumbers"),
                  onum: feature("numberCase", "lowerCaseNumbers"),
                  mgrk: feature("mathematicalExtras", "mathematicalGreek"),
                  // nalt: not enough info. what type of annotation?
                  // ornm: ditto, which ornament style?
                  calt: feature("contextualAlternates", "contextualAlternates"),
                  // or more?
                  vrt2: feature("verticalSubstitution", "substituteVerticalForms"),
                  // oh... below?
                  vert: feature("verticalSubstitution", "substituteVerticalForms"),
                  tnum: feature("numberSpacing", "monospacedNumbers"),
                  pnum: feature("numberSpacing", "proportionalNumbers"),
                  sups: feature("verticalPosition", "superiors"),
                  subs: feature("verticalPosition", "inferiors"),
                  ordn: feature("verticalPosition", "ordinals"),
                  pwid: feature("textSpacing", "proportionalText"),
                  hwid: feature("textSpacing", "halfWidthText"),
                  qwid: feature("textSpacing", "quarterWidthText"),
                  // also QuarterWidthNumbers?
                  twid: feature("textSpacing", "thirdWidthText"),
                  // also ThirdWidthNumbers?
                  fwid: feature("textSpacing", "proportionalText"),
                  //??
                  palt: feature("textSpacing", "altProportionalText"),
                  trad: feature("characterShape", "traditionalCharacters"),
                  smpl: feature("characterShape", "simplifiedCharacters"),
                  jp78: feature("characterShape", "JIS1978Characters"),
                  jp83: feature("characterShape", "JIS1983Characters"),
                  jp90: feature("characterShape", "JIS1990Characters"),
                  jp04: feature("characterShape", "JIS2004Characters"),
                  expt: feature("characterShape", "expertCharacters"),
                  hojo: feature("characterShape", "hojoCharacters"),
                  nlck: feature("characterShape", "NLCCharacters"),
                  tnam: feature("characterShape", "traditionalNamesCharacters"),
                  ruby: feature("rubyKana", "rubyKana"),
                  titl: feature("styleOptions", "titlingCaps"),
                  zero: feature("typographicExtras", "slashedZero"),
                  ss01: feature("stylisticAlternatives", "stylisticAltOne"),
                  ss02: feature("stylisticAlternatives", "stylisticAltTwo"),
                  ss03: feature("stylisticAlternatives", "stylisticAltThree"),
                  ss04: feature("stylisticAlternatives", "stylisticAltFour"),
                  ss05: feature("stylisticAlternatives", "stylisticAltFive"),
                  ss06: feature("stylisticAlternatives", "stylisticAltSix"),
                  ss07: feature("stylisticAlternatives", "stylisticAltSeven"),
                  ss08: feature("stylisticAlternatives", "stylisticAltEight"),
                  ss09: feature("stylisticAlternatives", "stylisticAltNine"),
                  ss10: feature("stylisticAlternatives", "stylisticAltTen"),
                  ss11: feature("stylisticAlternatives", "stylisticAltEleven"),
                  ss12: feature("stylisticAlternatives", "stylisticAltTwelve"),
                  ss13: feature("stylisticAlternatives", "stylisticAltThirteen"),
                  ss14: feature("stylisticAlternatives", "stylisticAltFourteen"),
                  ss15: feature("stylisticAlternatives", "stylisticAltFifteen"),
                  ss16: feature("stylisticAlternatives", "stylisticAltSixteen"),
                  ss17: feature("stylisticAlternatives", "stylisticAltSeventeen"),
                  ss18: feature("stylisticAlternatives", "stylisticAltEighteen"),
                  ss19: feature("stylisticAlternatives", "stylisticAltNineteen"),
                  ss20: feature("stylisticAlternatives", "stylisticAltTwenty")
                };
                for (var i = 1; i <= 99; i++) {
                  OTMapping["cv".concat("00".concat(i).slice(-2))] = [features.characterAlternatives.code, i];
                }
                var AATMapping = {};
                for (var ot in OTMapping) {
                  var aat = OTMapping[ot];
                  if (AATMapping[aat[0]] == null) {
                    AATMapping[aat[0]] = {};
                  }
                  AATMapping[aat[0]][aat[1]] = ot;
                }
                function mapOTToAAT(features2) {
                  var res = {};
                  for (var k in features2) {
                    var r2 = void 0;
                    if (r2 = OTMapping[k]) {
                      if (res[r2[0]] == null) {
                        res[r2[0]] = {};
                      }
                      res[r2[0]][r2[1]] = features2[k];
                    }
                  }
                  return res;
                }
                function mapFeatureStrings(f) {
                  var type = f[0], setting = f[1];
                  if (isNaN(type)) {
                    var typeCode = features[type] && features[type].code;
                  } else {
                    var typeCode = type;
                  }
                  if (isNaN(setting)) {
                    var settingCode = features[type] && features[type][setting];
                  } else {
                    var settingCode = setting;
                  }
                  return [typeCode, settingCode];
                }
                function mapAATToOT(features2) {
                  var res = {};
                  if (Array.isArray(features2)) {
                    for (var k = 0; k < features2.length; k++) {
                      var r2 = void 0;
                      var f = mapFeatureStrings(features2[k]);
                      if (r2 = AATMapping[f[0]] && AATMapping[f[0]][f[1]]) {
                        res[r2] = true;
                      }
                    }
                  } else if (typeof features2 === "object") {
                    for (var type in features2) {
                      var _feature = features2[type];
                      for (var setting in _feature) {
                        var _r = void 0;
                        var _f = mapFeatureStrings([type, setting]);
                        if (_feature[setting] && (_r = AATMapping[_f[0]] && AATMapping[_f[0]][_f[1]])) {
                          res[_r] = true;
                        }
                      }
                    }
                  }
                  return Object.keys(res);
                }
                var _class$1;
                var AATLookupTable = (_class$1 = function() {
                  function AATLookupTable2(table) {
                    this.table = table;
                  }
                  var _proto19 = AATLookupTable2.prototype;
                  _proto19.lookup = function lookup(glyph2) {
                    switch (this.table.version) {
                      case 0:
                        return this.table.values.getItem(glyph2);
                      case 2:
                      case 4: {
                        var min = 0;
                        var max = this.table.binarySearchHeader.nUnits - 1;
                        while (min <= max) {
                          var mid = min + max >> 1;
                          var seg = this.table.segments[mid];
                          if (seg.firstGlyph === 65535) {
                            return null;
                          }
                          if (glyph2 < seg.firstGlyph) {
                            max = mid - 1;
                          } else if (glyph2 > seg.lastGlyph) {
                            min = mid + 1;
                          } else {
                            if (this.table.version === 2) {
                              return seg.value;
                            } else {
                              return seg.values[glyph2 - seg.firstGlyph];
                            }
                          }
                        }
                        return null;
                      }
                      case 6: {
                        var _min = 0;
                        var _max = this.table.binarySearchHeader.nUnits - 1;
                        while (_min <= _max) {
                          var mid = _min + _max >> 1;
                          var seg = this.table.segments[mid];
                          if (seg.glyph === 65535) {
                            return null;
                          }
                          if (glyph2 < seg.glyph) {
                            _max = mid - 1;
                          } else if (glyph2 > seg.glyph) {
                            _min = mid + 1;
                          } else {
                            return seg.value;
                          }
                        }
                        return null;
                      }
                      case 8:
                        return this.table.values[glyph2 - this.table.firstGlyph];
                      default:
                        throw new Error("Unknown lookup table format: ".concat(this.table.version));
                    }
                  };
                  _proto19.glyphsForValue = function glyphsForValue(classValue) {
                    var res = [];
                    switch (this.table.version) {
                      case 2:
                      case 4: {
                        for (var _iterator21 = _createForOfIteratorHelperLoose(this.table.segments), _step21; !(_step21 = _iterator21()).done; ) {
                          var segment = _step21.value;
                          if (this.table.version === 2 && segment.value === classValue) {
                            res.push.apply(res, range(segment.firstGlyph, segment.lastGlyph + 1));
                          } else {
                            for (var index = 0; index < segment.values.length; index++) {
                              if (segment.values[index] === classValue) {
                                res.push(segment.firstGlyph + index);
                              }
                            }
                          }
                        }
                        break;
                      }
                      case 6: {
                        for (var _iterator22 = _createForOfIteratorHelperLoose(this.table.segments), _step22; !(_step22 = _iterator22()).done; ) {
                          var _segment = _step22.value;
                          if (_segment.value === classValue) {
                            res.push(_segment.glyph);
                          }
                        }
                        break;
                      }
                      case 8: {
                        for (var i2 = 0; i2 < this.table.values.length; i2++) {
                          if (this.table.values[i2] === classValue) {
                            res.push(this.table.firstGlyph + i2);
                          }
                        }
                        break;
                      }
                      default:
                        throw new Error("Unknown lookup table format: ".concat(this.table.version));
                    }
                    return res;
                  };
                  return AATLookupTable2;
                }(), _applyDecoratedDescriptor(_class$1.prototype, "glyphsForValue", [cache], Object.getOwnPropertyDescriptor(_class$1.prototype, "glyphsForValue"), _class$1.prototype), _class$1);
                var START_OF_TEXT_STATE = 0;
                var END_OF_TEXT_CLASS = 0;
                var OUT_OF_BOUNDS_CLASS = 1;
                var DELETED_GLYPH_CLASS = 2;
                var DONT_ADVANCE = 16384;
                var AATStateMachine = function() {
                  function AATStateMachine2(stateTable2) {
                    this.stateTable = stateTable2;
                    this.lookupTable = new AATLookupTable(stateTable2.classTable);
                  }
                  var _proto20 = AATStateMachine2.prototype;
                  _proto20.process = function process(glyphs, reverse, processEntry) {
                    var currentState = START_OF_TEXT_STATE;
                    var index = reverse ? glyphs.length - 1 : 0;
                    var dir = reverse ? -1 : 1;
                    while (dir === 1 && index <= glyphs.length || dir === -1 && index >= -1) {
                      var glyph2 = null;
                      var classCode = OUT_OF_BOUNDS_CLASS;
                      var shouldAdvance = true;
                      if (index === glyphs.length || index === -1) {
                        classCode = END_OF_TEXT_CLASS;
                      } else {
                        glyph2 = glyphs[index];
                        if (glyph2.id === 65535) {
                          classCode = DELETED_GLYPH_CLASS;
                        } else {
                          classCode = this.lookupTable.lookup(glyph2.id);
                          if (classCode == null) {
                            classCode = OUT_OF_BOUNDS_CLASS;
                          }
                        }
                      }
                      var row = this.stateTable.stateArray.getItem(currentState);
                      var entryIndex = row[classCode];
                      var entry = this.stateTable.entryTable.getItem(entryIndex);
                      if (classCode !== END_OF_TEXT_CLASS && classCode !== DELETED_GLYPH_CLASS) {
                        processEntry(glyph2, entry, index);
                        shouldAdvance = !(entry.flags & DONT_ADVANCE);
                      }
                      currentState = entry.newState;
                      if (shouldAdvance) {
                        index += dir;
                      }
                    }
                    return glyphs;
                  };
                  _proto20.traverse = function traverse(opts, state, visited) {
                    if (state === void 0) {
                      state = 0;
                    }
                    if (visited === void 0) {
                      visited = /* @__PURE__ */ new Set();
                    }
                    if (visited.has(state)) {
                      return;
                    }
                    visited.add(state);
                    var _this$stateTable = this.stateTable, nClasses = _this$stateTable.nClasses, stateArray = _this$stateTable.stateArray, entryTable = _this$stateTable.entryTable;
                    var row = stateArray.getItem(state);
                    for (var classCode = 4; classCode < nClasses; classCode++) {
                      var entryIndex = row[classCode];
                      var entry = entryTable.getItem(entryIndex);
                      for (var _iterator23 = _createForOfIteratorHelperLoose(this.lookupTable.glyphsForValue(classCode)), _step23; !(_step23 = _iterator23()).done; ) {
                        var glyph2 = _step23.value;
                        if (opts.enter) {
                          opts.enter(glyph2, entry);
                        }
                        if (entry.newState !== 0) {
                          this.traverse(opts, entry.newState, visited);
                        }
                        if (opts.exit) {
                          opts.exit(glyph2, entry);
                        }
                      }
                    }
                  };
                  return AATStateMachine2;
                }();
                var _class$2;
                var MARK_FIRST = 32768;
                var MARK_LAST = 8192;
                var VERB = 15;
                var SET_MARK = 32768;
                var SET_COMPONENT = 32768;
                var PERFORM_ACTION = 8192;
                var LAST_MASK = 2147483648;
                var STORE_MASK = 1073741824;
                var OFFSET_MASK = 1073741823;
                var REVERSE_DIRECTION = 4194304;
                var CURRENT_INSERT_BEFORE = 2048;
                var MARKED_INSERT_BEFORE = 1024;
                var CURRENT_INSERT_COUNT = 992;
                var MARKED_INSERT_COUNT = 31;
                var AATMorxProcessor = (_class$2 = function() {
                  function AATMorxProcessor2(font) {
                    this.processIndicRearragement = this.processIndicRearragement.bind(this);
                    this.processContextualSubstitution = this.processContextualSubstitution.bind(this);
                    this.processLigature = this.processLigature.bind(this);
                    this.processNoncontextualSubstitutions = this.processNoncontextualSubstitutions.bind(this);
                    this.processGlyphInsertion = this.processGlyphInsertion.bind(this);
                    this.font = font;
                    this.morx = font.morx;
                    this.inputCache = null;
                  }
                  var _proto21 = AATMorxProcessor2.prototype;
                  _proto21.process = function process(glyphs, features2) {
                    if (features2 === void 0) {
                      features2 = {};
                    }
                    for (var _iterator24 = _createForOfIteratorHelperLoose(this.morx.chains), _step24; !(_step24 = _iterator24()).done; ) {
                      var chain = _step24.value;
                      var flags = chain.defaultFlags;
                      for (var _iterator25 = _createForOfIteratorHelperLoose(chain.features), _step25; !(_step25 = _iterator25()).done; ) {
                        var feature2 = _step25.value;
                        var f = void 0;
                        if (f = features2[feature2.featureType]) {
                          if (f[feature2.featureSetting]) {
                            flags &= feature2.disableFlags;
                            flags |= feature2.enableFlags;
                          } else if (f[feature2.featureSetting] === false) {
                            flags |= ~feature2.disableFlags;
                            flags &= ~feature2.enableFlags;
                          }
                        }
                      }
                      for (var _iterator26 = _createForOfIteratorHelperLoose(chain.subtables), _step26; !(_step26 = _iterator26()).done; ) {
                        var subtable = _step26.value;
                        if (subtable.subFeatureFlags & flags) {
                          this.processSubtable(subtable, glyphs);
                        }
                      }
                    }
                    var index = glyphs.length - 1;
                    while (index >= 0) {
                      if (glyphs[index].id === 65535) {
                        glyphs.splice(index, 1);
                      }
                      index--;
                    }
                    return glyphs;
                  };
                  _proto21.processSubtable = function processSubtable(subtable, glyphs) {
                    this.subtable = subtable;
                    this.glyphs = glyphs;
                    if (this.subtable.type === 4) {
                      this.processNoncontextualSubstitutions(this.subtable, this.glyphs);
                      return;
                    }
                    this.ligatureStack = [];
                    this.markedGlyph = null;
                    this.firstGlyph = null;
                    this.lastGlyph = null;
                    this.markedIndex = null;
                    var stateMachine2 = this.getStateMachine(subtable);
                    var process = this.getProcessor();
                    var reverse = !!(this.subtable.coverage & REVERSE_DIRECTION);
                    return stateMachine2.process(this.glyphs, reverse, process);
                  };
                  _proto21.getStateMachine = function getStateMachine(subtable) {
                    return new AATStateMachine(subtable.table.stateTable);
                  };
                  _proto21.getProcessor = function getProcessor() {
                    switch (this.subtable.type) {
                      case 0:
                        return this.processIndicRearragement;
                      case 1:
                        return this.processContextualSubstitution;
                      case 2:
                        return this.processLigature;
                      case 4:
                        return this.processNoncontextualSubstitutions;
                      case 5:
                        return this.processGlyphInsertion;
                      default:
                        throw new Error("Invalid morx subtable type: ".concat(this.subtable.type));
                    }
                  };
                  _proto21.processIndicRearragement = function processIndicRearragement(glyph2, entry, index) {
                    if (entry.flags & MARK_FIRST) {
                      this.firstGlyph = index;
                    }
                    if (entry.flags & MARK_LAST) {
                      this.lastGlyph = index;
                    }
                    reorderGlyphs(this.glyphs, entry.flags & VERB, this.firstGlyph, this.lastGlyph);
                  };
                  _proto21.processContextualSubstitution = function processContextualSubstitution(glyph2, entry, index) {
                    var subsitutions = this.subtable.table.substitutionTable.items;
                    if (entry.markIndex !== 65535) {
                      var lookup = subsitutions.getItem(entry.markIndex);
                      var lookupTable = new AATLookupTable(lookup);
                      glyph2 = this.glyphs[this.markedGlyph];
                      var gid = lookupTable.lookup(glyph2.id);
                      if (gid) {
                        this.glyphs[this.markedGlyph] = this.font.getGlyph(gid, glyph2.codePoints);
                      }
                    }
                    if (entry.currentIndex !== 65535) {
                      var _lookup = subsitutions.getItem(entry.currentIndex);
                      var _lookupTable = new AATLookupTable(_lookup);
                      glyph2 = this.glyphs[index];
                      var gid = _lookupTable.lookup(glyph2.id);
                      if (gid) {
                        this.glyphs[index] = this.font.getGlyph(gid, glyph2.codePoints);
                      }
                    }
                    if (entry.flags & SET_MARK) {
                      this.markedGlyph = index;
                    }
                  };
                  _proto21.processLigature = function processLigature(glyph2, entry, index) {
                    if (entry.flags & SET_COMPONENT) {
                      this.ligatureStack.push(index);
                    }
                    if (entry.flags & PERFORM_ACTION) {
                      var _this$ligatureStack;
                      var actions = this.subtable.table.ligatureActions;
                      var components = this.subtable.table.components;
                      var ligatureList = this.subtable.table.ligatureList;
                      var actionIndex = entry.action;
                      var last = false;
                      var ligatureIndex = 0;
                      var codePoints = [];
                      var ligatureGlyphs = [];
                      while (!last) {
                        var _codePoints;
                        var componentGlyph = this.ligatureStack.pop();
                        (_codePoints = codePoints).unshift.apply(_codePoints, this.glyphs[componentGlyph].codePoints);
                        var action = actions.getItem(actionIndex++);
                        last = !!(action & LAST_MASK);
                        var store = !!(action & STORE_MASK);
                        var offset = (action & OFFSET_MASK) << 2 >> 2;
                        offset += this.glyphs[componentGlyph].id;
                        var component = components.getItem(offset);
                        ligatureIndex += component;
                        if (last || store) {
                          var ligatureEntry = ligatureList.getItem(ligatureIndex);
                          this.glyphs[componentGlyph] = this.font.getGlyph(ligatureEntry, codePoints);
                          ligatureGlyphs.push(componentGlyph);
                          ligatureIndex = 0;
                          codePoints = [];
                        } else {
                          this.glyphs[componentGlyph] = this.font.getGlyph(65535);
                        }
                      }
                      (_this$ligatureStack = this.ligatureStack).push.apply(_this$ligatureStack, ligatureGlyphs);
                    }
                  };
                  _proto21.processNoncontextualSubstitutions = function processNoncontextualSubstitutions(subtable, glyphs, index) {
                    var lookupTable = new AATLookupTable(subtable.table.lookupTable);
                    for (index = 0; index < glyphs.length; index++) {
                      var glyph2 = glyphs[index];
                      if (glyph2.id !== 65535) {
                        var gid = lookupTable.lookup(glyph2.id);
                        if (gid) {
                          glyphs[index] = this.font.getGlyph(gid, glyph2.codePoints);
                        }
                      }
                    }
                  };
                  _proto21._insertGlyphs = function _insertGlyphs(glyphIndex, insertionActionIndex, count, isBefore) {
                    var _this$glyphs;
                    var insertions = [];
                    while (count--) {
                      var gid = this.subtable.table.insertionActions.getItem(insertionActionIndex++);
                      insertions.push(this.font.getGlyph(gid));
                    }
                    if (!isBefore) {
                      glyphIndex++;
                    }
                    (_this$glyphs = this.glyphs).splice.apply(_this$glyphs, [glyphIndex, 0].concat(insertions));
                  };
                  _proto21.processGlyphInsertion = function processGlyphInsertion(glyph2, entry, index) {
                    if (entry.flags & SET_MARK) {
                      this.markedIndex = index;
                    }
                    if (entry.markedInsertIndex !== 65535) {
                      var count = (entry.flags & MARKED_INSERT_COUNT) >>> 5;
                      var isBefore = !!(entry.flags & MARKED_INSERT_BEFORE);
                      this._insertGlyphs(this.markedIndex, entry.markedInsertIndex, count, isBefore);
                    }
                    if (entry.currentInsertIndex !== 65535) {
                      var _count = (entry.flags & CURRENT_INSERT_COUNT) >>> 5;
                      var _isBefore = !!(entry.flags & CURRENT_INSERT_BEFORE);
                      this._insertGlyphs(index, entry.currentInsertIndex, _count, _isBefore);
                    }
                  };
                  _proto21.getSupportedFeatures = function getSupportedFeatures() {
                    var features2 = [];
                    for (var _iterator27 = _createForOfIteratorHelperLoose(this.morx.chains), _step27; !(_step27 = _iterator27()).done; ) {
                      var chain = _step27.value;
                      for (var _iterator28 = _createForOfIteratorHelperLoose(chain.features), _step28; !(_step28 = _iterator28()).done; ) {
                        var feature2 = _step28.value;
                        features2.push([feature2.featureType, feature2.featureSetting]);
                      }
                    }
                    return features2;
                  };
                  _proto21.generateInputs = function generateInputs(gid) {
                    if (!this.inputCache) {
                      this.generateInputCache();
                    }
                    return this.inputCache[gid] || [];
                  };
                  _proto21.generateInputCache = function generateInputCache() {
                    this.inputCache = {};
                    for (var _iterator29 = _createForOfIteratorHelperLoose(this.morx.chains), _step29; !(_step29 = _iterator29()).done; ) {
                      var chain = _step29.value;
                      var flags = chain.defaultFlags;
                      for (var _iterator30 = _createForOfIteratorHelperLoose(chain.subtables), _step30; !(_step30 = _iterator30()).done; ) {
                        var subtable = _step30.value;
                        if (subtable.subFeatureFlags & flags) {
                          this.generateInputsForSubtable(subtable);
                        }
                      }
                    }
                  };
                  _proto21.generateInputsForSubtable = function generateInputsForSubtable(subtable) {
                    var _this3 = this;
                    if (subtable.type !== 2) {
                      return;
                    }
                    var reverse = !!(subtable.coverage & REVERSE_DIRECTION);
                    if (reverse) {
                      throw new Error("Reverse subtable, not supported.");
                    }
                    this.subtable = subtable;
                    this.ligatureStack = [];
                    var stateMachine2 = this.getStateMachine(subtable);
                    var process = this.getProcessor();
                    var input = [];
                    var stack = [];
                    this.glyphs = [];
                    stateMachine2.traverse({
                      enter: function enter(glyph2, entry) {
                        var glyphs = _this3.glyphs;
                        stack.push({
                          glyphs: glyphs.slice(),
                          ligatureStack: _this3.ligatureStack.slice()
                        });
                        var g = _this3.font.getGlyph(glyph2);
                        input.push(g);
                        glyphs.push(input[input.length - 1]);
                        process(glyphs[glyphs.length - 1], entry, glyphs.length - 1);
                        var count = 0;
                        var found = 0;
                        for (var i2 = 0; i2 < glyphs.length && count <= 1; i2++) {
                          if (glyphs[i2].id !== 65535) {
                            count++;
                            found = glyphs[i2].id;
                          }
                        }
                        if (count === 1) {
                          var result = input.map(function(g2) {
                            return g2.id;
                          });
                          var _cache = _this3.inputCache[found];
                          if (_cache) {
                            _cache.push(result);
                          } else {
                            _this3.inputCache[found] = [result];
                          }
                        }
                      },
                      exit: function exit() {
                        var _stack$pop = stack.pop();
                        _this3.glyphs = _stack$pop.glyphs;
                        _this3.ligatureStack = _stack$pop.ligatureStack;
                        input.pop();
                      }
                    });
                  };
                  return AATMorxProcessor2;
                }(), _applyDecoratedDescriptor(_class$2.prototype, "getStateMachine", [cache], Object.getOwnPropertyDescriptor(_class$2.prototype, "getStateMachine"), _class$2.prototype), _class$2);
                function swap(glyphs, rangeA, rangeB, reverseA, reverseB) {
                  if (reverseA === void 0) {
                    reverseA = false;
                  }
                  if (reverseB === void 0) {
                    reverseB = false;
                  }
                  var end = glyphs.splice(rangeB[0] - (rangeB[1] - 1), rangeB[1]);
                  if (reverseB) {
                    end.reverse();
                  }
                  var start = glyphs.splice.apply(glyphs, [rangeA[0], rangeA[1]].concat(end));
                  if (reverseA) {
                    start.reverse();
                  }
                  glyphs.splice.apply(glyphs, [rangeB[0] - (rangeA[1] - 1), 0].concat(start));
                  return glyphs;
                }
                function reorderGlyphs(glyphs, verb, firstGlyph, lastGlyph) {
                  switch (verb) {
                    case 0:
                      return glyphs;
                    case 1:
                      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 0]);
                    case 2:
                      return swap(glyphs, [firstGlyph, 0], [lastGlyph, 1]);
                    case 3:
                      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 1]);
                    case 4:
                      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 0]);
                    case 5:
                      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 0], true, false);
                    case 6:
                      return swap(glyphs, [firstGlyph, 0], [lastGlyph, 2]);
                    case 7:
                      return swap(glyphs, [firstGlyph, 0], [lastGlyph, 2], false, true);
                    case 8:
                      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 2]);
                    case 9:
                      return swap(glyphs, [firstGlyph, 1], [lastGlyph, 2], false, true);
                    case 10:
                      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 1]);
                    case 11:
                      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 1], true, false);
                    case 12:
                      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2]);
                    case 13:
                      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], true, false);
                    case 14:
                      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], false, true);
                    case 15:
                      return swap(glyphs, [firstGlyph, 2], [lastGlyph, 2], true, true);
                    default:
                      throw new Error("Unknown verb: ".concat(verb));
                  }
                }
                var AATLayoutEngine = function() {
                  function AATLayoutEngine2(font) {
                    this.font = font;
                    this.morxProcessor = new AATMorxProcessor(font);
                    this.fallbackPosition = false;
                  }
                  var _proto22 = AATLayoutEngine2.prototype;
                  _proto22.substitute = function substitute(glyphRun) {
                    if (glyphRun.direction === "rtl") {
                      glyphRun.glyphs.reverse();
                    }
                    this.morxProcessor.process(glyphRun.glyphs, mapOTToAAT(glyphRun.features));
                  };
                  _proto22.getAvailableFeatures = function getAvailableFeatures(script2, language) {
                    return mapAATToOT(this.morxProcessor.getSupportedFeatures());
                  };
                  _proto22.stringsForGlyph = function stringsForGlyph(gid) {
                    var glyphStrings = this.morxProcessor.generateInputs(gid);
                    var result = /* @__PURE__ */ new Set();
                    for (var _iterator31 = _createForOfIteratorHelperLoose(glyphStrings), _step31; !(_step31 = _iterator31()).done; ) {
                      var glyphs = _step31.value;
                      this._addStrings(glyphs, 0, result, "");
                    }
                    return result;
                  };
                  _proto22._addStrings = function _addStrings(glyphs, index, strings, string) {
                    var codePoints = this.font._cmapProcessor.codePointsForGlyph(glyphs[index]);
                    for (var _iterator32 = _createForOfIteratorHelperLoose(codePoints), _step32; !(_step32 = _iterator32()).done; ) {
                      var codePoint = _step32.value;
                      var s = string + String.fromCodePoint(codePoint);
                      if (index < glyphs.length - 1) {
                        this._addStrings(glyphs, index + 1, strings, s);
                      } else {
                        strings.add(s);
                      }
                    }
                  };
                  return AATLayoutEngine2;
                }();
                var ShapingPlan = function() {
                  function ShapingPlan2(font, script2, direction2) {
                    this.font = font;
                    this.script = script2;
                    this.direction = direction2;
                    this.stages = [];
                    this.globalFeatures = {};
                    this.allFeatures = {};
                  }
                  var _proto23 = ShapingPlan2.prototype;
                  _proto23._addFeatures = function _addFeatures(features2, global) {
                    var stageIndex = this.stages.length - 1;
                    var stage = this.stages[stageIndex];
                    for (var _iterator33 = _createForOfIteratorHelperLoose(features2), _step33; !(_step33 = _iterator33()).done; ) {
                      var feature2 = _step33.value;
                      if (this.allFeatures[feature2] == null) {
                        stage.push(feature2);
                        this.allFeatures[feature2] = stageIndex;
                        if (global) {
                          this.globalFeatures[feature2] = true;
                        }
                      }
                    }
                  };
                  _proto23.add = function add(arg, global) {
                    if (global === void 0) {
                      global = true;
                    }
                    if (this.stages.length === 0) {
                      this.stages.push([]);
                    }
                    if (typeof arg === "string") {
                      arg = [arg];
                    }
                    if (Array.isArray(arg)) {
                      this._addFeatures(arg, global);
                    } else if (typeof arg === "object") {
                      this._addFeatures(arg.global || [], true);
                      this._addFeatures(arg.local || [], false);
                    } else {
                      throw new Error("Unsupported argument to ShapingPlan#add");
                    }
                  };
                  _proto23.addStage = function addStage(arg, global) {
                    if (typeof arg === "function") {
                      this.stages.push(arg, []);
                    } else {
                      this.stages.push([]);
                      this.add(arg, global);
                    }
                  };
                  _proto23.setFeatureOverrides = function setFeatureOverrides(features2) {
                    if (Array.isArray(features2)) {
                      this.add(features2);
                    } else if (typeof features2 === "object") {
                      for (var tag2 in features2) {
                        if (features2[tag2]) {
                          this.add(tag2);
                        } else if (this.allFeatures[tag2] != null) {
                          var stage = this.stages[this.allFeatures[tag2]];
                          stage.splice(stage.indexOf(tag2), 1);
                          delete this.allFeatures[tag2];
                          delete this.globalFeatures[tag2];
                        }
                      }
                    }
                  };
                  _proto23.assignGlobalFeatures = function assignGlobalFeatures(glyphs) {
                    for (var _iterator34 = _createForOfIteratorHelperLoose(glyphs), _step34; !(_step34 = _iterator34()).done; ) {
                      var glyph2 = _step34.value;
                      for (var feature2 in this.globalFeatures) {
                        glyph2.features[feature2] = true;
                      }
                    }
                  };
                  _proto23.process = function process(processor, glyphs, positions) {
                    for (var _iterator35 = _createForOfIteratorHelperLoose(this.stages), _step35; !(_step35 = _iterator35()).done; ) {
                      var stage = _step35.value;
                      if (typeof stage === "function") {
                        if (!positions) {
                          stage(this.font, glyphs, this);
                        }
                      } else if (stage.length > 0) {
                        processor.applyFeatures(stage, glyphs, positions);
                      }
                    }
                  };
                  return ShapingPlan2;
                }();
                var VARIATION_FEATURES = ["rvrn"];
                var COMMON_FEATURES = ["ccmp", "locl", "rlig", "mark", "mkmk"];
                var FRACTIONAL_FEATURES = ["frac", "numr", "dnom"];
                var HORIZONTAL_FEATURES = ["calt", "clig", "liga", "rclt", "curs", "kern"];
                var DIRECTIONAL_FEATURES = {
                  ltr: ["ltra", "ltrm"],
                  rtl: ["rtla", "rtlm"]
                };
                var DefaultShaper = function() {
                  function DefaultShaper2() {
                  }
                  DefaultShaper2.plan = function plan(_plan, glyphs, features2) {
                    this.planPreprocessing(_plan);
                    this.planFeatures(_plan);
                    this.planPostprocessing(_plan, features2);
                    _plan.assignGlobalFeatures(glyphs);
                    this.assignFeatures(_plan, glyphs);
                  };
                  DefaultShaper2.planPreprocessing = function planPreprocessing(plan) {
                    plan.add({
                      global: [].concat(VARIATION_FEATURES, DIRECTIONAL_FEATURES[plan.direction]),
                      local: FRACTIONAL_FEATURES
                    });
                  };
                  DefaultShaper2.planFeatures = function planFeatures(plan) {
                  };
                  DefaultShaper2.planPostprocessing = function planPostprocessing(plan, userFeatures) {
                    plan.add([].concat(COMMON_FEATURES, HORIZONTAL_FEATURES));
                    plan.setFeatureOverrides(userFeatures);
                  };
                  DefaultShaper2.assignFeatures = function assignFeatures(plan, glyphs) {
                    for (var i2 = 0; i2 < glyphs.length; i2++) {
                      var glyph2 = glyphs[i2];
                      if (glyph2.codePoints[0] === 8260) {
                        var start = i2;
                        var end = i2 + 1;
                        while (start > 0 && unicode.isDigit(glyphs[start - 1].codePoints[0])) {
                          glyphs[start - 1].features.numr = true;
                          glyphs[start - 1].features.frac = true;
                          start--;
                        }
                        while (end < glyphs.length && unicode.isDigit(glyphs[end].codePoints[0])) {
                          glyphs[end].features.dnom = true;
                          glyphs[end].features.frac = true;
                          end++;
                        }
                        glyph2.features.frac = true;
                        i2 = end - 1;
                      }
                    }
                  };
                  return DefaultShaper2;
                }();
                _defineProperty(DefaultShaper, "zeroMarkWidths", "AFTER_GPOS");
                var trie = new UnicodeTrie(Buffer("APABAAAAAAAAOAAAAf0BAv7tmi1MxDAUx7vtvjhAgcDgkEgEAnmXEBIMCYaEcygEiqBQ4FAkCE4ikUgMiiBJSAgSiUQSDMn9L9eSl6bddddug9t7yS/trevre+3r27pcNxZiG+yCfdCVv/9LeQxOwRm4AJegD27ALbgD9+ABPJF+z+BN/h7yDj5k/VOWX6SdmU5+wLWknggxDxaS8u0qiiX4uiz9XamQ3wzDMAzDMAzDMAzDVI/h959V/v7BMAzDMAzDMLlyNTNiMSdewVxbiA44B4/guz1qW58VYlMI0WsJ0W+N6kXw0spvPtdwhtkwnGM6uLaV4Xyzg3v3PM9DPfQ/sOg4xPWjipy31P8LTqbU304c/cLCUmWJLNB2Uz2U1KTeRKNmKHVMfbJC+/0loTZRH/W5cvEvBJPMbREkWt3FD1NcqXZBSpuE2Ad0PBehPtNrPtIEdYP+hiRt/V1jIiE69X4NT/uVZI3PUHE9bm5M7ePGdZWy951v7Nn6j8v1WWKP3mt6ttnsigx6VN7Vc0VomSSGqW2mGNP1muZPl7LfjNUaKNFtDGVf2fvE9O7VlBS5j333c5p/eeoOqcs1R/hIqDWLJ7TTlksirVT1SI7l8k4Yp+g3jafGcrU1RM6l9th80XOpnlN97bDNY4i4s61B0Si/ipa0uHMl6zqEjlFfCZm/TM8KmzQDjmuTAQ==", "base64"));
                var FEATURES = ["isol", "fina", "fin2", "fin3", "medi", "med2", "init"];
                var ShapingClasses = {
                  Non_Joining: 0,
                  Left_Joining: 1,
                  Right_Joining: 2,
                  Dual_Joining: 3,
                  Join_Causing: 3,
                  ALAPH: 4,
                  "DALATH RISH": 5,
                  Transparent: 6
                };
                var ISOL = "isol";
                var FINA = "fina";
                var FIN2 = "fin2";
                var FIN3 = "fin3";
                var MEDI = "medi";
                var MED2 = "med2";
                var INIT = "init";
                var NONE = null;
                var STATE_TABLE = [
                  //   Non_Joining,        Left_Joining,       Right_Joining,     Dual_Joining,           ALAPH,            DALATH RISH
                  // State 0: prev was U,  not willing to join.
                  [[NONE, NONE, 0], [NONE, ISOL, 2], [NONE, ISOL, 1], [NONE, ISOL, 2], [NONE, ISOL, 1], [NONE, ISOL, 6]],
                  // State 1: prev was R or ISOL/ALAPH,  not willing to join.
                  [[NONE, NONE, 0], [NONE, ISOL, 2], [NONE, ISOL, 1], [NONE, ISOL, 2], [NONE, FIN2, 5], [NONE, ISOL, 6]],
                  // State 2: prev was D/L in ISOL form,  willing to join.
                  [[NONE, NONE, 0], [NONE, ISOL, 2], [INIT, FINA, 1], [INIT, FINA, 3], [INIT, FINA, 4], [INIT, FINA, 6]],
                  // State 3: prev was D in FINA form,  willing to join.
                  [[NONE, NONE, 0], [NONE, ISOL, 2], [MEDI, FINA, 1], [MEDI, FINA, 3], [MEDI, FINA, 4], [MEDI, FINA, 6]],
                  // State 4: prev was FINA ALAPH,  not willing to join.
                  [[NONE, NONE, 0], [NONE, ISOL, 2], [MED2, ISOL, 1], [MED2, ISOL, 2], [MED2, FIN2, 5], [MED2, ISOL, 6]],
                  // State 5: prev was FIN2/FIN3 ALAPH,  not willing to join.
                  [[NONE, NONE, 0], [NONE, ISOL, 2], [ISOL, ISOL, 1], [ISOL, ISOL, 2], [ISOL, FIN2, 5], [ISOL, ISOL, 6]],
                  // State 6: prev was DALATH/RISH,  not willing to join.
                  [[NONE, NONE, 0], [NONE, ISOL, 2], [NONE, ISOL, 1], [NONE, ISOL, 2], [NONE, FIN3, 5], [NONE, ISOL, 6]]
                ];
                var ArabicShaper = function(_DefaultShaper) {
                  _inheritsLoose(ArabicShaper2, _DefaultShaper);
                  function ArabicShaper2() {
                    return _DefaultShaper.apply(this, arguments) || this;
                  }
                  ArabicShaper2.planFeatures = function planFeatures(plan) {
                    plan.add(["ccmp", "locl"]);
                    for (var i2 = 0; i2 < FEATURES.length; i2++) {
                      var feature2 = FEATURES[i2];
                      plan.addStage(feature2, false);
                    }
                    plan.addStage("mset");
                  };
                  ArabicShaper2.assignFeatures = function assignFeatures(plan, glyphs) {
                    _DefaultShaper.assignFeatures.call(this, plan, glyphs);
                    var prev = -1;
                    var state = 0;
                    var actions = [];
                    for (var i2 = 0; i2 < glyphs.length; i2++) {
                      var curAction = void 0, prevAction = void 0;
                      var glyph2 = glyphs[i2];
                      var type = getShapingClass(glyph2.codePoints[0]);
                      if (type === ShapingClasses.Transparent) {
                        actions[i2] = NONE;
                        continue;
                      }
                      var _STATE_TABLE$state$ty = STATE_TABLE[state][type];
                      prevAction = _STATE_TABLE$state$ty[0];
                      curAction = _STATE_TABLE$state$ty[1];
                      state = _STATE_TABLE$state$ty[2];
                      if (prevAction !== NONE && prev !== -1) {
                        actions[prev] = prevAction;
                      }
                      actions[i2] = curAction;
                      prev = i2;
                    }
                    for (var index = 0; index < glyphs.length; index++) {
                      var feature2 = void 0;
                      var glyph2 = glyphs[index];
                      if (feature2 = actions[index]) {
                        glyph2.features[feature2] = true;
                      }
                    }
                  };
                  return ArabicShaper2;
                }(DefaultShaper);
                function getShapingClass(codePoint) {
                  var res = trie.get(codePoint);
                  if (res) {
                    return res - 1;
                  }
                  var category = unicode.getCategory(codePoint);
                  if (category === "Mn" || category === "Me" || category === "Cf") {
                    return ShapingClasses.Transparent;
                  }
                  return ShapingClasses.Non_Joining;
                }
                var GlyphIterator = function() {
                  function GlyphIterator2(glyphs, options) {
                    this.glyphs = glyphs;
                    this.reset(options);
                  }
                  var _proto24 = GlyphIterator2.prototype;
                  _proto24.reset = function reset(options, index) {
                    if (options === void 0) {
                      options = {};
                    }
                    if (index === void 0) {
                      index = 0;
                    }
                    this.options = options;
                    this.flags = options.flags || {};
                    this.markAttachmentType = options.markAttachmentType || 0;
                    this.index = index;
                  };
                  _proto24.shouldIgnore = function shouldIgnore(glyph2) {
                    return this.flags.ignoreMarks && glyph2.isMark || this.flags.ignoreBaseGlyphs && glyph2.isBase || this.flags.ignoreLigatures && glyph2.isLigature || this.markAttachmentType && glyph2.isMark && glyph2.markAttachmentType !== this.markAttachmentType;
                  };
                  _proto24.move = function move(dir) {
                    this.index += dir;
                    while (0 <= this.index && this.index < this.glyphs.length && this.shouldIgnore(this.glyphs[this.index])) {
                      this.index += dir;
                    }
                    if (0 > this.index || this.index >= this.glyphs.length) {
                      return null;
                    }
                    return this.glyphs[this.index];
                  };
                  _proto24.next = function next() {
                    return this.move(1);
                  };
                  _proto24.prev = function prev() {
                    return this.move(-1);
                  };
                  _proto24.peek = function peek(count) {
                    if (count === void 0) {
                      count = 1;
                    }
                    var idx = this.index;
                    var res = this.increment(count);
                    this.index = idx;
                    return res;
                  };
                  _proto24.peekIndex = function peekIndex(count) {
                    if (count === void 0) {
                      count = 1;
                    }
                    var idx = this.index;
                    this.increment(count);
                    var res = this.index;
                    this.index = idx;
                    return res;
                  };
                  _proto24.increment = function increment(count) {
                    if (count === void 0) {
                      count = 1;
                    }
                    var dir = count < 0 ? -1 : 1;
                    count = Math.abs(count);
                    while (count--) {
                      this.move(dir);
                    }
                    return this.glyphs[this.index];
                  };
                  _createClass(GlyphIterator2, [{
                    key: "cur",
                    get: function get() {
                      return this.glyphs[this.index] || null;
                    }
                  }]);
                  return GlyphIterator2;
                }();
                var DEFAULT_SCRIPTS = ["DFLT", "dflt", "latn"];
                var OTProcessor = function() {
                  function OTProcessor2(font, table) {
                    this.font = font;
                    this.table = table;
                    this.script = null;
                    this.scriptTag = null;
                    this.language = null;
                    this.languageTag = null;
                    this.features = {};
                    this.lookups = {};
                    this.variationsIndex = font._variationProcessor ? this.findVariationsIndex(font._variationProcessor.normalizedCoords) : -1;
                    this.selectScript();
                    this.glyphs = [];
                    this.positions = [];
                    this.ligatureID = 1;
                    this.currentFeature = null;
                  }
                  var _proto25 = OTProcessor2.prototype;
                  _proto25.findScript = function findScript(script2) {
                    if (this.table.scriptList == null) {
                      return null;
                    }
                    if (!Array.isArray(script2)) {
                      script2 = [script2];
                    }
                    for (var _iterator36 = _createForOfIteratorHelperLoose(script2), _step36; !(_step36 = _iterator36()).done; ) {
                      var s = _step36.value;
                      for (var _iterator37 = _createForOfIteratorHelperLoose(this.table.scriptList), _step37; !(_step37 = _iterator37()).done; ) {
                        var entry = _step37.value;
                        if (entry.tag === s) {
                          return entry;
                        }
                      }
                    }
                    return null;
                  };
                  _proto25.selectScript = function selectScript(script2, language, direction$1) {
                    var changed = false;
                    var entry;
                    if (!this.script || script2 !== this.scriptTag) {
                      entry = this.findScript(script2);
                      if (!entry) {
                        entry = this.findScript(DEFAULT_SCRIPTS);
                      }
                      if (!entry) {
                        return this.scriptTag;
                      }
                      this.scriptTag = entry.tag;
                      this.script = entry.script;
                      this.language = null;
                      this.languageTag = null;
                      changed = true;
                    }
                    if (!direction$1 || direction$1 !== this.direction) {
                      this.direction = direction$1 || direction(script2);
                    }
                    if (language && language.length < 4) {
                      language += " ".repeat(4 - language.length);
                    }
                    if (!language || language !== this.languageTag) {
                      this.language = null;
                      for (var _iterator38 = _createForOfIteratorHelperLoose(this.script.langSysRecords), _step38; !(_step38 = _iterator38()).done; ) {
                        var lang = _step38.value;
                        if (lang.tag === language) {
                          this.language = lang.langSys;
                          this.languageTag = lang.tag;
                          break;
                        }
                      }
                      if (!this.language) {
                        this.language = this.script.defaultLangSys;
                        this.languageTag = null;
                      }
                      changed = true;
                    }
                    if (changed) {
                      this.features = {};
                      if (this.language) {
                        for (var _iterator39 = _createForOfIteratorHelperLoose(this.language.featureIndexes), _step39; !(_step39 = _iterator39()).done; ) {
                          var featureIndex = _step39.value;
                          var record = this.table.featureList[featureIndex];
                          var substituteFeature = this.substituteFeatureForVariations(featureIndex);
                          this.features[record.tag] = substituteFeature || record.feature;
                        }
                      }
                    }
                    return this.scriptTag;
                  };
                  _proto25.lookupsForFeatures = function lookupsForFeatures(userFeatures, exclude) {
                    if (userFeatures === void 0) {
                      userFeatures = [];
                    }
                    var lookups = [];
                    for (var _iterator40 = _createForOfIteratorHelperLoose(userFeatures), _step40; !(_step40 = _iterator40()).done; ) {
                      var tag2 = _step40.value;
                      var feature2 = this.features[tag2];
                      if (!feature2) {
                        continue;
                      }
                      for (var _iterator41 = _createForOfIteratorHelperLoose(feature2.lookupListIndexes), _step41; !(_step41 = _iterator41()).done; ) {
                        var lookupIndex = _step41.value;
                        if (exclude && exclude.indexOf(lookupIndex) !== -1) {
                          continue;
                        }
                        lookups.push({
                          feature: tag2,
                          index: lookupIndex,
                          lookup: this.table.lookupList.get(lookupIndex)
                        });
                      }
                    }
                    lookups.sort(function(a, b) {
                      return a.index - b.index;
                    });
                    return lookups;
                  };
                  _proto25.substituteFeatureForVariations = function substituteFeatureForVariations(featureIndex) {
                    if (this.variationsIndex === -1) {
                      return null;
                    }
                    var record = this.table.featureVariations.featureVariationRecords[this.variationsIndex];
                    var substitutions = record.featureTableSubstitution.substitutions;
                    for (var _iterator42 = _createForOfIteratorHelperLoose(substitutions), _step42; !(_step42 = _iterator42()).done; ) {
                      var substitution = _step42.value;
                      if (substitution.featureIndex === featureIndex) {
                        return substitution.alternateFeatureTable;
                      }
                    }
                    return null;
                  };
                  _proto25.findVariationsIndex = function findVariationsIndex(coords) {
                    var variations = this.table.featureVariations;
                    if (!variations) {
                      return -1;
                    }
                    var records = variations.featureVariationRecords;
                    for (var i2 = 0; i2 < records.length; i2++) {
                      var conditions = records[i2].conditionSet.conditionTable;
                      if (this.variationConditionsMatch(conditions, coords)) {
                        return i2;
                      }
                    }
                    return -1;
                  };
                  _proto25.variationConditionsMatch = function variationConditionsMatch(conditions, coords) {
                    return conditions.every(function(condition) {
                      var coord = condition.axisIndex < coords.length ? coords[condition.axisIndex] : 0;
                      return condition.filterRangeMinValue <= coord && coord <= condition.filterRangeMaxValue;
                    });
                  };
                  _proto25.applyFeatures = function applyFeatures(userFeatures, glyphs, advances) {
                    var lookups = this.lookupsForFeatures(userFeatures);
                    this.applyLookups(lookups, glyphs, advances);
                  };
                  _proto25.applyLookups = function applyLookups(lookups, glyphs, positions) {
                    this.glyphs = glyphs;
                    this.positions = positions;
                    this.glyphIterator = new GlyphIterator(glyphs);
                    for (var _iterator43 = _createForOfIteratorHelperLoose(lookups), _step43; !(_step43 = _iterator43()).done; ) {
                      var _step43$value = _step43.value, feature2 = _step43$value.feature, lookup = _step43$value.lookup;
                      this.currentFeature = feature2;
                      this.glyphIterator.reset(lookup.flags);
                      while (this.glyphIterator.index < glyphs.length) {
                        if (!(feature2 in this.glyphIterator.cur.features)) {
                          this.glyphIterator.next();
                          continue;
                        }
                        for (var _iterator44 = _createForOfIteratorHelperLoose(lookup.subTables), _step44; !(_step44 = _iterator44()).done; ) {
                          var table = _step44.value;
                          var res = this.applyLookup(lookup.lookupType, table);
                          if (res) {
                            break;
                          }
                        }
                        this.glyphIterator.next();
                      }
                    }
                  };
                  _proto25.applyLookup = function applyLookup(lookup, table) {
                    throw new Error("applyLookup must be implemented by subclasses");
                  };
                  _proto25.applyLookupList = function applyLookupList(lookupRecords) {
                    var options = this.glyphIterator.options;
                    var glyphIndex = this.glyphIterator.index;
                    for (var _iterator45 = _createForOfIteratorHelperLoose(lookupRecords), _step45; !(_step45 = _iterator45()).done; ) {
                      var lookupRecord = _step45.value;
                      this.glyphIterator.reset(options, glyphIndex);
                      this.glyphIterator.increment(lookupRecord.sequenceIndex);
                      var lookup = this.table.lookupList.get(lookupRecord.lookupListIndex);
                      this.glyphIterator.reset(lookup.flags, this.glyphIterator.index);
                      for (var _iterator46 = _createForOfIteratorHelperLoose(lookup.subTables), _step46; !(_step46 = _iterator46()).done; ) {
                        var table = _step46.value;
                        if (this.applyLookup(lookup.lookupType, table)) {
                          break;
                        }
                      }
                    }
                    this.glyphIterator.reset(options, glyphIndex);
                    return true;
                  };
                  _proto25.coverageIndex = function coverageIndex(coverage, glyph2) {
                    if (glyph2 == null) {
                      glyph2 = this.glyphIterator.cur.id;
                    }
                    switch (coverage.version) {
                      case 1:
                        return coverage.glyphs.indexOf(glyph2);
                      case 2:
                        for (var _iterator47 = _createForOfIteratorHelperLoose(coverage.rangeRecords), _step47; !(_step47 = _iterator47()).done; ) {
                          var range2 = _step47.value;
                          if (range2.start <= glyph2 && glyph2 <= range2.end) {
                            return range2.startCoverageIndex + glyph2 - range2.start;
                          }
                        }
                        break;
                    }
                    return -1;
                  };
                  _proto25.match = function match(sequenceIndex, sequence, fn, matched) {
                    var pos = this.glyphIterator.index;
                    var glyph2 = this.glyphIterator.increment(sequenceIndex);
                    var idx = 0;
                    while (idx < sequence.length && glyph2 && fn(sequence[idx], glyph2)) {
                      if (matched) {
                        matched.push(this.glyphIterator.index);
                      }
                      idx++;
                      glyph2 = this.glyphIterator.next();
                    }
                    this.glyphIterator.index = pos;
                    if (idx < sequence.length) {
                      return false;
                    }
                    return matched || true;
                  };
                  _proto25.sequenceMatches = function sequenceMatches(sequenceIndex, sequence) {
                    return this.match(sequenceIndex, sequence, function(component, glyph2) {
                      return component === glyph2.id;
                    });
                  };
                  _proto25.sequenceMatchIndices = function sequenceMatchIndices(sequenceIndex, sequence) {
                    var _this4 = this;
                    return this.match(sequenceIndex, sequence, function(component, glyph2) {
                      if (!(_this4.currentFeature in glyph2.features)) {
                        return false;
                      }
                      return component === glyph2.id;
                    }, []);
                  };
                  _proto25.coverageSequenceMatches = function coverageSequenceMatches(sequenceIndex, sequence) {
                    var _this5 = this;
                    return this.match(sequenceIndex, sequence, function(coverage, glyph2) {
                      return _this5.coverageIndex(coverage, glyph2.id) >= 0;
                    });
                  };
                  _proto25.getClassID = function getClassID(glyph2, classDef) {
                    switch (classDef.version) {
                      case 1:
                        var i2 = glyph2 - classDef.startGlyph;
                        if (i2 >= 0 && i2 < classDef.classValueArray.length) {
                          return classDef.classValueArray[i2];
                        }
                        break;
                      case 2:
                        for (var _iterator48 = _createForOfIteratorHelperLoose(classDef.classRangeRecord), _step48; !(_step48 = _iterator48()).done; ) {
                          var range2 = _step48.value;
                          if (range2.start <= glyph2 && glyph2 <= range2.end) {
                            return range2.class;
                          }
                        }
                        break;
                    }
                    return 0;
                  };
                  _proto25.classSequenceMatches = function classSequenceMatches(sequenceIndex, sequence, classDef) {
                    var _this6 = this;
                    return this.match(sequenceIndex, sequence, function(classID, glyph2) {
                      return classID === _this6.getClassID(glyph2.id, classDef);
                    });
                  };
                  _proto25.applyContext = function applyContext(table) {
                    switch (table.version) {
                      case 1:
                        var index = this.coverageIndex(table.coverage);
                        if (index === -1) {
                          return false;
                        }
                        var set = table.ruleSets[index];
                        for (var _iterator49 = _createForOfIteratorHelperLoose(set), _step49; !(_step49 = _iterator49()).done; ) {
                          var rule = _step49.value;
                          if (this.sequenceMatches(1, rule.input)) {
                            return this.applyLookupList(rule.lookupRecords);
                          }
                        }
                        break;
                      case 2:
                        if (this.coverageIndex(table.coverage) === -1) {
                          return false;
                        }
                        index = this.getClassID(this.glyphIterator.cur.id, table.classDef);
                        if (index === -1) {
                          return false;
                        }
                        set = table.classSet[index];
                        for (var _iterator50 = _createForOfIteratorHelperLoose(set), _step50; !(_step50 = _iterator50()).done; ) {
                          var _rule = _step50.value;
                          if (this.classSequenceMatches(1, _rule.classes, table.classDef)) {
                            return this.applyLookupList(_rule.lookupRecords);
                          }
                        }
                        break;
                      case 3:
                        if (this.coverageSequenceMatches(0, table.coverages)) {
                          return this.applyLookupList(table.lookupRecords);
                        }
                        break;
                    }
                    return false;
                  };
                  _proto25.applyChainingContext = function applyChainingContext(table) {
                    switch (table.version) {
                      case 1:
                        var index = this.coverageIndex(table.coverage);
                        if (index === -1) {
                          return false;
                        }
                        var set = table.chainRuleSets[index];
                        for (var _iterator51 = _createForOfIteratorHelperLoose(set), _step51; !(_step51 = _iterator51()).done; ) {
                          var rule = _step51.value;
                          if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack) && this.sequenceMatches(1, rule.input) && this.sequenceMatches(1 + rule.input.length, rule.lookahead)) {
                            return this.applyLookupList(rule.lookupRecords);
                          }
                        }
                        break;
                      case 2:
                        if (this.coverageIndex(table.coverage) === -1) {
                          return false;
                        }
                        index = this.getClassID(this.glyphIterator.cur.id, table.inputClassDef);
                        var rules = table.chainClassSet[index];
                        if (!rules) {
                          return false;
                        }
                        for (var _iterator52 = _createForOfIteratorHelperLoose(rules), _step52; !(_step52 = _iterator52()).done; ) {
                          var _rule2 = _step52.value;
                          if (this.classSequenceMatches(-_rule2.backtrack.length, _rule2.backtrack, table.backtrackClassDef) && this.classSequenceMatches(1, _rule2.input, table.inputClassDef) && this.classSequenceMatches(1 + _rule2.input.length, _rule2.lookahead, table.lookaheadClassDef)) {
                            return this.applyLookupList(_rule2.lookupRecords);
                          }
                        }
                        break;
                      case 3:
                        if (this.coverageSequenceMatches(-table.backtrackGlyphCount, table.backtrackCoverage) && this.coverageSequenceMatches(0, table.inputCoverage) && this.coverageSequenceMatches(table.inputGlyphCount, table.lookaheadCoverage)) {
                          return this.applyLookupList(table.lookupRecords);
                        }
                        break;
                    }
                    return false;
                  };
                  return OTProcessor2;
                }();
                var GlyphInfo = function() {
                  function GlyphInfo2(font, id, codePoints, features2) {
                    if (codePoints === void 0) {
                      codePoints = [];
                    }
                    this._font = font;
                    this.codePoints = codePoints;
                    this.id = id;
                    this.features = {};
                    if (Array.isArray(features2)) {
                      for (var i2 = 0; i2 < features2.length; i2++) {
                        var feature2 = features2[i2];
                        this.features[feature2] = true;
                      }
                    } else if (typeof features2 === "object") {
                      Object.assign(this.features, features2);
                    }
                    this.ligatureID = null;
                    this.ligatureComponent = null;
                    this.isLigated = false;
                    this.cursiveAttachment = null;
                    this.markAttachment = null;
                    this.shaperInfo = null;
                    this.substituted = false;
                    this.isMultiplied = false;
                  }
                  var _proto26 = GlyphInfo2.prototype;
                  _proto26.copy = function copy() {
                    return new GlyphInfo2(this._font, this.id, this.codePoints, this.features);
                  };
                  _createClass(GlyphInfo2, [{
                    key: "id",
                    get: function get() {
                      return this._id;
                    },
                    set: function set(id) {
                      this._id = id;
                      this.substituted = true;
                      var GDEF2 = this._font.GDEF;
                      if (GDEF2 && GDEF2.glyphClassDef) {
                        var classID = OTProcessor.prototype.getClassID(id, GDEF2.glyphClassDef);
                        this.isBase = classID === 1;
                        this.isLigature = classID === 2;
                        this.isMark = classID === 3;
                        this.markAttachmentType = GDEF2.markAttachClassDef ? OTProcessor.prototype.getClassID(id, GDEF2.markAttachClassDef) : 0;
                      } else {
                        this.isMark = this.codePoints.length > 0 && this.codePoints.every(unicode.isMark);
                        this.isBase = !this.isMark;
                        this.isLigature = this.codePoints.length > 1;
                        this.markAttachmentType = 0;
                      }
                    }
                  }]);
                  return GlyphInfo2;
                }();
                var HangulShaper = function(_DefaultShaper2) {
                  _inheritsLoose(HangulShaper2, _DefaultShaper2);
                  function HangulShaper2() {
                    return _DefaultShaper2.apply(this, arguments) || this;
                  }
                  HangulShaper2.planFeatures = function planFeatures(plan) {
                    plan.add(["ljmo", "vjmo", "tjmo"], false);
                  };
                  HangulShaper2.assignFeatures = function assignFeatures(plan, glyphs) {
                    var state = 0;
                    var i2 = 0;
                    while (i2 < glyphs.length) {
                      var action = void 0;
                      var glyph2 = glyphs[i2];
                      var code = glyph2.codePoints[0];
                      var type = getType(code);
                      var _STATE_TABLE$1$state$ = STATE_TABLE$1[state][type];
                      action = _STATE_TABLE$1$state$[0];
                      state = _STATE_TABLE$1$state$[1];
                      switch (action) {
                        case DECOMPOSE:
                          if (!plan.font.hasGlyphForCodePoint(code)) {
                            i2 = decompose(glyphs, i2, plan.font);
                          }
                          break;
                        case COMPOSE:
                          i2 = compose(glyphs, i2, plan.font);
                          break;
                        case TONE_MARK:
                          reorderToneMark(glyphs, i2, plan.font);
                          break;
                        case INVALID:
                          i2 = insertDottedCircle(glyphs, i2, plan.font);
                          break;
                      }
                      i2++;
                    }
                  };
                  return HangulShaper2;
                }(DefaultShaper);
                _defineProperty(HangulShaper, "zeroMarkWidths", "NONE");
                var HANGUL_BASE = 44032;
                var HANGUL_END = 55204;
                var HANGUL_COUNT = HANGUL_END - HANGUL_BASE + 1;
                var L_BASE = 4352;
                var V_BASE = 4449;
                var T_BASE = 4519;
                var L_COUNT = 19;
                var V_COUNT = 21;
                var T_COUNT = 28;
                var L_END = L_BASE + L_COUNT - 1;
                var V_END = V_BASE + V_COUNT - 1;
                var T_END = T_BASE + T_COUNT - 1;
                var DOTTED_CIRCLE = 9676;
                var isL = function isL2(code) {
                  return 4352 <= code && code <= 4447 || 43360 <= code && code <= 43388;
                };
                var isV = function isV2(code) {
                  return 4448 <= code && code <= 4519 || 55216 <= code && code <= 55238;
                };
                var isT = function isT2(code) {
                  return 4520 <= code && code <= 4607 || 55243 <= code && code <= 55291;
                };
                var isTone = function isTone2(code) {
                  return 12334 <= code && code <= 12335;
                };
                var isLVT = function isLVT2(code) {
                  return HANGUL_BASE <= code && code <= HANGUL_END;
                };
                var isLV = function isLV2(code) {
                  return code - HANGUL_BASE < HANGUL_COUNT && (code - HANGUL_BASE) % T_COUNT === 0;
                };
                var isCombiningL = function isCombiningL2(code) {
                  return L_BASE <= code && code <= L_END;
                };
                var isCombiningV = function isCombiningV2(code) {
                  return V_BASE <= code && code <= V_END;
                };
                var isCombiningT = function isCombiningT2(code) {
                  return 1 <= code && code <= T_END;
                };
                var X = 0;
                var L = 1;
                var V = 2;
                var T = 3;
                var LV = 4;
                var LVT = 5;
                var M = 6;
                function getType(code) {
                  if (isL(code)) {
                    return L;
                  }
                  if (isV(code)) {
                    return V;
                  }
                  if (isT(code)) {
                    return T;
                  }
                  if (isLV(code)) {
                    return LV;
                  }
                  if (isLVT(code)) {
                    return LVT;
                  }
                  if (isTone(code)) {
                    return M;
                  }
                  return X;
                }
                var NO_ACTION = 0;
                var DECOMPOSE = 1;
                var COMPOSE = 2;
                var TONE_MARK = 4;
                var INVALID = 5;
                var STATE_TABLE$1 = [
                  //       X                 L                 V                T                  LV                LVT               M
                  // State 0: start state
                  [[NO_ACTION, 0], [NO_ACTION, 1], [NO_ACTION, 0], [NO_ACTION, 0], [DECOMPOSE, 2], [DECOMPOSE, 3], [INVALID, 0]],
                  // State 1: <L>
                  [[NO_ACTION, 0], [NO_ACTION, 1], [COMPOSE, 2], [NO_ACTION, 0], [DECOMPOSE, 2], [DECOMPOSE, 3], [INVALID, 0]],
                  // State 2: <L,V> or <LV>
                  [[NO_ACTION, 0], [NO_ACTION, 1], [NO_ACTION, 0], [COMPOSE, 3], [DECOMPOSE, 2], [DECOMPOSE, 3], [TONE_MARK, 0]],
                  // State 3: <L,V,T> or <LVT>
                  [[NO_ACTION, 0], [NO_ACTION, 1], [NO_ACTION, 0], [NO_ACTION, 0], [DECOMPOSE, 2], [DECOMPOSE, 3], [TONE_MARK, 0]]
                ];
                function getGlyph(font, code, features2) {
                  return new GlyphInfo(font, font.glyphForCodePoint(code).id, [code], features2);
                }
                function decompose(glyphs, i2, font) {
                  var glyph2 = glyphs[i2];
                  var code = glyph2.codePoints[0];
                  var s = code - HANGUL_BASE;
                  var t2 = T_BASE + s % T_COUNT;
                  s = s / T_COUNT | 0;
                  var l = L_BASE + s / V_COUNT | 0;
                  var v = V_BASE + s % V_COUNT;
                  if (!font.hasGlyphForCodePoint(l) || !font.hasGlyphForCodePoint(v) || t2 !== T_BASE && !font.hasGlyphForCodePoint(t2)) {
                    return i2;
                  }
                  var ljmo = getGlyph(font, l, glyph2.features);
                  ljmo.features.ljmo = true;
                  var vjmo = getGlyph(font, v, glyph2.features);
                  vjmo.features.vjmo = true;
                  var insert = [ljmo, vjmo];
                  if (t2 > T_BASE) {
                    var tjmo = getGlyph(font, t2, glyph2.features);
                    tjmo.features.tjmo = true;
                    insert.push(tjmo);
                  }
                  glyphs.splice.apply(glyphs, [i2, 1].concat(insert));
                  return i2 + insert.length - 1;
                }
                function compose(glyphs, i2, font) {
                  var glyph2 = glyphs[i2];
                  var code = glyphs[i2].codePoints[0];
                  var type = getType(code);
                  var prev = glyphs[i2 - 1].codePoints[0];
                  var prevType = getType(prev);
                  var lv, ljmo, vjmo, tjmo;
                  if (prevType === LV && type === T) {
                    lv = prev;
                    tjmo = glyph2;
                  } else {
                    if (type === V) {
                      ljmo = glyphs[i2 - 1];
                      vjmo = glyph2;
                    } else {
                      ljmo = glyphs[i2 - 2];
                      vjmo = glyphs[i2 - 1];
                      tjmo = glyph2;
                    }
                    var l = ljmo.codePoints[0];
                    var v = vjmo.codePoints[0];
                    if (isCombiningL(l) && isCombiningV(v)) {
                      lv = HANGUL_BASE + ((l - L_BASE) * V_COUNT + (v - V_BASE)) * T_COUNT;
                    }
                  }
                  var t2 = tjmo && tjmo.codePoints[0] || T_BASE;
                  if (lv != null && (t2 === T_BASE || isCombiningT(t2))) {
                    var s = lv + (t2 - T_BASE);
                    if (font.hasGlyphForCodePoint(s)) {
                      var del = prevType === V ? 3 : 2;
                      glyphs.splice(i2 - del + 1, del, getGlyph(font, s, glyph2.features));
                      return i2 - del + 1;
                    }
                  }
                  if (ljmo) {
                    ljmo.features.ljmo = true;
                  }
                  if (vjmo) {
                    vjmo.features.vjmo = true;
                  }
                  if (tjmo) {
                    tjmo.features.tjmo = true;
                  }
                  if (prevType === LV) {
                    decompose(glyphs, i2 - 1, font);
                    return i2 + 1;
                  }
                  return i2;
                }
                function getLength(code) {
                  switch (getType(code)) {
                    case LV:
                    case LVT:
                      return 1;
                    case V:
                      return 2;
                    case T:
                      return 3;
                  }
                }
                function reorderToneMark(glyphs, i2, font) {
                  var glyph2 = glyphs[i2];
                  var code = glyphs[i2].codePoints[0];
                  if (font.glyphForCodePoint(code).advanceWidth === 0) {
                    return;
                  }
                  var prev = glyphs[i2 - 1].codePoints[0];
                  var len = getLength(prev);
                  glyphs.splice(i2, 1);
                  return glyphs.splice(i2 - len, 0, glyph2);
                }
                function insertDottedCircle(glyphs, i2, font) {
                  var glyph2 = glyphs[i2];
                  var code = glyphs[i2].codePoints[0];
                  if (font.hasGlyphForCodePoint(DOTTED_CIRCLE)) {
                    var dottedCircle = getGlyph(font, DOTTED_CIRCLE, glyph2.features);
                    var idx = font.glyphForCodePoint(code).advanceWidth === 0 ? i2 : i2 + 1;
                    glyphs.splice(idx, 0, dottedCircle);
                    i2++;
                  }
                  return i2;
                }
                var stateTable = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 3, 4, 5, 6, 7, 8, 9, 0, 10, 11, 11, 12, 13, 14, 15, 16, 17], [0, 0, 0, 18, 19, 20, 21, 22, 23, 0, 24, 0, 0, 25, 26, 0, 0, 27, 0], [0, 0, 0, 28, 29, 30, 31, 32, 33, 0, 34, 0, 0, 35, 36, 0, 0, 37, 0], [0, 0, 0, 38, 5, 7, 7, 8, 9, 0, 10, 0, 0, 0, 13, 0, 0, 16, 0], [0, 39, 0, 0, 0, 40, 41, 0, 9, 0, 10, 0, 0, 0, 42, 0, 39, 0, 0], [0, 0, 0, 0, 43, 44, 44, 8, 9, 0, 0, 0, 0, 12, 43, 0, 0, 0, 0], [0, 0, 0, 0, 43, 44, 44, 8, 9, 0, 0, 0, 0, 0, 43, 0, 0, 0, 0], [0, 0, 0, 45, 46, 47, 48, 49, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 50, 0, 0, 51, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 53, 54, 55, 56, 57, 58, 0, 59, 0, 0, 60, 61, 0, 0, 62, 0], [0, 0, 0, 4, 5, 7, 7, 8, 9, 0, 10, 0, 0, 0, 13, 0, 0, 16, 0], [0, 63, 64, 0, 0, 40, 41, 0, 9, 0, 10, 0, 0, 0, 42, 0, 63, 0, 0], [0, 2, 3, 4, 5, 6, 7, 8, 9, 0, 10, 11, 11, 12, 13, 0, 2, 16, 0], [0, 0, 0, 18, 65, 20, 21, 22, 23, 0, 24, 0, 0, 25, 26, 0, 0, 27, 0], [0, 0, 0, 0, 66, 67, 67, 8, 9, 0, 10, 0, 0, 0, 68, 0, 0, 0, 0], [0, 0, 0, 69, 0, 70, 70, 0, 71, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 73, 19, 74, 74, 22, 23, 0, 24, 0, 0, 0, 26, 0, 0, 27, 0], [0, 75, 0, 0, 0, 76, 77, 0, 23, 0, 24, 0, 0, 0, 78, 0, 75, 0, 0], [0, 0, 0, 0, 79, 80, 80, 22, 23, 0, 0, 0, 0, 25, 79, 0, 0, 0, 0], [0, 0, 0, 18, 19, 20, 74, 22, 23, 0, 24, 0, 0, 25, 26, 0, 0, 27, 0], [0, 0, 0, 81, 82, 83, 84, 85, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 0, 86, 0, 0, 87, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 88, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 18, 19, 74, 74, 22, 23, 0, 24, 0, 0, 0, 26, 0, 0, 27, 0], [0, 89, 90, 0, 0, 76, 77, 0, 23, 0, 24, 0, 0, 0, 78, 0, 89, 0, 0], [0, 0, 0, 0, 91, 92, 92, 22, 23, 0, 24, 0, 0, 0, 93, 0, 0, 0, 0], [0, 0, 0, 94, 29, 95, 31, 32, 33, 0, 34, 0, 0, 0, 36, 0, 0, 37, 0], [0, 96, 0, 0, 0, 97, 98, 0, 33, 0, 34, 0, 0, 0, 99, 0, 96, 0, 0], [0, 0, 0, 0, 100, 101, 101, 32, 33, 0, 0, 0, 0, 35, 100, 0, 0, 0, 0], [0, 0, 0, 0, 100, 101, 101, 32, 33, 0, 0, 0, 0, 0, 100, 0, 0, 0, 0], [0, 0, 0, 102, 103, 104, 105, 106, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 0, 107, 0, 0, 108, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 109, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 28, 29, 95, 31, 32, 33, 0, 34, 0, 0, 0, 36, 0, 0, 37, 0], [0, 110, 111, 0, 0, 97, 98, 0, 33, 0, 34, 0, 0, 0, 99, 0, 110, 0, 0], [0, 0, 0, 0, 112, 113, 113, 32, 33, 0, 34, 0, 0, 0, 114, 0, 0, 0, 0], [0, 0, 0, 0, 5, 7, 7, 8, 9, 0, 10, 0, 0, 0, 13, 0, 0, 16, 0], [0, 0, 0, 115, 116, 117, 118, 8, 9, 0, 10, 0, 0, 119, 120, 0, 0, 16, 0], [0, 0, 0, 0, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 39, 0, 122, 0, 123, 123, 8, 9, 0, 10, 0, 0, 0, 42, 0, 39, 0, 0], [0, 124, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 124, 0, 0], [0, 39, 0, 0, 0, 121, 125, 0, 9, 0, 10, 0, 0, 0, 42, 0, 39, 0, 0], [0, 0, 0, 0, 0, 126, 126, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 46, 47, 48, 49, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 47, 47, 49, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 127, 127, 49, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 128, 127, 127, 49, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 129, 130, 131, 132, 133, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 50, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 134, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 135, 54, 56, 56, 57, 58, 0, 59, 0, 0, 0, 61, 0, 0, 62, 0], [0, 136, 0, 0, 0, 137, 138, 0, 58, 0, 59, 0, 0, 0, 139, 0, 136, 0, 0], [0, 0, 0, 0, 140, 141, 141, 57, 58, 0, 0, 0, 0, 60, 140, 0, 0, 0, 0], [0, 0, 0, 0, 140, 141, 141, 57, 58, 0, 0, 0, 0, 0, 140, 0, 0, 0, 0], [0, 0, 0, 142, 143, 144, 145, 146, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 147, 0, 0, 148, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 149, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 53, 54, 56, 56, 57, 58, 0, 59, 0, 0, 0, 61, 0, 0, 62, 0], [0, 150, 151, 0, 0, 137, 138, 0, 58, 0, 59, 0, 0, 0, 139, 0, 150, 0, 0], [0, 0, 0, 0, 152, 153, 153, 57, 58, 0, 59, 0, 0, 0, 154, 0, 0, 0, 0], [0, 0, 0, 155, 116, 156, 157, 8, 9, 0, 10, 0, 0, 158, 120, 0, 0, 16, 0], [0, 0, 0, 0, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0], [0, 75, 3, 4, 5, 159, 160, 8, 161, 0, 162, 0, 11, 12, 163, 0, 75, 16, 0], [0, 0, 0, 0, 0, 40, 164, 0, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 165, 44, 44, 8, 9, 0, 0, 0, 0, 0, 165, 0, 0, 0, 0], [0, 124, 64, 0, 0, 40, 164, 0, 9, 0, 10, 0, 0, 0, 42, 0, 124, 0, 0], [0, 0, 0, 0, 0, 70, 70, 0, 71, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 166, 0, 0, 167, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 168, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 19, 74, 74, 22, 23, 0, 24, 0, 0, 0, 26, 0, 0, 27, 0], [0, 0, 0, 0, 79, 80, 80, 22, 23, 0, 0, 0, 0, 0, 79, 0, 0, 0, 0], [0, 0, 0, 169, 170, 171, 172, 22, 23, 0, 24, 0, 0, 173, 174, 0, 0, 27, 0], [0, 0, 0, 0, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 75, 0, 176, 0, 177, 177, 22, 23, 0, 24, 0, 0, 0, 78, 0, 75, 0, 0], [0, 178, 90, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 178, 0, 0], [0, 75, 0, 0, 0, 175, 179, 0, 23, 0, 24, 0, 0, 0, 78, 0, 75, 0, 0], [0, 0, 0, 0, 0, 180, 180, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 82, 83, 84, 85, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 0, 83, 83, 85, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 0, 181, 181, 85, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 182, 181, 181, 85, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 183, 184, 185, 186, 187, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 86, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 188, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 189, 170, 190, 191, 22, 23, 0, 24, 0, 0, 192, 174, 0, 0, 27, 0], [0, 0, 0, 0, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 76, 193, 0, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 194, 80, 80, 22, 23, 0, 0, 0, 0, 0, 194, 0, 0, 0, 0], [0, 178, 90, 0, 0, 76, 193, 0, 23, 0, 24, 0, 0, 0, 78, 0, 178, 0, 0], [0, 0, 0, 0, 29, 95, 31, 32, 33, 0, 34, 0, 0, 0, 36, 0, 0, 37, 0], [0, 0, 0, 0, 100, 101, 101, 32, 33, 0, 0, 0, 0, 0, 100, 0, 0, 0, 0], [0, 0, 0, 195, 196, 197, 198, 32, 33, 0, 34, 0, 0, 199, 200, 0, 0, 37, 0], [0, 0, 0, 0, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 96, 0, 202, 0, 203, 203, 32, 33, 0, 34, 0, 0, 0, 99, 0, 96, 0, 0], [0, 204, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 204, 0, 0], [0, 96, 0, 0, 0, 201, 205, 0, 33, 0, 34, 0, 0, 0, 99, 0, 96, 0, 0], [0, 0, 0, 0, 0, 206, 206, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 103, 104, 105, 106, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 0, 104, 104, 106, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 0, 207, 207, 106, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 208, 207, 207, 106, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 209, 210, 211, 212, 213, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 107, 0, 0, 0, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 214, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 215, 196, 216, 217, 32, 33, 0, 34, 0, 0, 218, 200, 0, 0, 37, 0], [0, 0, 0, 0, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 97, 219, 0, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 220, 101, 101, 32, 33, 0, 0, 0, 0, 0, 220, 0, 0, 0, 0], [0, 204, 111, 0, 0, 97, 219, 0, 33, 0, 34, 0, 0, 0, 99, 0, 204, 0, 0], [0, 0, 0, 221, 116, 222, 222, 8, 9, 0, 10, 0, 0, 0, 120, 0, 0, 16, 0], [0, 223, 0, 0, 0, 40, 224, 0, 9, 0, 10, 0, 0, 0, 42, 0, 223, 0, 0], [0, 0, 0, 0, 225, 44, 44, 8, 9, 0, 0, 0, 0, 119, 225, 0, 0, 0, 0], [0, 0, 0, 115, 116, 117, 222, 8, 9, 0, 10, 0, 0, 119, 120, 0, 0, 16, 0], [0, 0, 0, 115, 116, 222, 222, 8, 9, 0, 10, 0, 0, 0, 120, 0, 0, 16, 0], [0, 226, 64, 0, 0, 40, 224, 0, 9, 0, 10, 0, 0, 0, 42, 0, 226, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 39, 0, 0, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 42, 0, 39, 0, 0], [0, 0, 0, 0, 0, 44, 44, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 227, 0, 228, 229, 0, 9, 0, 10, 0, 0, 230, 0, 0, 0, 0, 0], [0, 39, 0, 122, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 42, 0, 39, 0, 0], [0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 231, 231, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 232, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 130, 131, 132, 133, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 131, 131, 133, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 233, 233, 133, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 234, 233, 233, 133, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 235, 236, 237, 238, 239, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 54, 56, 56, 57, 58, 0, 59, 0, 0, 0, 61, 0, 0, 62, 0], [0, 0, 0, 240, 241, 242, 243, 57, 58, 0, 59, 0, 0, 244, 245, 0, 0, 62, 0], [0, 0, 0, 0, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 136, 0, 247, 0, 248, 248, 57, 58, 0, 59, 0, 0, 0, 139, 0, 136, 0, 0], [0, 249, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 249, 0, 0], [0, 136, 0, 0, 0, 246, 250, 0, 58, 0, 59, 0, 0, 0, 139, 0, 136, 0, 0], [0, 0, 0, 0, 0, 251, 251, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 143, 144, 145, 146, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 144, 144, 146, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 252, 252, 146, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 253, 252, 252, 146, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 254, 255, 256, 257, 258, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 147, 0, 0, 0, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 259, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 260, 241, 261, 262, 57, 58, 0, 59, 0, 0, 263, 245, 0, 0, 62, 0], [0, 0, 0, 0, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 137, 264, 0, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 265, 141, 141, 57, 58, 0, 0, 0, 0, 0, 265, 0, 0, 0, 0], [0, 249, 151, 0, 0, 137, 264, 0, 58, 0, 59, 0, 0, 0, 139, 0, 249, 0, 0], [0, 0, 0, 221, 116, 222, 222, 8, 9, 0, 10, 0, 0, 0, 120, 0, 0, 16, 0], [0, 0, 0, 0, 225, 44, 44, 8, 9, 0, 0, 0, 0, 158, 225, 0, 0, 0, 0], [0, 0, 0, 155, 116, 156, 222, 8, 9, 0, 10, 0, 0, 158, 120, 0, 0, 16, 0], [0, 0, 0, 155, 116, 222, 222, 8, 9, 0, 10, 0, 0, 0, 120, 0, 0, 16, 0], [0, 0, 0, 0, 43, 266, 266, 8, 161, 0, 24, 0, 0, 12, 267, 0, 0, 0, 0], [0, 75, 0, 176, 43, 268, 268, 269, 161, 0, 24, 0, 0, 0, 267, 0, 75, 0, 0], [0, 0, 0, 0, 0, 270, 0, 0, 271, 0, 162, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 272, 0, 0, 0, 0, 0, 0, 0, 0], [0, 273, 274, 0, 0, 40, 41, 0, 9, 0, 10, 0, 0, 0, 42, 0, 273, 0, 0], [0, 0, 0, 40, 0, 123, 123, 8, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 121, 275, 0, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 166, 0, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 276, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 277, 170, 278, 278, 22, 23, 0, 24, 0, 0, 0, 174, 0, 0, 27, 0], [0, 279, 0, 0, 0, 76, 280, 0, 23, 0, 24, 0, 0, 0, 78, 0, 279, 0, 0], [0, 0, 0, 0, 281, 80, 80, 22, 23, 0, 0, 0, 0, 173, 281, 0, 0, 0, 0], [0, 0, 0, 169, 170, 171, 278, 22, 23, 0, 24, 0, 0, 173, 174, 0, 0, 27, 0], [0, 0, 0, 169, 170, 278, 278, 22, 23, 0, 24, 0, 0, 0, 174, 0, 0, 27, 0], [0, 282, 90, 0, 0, 76, 280, 0, 23, 0, 24, 0, 0, 0, 78, 0, 282, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 75, 0, 0, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 78, 0, 75, 0, 0], [0, 0, 0, 0, 0, 80, 80, 22, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 283, 0, 284, 285, 0, 23, 0, 24, 0, 0, 286, 0, 0, 0, 0, 0], [0, 75, 0, 176, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 78, 0, 75, 0, 0], [0, 0, 0, 0, 0, 0, 0, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 287, 287, 85, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 288, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 184, 185, 186, 187, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 0, 185, 185, 187, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 0, 289, 289, 187, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 290, 289, 289, 187, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 291, 292, 293, 294, 295, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 277, 170, 278, 278, 22, 23, 0, 24, 0, 0, 0, 174, 0, 0, 27, 0], [0, 0, 0, 0, 281, 80, 80, 22, 23, 0, 0, 0, 0, 192, 281, 0, 0, 0, 0], [0, 0, 0, 189, 170, 190, 278, 22, 23, 0, 24, 0, 0, 192, 174, 0, 0, 27, 0], [0, 0, 0, 189, 170, 278, 278, 22, 23, 0, 24, 0, 0, 0, 174, 0, 0, 27, 0], [0, 0, 0, 76, 0, 177, 177, 22, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 0, 175, 296, 0, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 297, 196, 298, 298, 32, 33, 0, 34, 0, 0, 0, 200, 0, 0, 37, 0], [0, 299, 0, 0, 0, 97, 300, 0, 33, 0, 34, 0, 0, 0, 99, 0, 299, 0, 0], [0, 0, 0, 0, 301, 101, 101, 32, 33, 0, 0, 0, 0, 199, 301, 0, 0, 0, 0], [0, 0, 0, 195, 196, 197, 298, 32, 33, 0, 34, 0, 0, 199, 200, 0, 0, 37, 0], [0, 0, 0, 195, 196, 298, 298, 32, 33, 0, 34, 0, 0, 0, 200, 0, 0, 37, 0], [0, 302, 111, 0, 0, 97, 300, 0, 33, 0, 34, 0, 0, 0, 99, 0, 302, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 96, 0, 0, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 99, 0, 96, 0, 0], [0, 0, 0, 0, 0, 101, 101, 32, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 303, 0, 304, 305, 0, 33, 0, 34, 0, 0, 306, 0, 0, 0, 0, 0], [0, 96, 0, 202, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 99, 0, 96, 0, 0], [0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 307, 307, 106, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 308, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 210, 211, 212, 213, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 0, 211, 211, 213, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 0, 309, 309, 213, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 310, 309, 309, 213, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 311, 312, 313, 314, 315, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 297, 196, 298, 298, 32, 33, 0, 34, 0, 0, 0, 200, 0, 0, 37, 0], [0, 0, 0, 0, 301, 101, 101, 32, 33, 0, 0, 0, 0, 218, 301, 0, 0, 0, 0], [0, 0, 0, 215, 196, 216, 298, 32, 33, 0, 34, 0, 0, 218, 200, 0, 0, 37, 0], [0, 0, 0, 215, 196, 298, 298, 32, 33, 0, 34, 0, 0, 0, 200, 0, 0, 37, 0], [0, 0, 0, 97, 0, 203, 203, 32, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 0, 201, 316, 0, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 116, 222, 222, 8, 9, 0, 10, 0, 0, 0, 120, 0, 0, 16, 0], [0, 0, 0, 0, 225, 44, 44, 8, 9, 0, 0, 0, 0, 0, 225, 0, 0, 0, 0], [0, 0, 0, 317, 318, 319, 320, 8, 9, 0, 10, 0, 0, 321, 322, 0, 0, 16, 0], [0, 223, 0, 323, 0, 123, 123, 8, 9, 0, 10, 0, 0, 0, 42, 0, 223, 0, 0], [0, 223, 0, 0, 0, 121, 324, 0, 9, 0, 10, 0, 0, 0, 42, 0, 223, 0, 0], [0, 0, 0, 325, 318, 326, 327, 8, 9, 0, 10, 0, 0, 328, 322, 0, 0, 16, 0], [0, 0, 0, 64, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 230, 0, 0, 0, 0, 0], [0, 0, 0, 227, 0, 228, 121, 0, 9, 0, 10, 0, 0, 230, 0, 0, 0, 0, 0], [0, 0, 0, 227, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 46, 0, 0], [0, 0, 0, 0, 0, 329, 329, 133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 330, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 236, 237, 238, 239, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 237, 237, 239, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 331, 331, 239, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 332, 331, 331, 239, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 333, 40, 121, 334, 0, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 335, 241, 336, 336, 57, 58, 0, 59, 0, 0, 0, 245, 0, 0, 62, 0], [0, 337, 0, 0, 0, 137, 338, 0, 58, 0, 59, 0, 0, 0, 139, 0, 337, 0, 0], [0, 0, 0, 0, 339, 141, 141, 57, 58, 0, 0, 0, 0, 244, 339, 0, 0, 0, 0], [0, 0, 0, 240, 241, 242, 336, 57, 58, 0, 59, 0, 0, 244, 245, 0, 0, 62, 0], [0, 0, 0, 240, 241, 336, 336, 57, 58, 0, 59, 0, 0, 0, 245, 0, 0, 62, 0], [0, 340, 151, 0, 0, 137, 338, 0, 58, 0, 59, 0, 0, 0, 139, 0, 340, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 136, 0, 0, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 139, 0, 136, 0, 0], [0, 0, 0, 0, 0, 141, 141, 57, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 341, 0, 342, 343, 0, 58, 0, 59, 0, 0, 344, 0, 0, 0, 0, 0], [0, 136, 0, 247, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 139, 0, 136, 0, 0], [0, 0, 0, 0, 0, 0, 0, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 345, 345, 146, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 346, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 255, 256, 257, 258, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 256, 256, 258, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 347, 347, 258, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 348, 347, 347, 258, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 349, 350, 351, 352, 353, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 335, 241, 336, 336, 57, 58, 0, 59, 0, 0, 0, 245, 0, 0, 62, 0], [0, 0, 0, 0, 339, 141, 141, 57, 58, 0, 0, 0, 0, 263, 339, 0, 0, 0, 0], [0, 0, 0, 260, 241, 261, 336, 57, 58, 0, 59, 0, 0, 263, 245, 0, 0, 62, 0], [0, 0, 0, 260, 241, 336, 336, 57, 58, 0, 59, 0, 0, 0, 245, 0, 0, 62, 0], [0, 0, 0, 137, 0, 248, 248, 57, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 246, 354, 0, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 126, 126, 8, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 355, 90, 0, 0, 121, 125, 0, 9, 0, 10, 0, 0, 0, 42, 0, 355, 0, 0], [0, 0, 0, 0, 0, 356, 356, 269, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 357, 358, 359, 360, 361, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 162, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 270, 0, 0, 0, 0, 162, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 363, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 364, 116, 365, 366, 8, 161, 0, 162, 0, 0, 367, 120, 0, 0, 16, 0], [0, 0, 0, 0, 0, 368, 368, 0, 161, 0, 162, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 40, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 170, 278, 278, 22, 23, 0, 24, 0, 0, 0, 174, 0, 0, 27, 0], [0, 0, 0, 0, 281, 80, 80, 22, 23, 0, 0, 0, 0, 0, 281, 0, 0, 0, 0], [0, 0, 0, 369, 370, 371, 372, 22, 23, 0, 24, 0, 0, 373, 374, 0, 0, 27, 0], [0, 279, 0, 375, 0, 177, 177, 22, 23, 0, 24, 0, 0, 0, 78, 0, 279, 0, 0], [0, 279, 0, 0, 0, 175, 376, 0, 23, 0, 24, 0, 0, 0, 78, 0, 279, 0, 0], [0, 0, 0, 377, 370, 378, 379, 22, 23, 0, 24, 0, 0, 380, 374, 0, 0, 27, 0], [0, 0, 0, 90, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 286, 0, 0, 0, 0, 0], [0, 0, 0, 283, 0, 284, 175, 0, 23, 0, 24, 0, 0, 286, 0, 0, 0, 0, 0], [0, 0, 0, 283, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 85, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 82, 0, 0], [0, 0, 0, 0, 0, 381, 381, 187, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 382, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 292, 293, 294, 295, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 0, 293, 293, 295, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 0, 383, 383, 295, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 384, 383, 383, 295, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 385, 76, 175, 386, 0, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 76, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 196, 298, 298, 32, 33, 0, 34, 0, 0, 0, 200, 0, 0, 37, 0], [0, 0, 0, 0, 301, 101, 101, 32, 33, 0, 0, 0, 0, 0, 301, 0, 0, 0, 0], [0, 0, 0, 387, 388, 389, 390, 32, 33, 0, 34, 0, 0, 391, 392, 0, 0, 37, 0], [0, 299, 0, 393, 0, 203, 203, 32, 33, 0, 34, 0, 0, 0, 99, 0, 299, 0, 0], [0, 299, 0, 0, 0, 201, 394, 0, 33, 0, 34, 0, 0, 0, 99, 0, 299, 0, 0], [0, 0, 0, 395, 388, 396, 397, 32, 33, 0, 34, 0, 0, 398, 392, 0, 0, 37, 0], [0, 0, 0, 111, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 33, 0, 0, 0, 0, 306, 0, 0, 0, 0, 0], [0, 0, 0, 303, 0, 304, 201, 0, 33, 0, 34, 0, 0, 306, 0, 0, 0, 0, 0], [0, 0, 0, 303, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 106, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 103, 0, 0], [0, 0, 0, 0, 0, 399, 399, 213, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 400, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 312, 313, 314, 315, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 0, 313, 313, 315, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 0, 401, 401, 315, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 402, 401, 401, 315, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 403, 97, 201, 404, 0, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 97, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 405, 318, 406, 406, 8, 9, 0, 10, 0, 0, 0, 322, 0, 0, 16, 0], [0, 407, 0, 0, 0, 40, 408, 0, 9, 0, 10, 0, 0, 0, 42, 0, 407, 0, 0], [0, 0, 0, 0, 409, 44, 44, 8, 9, 0, 0, 0, 0, 321, 409, 0, 0, 0, 0], [0, 0, 0, 317, 318, 319, 406, 8, 9, 0, 10, 0, 0, 321, 322, 0, 0, 16, 0], [0, 0, 0, 317, 318, 406, 406, 8, 9, 0, 10, 0, 0, 0, 322, 0, 0, 16, 0], [0, 410, 64, 0, 0, 40, 408, 0, 9, 0, 10, 0, 0, 0, 42, 0, 410, 0, 0], [0, 223, 0, 0, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 42, 0, 223, 0, 0], [0, 223, 0, 323, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 42, 0, 223, 0, 0], [0, 0, 0, 405, 318, 406, 406, 8, 9, 0, 10, 0, 0, 0, 322, 0, 0, 16, 0], [0, 0, 0, 0, 409, 44, 44, 8, 9, 0, 0, 0, 0, 328, 409, 0, 0, 0, 0], [0, 0, 0, 325, 318, 326, 406, 8, 9, 0, 10, 0, 0, 328, 322, 0, 0, 16, 0], [0, 0, 0, 325, 318, 406, 406, 8, 9, 0, 10, 0, 0, 0, 322, 0, 0, 16, 0], [0, 0, 0, 0, 0, 0, 0, 133, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 130, 0, 0], [0, 0, 0, 0, 0, 411, 411, 239, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 412, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 40, 121, 334, 0, 9, 0, 10, 0, 0, 0, 42, 0, 0, 0, 0], [0, 0, 0, 0, 413, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 241, 336, 336, 57, 58, 0, 59, 0, 0, 0, 245, 0, 0, 62, 0], [0, 0, 0, 0, 339, 141, 141, 57, 58, 0, 0, 0, 0, 0, 339, 0, 0, 0, 0], [0, 0, 0, 414, 415, 416, 417, 57, 58, 0, 59, 0, 0, 418, 419, 0, 0, 62, 0], [0, 337, 0, 420, 0, 248, 248, 57, 58, 0, 59, 0, 0, 0, 139, 0, 337, 0, 0], [0, 337, 0, 0, 0, 246, 421, 0, 58, 0, 59, 0, 0, 0, 139, 0, 337, 0, 0], [0, 0, 0, 422, 415, 423, 424, 57, 58, 0, 59, 0, 0, 425, 419, 0, 0, 62, 0], [0, 0, 0, 151, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 58, 0, 0, 0, 0, 344, 0, 0, 0, 0, 0], [0, 0, 0, 341, 0, 342, 246, 0, 58, 0, 59, 0, 0, 344, 0, 0, 0, 0, 0], [0, 0, 0, 341, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 146, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0], [0, 0, 0, 0, 0, 426, 426, 258, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 427, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 350, 351, 352, 353, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 351, 351, 353, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 0, 428, 428, 353, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 429, 428, 428, 353, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 430, 137, 246, 431, 0, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 137, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 432, 116, 433, 434, 8, 161, 0, 162, 0, 0, 435, 120, 0, 0, 16, 0], [0, 0, 0, 0, 0, 180, 180, 269, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 358, 359, 360, 361, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 0, 0, 359, 359, 361, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 0, 0, 436, 436, 361, 161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 437, 436, 436, 361, 161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 438, 439, 440, 441, 442, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 443, 274, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 443, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 444, 116, 445, 445, 8, 161, 0, 162, 0, 0, 0, 120, 0, 0, 16, 0], [0, 0, 0, 0, 225, 44, 44, 8, 161, 0, 0, 0, 0, 367, 225, 0, 0, 0, 0], [0, 0, 0, 364, 116, 365, 445, 8, 161, 0, 162, 0, 0, 367, 120, 0, 0, 16, 0], [0, 0, 0, 364, 116, 445, 445, 8, 161, 0, 162, 0, 0, 0, 120, 0, 0, 16, 0], [0, 0, 0, 0, 0, 0, 0, 0, 161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 446, 370, 447, 447, 22, 23, 0, 24, 0, 0, 0, 374, 0, 0, 27, 0], [0, 448, 0, 0, 0, 76, 449, 0, 23, 0, 24, 0, 0, 0, 78, 0, 448, 0, 0], [0, 0, 0, 0, 450, 80, 80, 22, 23, 0, 0, 0, 0, 373, 450, 0, 0, 0, 0], [0, 0, 0, 369, 370, 371, 447, 22, 23, 0, 24, 0, 0, 373, 374, 0, 0, 27, 0], [0, 0, 0, 369, 370, 447, 447, 22, 23, 0, 24, 0, 0, 0, 374, 0, 0, 27, 0], [0, 451, 90, 0, 0, 76, 449, 0, 23, 0, 24, 0, 0, 0, 78, 0, 451, 0, 0], [0, 279, 0, 0, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 78, 0, 279, 0, 0], [0, 279, 0, 375, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 78, 0, 279, 0, 0], [0, 0, 0, 446, 370, 447, 447, 22, 23, 0, 24, 0, 0, 0, 374, 0, 0, 27, 0], [0, 0, 0, 0, 450, 80, 80, 22, 23, 0, 0, 0, 0, 380, 450, 0, 0, 0, 0], [0, 0, 0, 377, 370, 378, 447, 22, 23, 0, 24, 0, 0, 380, 374, 0, 0, 27, 0], [0, 0, 0, 377, 370, 447, 447, 22, 23, 0, 24, 0, 0, 0, 374, 0, 0, 27, 0], [0, 0, 0, 0, 0, 0, 0, 187, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 184, 0, 0], [0, 0, 0, 0, 0, 452, 452, 295, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 453, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 76, 175, 386, 0, 23, 0, 24, 0, 0, 0, 78, 0, 0, 0, 0], [0, 0, 0, 0, 454, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 455, 388, 456, 456, 32, 33, 0, 34, 0, 0, 0, 392, 0, 0, 37, 0], [0, 457, 0, 0, 0, 97, 458, 0, 33, 0, 34, 0, 0, 0, 99, 0, 457, 0, 0], [0, 0, 0, 0, 459, 101, 101, 32, 33, 0, 0, 0, 0, 391, 459, 0, 0, 0, 0], [0, 0, 0, 387, 388, 389, 456, 32, 33, 0, 34, 0, 0, 391, 392, 0, 0, 37, 0], [0, 0, 0, 387, 388, 456, 456, 32, 33, 0, 34, 0, 0, 0, 392, 0, 0, 37, 0], [0, 460, 111, 0, 0, 97, 458, 0, 33, 0, 34, 0, 0, 0, 99, 0, 460, 0, 0], [0, 299, 0, 0, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 99, 0, 299, 0, 0], [0, 299, 0, 393, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 99, 0, 299, 0, 0], [0, 0, 0, 455, 388, 456, 456, 32, 33, 0, 34, 0, 0, 0, 392, 0, 0, 37, 0], [0, 0, 0, 0, 459, 101, 101, 32, 33, 0, 0, 0, 0, 398, 459, 0, 0, 0, 0], [0, 0, 0, 395, 388, 396, 456, 32, 33, 0, 34, 0, 0, 398, 392, 0, 0, 37, 0], [0, 0, 0, 395, 388, 456, 456, 32, 33, 0, 34, 0, 0, 0, 392, 0, 0, 37, 0], [0, 0, 0, 0, 0, 0, 0, 213, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 210, 0, 0], [0, 0, 0, 0, 0, 461, 461, 315, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 462, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 97, 201, 404, 0, 33, 0, 34, 0, 0, 0, 99, 0, 0, 0, 0], [0, 0, 0, 0, 463, 0, 0, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 318, 406, 406, 8, 9, 0, 10, 0, 0, 0, 322, 0, 0, 16, 0], [0, 0, 0, 0, 409, 44, 44, 8, 9, 0, 0, 0, 0, 0, 409, 0, 0, 0, 0], [0, 0, 0, 464, 465, 466, 467, 8, 9, 0, 10, 0, 0, 468, 469, 0, 0, 16, 0], [0, 407, 0, 470, 0, 123, 123, 8, 9, 0, 10, 0, 0, 0, 42, 0, 407, 0, 0], [0, 407, 0, 0, 0, 121, 471, 0, 9, 0, 10, 0, 0, 0, 42, 0, 407, 0, 0], [0, 0, 0, 472, 465, 473, 474, 8, 9, 0, 10, 0, 0, 475, 469, 0, 0, 16, 0], [0, 0, 0, 0, 0, 0, 0, 239, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 236, 0, 0], [0, 0, 0, 0, 0, 0, 476, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 477, 415, 478, 478, 57, 58, 0, 59, 0, 0, 0, 419, 0, 0, 62, 0], [0, 479, 0, 0, 0, 137, 480, 0, 58, 0, 59, 0, 0, 0, 139, 0, 479, 0, 0], [0, 0, 0, 0, 481, 141, 141, 57, 58, 0, 0, 0, 0, 418, 481, 0, 0, 0, 0], [0, 0, 0, 414, 415, 416, 478, 57, 58, 0, 59, 0, 0, 418, 419, 0, 0, 62, 0], [0, 0, 0, 414, 415, 478, 478, 57, 58, 0, 59, 0, 0, 0, 419, 0, 0, 62, 0], [0, 482, 151, 0, 0, 137, 480, 0, 58, 0, 59, 0, 0, 0, 139, 0, 482, 0, 0], [0, 337, 0, 0, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 139, 0, 337, 0, 0], [0, 337, 0, 420, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 139, 0, 337, 0, 0], [0, 0, 0, 477, 415, 478, 478, 57, 58, 0, 59, 0, 0, 0, 419, 0, 0, 62, 0], [0, 0, 0, 0, 481, 141, 141, 57, 58, 0, 0, 0, 0, 425, 481, 0, 0, 0, 0], [0, 0, 0, 422, 415, 423, 478, 57, 58, 0, 59, 0, 0, 425, 419, 0, 0, 62, 0], [0, 0, 0, 422, 415, 478, 478, 57, 58, 0, 59, 0, 0, 0, 419, 0, 0, 62, 0], [0, 0, 0, 0, 0, 0, 0, 258, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0], [0, 0, 0, 0, 0, 483, 483, 353, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 484, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 137, 246, 431, 0, 58, 0, 59, 0, 0, 0, 139, 0, 0, 0, 0], [0, 0, 0, 0, 485, 0, 0, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 444, 116, 445, 445, 8, 161, 0, 162, 0, 0, 0, 120, 0, 0, 16, 0], [0, 0, 0, 0, 225, 44, 44, 8, 161, 0, 0, 0, 0, 435, 225, 0, 0, 0, 0], [0, 0, 0, 432, 116, 433, 445, 8, 161, 0, 162, 0, 0, 435, 120, 0, 0, 16, 0], [0, 0, 0, 432, 116, 445, 445, 8, 161, 0, 162, 0, 0, 0, 120, 0, 0, 16, 0], [0, 0, 0, 0, 0, 486, 486, 361, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 487, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 439, 440, 441, 442, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 0, 0, 440, 440, 442, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 0, 0, 488, 488, 442, 161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 489, 488, 488, 442, 161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 490, 491, 492, 493, 494, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 495, 0, 496, 497, 0, 161, 0, 162, 0, 0, 498, 0, 0, 0, 0, 0], [0, 0, 0, 0, 116, 445, 445, 8, 161, 0, 162, 0, 0, 0, 120, 0, 0, 16, 0], [0, 0, 0, 0, 225, 44, 44, 8, 161, 0, 0, 0, 0, 0, 225, 0, 0, 0, 0], [0, 0, 0, 0, 370, 447, 447, 22, 23, 0, 24, 0, 0, 0, 374, 0, 0, 27, 0], [0, 0, 0, 0, 450, 80, 80, 22, 23, 0, 0, 0, 0, 0, 450, 0, 0, 0, 0], [0, 0, 0, 499, 500, 501, 502, 22, 23, 0, 24, 0, 0, 503, 504, 0, 0, 27, 0], [0, 448, 0, 505, 0, 177, 177, 22, 23, 0, 24, 0, 0, 0, 78, 0, 448, 0, 0], [0, 448, 0, 0, 0, 175, 506, 0, 23, 0, 24, 0, 0, 0, 78, 0, 448, 0, 0], [0, 0, 0, 507, 500, 508, 509, 22, 23, 0, 24, 0, 0, 510, 504, 0, 0, 27, 0], [0, 0, 0, 0, 0, 0, 0, 295, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 292, 0, 0], [0, 0, 0, 0, 0, 0, 511, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 388, 456, 456, 32, 33, 0, 34, 0, 0, 0, 392, 0, 0, 37, 0], [0, 0, 0, 0, 459, 101, 101, 32, 33, 0, 0, 0, 0, 0, 459, 0, 0, 0, 0], [0, 0, 0, 512, 513, 514, 515, 32, 33, 0, 34, 0, 0, 516, 517, 0, 0, 37, 0], [0, 457, 0, 518, 0, 203, 203, 32, 33, 0, 34, 0, 0, 0, 99, 0, 457, 0, 0], [0, 457, 0, 0, 0, 201, 519, 0, 33, 0, 34, 0, 0, 0, 99, 0, 457, 0, 0], [0, 0, 0, 520, 513, 521, 522, 32, 33, 0, 34, 0, 0, 523, 517, 0, 0, 37, 0], [0, 0, 0, 0, 0, 0, 0, 315, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 312, 0, 0], [0, 0, 0, 0, 0, 0, 524, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 525, 465, 526, 526, 8, 9, 0, 10, 0, 0, 0, 469, 0, 0, 16, 0], [0, 527, 0, 0, 0, 40, 528, 0, 9, 0, 10, 0, 0, 0, 42, 0, 527, 0, 0], [0, 0, 0, 0, 529, 44, 44, 8, 9, 0, 0, 0, 0, 468, 529, 0, 0, 0, 0], [0, 0, 0, 464, 465, 466, 526, 8, 9, 0, 10, 0, 0, 468, 469, 0, 0, 16, 0], [0, 0, 0, 464, 465, 526, 526, 8, 9, 0, 10, 0, 0, 0, 469, 0, 0, 16, 0], [0, 530, 64, 0, 0, 40, 528, 0, 9, 0, 10, 0, 0, 0, 42, 0, 530, 0, 0], [0, 407, 0, 0, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 42, 0, 407, 0, 0], [0, 407, 0, 470, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 42, 0, 407, 0, 0], [0, 0, 0, 525, 465, 526, 526, 8, 9, 0, 10, 0, 0, 0, 469, 0, 0, 16, 0], [0, 0, 0, 0, 529, 44, 44, 8, 9, 0, 0, 0, 0, 475, 529, 0, 0, 0, 0], [0, 0, 0, 472, 465, 473, 526, 8, 9, 0, 10, 0, 0, 475, 469, 0, 0, 16, 0], [0, 0, 0, 472, 465, 526, 526, 8, 9, 0, 10, 0, 0, 0, 469, 0, 0, 16, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0], [0, 0, 0, 0, 415, 478, 478, 57, 58, 0, 59, 0, 0, 0, 419, 0, 0, 62, 0], [0, 0, 0, 0, 481, 141, 141, 57, 58, 0, 0, 0, 0, 0, 481, 0, 0, 0, 0], [0, 0, 0, 531, 532, 533, 534, 57, 58, 0, 59, 0, 0, 535, 536, 0, 0, 62, 0], [0, 479, 0, 537, 0, 248, 248, 57, 58, 0, 59, 0, 0, 0, 139, 0, 479, 0, 0], [0, 479, 0, 0, 0, 246, 538, 0, 58, 0, 59, 0, 0, 0, 139, 0, 479, 0, 0], [0, 0, 0, 539, 532, 540, 541, 57, 58, 0, 59, 0, 0, 542, 536, 0, 0, 62, 0], [0, 0, 0, 0, 0, 0, 0, 353, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 350, 0, 0], [0, 0, 0, 0, 0, 0, 543, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 361, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 358, 0, 0], [0, 0, 0, 0, 0, 544, 544, 442, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 545, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 491, 492, 493, 494, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 0, 0, 492, 492, 494, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 0, 0, 546, 546, 494, 161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 547, 546, 546, 494, 161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 548, 549, 368, 550, 0, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 274, 0, 368, 368, 0, 161, 0, 162, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 161, 0, 0, 0, 0, 498, 0, 0, 0, 0, 0], [0, 0, 0, 495, 0, 496, 368, 0, 161, 0, 162, 0, 0, 498, 0, 0, 0, 0, 0], [0, 0, 0, 495, 0, 368, 368, 0, 161, 0, 162, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 551, 500, 552, 552, 22, 23, 0, 24, 0, 0, 0, 504, 0, 0, 27, 0], [0, 553, 0, 0, 0, 76, 554, 0, 23, 0, 24, 0, 0, 0, 78, 0, 553, 0, 0], [0, 0, 0, 0, 555, 80, 80, 22, 23, 0, 0, 0, 0, 503, 555, 0, 0, 0, 0], [0, 0, 0, 499, 500, 501, 552, 22, 23, 0, 24, 0, 0, 503, 504, 0, 0, 27, 0], [0, 0, 0, 499, 500, 552, 552, 22, 23, 0, 24, 0, 0, 0, 504, 0, 0, 27, 0], [0, 556, 90, 0, 0, 76, 554, 0, 23, 0, 24, 0, 0, 0, 78, 0, 556, 0, 0], [0, 448, 0, 0, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 78, 0, 448, 0, 0], [0, 448, 0, 505, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 78, 0, 448, 0, 0], [0, 0, 0, 551, 500, 552, 552, 22, 23, 0, 24, 0, 0, 0, 504, 0, 0, 27, 0], [0, 0, 0, 0, 555, 80, 80, 22, 23, 0, 0, 0, 0, 510, 555, 0, 0, 0, 0], [0, 0, 0, 507, 500, 508, 552, 22, 23, 0, 24, 0, 0, 510, 504, 0, 0, 27, 0], [0, 0, 0, 507, 500, 552, 552, 22, 23, 0, 24, 0, 0, 0, 504, 0, 0, 27, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 76, 0, 0], [0, 0, 0, 557, 513, 558, 558, 32, 33, 0, 34, 0, 0, 0, 517, 0, 0, 37, 0], [0, 559, 0, 0, 0, 97, 560, 0, 33, 0, 34, 0, 0, 0, 99, 0, 559, 0, 0], [0, 0, 0, 0, 561, 101, 101, 32, 33, 0, 0, 0, 0, 516, 561, 0, 0, 0, 0], [0, 0, 0, 512, 513, 514, 558, 32, 33, 0, 34, 0, 0, 516, 517, 0, 0, 37, 0], [0, 0, 0, 512, 513, 558, 558, 32, 33, 0, 34, 0, 0, 0, 517, 0, 0, 37, 0], [0, 562, 111, 0, 0, 97, 560, 0, 33, 0, 34, 0, 0, 0, 99, 0, 562, 0, 0], [0, 457, 0, 0, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 99, 0, 457, 0, 0], [0, 457, 0, 518, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 99, 0, 457, 0, 0], [0, 0, 0, 557, 513, 558, 558, 32, 33, 0, 34, 0, 0, 0, 517, 0, 0, 37, 0], [0, 0, 0, 0, 561, 101, 101, 32, 33, 0, 0, 0, 0, 523, 561, 0, 0, 0, 0], [0, 0, 0, 520, 513, 521, 558, 32, 33, 0, 34, 0, 0, 523, 517, 0, 0, 37, 0], [0, 0, 0, 520, 513, 558, 558, 32, 33, 0, 34, 0, 0, 0, 517, 0, 0, 37, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 97, 0, 0], [0, 0, 0, 0, 465, 526, 526, 8, 9, 0, 10, 0, 0, 0, 469, 0, 0, 16, 0], [0, 0, 0, 0, 529, 44, 44, 8, 9, 0, 0, 0, 0, 0, 529, 0, 0, 0, 0], [0, 0, 0, 563, 66, 564, 565, 8, 9, 0, 10, 0, 0, 566, 68, 0, 0, 16, 0], [0, 527, 0, 567, 0, 123, 123, 8, 9, 0, 10, 0, 0, 0, 42, 0, 527, 0, 0], [0, 527, 0, 0, 0, 121, 568, 0, 9, 0, 10, 0, 0, 0, 42, 0, 527, 0, 0], [0, 0, 0, 569, 66, 570, 571, 8, 9, 0, 10, 0, 0, 572, 68, 0, 0, 16, 0], [0, 0, 0, 573, 532, 574, 574, 57, 58, 0, 59, 0, 0, 0, 536, 0, 0, 62, 0], [0, 575, 0, 0, 0, 137, 576, 0, 58, 0, 59, 0, 0, 0, 139, 0, 575, 0, 0], [0, 0, 0, 0, 577, 141, 141, 57, 58, 0, 0, 0, 0, 535, 577, 0, 0, 0, 0], [0, 0, 0, 531, 532, 533, 574, 57, 58, 0, 59, 0, 0, 535, 536, 0, 0, 62, 0], [0, 0, 0, 531, 532, 574, 574, 57, 58, 0, 59, 0, 0, 0, 536, 0, 0, 62, 0], [0, 578, 151, 0, 0, 137, 576, 0, 58, 0, 59, 0, 0, 0, 139, 0, 578, 0, 0], [0, 479, 0, 0, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 139, 0, 479, 0, 0], [0, 479, 0, 537, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 139, 0, 479, 0, 0], [0, 0, 0, 573, 532, 574, 574, 57, 58, 0, 59, 0, 0, 0, 536, 0, 0, 62, 0], [0, 0, 0, 0, 577, 141, 141, 57, 58, 0, 0, 0, 0, 542, 577, 0, 0, 0, 0], [0, 0, 0, 539, 532, 540, 574, 57, 58, 0, 59, 0, 0, 542, 536, 0, 0, 62, 0], [0, 0, 0, 539, 532, 574, 574, 57, 58, 0, 59, 0, 0, 0, 536, 0, 0, 62, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 137, 0, 0], [0, 0, 0, 0, 0, 0, 0, 442, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 439, 0, 0], [0, 0, 0, 0, 0, 579, 579, 494, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 580, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 549, 368, 550, 0, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 0, 0, 368, 368, 0, 161, 0, 162, 0, 0, 0, 362, 0, 0, 0, 0], [0, 0, 0, 0, 581, 0, 0, 0, 161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 500, 552, 552, 22, 23, 0, 24, 0, 0, 0, 504, 0, 0, 27, 0], [0, 0, 0, 0, 555, 80, 80, 22, 23, 0, 0, 0, 0, 0, 555, 0, 0, 0, 0], [0, 0, 0, 582, 91, 583, 584, 22, 23, 0, 24, 0, 0, 585, 93, 0, 0, 27, 0], [0, 553, 0, 586, 0, 177, 177, 22, 23, 0, 24, 0, 0, 0, 78, 0, 553, 0, 0], [0, 553, 0, 0, 0, 175, 587, 0, 23, 0, 24, 0, 0, 0, 78, 0, 553, 0, 0], [0, 0, 0, 588, 91, 589, 590, 22, 23, 0, 24, 0, 0, 591, 93, 0, 0, 27, 0], [0, 0, 0, 0, 513, 558, 558, 32, 33, 0, 34, 0, 0, 0, 517, 0, 0, 37, 0], [0, 0, 0, 0, 561, 101, 101, 32, 33, 0, 0, 0, 0, 0, 561, 0, 0, 0, 0], [0, 0, 0, 592, 112, 593, 594, 32, 33, 0, 34, 0, 0, 595, 114, 0, 0, 37, 0], [0, 559, 0, 596, 0, 203, 203, 32, 33, 0, 34, 0, 0, 0, 99, 0, 559, 0, 0], [0, 559, 0, 0, 0, 201, 597, 0, 33, 0, 34, 0, 0, 0, 99, 0, 559, 0, 0], [0, 0, 0, 598, 112, 599, 600, 32, 33, 0, 34, 0, 0, 601, 114, 0, 0, 37, 0], [0, 0, 0, 602, 66, 67, 67, 8, 9, 0, 10, 0, 0, 0, 68, 0, 0, 16, 0], [0, 0, 0, 0, 165, 44, 44, 8, 9, 0, 0, 0, 0, 566, 165, 0, 0, 0, 0], [0, 0, 0, 563, 66, 564, 67, 8, 9, 0, 10, 0, 0, 566, 68, 0, 0, 16, 0], [0, 0, 0, 563, 66, 67, 67, 8, 9, 0, 10, 0, 0, 0, 68, 0, 0, 16, 0], [0, 527, 0, 0, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 42, 0, 527, 0, 0], [0, 527, 0, 567, 0, 121, 121, 0, 9, 0, 10, 0, 0, 0, 42, 0, 527, 0, 0], [0, 0, 0, 602, 66, 67, 67, 8, 9, 0, 10, 0, 0, 0, 68, 0, 0, 16, 0], [0, 0, 0, 0, 165, 44, 44, 8, 9, 0, 0, 0, 0, 572, 165, 0, 0, 0, 0], [0, 0, 0, 569, 66, 570, 67, 8, 9, 0, 10, 0, 0, 572, 68, 0, 0, 16, 0], [0, 0, 0, 569, 66, 67, 67, 8, 9, 0, 10, 0, 0, 0, 68, 0, 0, 16, 0], [0, 0, 0, 0, 532, 574, 574, 57, 58, 0, 59, 0, 0, 0, 536, 0, 0, 62, 0], [0, 0, 0, 0, 577, 141, 141, 57, 58, 0, 0, 0, 0, 0, 577, 0, 0, 0, 0], [0, 0, 0, 603, 152, 604, 605, 57, 58, 0, 59, 0, 0, 606, 154, 0, 0, 62, 0], [0, 575, 0, 607, 0, 248, 248, 57, 58, 0, 59, 0, 0, 0, 139, 0, 575, 0, 0], [0, 575, 0, 0, 0, 246, 608, 0, 58, 0, 59, 0, 0, 0, 139, 0, 575, 0, 0], [0, 0, 0, 609, 152, 610, 611, 57, 58, 0, 59, 0, 0, 612, 154, 0, 0, 62, 0], [0, 0, 0, 0, 0, 0, 0, 494, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 491, 0, 0], [0, 0, 0, 0, 0, 0, 613, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 614, 91, 92, 92, 22, 23, 0, 24, 0, 0, 0, 93, 0, 0, 27, 0], [0, 0, 0, 0, 194, 80, 80, 22, 23, 0, 0, 0, 0, 585, 194, 0, 0, 0, 0], [0, 0, 0, 582, 91, 583, 92, 22, 23, 0, 24, 0, 0, 585, 93, 0, 0, 27, 0], [0, 0, 0, 582, 91, 92, 92, 22, 23, 0, 24, 0, 0, 0, 93, 0, 0, 27, 0], [0, 553, 0, 0, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 78, 0, 553, 0, 0], [0, 553, 0, 586, 0, 175, 175, 0, 23, 0, 24, 0, 0, 0, 78, 0, 553, 0, 0], [0, 0, 0, 614, 91, 92, 92, 22, 23, 0, 24, 0, 0, 0, 93, 0, 0, 27, 0], [0, 0, 0, 0, 194, 80, 80, 22, 23, 0, 0, 0, 0, 591, 194, 0, 0, 0, 0], [0, 0, 0, 588, 91, 589, 92, 22, 23, 0, 24, 0, 0, 591, 93, 0, 0, 27, 0], [0, 0, 0, 588, 91, 92, 92, 22, 23, 0, 24, 0, 0, 0, 93, 0, 0, 27, 0], [0, 0, 0, 615, 112, 113, 113, 32, 33, 0, 34, 0, 0, 0, 114, 0, 0, 37, 0], [0, 0, 0, 0, 220, 101, 101, 32, 33, 0, 0, 0, 0, 595, 220, 0, 0, 0, 0], [0, 0, 0, 592, 112, 593, 113, 32, 33, 0, 34, 0, 0, 595, 114, 0, 0, 37, 0], [0, 0, 0, 592, 112, 113, 113, 32, 33, 0, 34, 0, 0, 0, 114, 0, 0, 37, 0], [0, 559, 0, 0, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 99, 0, 559, 0, 0], [0, 559, 0, 596, 0, 201, 201, 0, 33, 0, 34, 0, 0, 0, 99, 0, 559, 0, 0], [0, 0, 0, 615, 112, 113, 113, 32, 33, 0, 34, 0, 0, 0, 114, 0, 0, 37, 0], [0, 0, 0, 0, 220, 101, 101, 32, 33, 0, 0, 0, 0, 601, 220, 0, 0, 0, 0], [0, 0, 0, 598, 112, 599, 113, 32, 33, 0, 34, 0, 0, 601, 114, 0, 0, 37, 0], [0, 0, 0, 598, 112, 113, 113, 32, 33, 0, 34, 0, 0, 0, 114, 0, 0, 37, 0], [0, 0, 0, 0, 66, 67, 67, 8, 9, 0, 10, 0, 0, 0, 68, 0, 0, 16, 0], [0, 0, 0, 616, 152, 153, 153, 57, 58, 0, 59, 0, 0, 0, 154, 0, 0, 62, 0], [0, 0, 0, 0, 265, 141, 141, 57, 58, 0, 0, 0, 0, 606, 265, 0, 0, 0, 0], [0, 0, 0, 603, 152, 604, 153, 57, 58, 0, 59, 0, 0, 606, 154, 0, 0, 62, 0], [0, 0, 0, 603, 152, 153, 153, 57, 58, 0, 59, 0, 0, 0, 154, 0, 0, 62, 0], [0, 575, 0, 0, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 139, 0, 575, 0, 0], [0, 575, 0, 607, 0, 246, 246, 0, 58, 0, 59, 0, 0, 0, 139, 0, 575, 0, 0], [0, 0, 0, 616, 152, 153, 153, 57, 58, 0, 59, 0, 0, 0, 154, 0, 0, 62, 0], [0, 0, 0, 0, 265, 141, 141, 57, 58, 0, 0, 0, 0, 612, 265, 0, 0, 0, 0], [0, 0, 0, 609, 152, 610, 153, 57, 58, 0, 59, 0, 0, 612, 154, 0, 0, 62, 0], [0, 0, 0, 609, 152, 153, 153, 57, 58, 0, 59, 0, 0, 0, 154, 0, 0, 62, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 549, 0, 0], [0, 0, 0, 0, 91, 92, 92, 22, 23, 0, 24, 0, 0, 0, 93, 0, 0, 27, 0], [0, 0, 0, 0, 112, 113, 113, 32, 33, 0, 34, 0, 0, 0, 114, 0, 0, 37, 0], [0, 0, 0, 0, 152, 153, 153, 57, 58, 0, 59, 0, 0, 0, 154, 0, 0, 62, 0]];
                var accepting = [false, true, true, true, true, true, false, false, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, true, true, false, true, false, true, true, false, false, true, true, true, true, true, true, false, false, true, true, true, true, true, true, true, true, true, true, false, true, true, false, true, true, true, false, true, true, true, false, true, false, true, true, false, false, true, true, true, true, true, true, true, false, true, true, false, true, true, true, false, true, false, true, true, false, false, true, true, true, true, true, true, true, false, true, true, true, false, true, true, true, false, true, false, true, true, false, false, false, true, true, false, false, true, true, true, true, true, true, false, true, false, true, true, false, false, true, true, true, true, true, true, true, false, true, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, false, true, false, true, true, false, false, false, true, true, false, false, true, true, true, false, true, true, true, true, true, true, false, true, true, true, false, true, false, true, true, false, false, false, true, true, false, false, true, true, true, false, true, true, true, true, true, false, true, true, true, true, true, false, true, true, false, false, false, false, true, true, false, false, true, true, true, false, true, true, true, false, true, false, true, true, false, false, false, true, true, false, false, true, true, true, false, true, true, true, true, false, true, false, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, false, true, true, false, false, false, false, true, true, false, false, true, true, true, false, true, true, true, true, true, false, true, true, false, false, false, false, true, true, false, false, true, true, true, true, false, true, true, true, true, true, true, false, true, true, false, false, false, false, true, false, true, false, true, true, true, true, true, false, true, true, false, false, false, false, true, true, false, false, true, true, true, false, true, true, false, false, true, false, true, true, false, true, true, false, true, true, false, true, true, true, true, true, true, false, true, true, false, false, false, false, true, false, true, true, false, true, true, true, true, true, true, false, true, true, false, false, false, false, true, false, true, false, true, true, true, true, false, false, false, true, true, false, true, true, true, true, true, true, false, true, true, false, false, false, false, true, false, true, false, true, true, false, false, true, true, false, false, true, true, true, false, true, false, true, true, true, true, false, false, false, true, false, true, true, true, true, false, false, false, true, true, false, true, true, true, true, true, true, false, true, true, false, true, false, true, true, true, true, false, false, false, false, false, false, false, true, true, false, false, true, true, false, true, true, true, true, false, true, true, true, true, true, true, false, true, true, false, true, true, false, true, true, true, true, true, true, false, true, true, false, true, false, true, true, true, true, true, true, false, true, true, true, true, true, true, false, true, true, false, false, false, false, false, true, true, false, true, false, true, true, true, true, true, false, true, true, true, true, true, false, true, true, true, true, true, false, true, true, true, false, true, true, true, true, false, false, false, true, false, true, true, true, true, true, false, true, true, true, false, true, true, true, true, true, false, true, true, true, true, false, true, true, true, true, true, false, true, true, false, true, true, true];
                var tags = [[], ["broken_cluster"], ["consonant_syllable"], ["vowel_syllable"], ["broken_cluster"], ["broken_cluster"], [], [], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["standalone_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["consonant_syllable"], ["broken_cluster"], ["symbol_cluster"], ["consonant_syllable"], ["consonant_syllable"], [], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["vowel_syllable"], ["vowel_syllable"], [], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], [], ["broken_cluster"], [], ["broken_cluster"], ["broken_cluster"], [], [], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["standalone_cluster"], ["standalone_cluster"], [], [], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["broken_cluster"], ["broken_cluster"], ["consonant_syllable", "broken_cluster"], ["broken_cluster"], [], ["broken_cluster"], ["symbol_cluster"], [], ["symbol_cluster"], ["symbol_cluster"], ["consonant_syllable"], [], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], [], ["consonant_syllable"], [], ["consonant_syllable"], ["consonant_syllable"], [], [], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], [], ["consonant_syllable"], ["vowel_syllable"], [], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], [], ["vowel_syllable"], [], ["vowel_syllable"], ["vowel_syllable"], [], [], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], [], ["vowel_syllable"], ["broken_cluster"], ["broken_cluster"], [], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], [], ["broken_cluster"], [], ["broken_cluster"], ["broken_cluster"], [], [], [], ["broken_cluster"], ["broken_cluster"], [], [], ["broken_cluster"], ["broken_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], [], ["standalone_cluster"], [], ["standalone_cluster"], ["standalone_cluster"], [], [], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], [], ["standalone_cluster"], ["broken_cluster"], [], ["broken_cluster"], ["broken_cluster"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable", "broken_cluster"], ["consonant_syllable", "broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["symbol_cluster"], ["symbol_cluster"], ["symbol_cluster"], ["consonant_syllable"], ["consonant_syllable"], [], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], [], ["consonant_syllable"], [], ["consonant_syllable"], ["consonant_syllable"], [], [], [], ["consonant_syllable"], ["consonant_syllable"], [], [], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], [], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["vowel_syllable"], ["vowel_syllable"], [], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], [], ["vowel_syllable"], [], ["vowel_syllable"], ["vowel_syllable"], [], [], [], ["vowel_syllable"], ["vowel_syllable"], [], [], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], [], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["broken_cluster"], [], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], [], ["broken_cluster"], ["broken_cluster"], [], [], [], [], ["broken_cluster"], ["broken_cluster"], [], [], ["broken_cluster"], ["standalone_cluster"], ["standalone_cluster"], [], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], [], ["standalone_cluster"], [], ["standalone_cluster"], ["standalone_cluster"], [], [], [], ["standalone_cluster"], ["standalone_cluster"], [], [], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], [], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], [], ["broken_cluster"], [], ["consonant_syllable", "broken_cluster"], ["consonant_syllable", "broken_cluster"], ["consonant_syllable", "broken_cluster"], ["consonant_syllable", "broken_cluster"], ["consonant_syllable", "broken_cluster"], ["consonant_syllable", "broken_cluster"], ["broken_cluster"], ["symbol_cluster"], ["consonant_syllable"], [], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], [], ["consonant_syllable"], ["consonant_syllable"], [], [], [], [], ["consonant_syllable"], ["consonant_syllable"], [], [], ["consonant_syllable"], ["consonant_syllable"], ["vowel_syllable"], [], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], [], ["vowel_syllable"], ["vowel_syllable"], [], [], [], [], ["vowel_syllable"], ["vowel_syllable"], [], [], ["vowel_syllable"], ["vowel_syllable"], ["broken_cluster"], ["broken_cluster"], [], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], [], ["broken_cluster"], ["broken_cluster"], [], [], [], [], ["broken_cluster"], [], ["standalone_cluster"], [], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], [], ["standalone_cluster"], ["standalone_cluster"], [], [], [], [], ["standalone_cluster"], ["standalone_cluster"], [], [], ["standalone_cluster"], ["standalone_cluster"], ["consonant_syllable", "broken_cluster"], [], ["consonant_syllable", "broken_cluster"], ["consonant_syllable", "broken_cluster"], [], [], ["consonant_syllable", "broken_cluster"], [], ["consonant_syllable", "broken_cluster"], ["consonant_syllable", "broken_cluster"], [], ["consonant_syllable", "broken_cluster"], ["consonant_syllable", "broken_cluster"], [], ["consonant_syllable"], ["consonant_syllable"], [], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], [], ["consonant_syllable"], ["consonant_syllable"], [], [], [], [], ["consonant_syllable"], [], ["vowel_syllable"], ["vowel_syllable"], [], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], [], ["vowel_syllable"], ["vowel_syllable"], [], [], [], [], ["vowel_syllable"], [], ["broken_cluster"], [], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], [], [], [], ["standalone_cluster"], ["standalone_cluster"], [], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], [], ["standalone_cluster"], ["standalone_cluster"], [], [], [], [], ["standalone_cluster"], [], ["consonant_syllable", "broken_cluster"], [], ["consonant_syllable", "broken_cluster"], ["consonant_syllable", "broken_cluster"], [], [], ["consonant_syllable", "broken_cluster"], ["consonant_syllable", "broken_cluster"], [], [], ["consonant_syllable", "broken_cluster"], ["consonant_syllable", "broken_cluster"], ["consonant_syllable", "broken_cluster"], [], ["consonant_syllable"], [], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], [], [], [], ["vowel_syllable"], [], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], [], [], [], ["broken_cluster"], ["broken_cluster"], [], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], [], ["broken_cluster"], ["broken_cluster"], [], ["standalone_cluster"], [], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], [], [], [], [], [], [], [], ["consonant_syllable", "broken_cluster"], ["consonant_syllable", "broken_cluster"], [], [], ["consonant_syllable", "broken_cluster"], ["consonant_syllable", "broken_cluster"], [], ["consonant_syllable", "broken_cluster"], ["consonant_syllable", "broken_cluster"], ["consonant_syllable"], ["consonant_syllable"], [], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], [], ["consonant_syllable"], ["consonant_syllable"], [], ["vowel_syllable"], ["vowel_syllable"], [], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], [], ["vowel_syllable"], ["vowel_syllable"], [], ["broken_cluster"], [], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["standalone_cluster"], ["standalone_cluster"], [], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], [], ["standalone_cluster"], ["standalone_cluster"], [], [], [], [], [], ["consonant_syllable", "broken_cluster"], ["consonant_syllable", "broken_cluster"], [], ["consonant_syllable"], [], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["vowel_syllable"], [], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["broken_cluster"], [], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], [], ["broken_cluster"], ["broken_cluster"], ["standalone_cluster"], [], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], [], [], [], ["consonant_syllable"], [], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], ["consonant_syllable"], [], ["consonant_syllable"], ["consonant_syllable"], ["vowel_syllable"], [], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], ["vowel_syllable"], [], ["vowel_syllable"], ["vowel_syllable"], ["broken_cluster"], ["standalone_cluster"], [], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], ["standalone_cluster"], [], ["standalone_cluster"], ["standalone_cluster"], [], ["consonant_syllable"], ["vowel_syllable"], ["standalone_cluster"]];
                var indicMachine = {
                  stateTable,
                  accepting,
                  tags
                };
                var categories = ["O", "IND", "S", "GB", "B", "FM", "CGJ", "VMAbv", "VMPst", "VAbv", "VPst", "CMBlw", "VPre", "VBlw", "H", "VMBlw", "CMAbv", "MBlw", "CS", "R", "SUB", "MPst", "MPre", "FAbv", "FPst", "FBlw", "null", "SMAbv", "SMBlw", "VMPre", "ZWNJ", "ZWJ", "WJ", "M", "VS", "N", "HN", "MAbv"];
                var decompositions = {
                  "2507": [2503, 2494],
                  "2508": [2503, 2519],
                  "2888": [2887, 2902],
                  "2891": [2887, 2878],
                  "2892": [2887, 2903],
                  "3018": [3014, 3006],
                  "3019": [3015, 3006],
                  "3020": [3014, 3031],
                  "3144": [3142, 3158],
                  "3264": [3263, 3285],
                  "3271": [3270, 3285],
                  "3272": [3270, 3286],
                  "3274": [3270, 3266],
                  "3275": [3270, 3266, 3285],
                  "3402": [3398, 3390],
                  "3403": [3399, 3390],
                  "3404": [3398, 3415],
                  "3546": [3545, 3530],
                  "3548": [3545, 3535],
                  "3549": [3545, 3535, 3530],
                  "3550": [3545, 3551],
                  "3635": [3661, 3634],
                  "3763": [3789, 3762],
                  "3955": [3953, 3954],
                  "3957": [3953, 3956],
                  "3958": [4018, 3968],
                  "3959": [4018, 3953, 3968],
                  "3960": [4019, 3968],
                  "3961": [4019, 3953, 3968],
                  "3969": [3953, 3968],
                  "6971": [6970, 6965],
                  "6973": [6972, 6965],
                  "6976": [6974, 6965],
                  "6977": [6975, 6965],
                  "6979": [6978, 6965],
                  "69934": [69937, 69927],
                  "69935": [69938, 69927],
                  "70475": [70471, 70462],
                  "70476": [70471, 70487],
                  "70843": [70841, 70842],
                  "70844": [70841, 70832],
                  "70846": [70841, 70845],
                  "71098": [71096, 71087],
                  "71099": [71097, 71087]
                };
                var stateTable$1 = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 3, 4, 4, 5, 0, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 0, 17, 18, 11, 19, 20, 21, 22, 0, 0, 0, 23, 0, 0, 2, 0, 0, 24, 0, 25], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 28, 0, 0, 0, 0, 0, 27, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 0, 0, 41, 35, 42, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 39, 0, 0, 47], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 6, 7, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 6, 7, 8, 9, 0, 0, 12, 0, 14, 0, 0, 0, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 6, 7, 0, 9, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0, 16, 0, 0, 18, 11, 19, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 25], [0, 0, 0, 0, 0, 5, 0, 6, 7, 8, 9, 0, 11, 12, 0, 14, 0, 0, 0, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 6, 7, 0, 9, 0, 0, 12, 0, 14, 0, 0, 0, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 7, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 0, 0, 18, 11, 19, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 25], [0, 0, 0, 0, 0, 5, 0, 6, 7, 8, 9, 0, 11, 12, 0, 14, 0, 0, 0, 0, 0, 11, 0, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 5, 0, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 0, 0, 18, 11, 19, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 25], [0, 0, 0, 0, 0, 5, 0, 6, 7, 8, 9, 48, 11, 12, 13, 14, 48, 16, 0, 0, 18, 11, 19, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 49, 0, 0, 25], [0, 0, 0, 0, 0, 5, 0, 6, 7, 8, 9, 0, 11, 12, 0, 14, 0, 16, 0, 0, 0, 11, 0, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 25], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 6, 7, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 0, 51, 0], [0, 0, 0, 0, 0, 5, 0, 6, 7, 8, 9, 0, 11, 12, 0, 14, 0, 16, 0, 0, 0, 11, 0, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 0, 0, 0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 43, 44, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 44, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 0, 0, 36, 0, 38, 0, 0, 0, 0, 0, 0, 0, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 0, 33, 0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 34, 35, 36, 37, 38, 0, 40, 0, 0, 41, 35, 42, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 47], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 0, 35, 36, 0, 38, 0, 0, 0, 0, 0, 0, 0, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 0, 33, 0, 0, 36, 0, 38, 0, 0, 0, 0, 0, 0, 0, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 0, 31, 0, 0, 0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 43, 44, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 0, 0, 41, 35, 42, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 47], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 0, 35, 36, 0, 38, 0, 0, 0, 0, 0, 35, 0, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 52, 35, 36, 37, 38, 52, 40, 0, 0, 41, 35, 42, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 53, 0, 0, 47], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 0, 35, 36, 0, 38, 0, 40, 0, 0, 0, 35, 0, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 47], [0, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 44, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 0, 0, 0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 0, 35, 36, 0, 38, 0, 40, 0, 0, 0, 35, 0, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 6, 7, 8, 9, 48, 11, 12, 13, 14, 0, 16, 0, 0, 18, 11, 19, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 25], [0, 0, 0, 0, 0, 5, 0, 6, 7, 8, 9, 48, 11, 12, 13, 14, 48, 16, 0, 0, 18, 11, 19, 20, 21, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 25], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 51, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 54, 0, 0], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 52, 35, 36, 37, 38, 0, 40, 0, 0, 41, 35, 42, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 47], [0, 0, 0, 0, 0, 29, 0, 30, 31, 32, 33, 52, 35, 36, 37, 38, 52, 40, 0, 0, 41, 35, 42, 43, 44, 45, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 47], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 0, 51, 0]];
                var accepting$1 = [false, true, true, true, true, true, true, true, true, true, true, true, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true];
                var tags$1 = [[], ["broken_cluster"], ["independent_cluster"], ["symbol_cluster"], ["standard_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], [], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["broken_cluster"], ["numeral_cluster"], ["broken_cluster"], ["independent_cluster"], ["symbol_cluster"], ["symbol_cluster"], ["standard_cluster"], ["standard_cluster"], ["standard_cluster"], ["standard_cluster"], ["standard_cluster"], ["standard_cluster"], ["standard_cluster"], ["standard_cluster"], ["virama_terminated_cluster"], ["standard_cluster"], ["standard_cluster"], ["standard_cluster"], ["standard_cluster"], ["standard_cluster"], ["standard_cluster"], ["standard_cluster"], ["standard_cluster"], ["standard_cluster"], ["standard_cluster"], ["broken_cluster"], ["broken_cluster"], ["numeral_cluster"], ["number_joiner_terminated_cluster"], ["standard_cluster"], ["standard_cluster"], ["numeral_cluster"]];
                var useData = {
                  categories,
                  decompositions,
                  stateTable: stateTable$1,
                  accepting: accepting$1,
                  tags: tags$1
                };
                var CATEGORIES = {
                  X: 1 << 0,
                  C: 1 << 1,
                  V: 1 << 2,
                  N: 1 << 3,
                  H: 1 << 4,
                  ZWNJ: 1 << 5,
                  ZWJ: 1 << 6,
                  M: 1 << 7,
                  SM: 1 << 8,
                  VD: 1 << 9,
                  A: 1 << 10,
                  Placeholder: 1 << 11,
                  Dotted_Circle: 1 << 12,
                  RS: 1 << 13,
                  // Register Shifter, used in Khmer OT spec.
                  Coeng: 1 << 14,
                  // Khmer-style Virama.
                  Repha: 1 << 15,
                  // Atomically-encoded logical or visual repha.
                  Ra: 1 << 16,
                  CM: 1 << 17,
                  // Consonant-Medial.
                  Symbol: 1 << 18
                  // Avagraha, etc that take marks (SM,A,VD).
                };
                var POSITIONS = {
                  Start: 1 << 0,
                  Ra_To_Become_Reph: 1 << 1,
                  Pre_M: 1 << 2,
                  Pre_C: 1 << 3,
                  Base_C: 1 << 4,
                  After_Main: 1 << 5,
                  Above_C: 1 << 6,
                  Before_Sub: 1 << 7,
                  Below_C: 1 << 8,
                  After_Sub: 1 << 9,
                  Before_Post: 1 << 10,
                  Post_C: 1 << 11,
                  After_Post: 1 << 12,
                  Final_C: 1 << 13,
                  SMVD: 1 << 14,
                  End: 1 << 15
                };
                var CONSONANT_FLAGS = CATEGORIES.C | CATEGORIES.Ra | CATEGORIES.CM | CATEGORIES.V | CATEGORIES.Placeholder | CATEGORIES.Dotted_Circle;
                var JOINER_FLAGS = CATEGORIES.ZWJ | CATEGORIES.ZWNJ;
                var HALANT_OR_COENG_FLAGS = CATEGORIES.H | CATEGORIES.Coeng;
                var INDIC_CONFIGS = {
                  Default: {
                    hasOldSpec: false,
                    virama: 0,
                    basePos: "Last",
                    rephPos: POSITIONS.Before_Post,
                    rephMode: "Implicit",
                    blwfMode: "Pre_And_Post"
                  },
                  Devanagari: {
                    hasOldSpec: true,
                    virama: 2381,
                    basePos: "Last",
                    rephPos: POSITIONS.Before_Post,
                    rephMode: "Implicit",
                    blwfMode: "Pre_And_Post"
                  },
                  Bengali: {
                    hasOldSpec: true,
                    virama: 2509,
                    basePos: "Last",
                    rephPos: POSITIONS.After_Sub,
                    rephMode: "Implicit",
                    blwfMode: "Pre_And_Post"
                  },
                  Gurmukhi: {
                    hasOldSpec: true,
                    virama: 2637,
                    basePos: "Last",
                    rephPos: POSITIONS.Before_Sub,
                    rephMode: "Implicit",
                    blwfMode: "Pre_And_Post"
                  },
                  Gujarati: {
                    hasOldSpec: true,
                    virama: 2765,
                    basePos: "Last",
                    rephPos: POSITIONS.Before_Post,
                    rephMode: "Implicit",
                    blwfMode: "Pre_And_Post"
                  },
                  Oriya: {
                    hasOldSpec: true,
                    virama: 2893,
                    basePos: "Last",
                    rephPos: POSITIONS.After_Main,
                    rephMode: "Implicit",
                    blwfMode: "Pre_And_Post"
                  },
                  Tamil: {
                    hasOldSpec: true,
                    virama: 3021,
                    basePos: "Last",
                    rephPos: POSITIONS.After_Post,
                    rephMode: "Implicit",
                    blwfMode: "Pre_And_Post"
                  },
                  Telugu: {
                    hasOldSpec: true,
                    virama: 3149,
                    basePos: "Last",
                    rephPos: POSITIONS.After_Post,
                    rephMode: "Explicit",
                    blwfMode: "Post_Only"
                  },
                  Kannada: {
                    hasOldSpec: true,
                    virama: 3277,
                    basePos: "Last",
                    rephPos: POSITIONS.After_Post,
                    rephMode: "Implicit",
                    blwfMode: "Post_Only"
                  },
                  Malayalam: {
                    hasOldSpec: true,
                    virama: 3405,
                    basePos: "Last",
                    rephPos: POSITIONS.After_Main,
                    rephMode: "Log_Repha",
                    blwfMode: "Pre_And_Post"
                  },
                  // Handled by UniversalShaper
                  // Sinhala: {
                  //   hasOldSpec: false,
                  //   virama: 0x0DCA,
                  //   basePos: 'Last_Sinhala',
                  //   rephPos: POSITIONS.After_Main,
                  //   rephMode: 'Explicit',
                  //   blwfMode: 'Pre_And_Post'
                  // },
                  Khmer: {
                    hasOldSpec: false,
                    virama: 6098,
                    basePos: "First",
                    rephPos: POSITIONS.Ra_To_Become_Reph,
                    rephMode: "Vis_Repha",
                    blwfMode: "Pre_And_Post"
                  }
                };
                var INDIC_DECOMPOSITIONS = {
                  // Khmer
                  6078: [6081, 6078],
                  6079: [6081, 6079],
                  6080: [6081, 6080],
                  6084: [6081, 6084],
                  6085: [6081, 6085]
                };
                var decompositions$1 = useData.decompositions;
                var trie$1 = new UnicodeTrie(Buffer("AAARAAAAAABg2AAAAWYPmfDtnXuMXFUdx+/uzs7M7szudAtECGJRIMRQbUAithQWkGAKiVhNpFVRRAmIQVCDkDYICGotIA9BTCz8IeUviv7BQ2PBtBIRLBBQIWAUsKg1BKxRAqIgfs/cc+aeOXPej3tnZX7JJ/dxzj3nd36/8753Z5fUsuxgsAwcAU4Gp4BPgM+Cd4P3RjieDs4GXwLrHJ5bDy4DG8A14LvgZrAZbAF3gns0z18ALgY/B78C94NHwBPgabAE/AX8DbwM5sF/QX0yD5vFcU/wVnAgWAoOAyvAceBE8CGwBpwGzgJfAF8BXwXfAFeC68EmsBlsAXeCreA+8CB4DDwF/gh2gd3gFfAGmKxn2QzYC+wHDgRLweFgJTgWrKrnuq/GcQ04jV6fheN54EJwEbgcXAG+Q8O/j+Mt4DZwB9haz8t9Hz3a8iCN/xiOvwRP0evH6fE68AzOH+Ke2eWYhw3PcGnuxvkr4A3QaGRZB7wFLAEHg2XgiEZ/fHKcp/ceBh/A+cngFPCpRm6vM3E8l8a5gN67GMdvgqsbeX2ap9yI601gM7gN3AG20mfuo8cdOP6GpvdUg9oKxz839GV90RDO2/glxN1B790NXsN1rZll7WYRdw+c70uvTwIHNAfTO0RyL5TDmnnbc3lmRQI9UnM0dD5eovfz4FpJ/BNpXNYWV+N6Lfg0hY97JK1vn+Pur9DoQur2F7m436bHDUK8C5t5/8vruo4+97WmXG+GLmzEiBF+PDwEOowYMWLEiBEjRoxYeBw5BDqIPEfXut9yWN+vVNxfrnnmWqR/PdgENoMt4E5wD9gOHgCPgifBs2BXM99b2o3jP8F/wMRUlrXAHNgHvH0q3895J46HguXgWHAGLctmLv9VuL96qnp7jxgxYsSbCbJvuRZ97/tqxT59VVRtixEjRsThBG7OSt5zzoPT0M+cBc4T5noXOs79TqLHeZrHUeCSqeJ96gacXy2kecNU8V6Hh7yXuQlhtw7B/PO1RTkr52Aj8JNFZjYg3gOKuC/g/v6Ls2wNuAY8urg//PcIb+6RZXuDNeCS6SzbBrJWlh0DLiFHco8ed9IjzzvaWfa9sZzTcf6D9mCcnbg3PlNcH4fzS8F2MDaLdQG4dLZIJxbbaZqv4ri8k58f3+mPs66T6/TTzqDeI0aMGDGiHP5dcR8ce/xxYcWi6vOfr725uRzcjnngXVOD61Hync+9uL+Nmyfej/NHpvL56A5Jeuz7uyfo+pqcPz2Vf1NH0ttJ03pekt8SmuY/EPYy9zzbN319ym/9TL6ZIt9MHCXRdxJtoAkWTRdz472n87D9cTwYLJvuz++I6WIePo/zE8AHp4v8WLyP0nufnM6/+zoDx8+DL08P6r9+urheRtO+jD6/cdrsx3mqu8w+xH4PScKIXa5D2jeCm8Et4DbwI/BjcC/4BXgI/Bb8DuwEu8Bu8Ap4A9RaRZptnO8J9gUHgEPAoWA5OLY1qMO90GEV7q+mYWtxPBWcIYnL4p+DsPNbxfVFOP86uAr8DNc34HgTDb8Vx9sVaRFI/LtagzYjnCqpb908EX87eBA8Bh4Hf2jle/9/wvGFVv787rrZZy8h7qtgDOuFOmiBuXYRvg/O9wMHgXeB97SLspk4sq0OI/q9v13+ek+sh3zYSRp9jrYorw9ll1/GRzR+KotYZSHf8laVP2lvpA/8OGdPMk59hqtXZ+L8nHbxvWwqO65ryu+fT3VZz+l4dET7L0R072ljsMyzTpaJqQxsbL8M9WajY789DO85XMp/Dcp3Qztdn+9qf/a97ZWK8PXc3G+TpC/nv8Mncy7ZvICF302P5O+aNiOtLdTXd+D4Q7DVwfcvWvx9zTEJ/o5iG3R8YAjGNFseha5PGuZKz7b7xxXbOrXMcu5eJSo//rXdH/73Enz6L1q/X+fyIu8wZGtNBmkjkzNZNgP2AvuBg2bysKUzduXn/66JtNeN4PCZvO0/x7Ujdn4VnYOvRJzjZ/I+9sQZeftX2Tc1RPcPz/Tf4/si0g+t5Mq+kfZjZL34Mc5ul3PPnE7TOxvHK2qDaZ+L++db2HyYqMo/qVnb/P8uH8/rmnFxR0k6DCu/rjj/RxT7KGUSWgbd+LMQuEgYB1zsk2qtvJD8v5AhdfdttbEunSxbcJD9Zf7chqp1Hlbe7FK1/aPVTfp7FgtC1yGGiSncFK/DhZvi+epZta0WWjlsfDZMyPRdSPrryqSSKnXx1bkq/Ye9TlRpk7Lrjq1UrfdC9X+MtKqwP6+3a/4pJFUZF0pZZpv91MYjMBaRRXbxpho5zQmUY3F+Pt4o7rvQrBXPdm00TaE24uMadaM2meLSI7iu071t3er3b6ZLi8JEde3qw+6zGv+ycF5kaRBh/m1T/7Yl/mMyTuMwadP4xL9ifjJpNwbvDZRJ8G8vnqV/Wf12aa/kyOdl69+BspTsXzGueE6E+JfZnvmXIfNPW+FfXkjb1YmqPNpnLP3b61fHCj/X5tzGANf2y3yqvC7Jv7btV4TVbdammI9l/g0dS5lNxLrk2j9r8xjjxhBQnygg0lgg/bOrfyct+udJi/Yrk0lFnxC7f+5kRbsNmcexfrubt0X/rGvLqrGSnYv3ZPHEe8r7lvMvUfi2LOu/2dg8LrRtQt2yfcv8r5IU70VkIs6nbebUXf0M/o7Znl39Sdoz+X1oEb5N8ffF67qhPfPP6eoUbxf+GRf/6sRnvaSdmw+Bf1VxmbD+2sa//DU7t/Gv2PfKpKdrBP92Ojk+IvqX16ks/2qxbL8EZnc2HqsgYuqPuzZV+I3RbujbDm+T0PmWCVO/5jqftp1zy+wSA6s0JWtp2z5e1oZV+yMsjB3ZXolsv0Ulrv01v3/iKrF94Qtbt9siCnmeb6fjjf59KnLk1xaEbvtvFnFirGvEOqmycQrbm/IMsXd3P28uh4nM3swXRER717OiX8kc7K2qqyn2p3maFGU/aruP5VCv+PraoTYU8yUmmbDwcYo6pusnM486xdoga4dkPCb1pK7Sfc6ebvkd4qeAtQcd/N63bB3lU3dlUnUf38VyvqCqK7JxlNSd7lydrDlm+/uqHiRvl30Nrp/n9zpkZRjoJ3V1diyP05rIYXHYs+w+D5+WMS8b5gZtKcuX0KT5d/WwtB97VnyvY6rjMukI56HI0rFJPwt8PjT/1OXzSbcMeEmdh294qvKK4rNu7j4n3LNZg8TKXwafv025U+XvKjHsT8Q7/7LGaJt9lAh7Asz3uv0XEX6t0duDoWN/93wmh92XpUHmCKb9GALbG+rZP3AfNbQPKKv/jpF/bP0JXfuW1QYk7dhljcyvk5mw+933Hpo1g26PQ2ZP6zVmTJt47P25jncD9vPwGS+q9QS/V6RaY8j8K8LmvUr9HfYCpH5OWL9lZY+Sv6pesHCJHbtrf9k6etZvf0G1L0ja4cAe1UT/s3zdCe3/Q5/n372wMc97/E1Qh0Tbmfwh3m/V9On72tNnrCF1sJkVe1EyXMdBa7+lHMsk44zMF6St9e2djNnbm8ybpHkq+gbbemMaH0UZmD8obKGrk7r+nt+3bE7o83YZp/vqOKdv6PzJNN6mTJsI/51XR7i2ZrGA5B6zFwnjzxmqPjaGfW3tZNrz1eljq29mOOqeCfF/irRt87PNw0uXSVAvrmOMNT569MptsYaV0sic/wbY13e8hPrb9K2ySUJ0j6G/Lu0U4qpTrR23jMp6m5hU+YTaWCeh9aIsm/rqUHV4bFv42kgnZdfH1PUj1D7DVH9d8khRN1zFRl/+/TW//qxL1uH83+mk3H+SvRtS2TDU90nX2TpM6/1xzZpZtoYdK763dqlz0f6uNeFehcs+H/nbGP77MpX06n/ofpzP+tVmTUvRtVuX/cjS67OE5kRBrxyJ+w/dPo7r+9cO1160e3gqu0S2uW7PjN/L6ns/UfMf10Lai87frJ+3KndAfc8yTf1M3T4s6qm4/yh7/2GSkG8UMw//DvRLgbYZSEOxr0LCWvRdjfh9XGzfqN4NivfZd7rsmFp08zmbssrKJEuTfVMZopdpbuwSrhNv3/N2s+0PDG3KNB6RMrFvJHv6B85HXObAoWsd3zm3i+6uZYytv+5+pohbpo6+tpZJFfmGlrcMf4c8b1Pe2OUIsaXJrinCTfaxtZOt+NYnU3hIfQlN20Z/1+dt7JaqLsbIzycNWZmrlNg2Dc2/LJ1T+T6WrrYSml4Ku7ik7yIx2opJD51vU9UfVRmrqL8u/olZj0PyCLV5irxcdKoi/6rKb8qTrHsnhW9jyZH/nSpeWDzxd9769uQ016lgUuf2pAfKPhu2FpfZL2Yb9snLNl/fNIepXaUsj4vNXCXUZ75px8ojNP8UPvAta2g6fb+F1ckZuneshv1vGXXDeyRRrN/bBPS1Jul+l+7zW86R7Wv63WXyDpt/RxraRjvC+TC3O61/Sqj/prag8x372yQivn+XwudrI2X2E2KdtJEov52e0L+uv4FO3p/rvssgsL8F4d/z9PzlWS94m8fqS3361Fi+6qaVYHwi9Yz4iH2fobIj+45cpz/TUaarr/4+z+vaWtVtyAX2d1LG8W9C3f+F1mnf36/k4w3YPrLv+XBVXCJs3cr+n4MKJuLv/fN9GhNdXVP5pJMN9vFi3rpv3/r8Ywg3SYp66zNOsO8QGcxPpnmRS/1mvmJjju3v7absI2xspQrvs1dNbjOj/wP7h1RlZyKGy8occ408UL8En4v6xfC/K3z52XzJd62T8vuZGGsxo/6O46ntmNqqFb/jps2/hHV4rPKH0svT4pstU7t2tZ9u/ZdqbJL1MwP6O86Fyt4jYaIrGz9mjEt8lFL4PtVE6votG2P6fpdf/GZRse7s3bf4BtSl/DIbKMctx++Z+8o6K6z9FPOwKsRmXiaNl7C+6NYRpjlbqG1j72f49qsuY4brd/amb4ZVc8TQ+sSH985LrEe8iPWJnfPrJRbWbb+dwn4x6o+r/aS2S7w3qWt//LnYz2ntE0vH1uDcyKatx1rH+EiMPEN1SZG/iz6+9o01Rob6O7Q+xLZ1jHobK61U+pWVvo2EpuWqzzD6Poa+pvhli0wn8Zq/72Mzm2d90o5VN1x9ZKuzbTgvqWwUIin8FSpl1CXXvFRxU0iozVPYJDRtF3uFphn6XAyJUUdD7SjTJ8v6n9fVbVObkKWp001lc9VRlqdOf5v0ZM+bymdbfp1NfG0bq27Y5JMyfxeJkU6o/inKH8O2Zfgidb6h/g3VJ7QcVbWL0Pxt6rlrPqa4KfQ25a2zl4/E8GdM/4fK/wA=", "base64"));
                var stateMachine = new StateMachine(indicMachine);
                var IndicShaper = function(_DefaultShaper3) {
                  _inheritsLoose(IndicShaper2, _DefaultShaper3);
                  function IndicShaper2() {
                    return _DefaultShaper3.apply(this, arguments) || this;
                  }
                  IndicShaper2.planFeatures = function planFeatures(plan) {
                    plan.addStage(setupSyllables);
                    plan.addStage(["locl", "ccmp"]);
                    plan.addStage(initialReordering);
                    plan.addStage("nukt");
                    plan.addStage("akhn");
                    plan.addStage("rphf", false);
                    plan.addStage("rkrf");
                    plan.addStage("pref", false);
                    plan.addStage("blwf", false);
                    plan.addStage("abvf", false);
                    plan.addStage("half", false);
                    plan.addStage("pstf", false);
                    plan.addStage("vatu");
                    plan.addStage("cjct");
                    plan.addStage("cfar", false);
                    plan.addStage(finalReordering);
                    plan.addStage({
                      local: ["init"],
                      global: ["pres", "abvs", "blws", "psts", "haln", "dist", "abvm", "blwm", "calt", "clig"]
                    });
                    plan.unicodeScript = fromOpenType(plan.script);
                    plan.indicConfig = INDIC_CONFIGS[plan.unicodeScript] || INDIC_CONFIGS.Default;
                    plan.isOldSpec = plan.indicConfig.hasOldSpec && plan.script[plan.script.length - 1] !== "2";
                  };
                  IndicShaper2.assignFeatures = function assignFeatures(plan, glyphs) {
                    var _loop2 = function _loop3(i3) {
                      var codepoint = glyphs[i3].codePoints[0];
                      var d = INDIC_DECOMPOSITIONS[codepoint] || decompositions$1[codepoint];
                      if (d) {
                        var decomposed = d.map(function(c) {
                          var g = plan.font.glyphForCodePoint(c);
                          return new GlyphInfo(plan.font, g.id, [c], glyphs[i3].features);
                        });
                        glyphs.splice.apply(glyphs, [i3, 1].concat(decomposed));
                      }
                    };
                    for (var i2 = glyphs.length - 1; i2 >= 0; i2--) {
                      _loop2(i2);
                    }
                  };
                  return IndicShaper2;
                }(DefaultShaper);
                _defineProperty(IndicShaper, "zeroMarkWidths", "NONE");
                function indicCategory(glyph2) {
                  return trie$1.get(glyph2.codePoints[0]) >> 8;
                }
                function indicPosition(glyph2) {
                  return 1 << (trie$1.get(glyph2.codePoints[0]) & 255);
                }
                var IndicInfo = function IndicInfo2(category, position, syllableType, syllable) {
                  this.category = category;
                  this.position = position;
                  this.syllableType = syllableType;
                  this.syllable = syllable;
                };
                function setupSyllables(font, glyphs) {
                  var syllable = 0;
                  var last = 0;
                  for (var _iterator53 = _createForOfIteratorHelperLoose(stateMachine.match(glyphs.map(indicCategory))), _step53; !(_step53 = _iterator53()).done; ) {
                    var _step53$value = _step53.value, start = _step53$value[0], end = _step53$value[1], tags2 = _step53$value[2];
                    if (start > last) {
                      ++syllable;
                      for (var i2 = last; i2 < start; i2++) {
                        glyphs[i2].shaperInfo = new IndicInfo(CATEGORIES.X, POSITIONS.End, "non_indic_cluster", syllable);
                      }
                    }
                    ++syllable;
                    for (var _i = start; _i <= end; _i++) {
                      glyphs[_i].shaperInfo = new IndicInfo(1 << indicCategory(glyphs[_i]), indicPosition(glyphs[_i]), tags2[0], syllable);
                    }
                    last = end + 1;
                  }
                  if (last < glyphs.length) {
                    ++syllable;
                    for (var _i2 = last; _i2 < glyphs.length; _i2++) {
                      glyphs[_i2].shaperInfo = new IndicInfo(CATEGORIES.X, POSITIONS.End, "non_indic_cluster", syllable);
                    }
                  }
                }
                function isConsonant(glyph2) {
                  return glyph2.shaperInfo.category & CONSONANT_FLAGS;
                }
                function isJoiner(glyph2) {
                  return glyph2.shaperInfo.category & JOINER_FLAGS;
                }
                function isHalantOrCoeng(glyph2) {
                  return glyph2.shaperInfo.category & HALANT_OR_COENG_FLAGS;
                }
                function wouldSubstitute(glyphs, feature2) {
                  for (var _iterator54 = _createForOfIteratorHelperLoose(glyphs), _step54; !(_step54 = _iterator54()).done; ) {
                    var _glyph$features;
                    var glyph2 = _step54.value;
                    glyph2.features = (_glyph$features = {}, _glyph$features[feature2] = true, _glyph$features);
                  }
                  var GSUB2 = glyphs[0]._font._layoutEngine.engine.GSUBProcessor;
                  GSUB2.applyFeatures([feature2], glyphs);
                  return glyphs.length === 1;
                }
                function consonantPosition(font, consonant, virama) {
                  var glyphs = [virama, consonant, virama];
                  if (wouldSubstitute(glyphs.slice(0, 2), "blwf") || wouldSubstitute(glyphs.slice(1, 3), "blwf")) {
                    return POSITIONS.Below_C;
                  } else if (wouldSubstitute(glyphs.slice(0, 2), "pstf") || wouldSubstitute(glyphs.slice(1, 3), "pstf")) {
                    return POSITIONS.Post_C;
                  } else if (wouldSubstitute(glyphs.slice(0, 2), "pref") || wouldSubstitute(glyphs.slice(1, 3), "pref")) {
                    return POSITIONS.Post_C;
                  }
                  return POSITIONS.Base_C;
                }
                function initialReordering(font, glyphs, plan) {
                  var indicConfig = plan.indicConfig;
                  var features2 = font._layoutEngine.engine.GSUBProcessor.features;
                  var dottedCircle = font.glyphForCodePoint(9676).id;
                  var virama = font.glyphForCodePoint(indicConfig.virama).id;
                  if (virama) {
                    var info = new GlyphInfo(font, virama, [indicConfig.virama]);
                    for (var i2 = 0; i2 < glyphs.length; i2++) {
                      if (glyphs[i2].shaperInfo.position === POSITIONS.Base_C) {
                        glyphs[i2].shaperInfo.position = consonantPosition(font, glyphs[i2].copy(), info);
                      }
                    }
                  }
                  for (var start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {
                    var _glyphs$start$shaperI = glyphs[start].shaperInfo, category = _glyphs$start$shaperI.category, syllableType = _glyphs$start$shaperI.syllableType;
                    if (syllableType === "symbol_cluster" || syllableType === "non_indic_cluster") {
                      continue;
                    }
                    if (syllableType === "broken_cluster" && dottedCircle) {
                      var g = new GlyphInfo(font, dottedCircle, [9676]);
                      g.shaperInfo = new IndicInfo(1 << indicCategory(g), indicPosition(g), glyphs[start].shaperInfo.syllableType, glyphs[start].shaperInfo.syllable);
                      var _i3 = start;
                      while (_i3 < end && glyphs[_i3].shaperInfo.category === CATEGORIES.Repha) {
                        _i3++;
                      }
                      glyphs.splice(_i3++, 0, g);
                      end++;
                    }
                    var base = end;
                    var limit = start;
                    var hasReph = false;
                    if (indicConfig.rephPos !== POSITIONS.Ra_To_Become_Reph && features2.rphf && start + 3 <= end && (indicConfig.rephMode === "Implicit" && !isJoiner(glyphs[start + 2]) || indicConfig.rephMode === "Explicit" && glyphs[start + 2].shaperInfo.category === CATEGORIES.ZWJ)) {
                      var _g = [glyphs[start].copy(), glyphs[start + 1].copy(), glyphs[start + 2].copy()];
                      if (wouldSubstitute(_g.slice(0, 2), "rphf") || indicConfig.rephMode === "Explicit" && wouldSubstitute(_g, "rphf")) {
                        limit += 2;
                        while (limit < end && isJoiner(glyphs[limit])) {
                          limit++;
                        }
                        base = start;
                        hasReph = true;
                      }
                    } else if (indicConfig.rephMode === "Log_Repha" && glyphs[start].shaperInfo.category === CATEGORIES.Repha) {
                      limit++;
                      while (limit < end && isJoiner(glyphs[limit])) {
                        limit++;
                      }
                      base = start;
                      hasReph = true;
                    }
                    switch (indicConfig.basePos) {
                      case "Last": {
                        var _i4 = end;
                        var seenBelow = false;
                        do {
                          var _info = glyphs[--_i4].shaperInfo;
                          if (isConsonant(glyphs[_i4])) {
                            if (_info.position !== POSITIONS.Below_C && (_info.position !== POSITIONS.Post_C || seenBelow)) {
                              base = _i4;
                              break;
                            }
                            if (_info.position === POSITIONS.Below_C) {
                              seenBelow = true;
                            }
                            base = _i4;
                          } else if (start < _i4 && _info.category === CATEGORIES.ZWJ && glyphs[_i4 - 1].shaperInfo.category === CATEGORIES.H) {
                            break;
                          }
                        } while (_i4 > limit);
                        break;
                      }
                      case "First": {
                        base = start;
                        for (var _i5 = base + 1; _i5 < end; _i5++) {
                          if (isConsonant(glyphs[_i5])) {
                            glyphs[_i5].shaperInfo.position = POSITIONS.Below_C;
                          }
                        }
                      }
                    }
                    if (hasReph && base === start && limit - base <= 2) {
                      hasReph = false;
                    }
                    for (var _i6 = start; _i6 < base; _i6++) {
                      var _info2 = glyphs[_i6].shaperInfo;
                      _info2.position = Math.min(POSITIONS.Pre_C, _info2.position);
                    }
                    if (base < end) {
                      glyphs[base].shaperInfo.position = POSITIONS.Base_C;
                    }
                    for (var _i7 = base + 1; _i7 < end; _i7++) {
                      if (glyphs[_i7].shaperInfo.category === CATEGORIES.M) {
                        for (var j = _i7 + 1; j < end; j++) {
                          if (isConsonant(glyphs[j])) {
                            glyphs[j].shaperInfo.position = POSITIONS.Final_C;
                            break;
                          }
                        }
                        break;
                      }
                    }
                    if (hasReph) {
                      glyphs[start].shaperInfo.position = POSITIONS.Ra_To_Become_Reph;
                    }
                    if (plan.isOldSpec) {
                      var disallowDoubleHalants = plan.unicodeScript !== "Malayalam";
                      for (var _i8 = base + 1; _i8 < end; _i8++) {
                        if (glyphs[_i8].shaperInfo.category === CATEGORIES.H) {
                          var _j = void 0;
                          for (_j = end - 1; _j > _i8; _j--) {
                            if (isConsonant(glyphs[_j]) || disallowDoubleHalants && glyphs[_j].shaperInfo.category === CATEGORIES.H) {
                              break;
                            }
                          }
                          if (glyphs[_j].shaperInfo.category !== CATEGORIES.H && _j > _i8) {
                            var t2 = glyphs[_i8];
                            glyphs.splice.apply(glyphs, [_i8, 0].concat(glyphs.splice(_i8 + 1, _j - _i8)));
                            glyphs[_j] = t2;
                          }
                          break;
                        }
                      }
                    }
                    var lastPos = POSITIONS.Start;
                    for (var _i9 = start; _i9 < end; _i9++) {
                      var _info3 = glyphs[_i9].shaperInfo;
                      if (_info3.category & (JOINER_FLAGS | CATEGORIES.N | CATEGORIES.RS | CATEGORIES.CM | HALANT_OR_COENG_FLAGS & _info3.category)) {
                        _info3.position = lastPos;
                        if (_info3.category === CATEGORIES.H && _info3.position === POSITIONS.Pre_M) {
                          for (var _j2 = _i9; _j2 > start; _j2--) {
                            if (glyphs[_j2 - 1].shaperInfo.position !== POSITIONS.Pre_M) {
                              _info3.position = glyphs[_j2 - 1].shaperInfo.position;
                              break;
                            }
                          }
                        }
                      } else if (_info3.position !== POSITIONS.SMVD) {
                        lastPos = _info3.position;
                      }
                    }
                    var last = base;
                    for (var _i10 = base + 1; _i10 < end; _i10++) {
                      if (isConsonant(glyphs[_i10])) {
                        for (var _j3 = last + 1; _j3 < _i10; _j3++) {
                          if (glyphs[_j3].shaperInfo.position < POSITIONS.SMVD) {
                            glyphs[_j3].shaperInfo.position = glyphs[_i10].shaperInfo.position;
                          }
                        }
                        last = _i10;
                      } else if (glyphs[_i10].shaperInfo.category === CATEGORIES.M) {
                        last = _i10;
                      }
                    }
                    var arr = glyphs.slice(start, end);
                    arr.sort(function(a, b) {
                      return a.shaperInfo.position - b.shaperInfo.position;
                    });
                    glyphs.splice.apply(glyphs, [start, arr.length].concat(arr));
                    for (var _i11 = start; _i11 < end; _i11++) {
                      if (glyphs[_i11].shaperInfo.position === POSITIONS.Base_C) {
                        base = _i11;
                        break;
                      }
                    }
                    for (var _i12 = start; _i12 < end && glyphs[_i12].shaperInfo.position === POSITIONS.Ra_To_Become_Reph; _i12++) {
                      glyphs[_i12].features.rphf = true;
                    }
                    var blwf = !plan.isOldSpec && indicConfig.blwfMode === "Pre_And_Post";
                    for (var _i13 = start; _i13 < base; _i13++) {
                      glyphs[_i13].features.half = true;
                      if (blwf) {
                        glyphs[_i13].features.blwf = true;
                      }
                    }
                    for (var _i14 = base + 1; _i14 < end; _i14++) {
                      glyphs[_i14].features.abvf = true;
                      glyphs[_i14].features.pstf = true;
                      glyphs[_i14].features.blwf = true;
                    }
                    if (plan.isOldSpec && plan.unicodeScript === "Devanagari") {
                      for (var _i15 = start; _i15 + 1 < base; _i15++) {
                        if (glyphs[_i15].shaperInfo.category === CATEGORIES.Ra && glyphs[_i15 + 1].shaperInfo.category === CATEGORIES.H && (_i15 + 1 === base || glyphs[_i15 + 2].shaperInfo.category === CATEGORIES.ZWJ)) {
                          glyphs[_i15].features.blwf = true;
                          glyphs[_i15 + 1].features.blwf = true;
                        }
                      }
                    }
                    var prefLen = 2;
                    if (features2.pref && base + prefLen < end) {
                      for (var _i16 = base + 1; _i16 + prefLen - 1 < end; _i16++) {
                        var _g2 = [glyphs[_i16].copy(), glyphs[_i16 + 1].copy()];
                        if (wouldSubstitute(_g2, "pref")) {
                          for (var _j4 = 0; _j4 < prefLen; _j4++) {
                            glyphs[_i16++].features.pref = true;
                          }
                          if (features2.cfar) {
                            for (; _i16 < end; _i16++) {
                              glyphs[_i16].features.cfar = true;
                            }
                          }
                          break;
                        }
                      }
                    }
                    for (var _i17 = start + 1; _i17 < end; _i17++) {
                      if (isJoiner(glyphs[_i17])) {
                        var nonJoiner = glyphs[_i17].shaperInfo.category === CATEGORIES.ZWNJ;
                        var _j5 = _i17;
                        do {
                          _j5--;
                          if (nonJoiner) {
                            delete glyphs[_j5].features.half;
                          }
                        } while (_j5 > start && !isConsonant(glyphs[_j5]));
                      }
                    }
                  }
                }
                function finalReordering(font, glyphs, plan) {
                  var indicConfig = plan.indicConfig;
                  var features2 = font._layoutEngine.engine.GSUBProcessor.features;
                  for (var start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {
                    var tryPref = !!features2.pref;
                    var base = start;
                    for (; base < end; base++) {
                      if (glyphs[base].shaperInfo.position >= POSITIONS.Base_C) {
                        if (tryPref && base + 1 < end) {
                          for (var i2 = base + 1; i2 < end; i2++) {
                            if (glyphs[i2].features.pref) {
                              if (!(glyphs[i2].substituted && glyphs[i2].isLigated && !glyphs[i2].isMultiplied)) {
                                base = i2;
                                while (base < end && isHalantOrCoeng(glyphs[base])) {
                                  base++;
                                }
                                glyphs[base].shaperInfo.position = POSITIONS.BASE_C;
                                tryPref = false;
                              }
                              break;
                            }
                          }
                        }
                        if (plan.unicodeScript === "Malayalam") {
                          for (var _i18 = base + 1; _i18 < end; _i18++) {
                            while (_i18 < end && isJoiner(glyphs[_i18])) {
                              _i18++;
                            }
                            if (_i18 === end || !isHalantOrCoeng(glyphs[_i18])) {
                              break;
                            }
                            _i18++;
                            while (_i18 < end && isJoiner(glyphs[_i18])) {
                              _i18++;
                            }
                            if (_i18 < end && isConsonant(glyphs[_i18]) && glyphs[_i18].shaperInfo.position === POSITIONS.Below_C) {
                              base = _i18;
                              glyphs[base].shaperInfo.position = POSITIONS.Base_C;
                            }
                          }
                        }
                        if (start < base && glyphs[base].shaperInfo.position > POSITIONS.Base_C) {
                          base--;
                        }
                        break;
                      }
                    }
                    if (base === end && start < base && glyphs[base - 1].shaperInfo.category === CATEGORIES.ZWJ) {
                      base--;
                    }
                    if (base < end) {
                      while (start < base && glyphs[base].shaperInfo.category & (CATEGORIES.N | HALANT_OR_COENG_FLAGS)) {
                        base--;
                      }
                    }
                    if (start + 1 < end && start < base) {
                      var newPos = base === end ? base - 2 : base - 1;
                      if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
                        while (newPos > start && !(glyphs[newPos].shaperInfo.category & (CATEGORIES.M | HALANT_OR_COENG_FLAGS))) {
                          newPos--;
                        }
                        if (isHalantOrCoeng(glyphs[newPos]) && glyphs[newPos].shaperInfo.position !== POSITIONS.Pre_M) {
                          if (newPos + 1 < end && isJoiner(glyphs[newPos + 1])) {
                            newPos++;
                          }
                        } else {
                          newPos = start;
                        }
                      }
                      if (start < newPos && glyphs[newPos].shaperInfo.position !== POSITIONS.Pre_M) {
                        for (var _i19 = newPos; _i19 > start; _i19--) {
                          if (glyphs[_i19 - 1].shaperInfo.position === POSITIONS.Pre_M) {
                            var oldPos = _i19 - 1;
                            if (oldPos < base && base <= newPos) {
                              base--;
                            }
                            var tmp = glyphs[oldPos];
                            glyphs.splice.apply(glyphs, [oldPos, 0].concat(glyphs.splice(oldPos + 1, newPos - oldPos)));
                            glyphs[newPos] = tmp;
                            newPos--;
                          }
                        }
                      }
                    }
                    if (start + 1 < end && glyphs[start].shaperInfo.position === POSITIONS.Ra_To_Become_Reph && glyphs[start].shaperInfo.category === CATEGORIES.Repha !== (glyphs[start].isLigated && !glyphs[start].isMultiplied)) {
                      var newRephPos = void 0;
                      var rephPos = indicConfig.rephPos;
                      var found = false;
                      if (rephPos !== POSITIONS.After_Post) {
                        newRephPos = start + 1;
                        while (newRephPos < base && !isHalantOrCoeng(glyphs[newRephPos])) {
                          newRephPos++;
                        }
                        if (newRephPos < base && isHalantOrCoeng(glyphs[newRephPos])) {
                          if (newRephPos + 1 < base && isJoiner(glyphs[newRephPos + 1])) {
                            newRephPos++;
                          }
                          found = true;
                        }
                        if (!found && rephPos === POSITIONS.After_Main) {
                          newRephPos = base;
                          while (newRephPos + 1 < end && glyphs[newRephPos + 1].shaperInfo.position <= POSITIONS.After_Main) {
                            newRephPos++;
                          }
                          found = newRephPos < end;
                        }
                        if (!found && rephPos === POSITIONS.After_Sub) {
                          newRephPos = base;
                          while (newRephPos + 1 < end && !(glyphs[newRephPos + 1].shaperInfo.position & (POSITIONS.Post_C | POSITIONS.After_Post | POSITIONS.SMVD))) {
                            newRephPos++;
                          }
                          found = newRephPos < end;
                        }
                      }
                      if (!found) {
                        newRephPos = start + 1;
                        while (newRephPos < base && !isHalantOrCoeng(glyphs[newRephPos])) {
                          newRephPos++;
                        }
                        if (newRephPos < base && isHalantOrCoeng(glyphs[newRephPos])) {
                          if (newRephPos + 1 < base && isJoiner(glyphs[newRephPos + 1])) {
                            newRephPos++;
                          }
                          found = true;
                        }
                      }
                      if (!found) {
                        newRephPos = end - 1;
                        while (newRephPos > start && glyphs[newRephPos].shaperInfo.position === POSITIONS.SMVD) {
                          newRephPos--;
                        }
                        if (isHalantOrCoeng(glyphs[newRephPos])) {
                          for (var _i20 = base + 1; _i20 < newRephPos; _i20++) {
                            if (glyphs[_i20].shaperInfo.category === CATEGORIES.M) {
                              newRephPos--;
                            }
                          }
                        }
                      }
                      var reph = glyphs[start];
                      glyphs.splice.apply(glyphs, [start, 0].concat(glyphs.splice(start + 1, newRephPos - start)));
                      glyphs[newRephPos] = reph;
                      if (start < base && base <= newRephPos) {
                        base--;
                      }
                    }
                    if (tryPref && base + 1 < end) {
                      for (var _i21 = base + 1; _i21 < end; _i21++) {
                        if (glyphs[_i21].features.pref) {
                          if (glyphs[_i21].isLigated && !glyphs[_i21].isMultiplied) {
                            var _newPos = base;
                            if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
                              while (_newPos > start && !(glyphs[_newPos - 1].shaperInfo.category & (CATEGORIES.M | HALANT_OR_COENG_FLAGS))) {
                                _newPos--;
                              }
                              if (_newPos > start && glyphs[_newPos - 1].shaperInfo.category === CATEGORIES.M) {
                                var _oldPos2 = _i21;
                                for (var j = base + 1; j < _oldPos2; j++) {
                                  if (glyphs[j].shaperInfo.category === CATEGORIES.M) {
                                    _newPos--;
                                    break;
                                  }
                                }
                              }
                            }
                            if (_newPos > start && isHalantOrCoeng(glyphs[_newPos - 1])) {
                              if (_newPos < end && isJoiner(glyphs[_newPos])) {
                                _newPos++;
                              }
                            }
                            var _oldPos = _i21;
                            var _tmp = glyphs[_oldPos];
                            glyphs.splice.apply(glyphs, [_newPos + 1, 0].concat(glyphs.splice(_newPos, _oldPos - _newPos)));
                            glyphs[_newPos] = _tmp;
                            if (_newPos <= base && base < _oldPos) {
                              base++;
                            }
                          }
                          break;
                        }
                      }
                    }
                    if (glyphs[start].shaperInfo.position === POSITIONS.Pre_M && (!start || !/Cf|Mn/.test(unicode.getCategory(glyphs[start - 1].codePoints[0])))) {
                      glyphs[start].features.init = true;
                    }
                  }
                }
                function nextSyllable(glyphs, start) {
                  if (start >= glyphs.length)
                    return start;
                  var syllable = glyphs[start].shaperInfo.syllable;
                  while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable) {
                  }
                  return start;
                }
                var categories$1 = useData.categories, decompositions$2 = useData.decompositions;
                var trie$2 = new UnicodeTrie(Buffer("AAACAAAAAAAQugAAAQUO+vHtnHuMX0UVx2d3u/t7bXe7FlqgvB+mpQhFmhikMRAg0ZQmakMU+cPWBzZisEGNjUpoiIYCEgmGUGOEGqOVNPUZUGNA+QNIBU2KREEFFSMBUYRISMXE+B3vnPzOzp553tcWfif5ZO5jnufMzJ2ZO/eumlDqFLAWnAMuBBvBZnC5uXZeBe4WsA1sBzs8/naCXcL1G8GtYDfYA74NvgfuAfcZHmT+fwEeBb8DTwvxPQWeAavACyZvq8z9VYxXwCGglijVBcvACnA8eCM4E6wHG8BF4BLwbvA+8AHwUbAd7AA7wS5wC9gN7gR7wX5wN7gXPAAeBr8Gvwd/Ac+CF8EhoCaV6oBZsBKcAE4FZ0wWeV8P9zxwoTnfCHczuBxsAdvAx8Gnzf1r4X4B3AxuA1+bHJb9m5PzdVGW/Yjv+xXHyfmxFfd9OH8Q/Ar8Bjw1WZT3GfACeAX8N5CfqSmlZsAKsGqqCH8K3DXgbHCuuXYB3HeAd4HLpgrdarbi+EPgY+CT4HPg8ybMTcb9MtyvghtYut/A+b4pf95+ELgfw08Qx/3gADgInjDl0veehPtX8A/wsrn2KtzxDuogWNoJx38k/BzXKeI8Ee5qcBZYD9aZtDbg+AwT19uMX83F7JizCdcvBZdZ97c6/BMfMWmfzfTm88/95aLj+DDSvApcDXZ04uPfaen3TMHPLvi5BezuFPVtD4t/qUcfe3FvP7gb3Ouwo9T+H+gMy/UIjh8DfwBPm7T08d/M8WMBe1Sh3xEjXo+M2s+IESNGjBgxYsSI1wLrOsM1gRsi/P+TzV3/Zc1jvxgR/j8IM9Et1mEGcJeDFeA4cJq5/ia467uF/w1wzwdvB+80998LdwvYZs63w90Bdnbd6Wp/uzz3R4wYMWJEvZzTMm2Xf8SIEfVQd/v+EsaPt3eL90J3wP2WMJ78Trd4t6+P77Hu37cIxp9/ny6YXqrUJeCR6TA74e/nll81MzxejeMtYA94HBwy91bPYow+O/S3A8d7oIM/gRN7CAP29Iqx/B1ThfuwOecM+vA3NmRjf6Gfm3BtH7v+PI7XDpS6EuwDz4O10+0/f9om1F4ehO4OmHp6EO7jxl56nvhsN/15ut+4Z0b657yYkZ7UJ0jhX0bcr3bn+6P87vekN4762QNzvWHZtL+jcH5srzg/uTf0f3pvfj5i+6tYW7rK9+aefO+tuL4BXAQ2gs3gPeBJc//9OL4CXAWuNvc/A64DN4Jbwe0s7jtxvBfsAz8EPwX3gwPgoJAHPQ9/Atf/bO7p/TTP4fglwS/5/zfujfWH5z0cz4Gj+8X5Sf1ib4m+vwbHZ/fdOtP+z+3LOnPp/QL4vxhsApeCy8BWk/a2ftFmYu22Hf4/Ba4B14Hrwc0sP7fh+Cvg6+Au8F1WthA/8pT7UeTxZ/12njkuXT8UyM9i6iur1EEb6f+yPz/eg0b3v4X7x365fMaW42lPu7PTv6vi8i/G+lWF/cvUk7bLl1r+5/rN5tu3j2qvWTd/qV+4h+AqjDGnBsX59GDo94iBXDa6v6Yjl6vu+h8itJcsZq/ZykHhHg/3tMHhUe9s/Yfuny7YNxTvQ8LYdrER2+/c0GBezhrMv3ZNRv7PmYirh7oOv4W1Y72/cwPOzx8U7X8d2295sfE3MPnbBPfSQbHv9nK4HxTqiK/trI7Yy5mLzvuVg/nX+N7V51A3r+gMy/4J434W7l2dYf5PZWGuNX6uh3uzEPetuLY7sZ20zTETY2oxyBhj3DrnfsidYPeXRGLHpxzX6pbFofGRkFBdGhcgW40L4cYtd9JAElO36q4LEzXHX7VMtZ2BEhJjy9dT25fazOtJxhwsBrHzwfu8w12kMYN9fLhIbp2RxlI59rX1dzjpsKl2Fxt3iu6rbofc9q5+KcRrXVzzDn6/Crvk6p/y1GFgGhs9/6maHjBLgv8/18fTxl1q0bPoW8ywsFTGWaazHosrNn/kP2eeqEroZYLZphsZl7L82eephMIqNT8dyT9JjH1Jpg32ubZvTB/SF665ymSnnaqjUHum+1Qn+NyOtz9f2r6y5OQ51b6hYy0D40r2tYXar30+Y/mbVX6JqY+hMC60XZapoh3S/HdOpT3DYu3rs0lKnquyb277JZvyPlqp+f1zVVK2/dJYNpQGf04uYyh1+PTPqfalZ2tO/xwSu+3bOrDzmWvfcTW/fLmibRx6lkvlcOlc8qsE/y5/rnSk67F1iAu1VT6+4jKt5tufn8e2b+n57JKcckhrsKG1Cd6Wu+Y8tf2l5DenPafqQZ/7xstKLeyr+XnInjSelvRgS9n27JPQM5n6Am7jmLG8VK6m7OvyS2L313XYV2r/tth5LWPfNxhyhI+1Up7HVbe/HMgeZE8brtNQ/7tcyX0cn//H2LTO9kpir5VI6yYp9szJW9W2jI1Tqfl5ic2v1GZ5XaG6RDZbyvxMO/DVh1SdUj5y1vraaHs+2/TYNXvtSRoXk4wrf9w6fEctnFt0zL2y+xFsfSrLza2zOTqMiZv8xOpbn8+xsL5ykdj6VsxNKb/Lvxb7nX8u48y1x6yuMW3V9tNxTlouzXslibVxndjC14xda8g2NIbg5x01XAP2lfeIBFSi/zrQEporTXru8fCueiy1CUnqrhspSM9SzbSS64tep9R1ZsZcOxKsUEUfNZeYtr0vjY5DeXW915hT8/PRV8MxlR1HV4DHZZc9R7dzajgWoXikdLtGr0uEfPigsGS/NvYjSHW87XejoXZehZ74XrcqpQ4d5T5f7Gu8f6g7fQmefoqOqk4/VarQv2o4/VDetPDnhjR2dc3BCBp/9NVw7KGfwStVMf6aZNAajj6224j9HCZbpZa/LvH1gU30i/q5WnUdSNEprxv2eIOwx2pcjjLMsmObo008k0J4u69P3d9QdbspW/dy080Nb8PXqcrmj0vsc7tu6qwD1A5oLYr3U3XWSxqj6/a10nCMkudJMyxvrvbK55jUrqU+Xlr/Iai98jY7mVAml5QNHxq31j2m5TrSdmp6z5p+9kpzQntdQbI1Pafr6I9C60gxrALHGtdF6tyhLTtxeBuW+hhqyzPMX931xl6rJ5f6n5h3blpsW7vKbvdBfL1gpYfjDLrvob1drrRT+mcuMf1OrJSdW/P+RfufdUB+pOtdTzhpL5t0jfKr46P3obQfQdPGt1jS+DEkx4MT2PmEg1j72OthqfZNWX+JuZ4at/2sTAmn5cSIMqZIjk0pnD0+aUI6YS9ekdaspWsp8cWEC62dS66UTkq+ypajyvXSlPz4xhQhm/ns6wpXBVI560jHN9aKkdT46spvWT916rONdHNsGSNtl6Hp8oakTVukpF9n3U3Jx0TNefbp3R4jltVfFfpvQkJpNaH/puyco++qbZPz7sE1L3DFGVovc4XPLUPO3ELyrzLiSpmPhaTJfqeJ+t60PiTh9snNW2656upDQ+Wtyg6ueJquB7HSVPspW9a28lDWJouhb6iyv7XjTfVL67j2vjDpvUfMt1Vl4GvctMaeq/vYcFWXIfV5Ku3XaxK951H6dsWFrhcxa3pU/pz3C1xc71tTcaXjGjtJbYIj7UHm7wxSyx+D/d7SfpfJ3wPpfSQp32tS2dt8V2tD7+Bce3rpPa3eC6Dr8Ulq+K+J3HFvbn312Zv2RdStr9g0pP0P/B04XbP3Q8cIT2dlRF6orkrhY/Rv27FqHfL1DP480ffo/V6V7aTHXLKDbTdXOOrnyG1ScvSv6xqve30lPzdpj36M8Pilb+L5vr0xE3dd30nWIfZ45uSSxK4x+CRmTUK6F/LrSsfnj+aOdYyvpXyMK7/OpHWjlDTsa0rJum5K7Ppnj7F9c+0q0qtr7pQji2X9oMwcVrJfmblwU2V2SV3rEk3YuO46XXf8MfrQz077G2zftyDkj/ZqhcZr9nldkOg5ykAt3GunJbR3NGYsUfWafd3ts853C4dLHppOM6WcfM5C+xSbaC/2HMa1H9v1vXdoXm/LKSVpYh5wqmr/X67SfwHtPc9a97p/k8bt0hpbW0j1Svr2m+7Rd98qIQ1pvSF273dKOjHYNmk6fd8/JX3tWIddblBqoU5p7zrZKnd9TppjVq0DSitWqkwz12b2exb7vwjaRvS/TFd/S+8AYvIo+Suri5TwvvZRdV1IQevQ1/8SA+UeH5eto7n/X1Oe86ptaafl8kPjcF7P7W93eD9d5n+oSvn7fFe7I/G9q1IBfylSR71N6fft94ZU18hOXKR+JqUO8f4+5dvLsmWlMQb/Vov+CUDlpTGUndeQlG3fdZWdRPoPgl3mmDlsLnaey/4X3tVuU+o6L3/Pym+qlLV/jk6rlBRd8394hZ6JdnuqIv2ykOh3pfq96Wkq/E8qu2xl88/tOJ4R3tfmpbGi3c5T859bzqr7MbsN03iI5itUNj5eaEKWqIX/KJCQ/iFWNZMmHXs8ovWk53JzFq5vPul6zDjLV36pX7bzvNzB0YlQOZephWtRS5T7eeSq8030R77/HvC1d7tN83Zt9yltrDdwSR0XxsZd5l+MvvvU1/M9jSnj+Nh6FPJbBld/w6XHXH5MZeXrOfS/65g9RTl1JCa8chzX2RZ9/3lXSh4/VqWfEBNq4b82Ytp6m+9Qqxir1jX+rfPdT1vvsWhM6bPbmON6E1LnPCZW7L0qqXswmtqf0MQelZj4myrzYtzvIYmURlvtqapyx+gzRfd0XPfahVSOquMoG+dibBdl46iyfdbV1qvUW9m8+KTudMvkzZe/pqTJ+pWTflX5zw1fVfox6ZTVc8hvHflOSb+OuG1JsZ0kufXAJf8D", "base64"));
                var stateMachine$1 = new StateMachine(useData);
                var UniversalShaper = function(_DefaultShaper4) {
                  _inheritsLoose(UniversalShaper2, _DefaultShaper4);
                  function UniversalShaper2() {
                    return _DefaultShaper4.apply(this, arguments) || this;
                  }
                  UniversalShaper2.planFeatures = function planFeatures(plan) {
                    plan.addStage(setupSyllables$1);
                    plan.addStage(["locl", "ccmp", "nukt", "akhn"]);
                    plan.addStage(clearSubstitutionFlags);
                    plan.addStage(["rphf"], false);
                    plan.addStage(recordRphf);
                    plan.addStage(clearSubstitutionFlags);
                    plan.addStage(["pref"]);
                    plan.addStage(recordPref);
                    plan.addStage(["rkrf", "abvf", "blwf", "half", "pstf", "vatu", "cjct"]);
                    plan.addStage(reorder);
                    plan.addStage(["abvs", "blws", "pres", "psts", "dist", "abvm", "blwm"]);
                  };
                  UniversalShaper2.assignFeatures = function assignFeatures(plan, glyphs) {
                    var _loop2 = function _loop3(i3) {
                      var codepoint = glyphs[i3].codePoints[0];
                      if (decompositions$2[codepoint]) {
                        var decomposed = decompositions$2[codepoint].map(function(c) {
                          var g = plan.font.glyphForCodePoint(c);
                          return new GlyphInfo(plan.font, g.id, [c], glyphs[i3].features);
                        });
                        glyphs.splice.apply(glyphs, [i3, 1].concat(decomposed));
                      }
                    };
                    for (var i2 = glyphs.length - 1; i2 >= 0; i2--) {
                      _loop2(i2);
                    }
                  };
                  return UniversalShaper2;
                }(DefaultShaper);
                _defineProperty(UniversalShaper, "zeroMarkWidths", "BEFORE_GPOS");
                function useCategory(glyph2) {
                  return trie$2.get(glyph2.codePoints[0]);
                }
                var USEInfo = function USEInfo2(category, syllableType, syllable) {
                  this.category = category;
                  this.syllableType = syllableType;
                  this.syllable = syllable;
                };
                function setupSyllables$1(font, glyphs) {
                  var syllable = 0;
                  for (var _iterator55 = _createForOfIteratorHelperLoose(stateMachine$1.match(glyphs.map(useCategory))), _step55; !(_step55 = _iterator55()).done; ) {
                    var _step55$value = _step55.value, start = _step55$value[0], end = _step55$value[1], tags2 = _step55$value[2];
                    ++syllable;
                    for (var i2 = start; i2 <= end; i2++) {
                      glyphs[i2].shaperInfo = new USEInfo(categories$1[useCategory(glyphs[i2])], tags2[0], syllable);
                    }
                    var limit = glyphs[start].shaperInfo.category === "R" ? 1 : Math.min(3, end - start);
                    for (var _i = start; _i < start + limit; _i++) {
                      glyphs[_i].features.rphf = true;
                    }
                  }
                }
                function clearSubstitutionFlags(font, glyphs) {
                  for (var _iterator56 = _createForOfIteratorHelperLoose(glyphs), _step56; !(_step56 = _iterator56()).done; ) {
                    var glyph2 = _step56.value;
                    glyph2.substituted = false;
                  }
                }
                function recordRphf(font, glyphs) {
                  for (var _iterator57 = _createForOfIteratorHelperLoose(glyphs), _step57; !(_step57 = _iterator57()).done; ) {
                    var glyph2 = _step57.value;
                    if (glyph2.substituted && glyph2.features.rphf) {
                      glyph2.shaperInfo.category = "R";
                    }
                  }
                }
                function recordPref(font, glyphs) {
                  for (var _iterator58 = _createForOfIteratorHelperLoose(glyphs), _step58; !(_step58 = _iterator58()).done; ) {
                    var glyph2 = _step58.value;
                    if (glyph2.substituted) {
                      glyph2.shaperInfo.category = "VPre";
                    }
                  }
                }
                function reorder(font, glyphs) {
                  var dottedCircle = font.glyphForCodePoint(9676).id;
                  for (var start = 0, end = nextSyllable$1(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable$1(glyphs, start)) {
                    var i2 = void 0, j = void 0;
                    var info = glyphs[start].shaperInfo;
                    var type = info.syllableType;
                    if (type !== "virama_terminated_cluster" && type !== "standard_cluster" && type !== "broken_cluster") {
                      continue;
                    }
                    if (type === "broken_cluster" && dottedCircle) {
                      var g = new GlyphInfo(font, dottedCircle, [9676]);
                      g.shaperInfo = info;
                      for (i2 = start; i2 < end && glyphs[i2].shaperInfo.category === "R"; i2++) {
                      }
                      glyphs.splice(++i2, 0, g);
                      end++;
                    }
                    if (info.category === "R" && end - start > 1) {
                      for (i2 = start + 1; i2 < end; i2++) {
                        info = glyphs[i2].shaperInfo;
                        if (isBase(info) || isHalant(glyphs[i2])) {
                          if (isHalant(glyphs[i2])) {
                            i2--;
                          }
                          glyphs.splice.apply(glyphs, [start, 0].concat(glyphs.splice(start + 1, i2 - start), [glyphs[i2]]));
                          break;
                        }
                      }
                    }
                    for (i2 = start, j = end; i2 < end; i2++) {
                      info = glyphs[i2].shaperInfo;
                      if (isBase(info) || isHalant(glyphs[i2])) {
                        j = isHalant(glyphs[i2]) ? i2 + 1 : i2;
                      } else if ((info.category === "VPre" || info.category === "VMPre") && j < i2) {
                        glyphs.splice.apply(glyphs, [j, 1, glyphs[i2]].concat(glyphs.splice(j, i2 - j)));
                      }
                    }
                  }
                }
                function nextSyllable$1(glyphs, start) {
                  if (start >= glyphs.length)
                    return start;
                  var syllable = glyphs[start].shaperInfo.syllable;
                  while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable) {
                  }
                  return start;
                }
                function isHalant(glyph2) {
                  return glyph2.shaperInfo.category === "H" && !glyph2.isLigated;
                }
                function isBase(info) {
                  return info.category === "B" || info.category === "GB";
                }
                var SHAPERS = {
                  arab: ArabicShaper,
                  // Arabic
                  mong: ArabicShaper,
                  // Mongolian
                  syrc: ArabicShaper,
                  // Syriac
                  "nko ": ArabicShaper,
                  // N'Ko
                  phag: ArabicShaper,
                  // Phags Pa
                  mand: ArabicShaper,
                  // Mandaic
                  mani: ArabicShaper,
                  // Manichaean
                  phlp: ArabicShaper,
                  // Psalter Pahlavi
                  hang: HangulShaper,
                  // Hangul
                  bng2: IndicShaper,
                  // Bengali
                  beng: IndicShaper,
                  // Bengali
                  dev2: IndicShaper,
                  // Devanagari
                  deva: IndicShaper,
                  // Devanagari
                  gjr2: IndicShaper,
                  // Gujarati
                  gujr: IndicShaper,
                  // Gujarati
                  guru: IndicShaper,
                  // Gurmukhi
                  gur2: IndicShaper,
                  // Gurmukhi
                  knda: IndicShaper,
                  // Kannada
                  knd2: IndicShaper,
                  // Kannada
                  mlm2: IndicShaper,
                  // Malayalam
                  mlym: IndicShaper,
                  // Malayalam
                  ory2: IndicShaper,
                  // Oriya
                  orya: IndicShaper,
                  // Oriya
                  taml: IndicShaper,
                  // Tamil
                  tml2: IndicShaper,
                  // Tamil
                  telu: IndicShaper,
                  // Telugu
                  tel2: IndicShaper,
                  // Telugu
                  khmr: IndicShaper,
                  // Khmer
                  bali: UniversalShaper,
                  // Balinese
                  batk: UniversalShaper,
                  // Batak
                  brah: UniversalShaper,
                  // Brahmi
                  bugi: UniversalShaper,
                  // Buginese
                  buhd: UniversalShaper,
                  // Buhid
                  cakm: UniversalShaper,
                  // Chakma
                  cham: UniversalShaper,
                  // Cham
                  dupl: UniversalShaper,
                  // Duployan
                  egyp: UniversalShaper,
                  // Egyptian Hieroglyphs
                  gran: UniversalShaper,
                  // Grantha
                  hano: UniversalShaper,
                  // Hanunoo
                  java: UniversalShaper,
                  // Javanese
                  kthi: UniversalShaper,
                  // Kaithi
                  kali: UniversalShaper,
                  // Kayah Li
                  khar: UniversalShaper,
                  // Kharoshthi
                  khoj: UniversalShaper,
                  // Khojki
                  sind: UniversalShaper,
                  // Khudawadi
                  lepc: UniversalShaper,
                  // Lepcha
                  limb: UniversalShaper,
                  // Limbu
                  mahj: UniversalShaper,
                  // Mahajani
                  // mand: UniversalShaper, // Mandaic
                  // mani: UniversalShaper, // Manichaean
                  mtei: UniversalShaper,
                  // Meitei Mayek
                  modi: UniversalShaper,
                  // Modi
                  // mong: UniversalShaper, // Mongolian
                  // 'nko ': UniversalShaper, // NKo
                  hmng: UniversalShaper,
                  // Pahawh Hmong
                  // phag: UniversalShaper, // Phags-pa
                  // phlp: UniversalShaper, // Psalter Pahlavi
                  rjng: UniversalShaper,
                  // Rejang
                  saur: UniversalShaper,
                  // Saurashtra
                  shrd: UniversalShaper,
                  // Sharada
                  sidd: UniversalShaper,
                  // Siddham
                  sinh: UniversalShaper,
                  // Sinhala
                  sund: UniversalShaper,
                  // Sundanese
                  sylo: UniversalShaper,
                  // Syloti Nagri
                  tglg: UniversalShaper,
                  // Tagalog
                  tagb: UniversalShaper,
                  // Tagbanwa
                  tale: UniversalShaper,
                  // Tai Le
                  lana: UniversalShaper,
                  // Tai Tham
                  tavt: UniversalShaper,
                  // Tai Viet
                  takr: UniversalShaper,
                  // Takri
                  tibt: UniversalShaper,
                  // Tibetan
                  tfng: UniversalShaper,
                  // Tifinagh
                  tirh: UniversalShaper,
                  // Tirhuta
                  latn: DefaultShaper,
                  // Latin
                  DFLT: DefaultShaper
                  // Default
                };
                function choose(script2) {
                  if (!Array.isArray(script2)) {
                    script2 = [script2];
                  }
                  for (var _iterator59 = _createForOfIteratorHelperLoose(script2), _step59; !(_step59 = _iterator59()).done; ) {
                    var s = _step59.value;
                    var shaper = SHAPERS[s];
                    if (shaper) {
                      return shaper;
                    }
                  }
                  return DefaultShaper;
                }
                var GSUBProcessor = function(_OTProcessor) {
                  _inheritsLoose(GSUBProcessor2, _OTProcessor);
                  function GSUBProcessor2() {
                    return _OTProcessor.apply(this, arguments) || this;
                  }
                  var _proto27 = GSUBProcessor2.prototype;
                  _proto27.applyLookup = function applyLookup(lookupType, table) {
                    var _this7 = this;
                    switch (lookupType) {
                      case 1: {
                        var index = this.coverageIndex(table.coverage);
                        if (index === -1) {
                          return false;
                        }
                        var glyph2 = this.glyphIterator.cur;
                        switch (table.version) {
                          case 1:
                            glyph2.id = glyph2.id + table.deltaGlyphID & 65535;
                            break;
                          case 2:
                            glyph2.id = table.substitute.get(index);
                            break;
                        }
                        return true;
                      }
                      case 2: {
                        var _index = this.coverageIndex(table.coverage);
                        if (_index !== -1) {
                          var _this$glyphs2;
                          var sequence = table.sequences.get(_index);
                          if (sequence.length === 0) {
                            this.glyphs.splice(this.glyphIterator.index, 1);
                            return true;
                          }
                          this.glyphIterator.cur.id = sequence[0];
                          this.glyphIterator.cur.ligatureComponent = 0;
                          var features2 = this.glyphIterator.cur.features;
                          var curGlyph = this.glyphIterator.cur;
                          var replacement = sequence.slice(1).map(function(gid, i3) {
                            var glyph3 = new GlyphInfo(_this7.font, gid, void 0, features2);
                            glyph3.shaperInfo = curGlyph.shaperInfo;
                            glyph3.isLigated = curGlyph.isLigated;
                            glyph3.ligatureComponent = i3 + 1;
                            glyph3.substituted = true;
                            glyph3.isMultiplied = true;
                            return glyph3;
                          });
                          (_this$glyphs2 = this.glyphs).splice.apply(_this$glyphs2, [this.glyphIterator.index + 1, 0].concat(replacement));
                          return true;
                        }
                        return false;
                      }
                      case 3: {
                        var _index2 = this.coverageIndex(table.coverage);
                        if (_index2 !== -1) {
                          var USER_INDEX = 0;
                          this.glyphIterator.cur.id = table.alternateSet.get(_index2)[USER_INDEX];
                          return true;
                        }
                        return false;
                      }
                      case 4: {
                        var _index3 = this.coverageIndex(table.coverage);
                        if (_index3 === -1) {
                          return false;
                        }
                        for (var _iterator60 = _createForOfIteratorHelperLoose(table.ligatureSets.get(_index3)), _step60; !(_step60 = _iterator60()).done; ) {
                          var ligature = _step60.value;
                          var matched = this.sequenceMatchIndices(1, ligature.components);
                          if (!matched) {
                            continue;
                          }
                          var _curGlyph = this.glyphIterator.cur;
                          var characters = _curGlyph.codePoints.slice();
                          for (var _iterator61 = _createForOfIteratorHelperLoose(matched), _step61; !(_step61 = _iterator61()).done; ) {
                            var _characters;
                            var _index4 = _step61.value;
                            (_characters = characters).push.apply(_characters, this.glyphs[_index4].codePoints);
                          }
                          var ligatureGlyph = new GlyphInfo(this.font, ligature.glyph, characters, _curGlyph.features);
                          ligatureGlyph.shaperInfo = _curGlyph.shaperInfo;
                          ligatureGlyph.isLigated = true;
                          ligatureGlyph.substituted = true;
                          var isMarkLigature = _curGlyph.isMark;
                          for (var i2 = 0; i2 < matched.length && isMarkLigature; i2++) {
                            isMarkLigature = this.glyphs[matched[i2]].isMark;
                          }
                          ligatureGlyph.ligatureID = isMarkLigature ? null : this.ligatureID++;
                          var lastLigID = _curGlyph.ligatureID;
                          var lastNumComps = _curGlyph.codePoints.length;
                          var curComps = lastNumComps;
                          var idx = this.glyphIterator.index + 1;
                          for (var _iterator62 = _createForOfIteratorHelperLoose(matched), _step62; !(_step62 = _iterator62()).done; ) {
                            var matchIndex = _step62.value;
                            if (isMarkLigature) {
                              idx = matchIndex;
                            } else {
                              while (idx < matchIndex) {
                                var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[idx].ligatureComponent || 1, lastNumComps);
                                this.glyphs[idx].ligatureID = ligatureGlyph.ligatureID;
                                this.glyphs[idx].ligatureComponent = ligatureComponent;
                                idx++;
                              }
                            }
                            lastLigID = this.glyphs[idx].ligatureID;
                            lastNumComps = this.glyphs[idx].codePoints.length;
                            curComps += lastNumComps;
                            idx++;
                          }
                          if (lastLigID && !isMarkLigature) {
                            for (var _i = idx; _i < this.glyphs.length; _i++) {
                              if (this.glyphs[_i].ligatureID === lastLigID) {
                                var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[_i].ligatureComponent || 1, lastNumComps);
                                this.glyphs[_i].ligatureComponent = ligatureComponent;
                              } else {
                                break;
                              }
                            }
                          }
                          for (var _i2 = matched.length - 1; _i2 >= 0; _i2--) {
                            this.glyphs.splice(matched[_i2], 1);
                          }
                          this.glyphs[this.glyphIterator.index] = ligatureGlyph;
                          return true;
                        }
                        return false;
                      }
                      case 5:
                        return this.applyContext(table);
                      case 6:
                        return this.applyChainingContext(table);
                      case 7:
                        return this.applyLookup(table.lookupType, table.extension);
                      default:
                        throw new Error("GSUB lookupType ".concat(lookupType, " is not supported"));
                    }
                  };
                  return GSUBProcessor2;
                }(OTProcessor);
                var GPOSProcessor = function(_OTProcessor2) {
                  _inheritsLoose(GPOSProcessor2, _OTProcessor2);
                  function GPOSProcessor2() {
                    return _OTProcessor2.apply(this, arguments) || this;
                  }
                  var _proto28 = GPOSProcessor2.prototype;
                  _proto28.applyPositionValue = function applyPositionValue(sequenceIndex, value) {
                    var position = this.positions[this.glyphIterator.peekIndex(sequenceIndex)];
                    if (value.xAdvance != null) {
                      position.xAdvance += value.xAdvance;
                    }
                    if (value.yAdvance != null) {
                      position.yAdvance += value.yAdvance;
                    }
                    if (value.xPlacement != null) {
                      position.xOffset += value.xPlacement;
                    }
                    if (value.yPlacement != null) {
                      position.yOffset += value.yPlacement;
                    }
                    var variationProcessor = this.font._variationProcessor;
                    var variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
                    if (variationProcessor && variationStore) {
                      if (value.xPlaDevice) {
                        position.xOffset += variationProcessor.getDelta(variationStore, value.xPlaDevice.a, value.xPlaDevice.b);
                      }
                      if (value.yPlaDevice) {
                        position.yOffset += variationProcessor.getDelta(variationStore, value.yPlaDevice.a, value.yPlaDevice.b);
                      }
                      if (value.xAdvDevice) {
                        position.xAdvance += variationProcessor.getDelta(variationStore, value.xAdvDevice.a, value.xAdvDevice.b);
                      }
                      if (value.yAdvDevice) {
                        position.yAdvance += variationProcessor.getDelta(variationStore, value.yAdvDevice.a, value.yAdvDevice.b);
                      }
                    }
                  };
                  _proto28.applyLookup = function applyLookup(lookupType, table) {
                    switch (lookupType) {
                      case 1: {
                        var index = this.coverageIndex(table.coverage);
                        if (index === -1) {
                          return false;
                        }
                        switch (table.version) {
                          case 1:
                            this.applyPositionValue(0, table.value);
                            break;
                          case 2:
                            this.applyPositionValue(0, table.values.get(index));
                            break;
                        }
                        return true;
                      }
                      case 2: {
                        var nextGlyph = this.glyphIterator.peek();
                        if (!nextGlyph) {
                          return false;
                        }
                        var _index = this.coverageIndex(table.coverage);
                        if (_index === -1) {
                          return false;
                        }
                        switch (table.version) {
                          case 1:
                            var set = table.pairSets.get(_index);
                            for (var _iterator63 = _createForOfIteratorHelperLoose(set), _step63; !(_step63 = _iterator63()).done; ) {
                              var _pair = _step63.value;
                              if (_pair.secondGlyph === nextGlyph.id) {
                                this.applyPositionValue(0, _pair.value1);
                                this.applyPositionValue(1, _pair.value2);
                                return true;
                              }
                            }
                            return false;
                          case 2:
                            var class1 = this.getClassID(this.glyphIterator.cur.id, table.classDef1);
                            var class2 = this.getClassID(nextGlyph.id, table.classDef2);
                            if (class1 === -1 || class2 === -1) {
                              return false;
                            }
                            var pair = table.classRecords.get(class1).get(class2);
                            this.applyPositionValue(0, pair.value1);
                            this.applyPositionValue(1, pair.value2);
                            return true;
                        }
                      }
                      case 3: {
                        var nextIndex = this.glyphIterator.peekIndex();
                        var _nextGlyph = this.glyphs[nextIndex];
                        if (!_nextGlyph) {
                          return false;
                        }
                        var curRecord = table.entryExitRecords[this.coverageIndex(table.coverage)];
                        if (!curRecord || !curRecord.exitAnchor) {
                          return false;
                        }
                        var nextRecord = table.entryExitRecords[this.coverageIndex(table.coverage, _nextGlyph.id)];
                        if (!nextRecord || !nextRecord.entryAnchor) {
                          return false;
                        }
                        var entry = this.getAnchor(nextRecord.entryAnchor);
                        var exit = this.getAnchor(curRecord.exitAnchor);
                        var cur = this.positions[this.glyphIterator.index];
                        var next = this.positions[nextIndex];
                        switch (this.direction) {
                          case "ltr":
                            cur.xAdvance = exit.x + cur.xOffset;
                            var d = entry.x + next.xOffset;
                            next.xAdvance -= d;
                            next.xOffset -= d;
                            break;
                          case "rtl":
                            d = exit.x + cur.xOffset;
                            cur.xAdvance -= d;
                            cur.xOffset -= d;
                            next.xAdvance = entry.x + next.xOffset;
                            break;
                        }
                        if (this.glyphIterator.flags.rightToLeft) {
                          this.glyphIterator.cur.cursiveAttachment = nextIndex;
                          cur.yOffset = entry.y - exit.y;
                        } else {
                          _nextGlyph.cursiveAttachment = this.glyphIterator.index;
                          cur.yOffset = exit.y - entry.y;
                        }
                        return true;
                      }
                      case 4: {
                        var markIndex = this.coverageIndex(table.markCoverage);
                        if (markIndex === -1) {
                          return false;
                        }
                        var baseGlyphIndex = this.glyphIterator.index;
                        while (--baseGlyphIndex >= 0 && (this.glyphs[baseGlyphIndex].isMark || this.glyphs[baseGlyphIndex].ligatureComponent > 0)) {
                        }
                        if (baseGlyphIndex < 0) {
                          return false;
                        }
                        var baseIndex = this.coverageIndex(table.baseCoverage, this.glyphs[baseGlyphIndex].id);
                        if (baseIndex === -1) {
                          return false;
                        }
                        var markRecord = table.markArray[markIndex];
                        var baseAnchor = table.baseArray[baseIndex][markRecord.class];
                        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
                        return true;
                      }
                      case 5: {
                        var _markIndex = this.coverageIndex(table.markCoverage);
                        if (_markIndex === -1) {
                          return false;
                        }
                        var _baseGlyphIndex = this.glyphIterator.index;
                        while (--_baseGlyphIndex >= 0 && this.glyphs[_baseGlyphIndex].isMark) {
                        }
                        if (_baseGlyphIndex < 0) {
                          return false;
                        }
                        var ligIndex = this.coverageIndex(table.ligatureCoverage, this.glyphs[_baseGlyphIndex].id);
                        if (ligIndex === -1) {
                          return false;
                        }
                        var ligAttach = table.ligatureArray[ligIndex];
                        var markGlyph = this.glyphIterator.cur;
                        var ligGlyph = this.glyphs[_baseGlyphIndex];
                        var compIndex = ligGlyph.ligatureID && ligGlyph.ligatureID === markGlyph.ligatureID && markGlyph.ligatureComponent > 0 ? Math.min(markGlyph.ligatureComponent, ligGlyph.codePoints.length) - 1 : ligGlyph.codePoints.length - 1;
                        var _markRecord = table.markArray[_markIndex];
                        var _baseAnchor = ligAttach[compIndex][_markRecord.class];
                        this.applyAnchor(_markRecord, _baseAnchor, _baseGlyphIndex);
                        return true;
                      }
                      case 6: {
                        var mark1Index = this.coverageIndex(table.mark1Coverage);
                        if (mark1Index === -1) {
                          return false;
                        }
                        var prevIndex = this.glyphIterator.peekIndex(-1);
                        var prev = this.glyphs[prevIndex];
                        if (!prev || !prev.isMark) {
                          return false;
                        }
                        var _cur = this.glyphIterator.cur;
                        var good = false;
                        if (_cur.ligatureID === prev.ligatureID) {
                          if (!_cur.ligatureID) {
                            good = true;
                          } else if (_cur.ligatureComponent === prev.ligatureComponent) {
                            good = true;
                          }
                        } else {
                          if (_cur.ligatureID && !_cur.ligatureComponent || prev.ligatureID && !prev.ligatureComponent) {
                            good = true;
                          }
                        }
                        if (!good) {
                          return false;
                        }
                        var mark2Index = this.coverageIndex(table.mark2Coverage, prev.id);
                        if (mark2Index === -1) {
                          return false;
                        }
                        var _markRecord2 = table.mark1Array[mark1Index];
                        var _baseAnchor2 = table.mark2Array[mark2Index][_markRecord2.class];
                        this.applyAnchor(_markRecord2, _baseAnchor2, prevIndex);
                        return true;
                      }
                      case 7:
                        return this.applyContext(table);
                      case 8:
                        return this.applyChainingContext(table);
                      case 9:
                        return this.applyLookup(table.lookupType, table.extension);
                      default:
                        throw new Error("Unsupported GPOS table: ".concat(lookupType));
                    }
                  };
                  _proto28.applyAnchor = function applyAnchor(markRecord, baseAnchor, baseGlyphIndex) {
                    var baseCoords = this.getAnchor(baseAnchor);
                    var markCoords = this.getAnchor(markRecord.markAnchor);
                    var basePos = this.positions[baseGlyphIndex];
                    var markPos = this.positions[this.glyphIterator.index];
                    markPos.xOffset = baseCoords.x - markCoords.x;
                    markPos.yOffset = baseCoords.y - markCoords.y;
                    this.glyphIterator.cur.markAttachment = baseGlyphIndex;
                  };
                  _proto28.getAnchor = function getAnchor(anchor) {
                    var x = anchor.xCoordinate;
                    var y = anchor.yCoordinate;
                    var variationProcessor = this.font._variationProcessor;
                    var variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
                    if (variationProcessor && variationStore) {
                      if (anchor.xDeviceTable) {
                        x += variationProcessor.getDelta(variationStore, anchor.xDeviceTable.a, anchor.xDeviceTable.b);
                      }
                      if (anchor.yDeviceTable) {
                        y += variationProcessor.getDelta(variationStore, anchor.yDeviceTable.a, anchor.yDeviceTable.b);
                      }
                    }
                    return {
                      x,
                      y
                    };
                  };
                  _proto28.applyFeatures = function applyFeatures(userFeatures, glyphs, advances) {
                    _OTProcessor2.prototype.applyFeatures.call(this, userFeatures, glyphs, advances);
                    for (var i2 = 0; i2 < this.glyphs.length; i2++) {
                      this.fixCursiveAttachment(i2);
                    }
                    this.fixMarkAttachment();
                  };
                  _proto28.fixCursiveAttachment = function fixCursiveAttachment(i2) {
                    var glyph2 = this.glyphs[i2];
                    if (glyph2.cursiveAttachment != null) {
                      var j = glyph2.cursiveAttachment;
                      glyph2.cursiveAttachment = null;
                      this.fixCursiveAttachment(j);
                      this.positions[i2].yOffset += this.positions[j].yOffset;
                    }
                  };
                  _proto28.fixMarkAttachment = function fixMarkAttachment() {
                    for (var i2 = 0; i2 < this.glyphs.length; i2++) {
                      var glyph2 = this.glyphs[i2];
                      if (glyph2.markAttachment != null) {
                        var j = glyph2.markAttachment;
                        this.positions[i2].xOffset += this.positions[j].xOffset;
                        this.positions[i2].yOffset += this.positions[j].yOffset;
                        if (this.direction === "ltr") {
                          for (var k = j; k < i2; k++) {
                            this.positions[i2].xOffset -= this.positions[k].xAdvance;
                            this.positions[i2].yOffset -= this.positions[k].yAdvance;
                          }
                        } else {
                          for (var _k = j + 1; _k < i2 + 1; _k++) {
                            this.positions[i2].xOffset += this.positions[_k].xAdvance;
                            this.positions[i2].yOffset += this.positions[_k].yAdvance;
                          }
                        }
                      }
                    }
                  };
                  return GPOSProcessor2;
                }(OTProcessor);
                var OTLayoutEngine = function() {
                  function OTLayoutEngine2(font) {
                    this.font = font;
                    this.glyphInfos = null;
                    this.plan = null;
                    this.GSUBProcessor = null;
                    this.GPOSProcessor = null;
                    this.fallbackPosition = true;
                    if (font.GSUB) {
                      this.GSUBProcessor = new GSUBProcessor(font, font.GSUB);
                    }
                    if (font.GPOS) {
                      this.GPOSProcessor = new GPOSProcessor(font, font.GPOS);
                    }
                  }
                  var _proto29 = OTLayoutEngine2.prototype;
                  _proto29.setup = function setup(glyphRun) {
                    var _this8 = this;
                    this.glyphInfos = glyphRun.glyphs.map(function(glyph2) {
                      return new GlyphInfo(_this8.font, glyph2.id, [].concat(glyph2.codePoints));
                    });
                    var script2 = null;
                    if (this.GPOSProcessor) {
                      script2 = this.GPOSProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
                    }
                    if (this.GSUBProcessor) {
                      script2 = this.GSUBProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
                    }
                    this.shaper = choose(script2);
                    this.plan = new ShapingPlan(this.font, script2, glyphRun.direction);
                    this.shaper.plan(this.plan, this.glyphInfos, glyphRun.features);
                    for (var key in this.plan.allFeatures) {
                      glyphRun.features[key] = true;
                    }
                  };
                  _proto29.substitute = function substitute(glyphRun) {
                    var _this9 = this;
                    if (this.GSUBProcessor) {
                      this.plan.process(this.GSUBProcessor, this.glyphInfos);
                      glyphRun.glyphs = this.glyphInfos.map(function(glyphInfo) {
                        return _this9.font.getGlyph(glyphInfo.id, glyphInfo.codePoints);
                      });
                    }
                  };
                  _proto29.position = function position(glyphRun) {
                    if (this.shaper.zeroMarkWidths === "BEFORE_GPOS") {
                      this.zeroMarkAdvances(glyphRun.positions);
                    }
                    if (this.GPOSProcessor) {
                      this.plan.process(this.GPOSProcessor, this.glyphInfos, glyphRun.positions);
                    }
                    if (this.shaper.zeroMarkWidths === "AFTER_GPOS") {
                      this.zeroMarkAdvances(glyphRun.positions);
                    }
                    if (glyphRun.direction === "rtl") {
                      glyphRun.glyphs.reverse();
                      glyphRun.positions.reverse();
                    }
                    return this.GPOSProcessor && this.GPOSProcessor.features;
                  };
                  _proto29.zeroMarkAdvances = function zeroMarkAdvances(positions) {
                    for (var i2 = 0; i2 < this.glyphInfos.length; i2++) {
                      if (this.glyphInfos[i2].isMark) {
                        positions[i2].xAdvance = 0;
                        positions[i2].yAdvance = 0;
                      }
                    }
                  };
                  _proto29.cleanup = function cleanup() {
                    this.glyphInfos = null;
                    this.plan = null;
                    this.shaper = null;
                  };
                  _proto29.getAvailableFeatures = function getAvailableFeatures(script2, language) {
                    var features2 = [];
                    if (this.GSUBProcessor) {
                      this.GSUBProcessor.selectScript(script2, language);
                      features2.push.apply(features2, Object.keys(this.GSUBProcessor.features));
                    }
                    if (this.GPOSProcessor) {
                      this.GPOSProcessor.selectScript(script2, language);
                      features2.push.apply(features2, Object.keys(this.GPOSProcessor.features));
                    }
                    return features2;
                  };
                  return OTLayoutEngine2;
                }();
                var LayoutEngine = function() {
                  function LayoutEngine2(font) {
                    this.font = font;
                    this.unicodeLayoutEngine = null;
                    this.kernProcessor = null;
                    if (this.font.morx) {
                      this.engine = new AATLayoutEngine(this.font);
                    } else if (this.font.GSUB || this.font.GPOS) {
                      this.engine = new OTLayoutEngine(this.font);
                    }
                  }
                  var _proto30 = LayoutEngine2.prototype;
                  _proto30.layout = function layout(string, features2, script2, language, direction2) {
                    if (typeof features2 === "string") {
                      direction2 = language;
                      language = script2;
                      script2 = features2;
                      features2 = [];
                    }
                    if (typeof string === "string") {
                      if (script2 == null) {
                        script2 = forString(string);
                      }
                      var glyphs = this.font.glyphsForString(string);
                    } else {
                      if (script2 == null) {
                        var codePoints = [];
                        for (var _iterator64 = _createForOfIteratorHelperLoose(string), _step64; !(_step64 = _iterator64()).done; ) {
                          var glyph2 = _step64.value;
                          codePoints.push.apply(codePoints, glyph2.codePoints);
                        }
                        script2 = forCodePoints(codePoints);
                      }
                      var glyphs = string;
                    }
                    var glyphRun = new GlyphRun(glyphs, features2, script2, language, direction2);
                    if (glyphs.length === 0) {
                      glyphRun.positions = [];
                      return glyphRun;
                    }
                    if (this.engine && this.engine.setup) {
                      this.engine.setup(glyphRun);
                    }
                    this.substitute(glyphRun);
                    this.position(glyphRun);
                    this.hideDefaultIgnorables(glyphRun.glyphs, glyphRun.positions);
                    if (this.engine && this.engine.cleanup) {
                      this.engine.cleanup();
                    }
                    return glyphRun;
                  };
                  _proto30.substitute = function substitute(glyphRun) {
                    if (this.engine && this.engine.substitute) {
                      this.engine.substitute(glyphRun);
                    }
                  };
                  _proto30.position = function position(glyphRun) {
                    glyphRun.positions = glyphRun.glyphs.map(function(glyph2) {
                      return new GlyphPosition(glyph2.advanceWidth);
                    });
                    var positioned = null;
                    if (this.engine && this.engine.position) {
                      positioned = this.engine.position(glyphRun);
                    }
                    if (!positioned && (!this.engine || this.engine.fallbackPosition)) {
                      if (!this.unicodeLayoutEngine) {
                        this.unicodeLayoutEngine = new UnicodeLayoutEngine(this.font);
                      }
                      this.unicodeLayoutEngine.positionGlyphs(glyphRun.glyphs, glyphRun.positions);
                    }
                    if ((!positioned || !positioned.kern) && glyphRun.features.kern !== false && this.font.kern) {
                      if (!this.kernProcessor) {
                        this.kernProcessor = new KernProcessor(this.font);
                      }
                      this.kernProcessor.process(glyphRun.glyphs, glyphRun.positions);
                      glyphRun.features.kern = true;
                    }
                  };
                  _proto30.hideDefaultIgnorables = function hideDefaultIgnorables(glyphs, positions) {
                    var space = this.font.glyphForCodePoint(32);
                    for (var i2 = 0; i2 < glyphs.length; i2++) {
                      if (this.isDefaultIgnorable(glyphs[i2].codePoints[0])) {
                        glyphs[i2] = space;
                        positions[i2].xAdvance = 0;
                        positions[i2].yAdvance = 0;
                      }
                    }
                  };
                  _proto30.isDefaultIgnorable = function isDefaultIgnorable(ch) {
                    var plane = ch >> 16;
                    if (plane === 0) {
                      switch (ch >> 8) {
                        case 0:
                          return ch === 173;
                        case 3:
                          return ch === 847;
                        case 6:
                          return ch === 1564;
                        case 23:
                          return 6068 <= ch && ch <= 6069;
                        case 24:
                          return 6155 <= ch && ch <= 6158;
                        case 32:
                          return 8203 <= ch && ch <= 8207 || 8234 <= ch && ch <= 8238 || 8288 <= ch && ch <= 8303;
                        case 254:
                          return 65024 <= ch && ch <= 65039 || ch === 65279;
                        case 255:
                          return 65520 <= ch && ch <= 65528;
                        default:
                          return false;
                      }
                    } else {
                      switch (plane) {
                        case 1:
                          return 113824 <= ch && ch <= 113827 || 119155 <= ch && ch <= 119162;
                        case 14:
                          return 917504 <= ch && ch <= 921599;
                        default:
                          return false;
                      }
                    }
                  };
                  _proto30.getAvailableFeatures = function getAvailableFeatures(script2, language) {
                    var features2 = [];
                    if (this.engine) {
                      features2.push.apply(features2, this.engine.getAvailableFeatures(script2, language));
                    }
                    if (this.font.kern && features2.indexOf("kern") === -1) {
                      features2.push("kern");
                    }
                    return features2;
                  };
                  _proto30.stringsForGlyph = function stringsForGlyph(gid) {
                    var result = /* @__PURE__ */ new Set();
                    var codePoints = this.font._cmapProcessor.codePointsForGlyph(gid);
                    for (var _iterator65 = _createForOfIteratorHelperLoose(codePoints), _step65; !(_step65 = _iterator65()).done; ) {
                      var codePoint = _step65.value;
                      result.add(String.fromCodePoint(codePoint));
                    }
                    if (this.engine && this.engine.stringsForGlyph) {
                      for (var _iterator66 = _createForOfIteratorHelperLoose(this.engine.stringsForGlyph(gid)), _step66; !(_step66 = _iterator66()).done; ) {
                        var string = _step66.value;
                        result.add(string);
                      }
                    }
                    return Array.from(result);
                  };
                  return LayoutEngine2;
                }();
                var SVG_COMMANDS = {
                  moveTo: "M",
                  lineTo: "L",
                  quadraticCurveTo: "Q",
                  bezierCurveTo: "C",
                  closePath: "Z"
                };
                var Path = function() {
                  function Path2() {
                    this.commands = [];
                    this._bbox = null;
                    this._cbox = null;
                  }
                  var _proto31 = Path2.prototype;
                  _proto31.toFunction = function toFunction() {
                    var _this10 = this;
                    return function(ctx) {
                      _this10.commands.forEach(function(c) {
                        return ctx[c.command].apply(ctx, c.args);
                      });
                    };
                  };
                  _proto31.toSVG = function toSVG() {
                    var cmds = this.commands.map(function(c) {
                      var args = c.args.map(function(arg) {
                        return Math.round(arg * 100) / 100;
                      });
                      return "".concat(SVG_COMMANDS[c.command]).concat(args.join(" "));
                    });
                    return cmds.join("");
                  };
                  _proto31.mapPoints = function mapPoints(fn) {
                    var path = new Path2();
                    for (var _iterator67 = _createForOfIteratorHelperLoose(this.commands), _step67; !(_step67 = _iterator67()).done; ) {
                      var c = _step67.value;
                      var args = [];
                      for (var i2 = 0; i2 < c.args.length; i2 += 2) {
                        var _fn = fn(c.args[i2], c.args[i2 + 1]), x = _fn[0], y = _fn[1];
                        args.push(x, y);
                      }
                      path[c.command].apply(path, args);
                    }
                    return path;
                  };
                  _proto31.transform = function transform(m0, m1, m2, m3, m4, m5) {
                    return this.mapPoints(function(x, y) {
                      x = m0 * x + m2 * y + m4;
                      y = m1 * x + m3 * y + m5;
                      return [x, y];
                    });
                  };
                  _proto31.translate = function translate(x, y) {
                    return this.transform(1, 0, 0, 1, x, y);
                  };
                  _proto31.rotate = function rotate(angle) {
                    var cos = Math.cos(angle);
                    var sin = Math.sin(angle);
                    return this.transform(cos, sin, -sin, cos, 0, 0);
                  };
                  _proto31.scale = function scale(scaleX, scaleY) {
                    if (scaleY === void 0) {
                      scaleY = scaleX;
                    }
                    return this.transform(scaleX, 0, 0, scaleY, 0, 0);
                  };
                  _createClass(Path2, [{
                    key: "cbox",
                    get: function get() {
                      if (!this._cbox) {
                        var cbox = new BBox();
                        for (var _iterator68 = _createForOfIteratorHelperLoose(this.commands), _step68; !(_step68 = _iterator68()).done; ) {
                          var command2 = _step68.value;
                          for (var i2 = 0; i2 < command2.args.length; i2 += 2) {
                            cbox.addPoint(command2.args[i2], command2.args[i2 + 1]);
                          }
                        }
                        this._cbox = Object.freeze(cbox);
                      }
                      return this._cbox;
                    }
                    /**
                     * Gets the exact bounding box of the path by evaluating curve segments.
                     * Slower to compute than the control box, but more accurate.
                     * @type {BBox}
                     */
                  }, {
                    key: "bbox",
                    get: function get() {
                      if (this._bbox) {
                        return this._bbox;
                      }
                      var bbox = new BBox();
                      var cx = 0, cy = 0;
                      var f = function f2(t3) {
                        return Math.pow(1 - t3, 3) * p0[i2] + 3 * Math.pow(1 - t3, 2) * t3 * p1[i2] + 3 * (1 - t3) * Math.pow(t3, 2) * p2[i2] + Math.pow(t3, 3) * p3[i2];
                      };
                      for (var _iterator69 = _createForOfIteratorHelperLoose(this.commands), _step69; !(_step69 = _iterator69()).done; ) {
                        var c = _step69.value;
                        switch (c.command) {
                          case "moveTo":
                          case "lineTo":
                            var _c$args = c.args, x = _c$args[0], y = _c$args[1];
                            bbox.addPoint(x, y);
                            cx = x;
                            cy = y;
                            break;
                          case "quadraticCurveTo":
                          case "bezierCurveTo":
                            if (c.command === "quadraticCurveTo") {
                              var _c$args2 = c.args, qp1x = _c$args2[0], qp1y = _c$args2[1], p3x = _c$args2[2], p3y = _c$args2[3];
                              var cp1x = cx + 2 / 3 * (qp1x - cx);
                              var cp1y = cy + 2 / 3 * (qp1y - cy);
                              var cp2x = p3x + 2 / 3 * (qp1x - p3x);
                              var cp2y = p3y + 2 / 3 * (qp1y - p3y);
                            } else {
                              var _c$args3 = c.args, cp1x = _c$args3[0], cp1y = _c$args3[1], cp2x = _c$args3[2], cp2y = _c$args3[3], p3x = _c$args3[4], p3y = _c$args3[5];
                            }
                            bbox.addPoint(p3x, p3y);
                            var p0 = [cx, cy];
                            var p1 = [cp1x, cp1y];
                            var p2 = [cp2x, cp2y];
                            var p3 = [p3x, p3y];
                            for (var i2 = 0; i2 <= 1; i2++) {
                              var b = 6 * p0[i2] - 12 * p1[i2] + 6 * p2[i2];
                              var a = -3 * p0[i2] + 9 * p1[i2] - 9 * p2[i2] + 3 * p3[i2];
                              c = 3 * p1[i2] - 3 * p0[i2];
                              if (a === 0) {
                                if (b === 0) {
                                  continue;
                                }
                                var t2 = -c / b;
                                if (0 < t2 && t2 < 1) {
                                  if (i2 === 0) {
                                    bbox.addPoint(f(t2), bbox.maxY);
                                  } else if (i2 === 1) {
                                    bbox.addPoint(bbox.maxX, f(t2));
                                  }
                                }
                                continue;
                              }
                              var b2ac = Math.pow(b, 2) - 4 * c * a;
                              if (b2ac < 0) {
                                continue;
                              }
                              var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
                              if (0 < t1 && t1 < 1) {
                                if (i2 === 0) {
                                  bbox.addPoint(f(t1), bbox.maxY);
                                } else if (i2 === 1) {
                                  bbox.addPoint(bbox.maxX, f(t1));
                                }
                              }
                              var t22 = (-b - Math.sqrt(b2ac)) / (2 * a);
                              if (0 < t22 && t22 < 1) {
                                if (i2 === 0) {
                                  bbox.addPoint(f(t22), bbox.maxY);
                                } else if (i2 === 1) {
                                  bbox.addPoint(bbox.maxX, f(t22));
                                }
                              }
                            }
                            cx = p3x;
                            cy = p3y;
                            break;
                        }
                      }
                      return this._bbox = Object.freeze(bbox);
                    }
                  }]);
                  return Path2;
                }();
                var _loop = function _loop2(command2) {
                  Path.prototype[command2] = function() {
                    this._bbox = this._cbox = null;
                    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                      args[_key2] = arguments[_key2];
                    }
                    this.commands.push({
                      command: command2,
                      args
                    });
                    return this;
                  };
                };
                for (var _i23 = 0, _arr = ["moveTo", "lineTo", "quadraticCurveTo", "bezierCurveTo", "closePath"]; _i23 < _arr.length; _i23++) {
                  var command = _arr[_i23];
                  _loop(command);
                }
                var StandardNames = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
                var _class$3;
                var Glyph = (_class$3 = function() {
                  function Glyph2(id, codePoints, font) {
                    this.id = id;
                    this.codePoints = codePoints;
                    this._font = font;
                    this.isMark = this.codePoints.length > 0 && this.codePoints.every(unicode.isMark);
                    this.isLigature = this.codePoints.length > 1;
                  }
                  var _proto32 = Glyph2.prototype;
                  _proto32._getPath = function _getPath() {
                    return new Path();
                  };
                  _proto32._getCBox = function _getCBox() {
                    return this.path.cbox;
                  };
                  _proto32._getBBox = function _getBBox() {
                    return this.path.bbox;
                  };
                  _proto32._getTableMetrics = function _getTableMetrics(table) {
                    if (this.id < table.metrics.length) {
                      return table.metrics.get(this.id);
                    }
                    var metric = table.metrics.get(table.metrics.length - 1);
                    var res = {
                      advance: metric ? metric.advance : 0,
                      bearing: table.bearings.get(this.id - table.metrics.length) || 0
                    };
                    return res;
                  };
                  _proto32._getMetrics = function _getMetrics(cbox) {
                    if (this._metrics) {
                      return this._metrics;
                    }
                    var _this$_getTableMetric = this._getTableMetrics(this._font.hmtx), advanceWidth = _this$_getTableMetric.advance, leftBearing = _this$_getTableMetric.bearing;
                    if (this._font.vmtx) {
                      var _this$_getTableMetric2 = this._getTableMetrics(this._font.vmtx), advanceHeight = _this$_getTableMetric2.advance, topBearing = _this$_getTableMetric2.bearing;
                    } else {
                      var os2;
                      if (typeof cbox === "undefined" || cbox === null) {
                        cbox = this.cbox;
                      }
                      if ((os2 = this._font["OS/2"]) && os2.version > 0) {
                        var advanceHeight = Math.abs(os2.typoAscender - os2.typoDescender);
                        var topBearing = os2.typoAscender - cbox.maxY;
                      } else {
                        var hhea2 = this._font.hhea;
                        var advanceHeight = Math.abs(hhea2.ascent - hhea2.descent);
                        var topBearing = hhea2.ascent - cbox.maxY;
                      }
                    }
                    if (this._font._variationProcessor && this._font.HVAR) {
                      advanceWidth += this._font._variationProcessor.getAdvanceAdjustment(this.id, this._font.HVAR);
                    }
                    return this._metrics = {
                      advanceWidth,
                      advanceHeight,
                      leftBearing,
                      topBearing
                    };
                  };
                  _proto32.getScaledPath = function getScaledPath(size) {
                    var scale = 1 / this._font.unitsPerEm * size;
                    return this.path.scale(scale);
                  };
                  _proto32._getName = function _getName() {
                    var post2 = this._font.post;
                    if (!post2) {
                      return null;
                    }
                    switch (post2.version) {
                      case 1:
                        return StandardNames[this.id];
                      case 2:
                        var id = post2.glyphNameIndex[this.id];
                        if (id < StandardNames.length) {
                          return StandardNames[id];
                        }
                        return post2.names[id - StandardNames.length];
                      case 2.5:
                        return StandardNames[this.id + post2.offsets[this.id]];
                      case 4:
                        return String.fromCharCode(post2.map[this.id]);
                    }
                  };
                  _proto32.render = function render(ctx, size) {
                    ctx.save();
                    var scale = 1 / this._font.head.unitsPerEm * size;
                    ctx.scale(scale, scale);
                    var fn = this.path.toFunction();
                    fn(ctx);
                    ctx.fill();
                    ctx.restore();
                  };
                  _createClass(Glyph2, [{
                    key: "cbox",
                    get: function get() {
                      return this._getCBox();
                    }
                    /**
                     * The glyphs bounding box, i.e. the rectangle that encloses the
                     * glyph outline as tightly as possible.
                     * @type {BBox}
                     */
                  }, {
                    key: "bbox",
                    get: function get() {
                      return this._getBBox();
                    }
                    /**
                     * A vector Path object representing the glyph outline.
                     * @type {Path}
                     */
                  }, {
                    key: "path",
                    get: function get() {
                      return this._getPath();
                    }
                  }, {
                    key: "advanceWidth",
                    get: function get() {
                      return this._getMetrics().advanceWidth;
                    }
                    /**
                     * The glyph's advance height.
                     * @type {number}
                     */
                  }, {
                    key: "advanceHeight",
                    get: function get() {
                      return this._getMetrics().advanceHeight;
                    }
                  }, {
                    key: "ligatureCaretPositions",
                    get: function get() {
                    }
                  }, {
                    key: "name",
                    get: function get() {
                      return this._getName();
                    }
                  }]);
                  return Glyph2;
                }(), _applyDecoratedDescriptor(_class$3.prototype, "cbox", [cache], Object.getOwnPropertyDescriptor(_class$3.prototype, "cbox"), _class$3.prototype), _applyDecoratedDescriptor(_class$3.prototype, "bbox", [cache], Object.getOwnPropertyDescriptor(_class$3.prototype, "bbox"), _class$3.prototype), _applyDecoratedDescriptor(_class$3.prototype, "path", [cache], Object.getOwnPropertyDescriptor(_class$3.prototype, "path"), _class$3.prototype), _applyDecoratedDescriptor(_class$3.prototype, "advanceWidth", [cache], Object.getOwnPropertyDescriptor(_class$3.prototype, "advanceWidth"), _class$3.prototype), _applyDecoratedDescriptor(_class$3.prototype, "advanceHeight", [cache], Object.getOwnPropertyDescriptor(_class$3.prototype, "advanceHeight"), _class$3.prototype), _applyDecoratedDescriptor(_class$3.prototype, "name", [cache], Object.getOwnPropertyDescriptor(_class$3.prototype, "name"), _class$3.prototype), _class$3);
                var GlyfHeader = new r.Struct({
                  numberOfContours: r.int16,
                  // if negative, this is a composite glyph
                  xMin: r.int16,
                  yMin: r.int16,
                  xMax: r.int16,
                  yMax: r.int16
                });
                var ON_CURVE = 1 << 0;
                var X_SHORT_VECTOR = 1 << 1;
                var Y_SHORT_VECTOR = 1 << 2;
                var REPEAT = 1 << 3;
                var SAME_X = 1 << 4;
                var SAME_Y = 1 << 5;
                var ARG_1_AND_2_ARE_WORDS = 1 << 0;
                var WE_HAVE_A_SCALE = 1 << 3;
                var MORE_COMPONENTS = 1 << 5;
                var WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;
                var WE_HAVE_A_TWO_BY_TWO = 1 << 7;
                var WE_HAVE_INSTRUCTIONS = 1 << 8;
                var Point = function() {
                  function Point2(onCurve, endContour, x, y) {
                    if (x === void 0) {
                      x = 0;
                    }
                    if (y === void 0) {
                      y = 0;
                    }
                    this.onCurve = onCurve;
                    this.endContour = endContour;
                    this.x = x;
                    this.y = y;
                  }
                  var _proto33 = Point2.prototype;
                  _proto33.copy = function copy() {
                    return new Point2(this.onCurve, this.endContour, this.x, this.y);
                  };
                  return Point2;
                }();
                var Component = function Component2(glyphID, dx, dy) {
                  this.glyphID = glyphID;
                  this.dx = dx;
                  this.dy = dy;
                  this.pos = 0;
                  this.scaleX = this.scaleY = 1;
                  this.scale01 = this.scale10 = 0;
                };
                var TTFGlyph = function(_Glyph) {
                  _inheritsLoose(TTFGlyph2, _Glyph);
                  function TTFGlyph2() {
                    return _Glyph.apply(this, arguments) || this;
                  }
                  var _proto34 = TTFGlyph2.prototype;
                  _proto34._getCBox = function _getCBox(internal) {
                    if (this._font._variationProcessor && !internal) {
                      return this.path.cbox;
                    }
                    var stream = this._font._getTableStream("glyf");
                    stream.pos += this._font.loca.offsets[this.id];
                    var glyph2 = GlyfHeader.decode(stream);
                    var cbox = new BBox(glyph2.xMin, glyph2.yMin, glyph2.xMax, glyph2.yMax);
                    return Object.freeze(cbox);
                  };
                  _proto34._parseGlyphCoord = function _parseGlyphCoord(stream, prev, short, same) {
                    if (short) {
                      var val = stream.readUInt8();
                      if (!same) {
                        val = -val;
                      }
                      val += prev;
                    } else {
                      if (same) {
                        var val = prev;
                      } else {
                        var val = prev + stream.readInt16BE();
                      }
                    }
                    return val;
                  };
                  _proto34._decode = function _decode() {
                    var glyfPos = this._font.loca.offsets[this.id];
                    var nextPos = this._font.loca.offsets[this.id + 1];
                    if (glyfPos === nextPos) {
                      return null;
                    }
                    var stream = this._font._getTableStream("glyf");
                    stream.pos += glyfPos;
                    var startPos = stream.pos;
                    var glyph2 = GlyfHeader.decode(stream);
                    if (glyph2.numberOfContours > 0) {
                      this._decodeSimple(glyph2, stream);
                    } else if (glyph2.numberOfContours < 0) {
                      this._decodeComposite(glyph2, stream, startPos);
                    }
                    return glyph2;
                  };
                  _proto34._decodeSimple = function _decodeSimple(glyph2, stream) {
                    glyph2.points = [];
                    var endPtsOfContours = new r.Array(r.uint16, glyph2.numberOfContours).decode(stream);
                    glyph2.instructions = new r.Array(r.uint8, r.uint16).decode(stream);
                    var flags = [];
                    var numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;
                    while (flags.length < numCoords) {
                      var flag = stream.readUInt8();
                      flags.push(flag);
                      if (flag & REPEAT) {
                        var count = stream.readUInt8();
                        for (var j = 0; j < count; j++) {
                          flags.push(flag);
                        }
                      }
                    }
                    for (var i2 = 0; i2 < flags.length; i2++) {
                      var flag = flags[i2];
                      var point = new Point(!!(flag & ON_CURVE), endPtsOfContours.indexOf(i2) >= 0, 0, 0);
                      glyph2.points.push(point);
                    }
                    var px = 0;
                    for (var i2 = 0; i2 < flags.length; i2++) {
                      var flag = flags[i2];
                      glyph2.points[i2].x = px = this._parseGlyphCoord(stream, px, flag & X_SHORT_VECTOR, flag & SAME_X);
                    }
                    var py = 0;
                    for (var i2 = 0; i2 < flags.length; i2++) {
                      var flag = flags[i2];
                      glyph2.points[i2].y = py = this._parseGlyphCoord(stream, py, flag & Y_SHORT_VECTOR, flag & SAME_Y);
                    }
                    if (this._font._variationProcessor) {
                      var points = glyph2.points.slice();
                      points.push.apply(points, this._getPhantomPoints(glyph2));
                      this._font._variationProcessor.transformPoints(this.id, points);
                      glyph2.phantomPoints = points.slice(-4);
                    }
                    return;
                  };
                  _proto34._decodeComposite = function _decodeComposite(glyph2, stream, offset) {
                    if (offset === void 0) {
                      offset = 0;
                    }
                    glyph2.components = [];
                    var haveInstructions = false;
                    var flags = MORE_COMPONENTS;
                    while (flags & MORE_COMPONENTS) {
                      flags = stream.readUInt16BE();
                      var gPos = stream.pos - offset;
                      var glyphID = stream.readUInt16BE();
                      if (!haveInstructions) {
                        haveInstructions = (flags & WE_HAVE_INSTRUCTIONS) !== 0;
                      }
                      if (flags & ARG_1_AND_2_ARE_WORDS) {
                        var dx = stream.readInt16BE();
                        var dy = stream.readInt16BE();
                      } else {
                        var dx = stream.readInt8();
                        var dy = stream.readInt8();
                      }
                      var component = new Component(glyphID, dx, dy);
                      component.pos = gPos;
                      if (flags & WE_HAVE_A_SCALE) {
                        component.scaleX = component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                      } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
                        component.scaleX = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                        component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                      } else if (flags & WE_HAVE_A_TWO_BY_TWO) {
                        component.scaleX = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                        component.scale01 = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                        component.scale10 = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                        component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                      }
                      glyph2.components.push(component);
                    }
                    if (this._font._variationProcessor) {
                      var points = [];
                      for (var j = 0; j < glyph2.components.length; j++) {
                        var component = glyph2.components[j];
                        points.push(new Point(true, true, component.dx, component.dy));
                      }
                      points.push.apply(points, this._getPhantomPoints(glyph2));
                      this._font._variationProcessor.transformPoints(this.id, points);
                      glyph2.phantomPoints = points.splice(-4, 4);
                      for (var i2 = 0; i2 < points.length; i2++) {
                        var point = points[i2];
                        glyph2.components[i2].dx = point.x;
                        glyph2.components[i2].dy = point.y;
                      }
                    }
                    return haveInstructions;
                  };
                  _proto34._getPhantomPoints = function _getPhantomPoints(glyph2) {
                    var cbox = this._getCBox(true);
                    if (this._metrics == null) {
                      this._metrics = Glyph.prototype._getMetrics.call(this, cbox);
                    }
                    var _this$_metrics = this._metrics, advanceWidth = _this$_metrics.advanceWidth, advanceHeight = _this$_metrics.advanceHeight, leftBearing = _this$_metrics.leftBearing, topBearing = _this$_metrics.topBearing;
                    return [new Point(false, true, glyph2.xMin - leftBearing, 0), new Point(false, true, glyph2.xMin - leftBearing + advanceWidth, 0), new Point(false, true, 0, glyph2.yMax + topBearing), new Point(false, true, 0, glyph2.yMax + topBearing + advanceHeight)];
                  };
                  _proto34._getContours = function _getContours() {
                    var glyph2 = this._decode();
                    if (!glyph2) {
                      return [];
                    }
                    var points = [];
                    if (glyph2.numberOfContours < 0) {
                      for (var _iterator70 = _createForOfIteratorHelperLoose(glyph2.components), _step70; !(_step70 = _iterator70()).done; ) {
                        var component = _step70.value;
                        var _contours = this._font.getGlyph(component.glyphID)._getContours();
                        for (var i2 = 0; i2 < _contours.length; i2++) {
                          var contour = _contours[i2];
                          for (var j = 0; j < contour.length; j++) {
                            var _point = contour[j];
                            var x = _point.x * component.scaleX + _point.y * component.scale01 + component.dx;
                            var y = _point.y * component.scaleY + _point.x * component.scale10 + component.dy;
                            points.push(new Point(_point.onCurve, _point.endContour, x, y));
                          }
                        }
                      }
                    } else {
                      points = glyph2.points || [];
                    }
                    if (glyph2.phantomPoints && !this._font.directory.tables.HVAR) {
                      this._metrics.advanceWidth = glyph2.phantomPoints[1].x - glyph2.phantomPoints[0].x;
                      this._metrics.advanceHeight = glyph2.phantomPoints[3].y - glyph2.phantomPoints[2].y;
                      this._metrics.leftBearing = glyph2.xMin - glyph2.phantomPoints[0].x;
                      this._metrics.topBearing = glyph2.phantomPoints[2].y - glyph2.yMax;
                    }
                    var contours = [];
                    var cur = [];
                    for (var k = 0; k < points.length; k++) {
                      var point = points[k];
                      cur.push(point);
                      if (point.endContour) {
                        contours.push(cur);
                        cur = [];
                      }
                    }
                    return contours;
                  };
                  _proto34._getMetrics = function _getMetrics() {
                    if (this._metrics) {
                      return this._metrics;
                    }
                    var cbox = this._getCBox(true);
                    _Glyph.prototype._getMetrics.call(this, cbox);
                    if (this._font._variationProcessor && !this._font.HVAR) {
                      this.path;
                    }
                    return this._metrics;
                  };
                  _proto34._getPath = function _getPath() {
                    var contours = this._getContours();
                    var path = new Path();
                    for (var i2 = 0; i2 < contours.length; i2++) {
                      var contour = contours[i2];
                      var firstPt = contour[0];
                      var lastPt = contour[contour.length - 1];
                      var start = 0;
                      if (firstPt.onCurve) {
                        var curvePt = null;
                        start = 1;
                      } else {
                        if (lastPt.onCurve) {
                          firstPt = lastPt;
                        } else {
                          firstPt = new Point(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);
                        }
                        var curvePt = firstPt;
                      }
                      path.moveTo(firstPt.x, firstPt.y);
                      for (var j = start; j < contour.length; j++) {
                        var pt = contour[j];
                        var prevPt = j === 0 ? firstPt : contour[j - 1];
                        if (prevPt.onCurve && pt.onCurve) {
                          path.lineTo(pt.x, pt.y);
                        } else if (prevPt.onCurve && !pt.onCurve) {
                          var curvePt = pt;
                        } else if (!prevPt.onCurve && !pt.onCurve) {
                          var midX = (prevPt.x + pt.x) / 2;
                          var midY = (prevPt.y + pt.y) / 2;
                          path.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);
                          var curvePt = pt;
                        } else if (!prevPt.onCurve && pt.onCurve) {
                          path.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
                          var curvePt = null;
                        } else {
                          throw new Error("Unknown TTF path state");
                        }
                      }
                      if (curvePt) {
                        path.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
                      }
                      path.closePath();
                    }
                    return path;
                  };
                  return TTFGlyph2;
                }(Glyph);
                var CFFGlyph = function(_Glyph2) {
                  _inheritsLoose(CFFGlyph2, _Glyph2);
                  function CFFGlyph2() {
                    return _Glyph2.apply(this, arguments) || this;
                  }
                  var _proto35 = CFFGlyph2.prototype;
                  _proto35._getName = function _getName() {
                    if (this._font.CFF2) {
                      return _Glyph2.prototype._getName.call(this);
                    }
                    return this._font["CFF "].getGlyphName(this.id);
                  };
                  _proto35.bias = function bias(s) {
                    if (s.length < 1240) {
                      return 107;
                    } else if (s.length < 33900) {
                      return 1131;
                    } else {
                      return 32768;
                    }
                  };
                  _proto35._getPath = function _getPath() {
                    var cff = this._font.CFF2 || this._font["CFF "];
                    var stream = cff.stream;
                    var str = cff.topDict.CharStrings[this.id];
                    var end = str.offset + str.length;
                    stream.pos = str.offset;
                    var path = new Path();
                    var stack = [];
                    var trans = [];
                    var width = null;
                    var nStems = 0;
                    var x = 0, y = 0;
                    var usedGsubrs;
                    var usedSubrs;
                    var open2 = false;
                    this._usedGsubrs = usedGsubrs = {};
                    this._usedSubrs = usedSubrs = {};
                    var gsubrs = cff.globalSubrIndex || [];
                    var gsubrsBias = this.bias(gsubrs);
                    var privateDict = cff.privateDictForGlyph(this.id) || {};
                    var subrs = privateDict.Subrs || [];
                    var subrsBias = this.bias(subrs);
                    var vstore = cff.topDict.vstore && cff.topDict.vstore.itemVariationStore;
                    var vsindex = privateDict.vsindex;
                    var variationProcessor = this._font._variationProcessor;
                    function checkWidth() {
                      if (width == null) {
                        width = stack.shift() + privateDict.nominalWidthX;
                      }
                    }
                    function parseStems() {
                      if (stack.length % 2 !== 0) {
                        checkWidth();
                      }
                      nStems += stack.length >> 1;
                      return stack.length = 0;
                    }
                    function moveTo(x2, y2) {
                      if (open2) {
                        path.closePath();
                      }
                      path.moveTo(x2, y2);
                      open2 = true;
                    }
                    var parse = function parse2() {
                      while (stream.pos < end) {
                        var op = stream.readUInt8();
                        if (op < 32) {
                          switch (op) {
                            case 1:
                            case 3:
                            case 18:
                            case 23:
                              parseStems();
                              break;
                            case 4:
                              if (stack.length > 1) {
                                checkWidth();
                              }
                              y += stack.shift();
                              moveTo(x, y);
                              break;
                            case 5:
                              while (stack.length >= 2) {
                                x += stack.shift();
                                y += stack.shift();
                                path.lineTo(x, y);
                              }
                              break;
                            case 6:
                            case 7:
                              var phase = op === 6;
                              while (stack.length >= 1) {
                                if (phase) {
                                  x += stack.shift();
                                } else {
                                  y += stack.shift();
                                }
                                path.lineTo(x, y);
                                phase = !phase;
                              }
                              break;
                            case 8:
                              while (stack.length > 0) {
                                var c1x = x + stack.shift();
                                var c1y = y + stack.shift();
                                var c2x = c1x + stack.shift();
                                var c2y = c1y + stack.shift();
                                x = c2x + stack.shift();
                                y = c2y + stack.shift();
                                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                              }
                              break;
                            case 10:
                              var index = stack.pop() + subrsBias;
                              var subr = subrs[index];
                              if (subr) {
                                usedSubrs[index] = true;
                                var p = stream.pos;
                                var e = end;
                                stream.pos = subr.offset;
                                end = subr.offset + subr.length;
                                parse2();
                                stream.pos = p;
                                end = e;
                              }
                              break;
                            case 11:
                              if (cff.version >= 2) {
                                break;
                              }
                              return;
                            case 14:
                              if (cff.version >= 2) {
                                break;
                              }
                              if (stack.length > 0) {
                                checkWidth();
                              }
                              if (open2) {
                                path.closePath();
                                open2 = false;
                              }
                              break;
                            case 15: {
                              if (cff.version < 2) {
                                throw new Error("vsindex operator not supported in CFF v1");
                              }
                              vsindex = stack.pop();
                              break;
                            }
                            case 16: {
                              if (cff.version < 2) {
                                throw new Error("blend operator not supported in CFF v1");
                              }
                              if (!variationProcessor) {
                                throw new Error("blend operator in non-variation font");
                              }
                              var blendVector = variationProcessor.getBlendVector(vstore, vsindex);
                              var numBlends = stack.pop();
                              var numOperands = numBlends * blendVector.length;
                              var delta = stack.length - numOperands;
                              var base = delta - numBlends;
                              for (var i2 = 0; i2 < numBlends; i2++) {
                                var sum = stack[base + i2];
                                for (var j = 0; j < blendVector.length; j++) {
                                  sum += blendVector[j] * stack[delta++];
                                }
                                stack[base + i2] = sum;
                              }
                              while (numOperands--) {
                                stack.pop();
                              }
                              break;
                            }
                            case 19:
                            case 20:
                              parseStems();
                              stream.pos += nStems + 7 >> 3;
                              break;
                            case 21:
                              if (stack.length > 2) {
                                checkWidth();
                              }
                              x += stack.shift();
                              y += stack.shift();
                              moveTo(x, y);
                              break;
                            case 22:
                              if (stack.length > 1) {
                                checkWidth();
                              }
                              x += stack.shift();
                              moveTo(x, y);
                              break;
                            case 24:
                              while (stack.length >= 8) {
                                var c1x = x + stack.shift();
                                var c1y = y + stack.shift();
                                var c2x = c1x + stack.shift();
                                var c2y = c1y + stack.shift();
                                x = c2x + stack.shift();
                                y = c2y + stack.shift();
                                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                              }
                              x += stack.shift();
                              y += stack.shift();
                              path.lineTo(x, y);
                              break;
                            case 25:
                              while (stack.length >= 8) {
                                x += stack.shift();
                                y += stack.shift();
                                path.lineTo(x, y);
                              }
                              var c1x = x + stack.shift();
                              var c1y = y + stack.shift();
                              var c2x = c1x + stack.shift();
                              var c2y = c1y + stack.shift();
                              x = c2x + stack.shift();
                              y = c2y + stack.shift();
                              path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                              break;
                            case 26:
                              if (stack.length % 2) {
                                x += stack.shift();
                              }
                              while (stack.length >= 4) {
                                c1x = x;
                                c1y = y + stack.shift();
                                c2x = c1x + stack.shift();
                                c2y = c1y + stack.shift();
                                x = c2x;
                                y = c2y + stack.shift();
                                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                              }
                              break;
                            case 27:
                              if (stack.length % 2) {
                                y += stack.shift();
                              }
                              while (stack.length >= 4) {
                                c1x = x + stack.shift();
                                c1y = y;
                                c2x = c1x + stack.shift();
                                c2y = c1y + stack.shift();
                                x = c2x + stack.shift();
                                y = c2y;
                                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                              }
                              break;
                            case 28:
                              stack.push(stream.readInt16BE());
                              break;
                            case 29:
                              index = stack.pop() + gsubrsBias;
                              subr = gsubrs[index];
                              if (subr) {
                                usedGsubrs[index] = true;
                                var p = stream.pos;
                                var e = end;
                                stream.pos = subr.offset;
                                end = subr.offset + subr.length;
                                parse2();
                                stream.pos = p;
                                end = e;
                              }
                              break;
                            case 30:
                            case 31:
                              phase = op === 31;
                              while (stack.length >= 4) {
                                if (phase) {
                                  c1x = x + stack.shift();
                                  c1y = y;
                                  c2x = c1x + stack.shift();
                                  c2y = c1y + stack.shift();
                                  y = c2y + stack.shift();
                                  x = c2x + (stack.length === 1 ? stack.shift() : 0);
                                } else {
                                  c1x = x;
                                  c1y = y + stack.shift();
                                  c2x = c1x + stack.shift();
                                  c2y = c1y + stack.shift();
                                  x = c2x + stack.shift();
                                  y = c2y + (stack.length === 1 ? stack.shift() : 0);
                                }
                                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                                phase = !phase;
                              }
                              break;
                            case 12:
                              op = stream.readUInt8();
                              switch (op) {
                                case 3:
                                  var a = stack.pop();
                                  var b = stack.pop();
                                  stack.push(a && b ? 1 : 0);
                                  break;
                                case 4:
                                  a = stack.pop();
                                  b = stack.pop();
                                  stack.push(a || b ? 1 : 0);
                                  break;
                                case 5:
                                  a = stack.pop();
                                  stack.push(a ? 0 : 1);
                                  break;
                                case 9:
                                  a = stack.pop();
                                  stack.push(Math.abs(a));
                                  break;
                                case 10:
                                  a = stack.pop();
                                  b = stack.pop();
                                  stack.push(a + b);
                                  break;
                                case 11:
                                  a = stack.pop();
                                  b = stack.pop();
                                  stack.push(a - b);
                                  break;
                                case 12:
                                  a = stack.pop();
                                  b = stack.pop();
                                  stack.push(a / b);
                                  break;
                                case 14:
                                  a = stack.pop();
                                  stack.push(-a);
                                  break;
                                case 15:
                                  a = stack.pop();
                                  b = stack.pop();
                                  stack.push(a === b ? 1 : 0);
                                  break;
                                case 18:
                                  stack.pop();
                                  break;
                                case 20:
                                  var val = stack.pop();
                                  var idx = stack.pop();
                                  trans[idx] = val;
                                  break;
                                case 21:
                                  idx = stack.pop();
                                  stack.push(trans[idx] || 0);
                                  break;
                                case 22:
                                  var s1 = stack.pop();
                                  var s2 = stack.pop();
                                  var v1 = stack.pop();
                                  var v2 = stack.pop();
                                  stack.push(v1 <= v2 ? s1 : s2);
                                  break;
                                case 23:
                                  stack.push(Math.random());
                                  break;
                                case 24:
                                  a = stack.pop();
                                  b = stack.pop();
                                  stack.push(a * b);
                                  break;
                                case 26:
                                  a = stack.pop();
                                  stack.push(Math.sqrt(a));
                                  break;
                                case 27:
                                  a = stack.pop();
                                  stack.push(a, a);
                                  break;
                                case 28:
                                  a = stack.pop();
                                  b = stack.pop();
                                  stack.push(b, a);
                                  break;
                                case 29:
                                  idx = stack.pop();
                                  if (idx < 0) {
                                    idx = 0;
                                  } else if (idx > stack.length - 1) {
                                    idx = stack.length - 1;
                                  }
                                  stack.push(stack[idx]);
                                  break;
                                case 30:
                                  var n = stack.pop();
                                  var _j = stack.pop();
                                  if (_j >= 0) {
                                    while (_j > 0) {
                                      var t2 = stack[n - 1];
                                      for (var _i = n - 2; _i >= 0; _i--) {
                                        stack[_i + 1] = stack[_i];
                                      }
                                      stack[0] = t2;
                                      _j--;
                                    }
                                  } else {
                                    while (_j < 0) {
                                      var t2 = stack[0];
                                      for (var _i2 = 0; _i2 <= n; _i2++) {
                                        stack[_i2] = stack[_i2 + 1];
                                      }
                                      stack[n - 1] = t2;
                                      _j++;
                                    }
                                  }
                                  break;
                                case 34:
                                  c1x = x + stack.shift();
                                  c1y = y;
                                  c2x = c1x + stack.shift();
                                  c2y = c1y + stack.shift();
                                  var c3x = c2x + stack.shift();
                                  var c3y = c2y;
                                  var c4x = c3x + stack.shift();
                                  var c4y = c3y;
                                  var c5x = c4x + stack.shift();
                                  var c5y = c4y;
                                  var c6x = c5x + stack.shift();
                                  var c6y = c5y;
                                  x = c6x;
                                  y = c6y;
                                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                                  break;
                                case 35:
                                  var pts = [];
                                  for (var _i3 = 0; _i3 <= 5; _i3++) {
                                    x += stack.shift();
                                    y += stack.shift();
                                    pts.push(x, y);
                                  }
                                  path.bezierCurveTo.apply(path, pts.slice(0, 6));
                                  path.bezierCurveTo.apply(path, pts.slice(6));
                                  stack.shift();
                                  break;
                                case 36:
                                  c1x = x + stack.shift();
                                  c1y = y + stack.shift();
                                  c2x = c1x + stack.shift();
                                  c2y = c1y + stack.shift();
                                  c3x = c2x + stack.shift();
                                  c3y = c2y;
                                  c4x = c3x + stack.shift();
                                  c4y = c3y;
                                  c5x = c4x + stack.shift();
                                  c5y = c4y + stack.shift();
                                  c6x = c5x + stack.shift();
                                  c6y = c5y;
                                  x = c6x;
                                  y = c6y;
                                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                                  break;
                                case 37:
                                  var startx = x;
                                  var starty = y;
                                  pts = [];
                                  for (var _i4 = 0; _i4 <= 4; _i4++) {
                                    x += stack.shift();
                                    y += stack.shift();
                                    pts.push(x, y);
                                  }
                                  if (Math.abs(x - startx) > Math.abs(y - starty)) {
                                    x += stack.shift();
                                    y = starty;
                                  } else {
                                    x = startx;
                                    y += stack.shift();
                                  }
                                  pts.push(x, y);
                                  path.bezierCurveTo.apply(path, pts.slice(0, 6));
                                  path.bezierCurveTo.apply(path, pts.slice(6));
                                  break;
                                default:
                                  throw new Error("Unknown op: 12 ".concat(op));
                              }
                              break;
                            default:
                              throw new Error("Unknown op: ".concat(op));
                          }
                        } else if (op < 247) {
                          stack.push(op - 139);
                        } else if (op < 251) {
                          var b1 = stream.readUInt8();
                          stack.push((op - 247) * 256 + b1 + 108);
                        } else if (op < 255) {
                          var b1 = stream.readUInt8();
                          stack.push(-(op - 251) * 256 - b1 - 108);
                        } else {
                          stack.push(stream.readInt32BE() / 65536);
                        }
                      }
                    };
                    parse();
                    if (open2) {
                      path.closePath();
                    }
                    return path;
                  };
                  return CFFGlyph2;
                }(Glyph);
                var SBIXImage = new r.Struct({
                  originX: r.uint16,
                  originY: r.uint16,
                  type: new r.String(4),
                  data: new r.Buffer(function(t2) {
                    return t2.parent.buflen - t2._currentOffset;
                  })
                });
                var SBIXGlyph = function(_TTFGlyph) {
                  _inheritsLoose(SBIXGlyph2, _TTFGlyph);
                  function SBIXGlyph2() {
                    return _TTFGlyph.apply(this, arguments) || this;
                  }
                  var _proto36 = SBIXGlyph2.prototype;
                  _proto36.getImageForSize = function getImageForSize(size) {
                    for (var i2 = 0; i2 < this._font.sbix.imageTables.length; i2++) {
                      var table = this._font.sbix.imageTables[i2];
                      if (table.ppem >= size) {
                        break;
                      }
                    }
                    var offsets = table.imageOffsets;
                    var start = offsets[this.id];
                    var end = offsets[this.id + 1];
                    if (start === end) {
                      return null;
                    }
                    this._font.stream.pos = start;
                    return SBIXImage.decode(this._font.stream, {
                      buflen: end - start
                    });
                  };
                  _proto36.render = function render(ctx, size) {
                    var img = this.getImageForSize(size);
                    if (img != null) {
                      var scale = size / this._font.unitsPerEm;
                      ctx.image(img.data, {
                        height: size,
                        x: img.originX,
                        y: (this.bbox.minY - img.originY) * scale
                      });
                    }
                    if (this._font.sbix.flags.renderOutlines) {
                      _TTFGlyph.prototype.render.call(this, ctx, size);
                    }
                  };
                  return SBIXGlyph2;
                }(TTFGlyph);
                var COLRLayer = function COLRLayer2(glyph2, color) {
                  this.glyph = glyph2;
                  this.color = color;
                };
                var COLRGlyph = function(_Glyph3) {
                  _inheritsLoose(COLRGlyph2, _Glyph3);
                  function COLRGlyph2() {
                    return _Glyph3.apply(this, arguments) || this;
                  }
                  var _proto37 = COLRGlyph2.prototype;
                  _proto37._getBBox = function _getBBox() {
                    var bbox = new BBox();
                    for (var i2 = 0; i2 < this.layers.length; i2++) {
                      var layer = this.layers[i2];
                      var b = layer.glyph.bbox;
                      bbox.addPoint(b.minX, b.minY);
                      bbox.addPoint(b.maxX, b.maxY);
                    }
                    return bbox;
                  };
                  _proto37.render = function render(ctx, size) {
                    for (var _iterator71 = _createForOfIteratorHelperLoose(this.layers), _step71; !(_step71 = _iterator71()).done; ) {
                      var _step71$value = _step71.value, glyph2 = _step71$value.glyph, color = _step71$value.color;
                      ctx.fillColor([color.red, color.green, color.blue], color.alpha / 255 * 100);
                      glyph2.render(ctx, size);
                    }
                    return;
                  };
                  _createClass(COLRGlyph2, [{
                    key: "layers",
                    get: function get() {
                      var cpal = this._font.CPAL;
                      var colr = this._font.COLR;
                      var low = 0;
                      var high = colr.baseGlyphRecord.length - 1;
                      while (low <= high) {
                        var mid = low + high >> 1;
                        var rec = colr.baseGlyphRecord[mid];
                        if (this.id < rec.gid) {
                          high = mid - 1;
                        } else if (this.id > rec.gid) {
                          low = mid + 1;
                        } else {
                          var baseLayer = rec;
                          break;
                        }
                      }
                      if (baseLayer == null) {
                        var g = this._font._getBaseGlyph(this.id);
                        var color = {
                          red: 0,
                          green: 0,
                          blue: 0,
                          alpha: 255
                        };
                        return [new COLRLayer(g, color)];
                      }
                      var layers = [];
                      for (var i2 = baseLayer.firstLayerIndex; i2 < baseLayer.firstLayerIndex + baseLayer.numLayers; i2++) {
                        var rec = colr.layerRecords[i2];
                        var color = cpal.colorRecords[rec.paletteIndex];
                        var g = this._font._getBaseGlyph(rec.gid);
                        layers.push(new COLRLayer(g, color));
                      }
                      return layers;
                    }
                  }]);
                  return COLRGlyph2;
                }(Glyph);
                var TUPLES_SHARE_POINT_NUMBERS = 32768;
                var TUPLE_COUNT_MASK = 4095;
                var EMBEDDED_TUPLE_COORD = 32768;
                var INTERMEDIATE_TUPLE = 16384;
                var PRIVATE_POINT_NUMBERS = 8192;
                var TUPLE_INDEX_MASK = 4095;
                var POINTS_ARE_WORDS = 128;
                var POINT_RUN_COUNT_MASK = 127;
                var DELTAS_ARE_ZERO = 128;
                var DELTAS_ARE_WORDS = 64;
                var DELTA_RUN_COUNT_MASK = 63;
                var GlyphVariationProcessor = function() {
                  function GlyphVariationProcessor2(font, coords) {
                    this.font = font;
                    this.normalizedCoords = this.normalizeCoords(coords);
                    this.blendVectors = /* @__PURE__ */ new Map();
                  }
                  var _proto38 = GlyphVariationProcessor2.prototype;
                  _proto38.normalizeCoords = function normalizeCoords(coords) {
                    var normalized = [];
                    for (var i2 = 0; i2 < this.font.fvar.axis.length; i2++) {
                      var axis = this.font.fvar.axis[i2];
                      if (coords[i2] < axis.defaultValue) {
                        normalized.push((coords[i2] - axis.defaultValue + Number.EPSILON) / (axis.defaultValue - axis.minValue + Number.EPSILON));
                      } else {
                        normalized.push((coords[i2] - axis.defaultValue + Number.EPSILON) / (axis.maxValue - axis.defaultValue + Number.EPSILON));
                      }
                    }
                    if (this.font.avar) {
                      for (var i2 = 0; i2 < this.font.avar.segment.length; i2++) {
                        var segment = this.font.avar.segment[i2];
                        for (var j = 0; j < segment.correspondence.length; j++) {
                          var pair = segment.correspondence[j];
                          if (j >= 1 && normalized[i2] < pair.fromCoord) {
                            var prev = segment.correspondence[j - 1];
                            normalized[i2] = ((normalized[i2] - prev.fromCoord) * (pair.toCoord - prev.toCoord) + Number.EPSILON) / (pair.fromCoord - prev.fromCoord + Number.EPSILON) + prev.toCoord;
                            break;
                          }
                        }
                      }
                    }
                    return normalized;
                  };
                  _proto38.transformPoints = function transformPoints(gid, glyphPoints) {
                    if (!this.font.fvar || !this.font.gvar) {
                      return;
                    }
                    var gvar2 = this.font.gvar;
                    if (gid >= gvar2.glyphCount) {
                      return;
                    }
                    var offset = gvar2.offsets[gid];
                    if (offset === gvar2.offsets[gid + 1]) {
                      return;
                    }
                    var stream = this.font.stream;
                    stream.pos = offset;
                    if (stream.pos >= stream.length) {
                      return;
                    }
                    var tupleCount = stream.readUInt16BE();
                    var offsetToData = offset + stream.readUInt16BE();
                    if (tupleCount & TUPLES_SHARE_POINT_NUMBERS) {
                      var here = stream.pos;
                      stream.pos = offsetToData;
                      var sharedPoints = this.decodePoints();
                      offsetToData = stream.pos;
                      stream.pos = here;
                    }
                    var origPoints = glyphPoints.map(function(pt) {
                      return pt.copy();
                    });
                    tupleCount &= TUPLE_COUNT_MASK;
                    for (var i2 = 0; i2 < tupleCount; i2++) {
                      var tupleDataSize = stream.readUInt16BE();
                      var tupleIndex = stream.readUInt16BE();
                      if (tupleIndex & EMBEDDED_TUPLE_COORD) {
                        var tupleCoords = [];
                        for (var a = 0; a < gvar2.axisCount; a++) {
                          tupleCoords.push(stream.readInt16BE() / 16384);
                        }
                      } else {
                        if ((tupleIndex & TUPLE_INDEX_MASK) >= gvar2.globalCoordCount) {
                          throw new Error("Invalid gvar table");
                        }
                        var tupleCoords = gvar2.globalCoords[tupleIndex & TUPLE_INDEX_MASK];
                      }
                      if (tupleIndex & INTERMEDIATE_TUPLE) {
                        var startCoords = [];
                        for (var _a = 0; _a < gvar2.axisCount; _a++) {
                          startCoords.push(stream.readInt16BE() / 16384);
                        }
                        var endCoords = [];
                        for (var _a2 = 0; _a2 < gvar2.axisCount; _a2++) {
                          endCoords.push(stream.readInt16BE() / 16384);
                        }
                      }
                      var factor = this.tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords);
                      if (factor === 0) {
                        offsetToData += tupleDataSize;
                        continue;
                      }
                      var here = stream.pos;
                      stream.pos = offsetToData;
                      if (tupleIndex & PRIVATE_POINT_NUMBERS) {
                        var points = this.decodePoints();
                      } else {
                        var points = sharedPoints;
                      }
                      var nPoints = points.length === 0 ? glyphPoints.length : points.length;
                      var xDeltas = this.decodeDeltas(nPoints);
                      var yDeltas = this.decodeDeltas(nPoints);
                      if (points.length === 0) {
                        for (var _i = 0; _i < glyphPoints.length; _i++) {
                          var point = glyphPoints[_i];
                          point.x += Math.round(xDeltas[_i] * factor);
                          point.y += Math.round(yDeltas[_i] * factor);
                        }
                      } else {
                        var outPoints = origPoints.map(function(pt) {
                          return pt.copy();
                        });
                        var hasDelta = glyphPoints.map(function() {
                          return false;
                        });
                        for (var _i2 = 0; _i2 < points.length; _i2++) {
                          var idx = points[_i2];
                          if (idx < glyphPoints.length) {
                            var _point = outPoints[idx];
                            hasDelta[idx] = true;
                            _point.x += Math.round(xDeltas[_i2] * factor);
                            _point.y += Math.round(yDeltas[_i2] * factor);
                          }
                        }
                        this.interpolateMissingDeltas(outPoints, origPoints, hasDelta);
                        for (var _i3 = 0; _i3 < glyphPoints.length; _i3++) {
                          var deltaX = outPoints[_i3].x - origPoints[_i3].x;
                          var deltaY = outPoints[_i3].y - origPoints[_i3].y;
                          glyphPoints[_i3].x += deltaX;
                          glyphPoints[_i3].y += deltaY;
                        }
                      }
                      offsetToData += tupleDataSize;
                      stream.pos = here;
                    }
                  };
                  _proto38.decodePoints = function decodePoints() {
                    var stream = this.font.stream;
                    var count = stream.readUInt8();
                    if (count & POINTS_ARE_WORDS) {
                      count = (count & POINT_RUN_COUNT_MASK) << 8 | stream.readUInt8();
                    }
                    var points = new Uint16Array(count);
                    var i2 = 0;
                    var point = 0;
                    while (i2 < count) {
                      var run = stream.readUInt8();
                      var runCount = (run & POINT_RUN_COUNT_MASK) + 1;
                      var fn = run & POINTS_ARE_WORDS ? stream.readUInt16 : stream.readUInt8;
                      for (var j = 0; j < runCount && i2 < count; j++) {
                        point += fn.call(stream);
                        points[i2++] = point;
                      }
                    }
                    return points;
                  };
                  _proto38.decodeDeltas = function decodeDeltas(count) {
                    var stream = this.font.stream;
                    var i2 = 0;
                    var deltas = new Int16Array(count);
                    while (i2 < count) {
                      var run = stream.readUInt8();
                      var runCount = (run & DELTA_RUN_COUNT_MASK) + 1;
                      if (run & DELTAS_ARE_ZERO) {
                        i2 += runCount;
                      } else {
                        var fn = run & DELTAS_ARE_WORDS ? stream.readInt16BE : stream.readInt8;
                        for (var j = 0; j < runCount && i2 < count; j++) {
                          deltas[i2++] = fn.call(stream);
                        }
                      }
                    }
                    return deltas;
                  };
                  _proto38.tupleFactor = function tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords) {
                    var normalized = this.normalizedCoords;
                    var gvar2 = this.font.gvar;
                    var factor = 1;
                    for (var i2 = 0; i2 < gvar2.axisCount; i2++) {
                      if (tupleCoords[i2] === 0) {
                        continue;
                      }
                      if (normalized[i2] === 0) {
                        return 0;
                      }
                      if ((tupleIndex & INTERMEDIATE_TUPLE) === 0) {
                        if (normalized[i2] < Math.min(0, tupleCoords[i2]) || normalized[i2] > Math.max(0, tupleCoords[i2])) {
                          return 0;
                        }
                        factor = (factor * normalized[i2] + Number.EPSILON) / (tupleCoords[i2] + Number.EPSILON);
                      } else {
                        if (normalized[i2] < startCoords[i2] || normalized[i2] > endCoords[i2]) {
                          return 0;
                        } else if (normalized[i2] < tupleCoords[i2]) {
                          factor = factor * (normalized[i2] - startCoords[i2] + Number.EPSILON) / (tupleCoords[i2] - startCoords[i2] + Number.EPSILON);
                        } else {
                          factor = factor * (endCoords[i2] - normalized[i2] + Number.EPSILON) / (endCoords[i2] - tupleCoords[i2] + Number.EPSILON);
                        }
                      }
                    }
                    return factor;
                  };
                  _proto38.interpolateMissingDeltas = function interpolateMissingDeltas(points, inPoints, hasDelta) {
                    if (points.length === 0) {
                      return;
                    }
                    var point = 0;
                    while (point < points.length) {
                      var firstPoint = point;
                      var endPoint = point;
                      var pt = points[endPoint];
                      while (!pt.endContour) {
                        pt = points[++endPoint];
                      }
                      while (point <= endPoint && !hasDelta[point]) {
                        point++;
                      }
                      if (point > endPoint) {
                        continue;
                      }
                      var firstDelta = point;
                      var curDelta = point;
                      point++;
                      while (point <= endPoint) {
                        if (hasDelta[point]) {
                          this.deltaInterpolate(curDelta + 1, point - 1, curDelta, point, inPoints, points);
                          curDelta = point;
                        }
                        point++;
                      }
                      if (curDelta === firstDelta) {
                        this.deltaShift(firstPoint, endPoint, curDelta, inPoints, points);
                      } else {
                        this.deltaInterpolate(curDelta + 1, endPoint, curDelta, firstDelta, inPoints, points);
                        if (firstDelta > 0) {
                          this.deltaInterpolate(firstPoint, firstDelta - 1, curDelta, firstDelta, inPoints, points);
                        }
                      }
                      point = endPoint + 1;
                    }
                  };
                  _proto38.deltaInterpolate = function deltaInterpolate(p1, p2, ref1, ref2, inPoints, outPoints) {
                    if (p1 > p2) {
                      return;
                    }
                    var iterable = ["x", "y"];
                    for (var i2 = 0; i2 < iterable.length; i2++) {
                      var k = iterable[i2];
                      if (inPoints[ref1][k] > inPoints[ref2][k]) {
                        var p = ref1;
                        ref1 = ref2;
                        ref2 = p;
                      }
                      var in1 = inPoints[ref1][k];
                      var in2 = inPoints[ref2][k];
                      var out1 = outPoints[ref1][k];
                      var out2 = outPoints[ref2][k];
                      if (in1 !== in2 || out1 === out2) {
                        var scale = in1 === in2 ? 0 : (out2 - out1) / (in2 - in1);
                        for (var _p = p1; _p <= p2; _p++) {
                          var out = inPoints[_p][k];
                          if (out <= in1) {
                            out += out1 - in1;
                          } else if (out >= in2) {
                            out += out2 - in2;
                          } else {
                            out = out1 + (out - in1) * scale;
                          }
                          outPoints[_p][k] = out;
                        }
                      }
                    }
                  };
                  _proto38.deltaShift = function deltaShift(p1, p2, ref, inPoints, outPoints) {
                    var deltaX = outPoints[ref].x - inPoints[ref].x;
                    var deltaY = outPoints[ref].y - inPoints[ref].y;
                    if (deltaX === 0 && deltaY === 0) {
                      return;
                    }
                    for (var p = p1; p <= p2; p++) {
                      if (p !== ref) {
                        outPoints[p].x += deltaX;
                        outPoints[p].y += deltaY;
                      }
                    }
                  };
                  _proto38.getAdvanceAdjustment = function getAdvanceAdjustment(gid, table) {
                    var outerIndex, innerIndex;
                    if (table.advanceWidthMapping) {
                      var idx = gid;
                      if (idx >= table.advanceWidthMapping.mapCount) {
                        idx = table.advanceWidthMapping.mapCount - 1;
                      }
                      var entryFormat = table.advanceWidthMapping.entryFormat;
                      var _table$advanceWidthMa = table.advanceWidthMapping.mapData[idx];
                      outerIndex = _table$advanceWidthMa.outerIndex;
                      innerIndex = _table$advanceWidthMa.innerIndex;
                    } else {
                      outerIndex = 0;
                      innerIndex = gid;
                    }
                    return this.getDelta(table.itemVariationStore, outerIndex, innerIndex);
                  };
                  _proto38.getDelta = function getDelta(itemStore, outerIndex, innerIndex) {
                    if (outerIndex >= itemStore.itemVariationData.length) {
                      return 0;
                    }
                    var varData = itemStore.itemVariationData[outerIndex];
                    if (innerIndex >= varData.deltaSets.length) {
                      return 0;
                    }
                    var deltaSet = varData.deltaSets[innerIndex];
                    var blendVector = this.getBlendVector(itemStore, outerIndex);
                    var netAdjustment = 0;
                    for (var master = 0; master < varData.regionIndexCount; master++) {
                      netAdjustment += deltaSet.deltas[master] * blendVector[master];
                    }
                    return netAdjustment;
                  };
                  _proto38.getBlendVector = function getBlendVector(itemStore, outerIndex) {
                    var varData = itemStore.itemVariationData[outerIndex];
                    if (this.blendVectors.has(varData)) {
                      return this.blendVectors.get(varData);
                    }
                    var normalizedCoords = this.normalizedCoords;
                    var blendVector = [];
                    for (var master = 0; master < varData.regionIndexCount; master++) {
                      var scalar = 1;
                      var regionIndex = varData.regionIndexes[master];
                      var axes = itemStore.variationRegionList.variationRegions[regionIndex];
                      for (var j = 0; j < axes.length; j++) {
                        var axis = axes[j];
                        var axisScalar = void 0;
                        if (axis.startCoord > axis.peakCoord || axis.peakCoord > axis.endCoord) {
                          axisScalar = 1;
                        } else if (axis.startCoord < 0 && axis.endCoord > 0 && axis.peakCoord !== 0) {
                          axisScalar = 1;
                        } else if (axis.peakCoord === 0) {
                          axisScalar = 1;
                        } else if (normalizedCoords[j] < axis.startCoord || normalizedCoords[j] > axis.endCoord) {
                          axisScalar = 0;
                        } else {
                          if (normalizedCoords[j] === axis.peakCoord) {
                            axisScalar = 1;
                          } else if (normalizedCoords[j] < axis.peakCoord) {
                            axisScalar = (normalizedCoords[j] - axis.startCoord + Number.EPSILON) / (axis.peakCoord - axis.startCoord + Number.EPSILON);
                          } else {
                            axisScalar = (axis.endCoord - normalizedCoords[j] + Number.EPSILON) / (axis.endCoord - axis.peakCoord + Number.EPSILON);
                          }
                        }
                        scalar *= axisScalar;
                      }
                      blendVector[master] = scalar;
                    }
                    this.blendVectors.set(varData, blendVector);
                    return blendVector;
                  };
                  return GlyphVariationProcessor2;
                }();
                var resolved = Promise.resolve();
                var Subset = function() {
                  function Subset2(font) {
                    this.font = font;
                    this.glyphs = [];
                    this.mapping = {};
                    this.includeGlyph(0);
                  }
                  var _proto39 = Subset2.prototype;
                  _proto39.includeGlyph = function includeGlyph(glyph2) {
                    if (typeof glyph2 === "object") {
                      glyph2 = glyph2.id;
                    }
                    if (this.mapping[glyph2] == null) {
                      this.glyphs.push(glyph2);
                      this.mapping[glyph2] = this.glyphs.length - 1;
                    }
                    return this.mapping[glyph2];
                  };
                  _proto39.encodeStream = function encodeStream() {
                    var _this11 = this;
                    var s = new r.EncodeStream();
                    resolved.then(function() {
                      _this11.encode(s);
                      return s.end();
                    });
                    return s;
                  };
                  return Subset2;
                }();
                var ON_CURVE$1 = 1 << 0;
                var X_SHORT_VECTOR$1 = 1 << 1;
                var Y_SHORT_VECTOR$1 = 1 << 2;
                var REPEAT$1 = 1 << 3;
                var SAME_X$1 = 1 << 4;
                var SAME_Y$1 = 1 << 5;
                var Point$1 = function() {
                  function Point$12() {
                  }
                  Point$12.size = function size(val) {
                    return val >= 0 && val <= 255 ? 1 : 2;
                  };
                  Point$12.encode = function encode(stream, value) {
                    if (value >= 0 && value <= 255) {
                      stream.writeUInt8(value);
                    } else {
                      stream.writeInt16BE(value);
                    }
                  };
                  return Point$12;
                }();
                var Glyf = new r.Struct({
                  numberOfContours: r.int16,
                  // if negative, this is a composite glyph
                  xMin: r.int16,
                  yMin: r.int16,
                  xMax: r.int16,
                  yMax: r.int16,
                  endPtsOfContours: new r.Array(r.uint16, "numberOfContours"),
                  instructions: new r.Array(r.uint8, r.uint16),
                  flags: new r.Array(r.uint8, 0),
                  xPoints: new r.Array(Point$1, 0),
                  yPoints: new r.Array(Point$1, 0)
                });
                var TTFGlyphEncoder = function() {
                  function TTFGlyphEncoder2() {
                  }
                  var _proto40 = TTFGlyphEncoder2.prototype;
                  _proto40.encodeSimple = function encodeSimple(path, instructions) {
                    if (instructions === void 0) {
                      instructions = [];
                    }
                    var endPtsOfContours = [];
                    var xPoints = [];
                    var yPoints = [];
                    var flags = [];
                    var same = 0;
                    var lastX = 0, lastY = 0, lastFlag = 0;
                    var pointCount = 0;
                    for (var i2 = 0; i2 < path.commands.length; i2++) {
                      var c = path.commands[i2];
                      for (var j = 0; j < c.args.length; j += 2) {
                        var x = c.args[j];
                        var y = c.args[j + 1];
                        var flag = 0;
                        if (c.command === "quadraticCurveTo" && j === 2) {
                          var next = path.commands[i2 + 1];
                          if (next && next.command === "quadraticCurveTo") {
                            var midX = (lastX + next.args[0]) / 2;
                            var midY = (lastY + next.args[1]) / 2;
                            if (x === midX && y === midY) {
                              continue;
                            }
                          }
                        }
                        if (!(c.command === "quadraticCurveTo" && j === 0)) {
                          flag |= ON_CURVE$1;
                        }
                        flag = this._encodePoint(x, lastX, xPoints, flag, X_SHORT_VECTOR$1, SAME_X$1);
                        flag = this._encodePoint(y, lastY, yPoints, flag, Y_SHORT_VECTOR$1, SAME_Y$1);
                        if (flag === lastFlag && same < 255) {
                          flags[flags.length - 1] |= REPEAT$1;
                          same++;
                        } else {
                          if (same > 0) {
                            flags.push(same);
                            same = 0;
                          }
                          flags.push(flag);
                          lastFlag = flag;
                        }
                        lastX = x;
                        lastY = y;
                        pointCount++;
                      }
                      if (c.command === "closePath") {
                        endPtsOfContours.push(pointCount - 1);
                      }
                    }
                    if (path.commands.length > 1 && path.commands[path.commands.length - 1].command !== "closePath") {
                      endPtsOfContours.push(pointCount - 1);
                    }
                    var bbox = path.bbox;
                    var glyf2 = {
                      numberOfContours: endPtsOfContours.length,
                      xMin: bbox.minX,
                      yMin: bbox.minY,
                      xMax: bbox.maxX,
                      yMax: bbox.maxY,
                      endPtsOfContours,
                      instructions,
                      flags,
                      xPoints,
                      yPoints
                    };
                    var size = Glyf.size(glyf2);
                    var tail = 4 - size % 4;
                    var stream = new r.EncodeStream(size + tail);
                    Glyf.encode(stream, glyf2);
                    if (tail !== 0) {
                      stream.fill(0, tail);
                    }
                    return stream.buffer;
                  };
                  _proto40._encodePoint = function _encodePoint(value, last, points, flag, shortFlag, sameFlag) {
                    var diff = value - last;
                    if (value === last) {
                      flag |= sameFlag;
                    } else {
                      if (-255 <= diff && diff <= 255) {
                        flag |= shortFlag;
                        if (diff < 0) {
                          diff = -diff;
                        } else {
                          flag |= sameFlag;
                        }
                      }
                      points.push(diff);
                    }
                    return flag;
                  };
                  return TTFGlyphEncoder2;
                }();
                var TTFSubset = function(_Subset) {
                  _inheritsLoose(TTFSubset2, _Subset);
                  function TTFSubset2(font) {
                    var _this12;
                    _this12 = _Subset.call(this, font) || this;
                    _this12.glyphEncoder = new TTFGlyphEncoder();
                    return _this12;
                  }
                  var _proto41 = TTFSubset2.prototype;
                  _proto41._addGlyph = function _addGlyph(gid) {
                    var glyph2 = this.font.getGlyph(gid);
                    var glyf2 = glyph2._decode();
                    var curOffset = this.font.loca.offsets[gid];
                    var nextOffset = this.font.loca.offsets[gid + 1];
                    var stream = this.font._getTableStream("glyf");
                    stream.pos += curOffset;
                    var buffer = stream.readBuffer(nextOffset - curOffset);
                    if (glyf2 && glyf2.numberOfContours < 0) {
                      buffer = Buffer.from(buffer);
                      for (var _iterator72 = _createForOfIteratorHelperLoose(glyf2.components), _step72; !(_step72 = _iterator72()).done; ) {
                        var component = _step72.value;
                        gid = this.includeGlyph(component.glyphID);
                        buffer.writeUInt16BE(gid, component.pos);
                      }
                    } else if (glyf2 && this.font._variationProcessor) {
                      buffer = this.glyphEncoder.encodeSimple(glyph2.path, glyf2.instructions);
                    }
                    this.glyf.push(buffer);
                    this.loca.offsets.push(this.offset);
                    this.hmtx.metrics.push({
                      advance: glyph2.advanceWidth,
                      bearing: glyph2._getMetrics().leftBearing
                    });
                    this.offset += buffer.length;
                    return this.glyf.length - 1;
                  };
                  _proto41.encode = function encode(stream) {
                    this.glyf = [];
                    this.offset = 0;
                    this.loca = {
                      offsets: [],
                      version: this.font.loca.version
                    };
                    this.hmtx = {
                      metrics: [],
                      bearings: []
                    };
                    var i2 = 0;
                    while (i2 < this.glyphs.length) {
                      this._addGlyph(this.glyphs[i2++]);
                    }
                    var maxp2 = cloneDeep(this.font.maxp);
                    maxp2.numGlyphs = this.glyf.length;
                    this.loca.offsets.push(this.offset);
                    var head2 = cloneDeep(this.font.head);
                    head2.indexToLocFormat = this.loca.version;
                    var hhea2 = cloneDeep(this.font.hhea);
                    hhea2.numberOfMetrics = this.hmtx.metrics.length;
                    Directory.encode(stream, {
                      tables: {
                        head: head2,
                        hhea: hhea2,
                        loca: this.loca,
                        maxp: maxp2,
                        "cvt ": this.font["cvt "],
                        prep: this.font.prep,
                        glyf: this.glyf,
                        hmtx: this.hmtx,
                        fpgm: this.font.fpgm
                        // name: clone @font.name
                        // 'OS/2': clone @font['OS/2']
                        // post: clone @font.post
                        // cmap: cmap
                      }
                    });
                  };
                  return TTFSubset2;
                }(Subset);
                var CFFSubset = function(_Subset2) {
                  _inheritsLoose(CFFSubset2, _Subset2);
                  function CFFSubset2(font) {
                    var _this13;
                    _this13 = _Subset2.call(this, font) || this;
                    _this13.cff = _this13.font["CFF "];
                    if (!_this13.cff) {
                      throw new Error("Not a CFF Font");
                    }
                    return _this13;
                  }
                  var _proto42 = CFFSubset2.prototype;
                  _proto42.subsetCharstrings = function subsetCharstrings() {
                    this.charstrings = [];
                    var gsubrs = {};
                    for (var _iterator73 = _createForOfIteratorHelperLoose(this.glyphs), _step73; !(_step73 = _iterator73()).done; ) {
                      var gid = _step73.value;
                      this.charstrings.push(this.cff.getCharString(gid));
                      var glyph2 = this.font.getGlyph(gid);
                      var path = glyph2.path;
                      for (var subr in glyph2._usedGsubrs) {
                        gsubrs[subr] = true;
                      }
                    }
                    this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, gsubrs);
                  };
                  _proto42.subsetSubrs = function subsetSubrs(subrs, used) {
                    var res = [];
                    for (var i2 = 0; i2 < subrs.length; i2++) {
                      var subr = subrs[i2];
                      if (used[i2]) {
                        this.cff.stream.pos = subr.offset;
                        res.push(this.cff.stream.readBuffer(subr.length));
                      } else {
                        res.push(Buffer.from([11]));
                      }
                    }
                    return res;
                  };
                  _proto42.subsetFontdict = function subsetFontdict(topDict) {
                    topDict.FDArray = [];
                    topDict.FDSelect = {
                      version: 0,
                      fds: []
                    };
                    var used_fds = {};
                    var used_subrs = [];
                    var fd_select = {};
                    for (var _iterator74 = _createForOfIteratorHelperLoose(this.glyphs), _step74; !(_step74 = _iterator74()).done; ) {
                      var gid = _step74.value;
                      var fd = this.cff.fdForGlyph(gid);
                      if (fd == null) {
                        continue;
                      }
                      if (!used_fds[fd]) {
                        topDict.FDArray.push(Object.assign({}, this.cff.topDict.FDArray[fd]));
                        used_subrs.push({});
                        fd_select[fd] = topDict.FDArray.length - 1;
                      }
                      used_fds[fd] = true;
                      topDict.FDSelect.fds.push(fd_select[fd]);
                      var glyph2 = this.font.getGlyph(gid);
                      var path = glyph2.path;
                      for (var subr in glyph2._usedSubrs) {
                        used_subrs[fd_select[fd]][subr] = true;
                      }
                    }
                    for (var i2 = 0; i2 < topDict.FDArray.length; i2++) {
                      var dict = topDict.FDArray[i2];
                      delete dict.FontName;
                      if (dict.Private && dict.Private.Subrs) {
                        dict.Private = Object.assign({}, dict.Private);
                        dict.Private.Subrs = this.subsetSubrs(dict.Private.Subrs, used_subrs[i2]);
                      }
                    }
                    return;
                  };
                  _proto42.createCIDFontdict = function createCIDFontdict(topDict) {
                    var used_subrs = {};
                    for (var _iterator75 = _createForOfIteratorHelperLoose(this.glyphs), _step75; !(_step75 = _iterator75()).done; ) {
                      var gid = _step75.value;
                      var glyph2 = this.font.getGlyph(gid);
                      var path = glyph2.path;
                      for (var subr in glyph2._usedSubrs) {
                        used_subrs[subr] = true;
                      }
                    }
                    var privateDict = Object.assign({}, this.cff.topDict.Private);
                    if (this.cff.topDict.Private && this.cff.topDict.Private.Subrs) {
                      privateDict.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, used_subrs);
                    }
                    topDict.FDArray = [{
                      Private: privateDict
                    }];
                    return topDict.FDSelect = {
                      version: 3,
                      nRanges: 1,
                      ranges: [{
                        first: 0,
                        fd: 0
                      }],
                      sentinel: this.charstrings.length
                    };
                  };
                  _proto42.addString = function addString(string) {
                    if (!string) {
                      return null;
                    }
                    if (!this.strings) {
                      this.strings = [];
                    }
                    this.strings.push(string);
                    return standardStrings.length + this.strings.length - 1;
                  };
                  _proto42.encode = function encode(stream) {
                    this.subsetCharstrings();
                    var charset = {
                      version: this.charstrings.length > 255 ? 2 : 1,
                      ranges: [{
                        first: 1,
                        nLeft: this.charstrings.length - 2
                      }]
                    };
                    var topDict = Object.assign({}, this.cff.topDict);
                    topDict.Private = null;
                    topDict.charset = charset;
                    topDict.Encoding = null;
                    topDict.CharStrings = this.charstrings;
                    for (var _i24 = 0, _arr2 = ["version", "Notice", "Copyright", "FullName", "FamilyName", "Weight", "PostScript", "BaseFontName", "FontName"]; _i24 < _arr2.length; _i24++) {
                      var key = _arr2[_i24];
                      topDict[key] = this.addString(this.cff.string(topDict[key]));
                    }
                    topDict.ROS = [this.addString("Adobe"), this.addString("Identity"), 0];
                    topDict.CIDCount = this.charstrings.length;
                    if (this.cff.isCIDFont) {
                      this.subsetFontdict(topDict);
                    } else {
                      this.createCIDFontdict(topDict);
                    }
                    var top = {
                      version: 1,
                      hdrSize: this.cff.hdrSize,
                      offSize: 4,
                      header: this.cff.header,
                      nameIndex: [this.cff.postscriptName],
                      topDictIndex: [topDict],
                      stringIndex: this.strings,
                      globalSubrIndex: this.gsubrs
                    };
                    CFFTop.encode(stream, top);
                  };
                  return CFFSubset2;
                }(Subset);
                var _class$4;
                var TTFFont = (_class$4 = function() {
                  TTFFont2.probe = function probe(buffer) {
                    var format = buffer.toString("ascii", 0, 4);
                    return format === "true" || format === "OTTO" || format === String.fromCharCode(0, 1, 0, 0);
                  };
                  function TTFFont2(stream, variationCoords) {
                    if (variationCoords === void 0) {
                      variationCoords = null;
                    }
                    this.defaultLanguage = null;
                    this.stream = stream;
                    this.variationCoords = variationCoords;
                    this._directoryPos = this.stream.pos;
                    this._tables = {};
                    this._glyphs = {};
                    this._decodeDirectory();
                    for (var tag2 in this.directory.tables) {
                      var table = this.directory.tables[tag2];
                      if (tables[tag2] && table.length > 0) {
                        Object.defineProperty(this, tag2, {
                          get: this._getTable.bind(this, table)
                        });
                      }
                    }
                  }
                  var _proto43 = TTFFont2.prototype;
                  _proto43.setDefaultLanguage = function setDefaultLanguage(lang) {
                    if (lang === void 0) {
                      lang = null;
                    }
                    this.defaultLanguage = lang;
                  };
                  _proto43._getTable = function _getTable(table) {
                    if (!(table.tag in this._tables)) {
                      try {
                        this._tables[table.tag] = this._decodeTable(table);
                      } catch (e) {
                        if (fontkit.logErrors) {
                          console.error("Error decoding table ".concat(table.tag));
                          console.error(e.stack);
                        }
                      }
                    }
                    return this._tables[table.tag];
                  };
                  _proto43._getTableStream = function _getTableStream(tag2) {
                    var table = this.directory.tables[tag2];
                    if (table) {
                      this.stream.pos = table.offset;
                      return this.stream;
                    }
                    return null;
                  };
                  _proto43._decodeDirectory = function _decodeDirectory() {
                    return this.directory = Directory.decode(this.stream, {
                      _startOffset: 0
                    });
                  };
                  _proto43._decodeTable = function _decodeTable(table) {
                    var pos = this.stream.pos;
                    var stream = this._getTableStream(table.tag);
                    var result = tables[table.tag].decode(stream, this, table.length);
                    this.stream.pos = pos;
                    return result;
                  };
                  _proto43.getName = function getName(key, lang) {
                    if (lang === void 0) {
                      lang = this.defaultLanguage || fontkit.defaultLanguage;
                    }
                    var record = this.name && this.name.records[key];
                    if (record) {
                      return record[lang] || record[this.defaultLanguage] || record[fontkit.defaultLanguage] || record["en"] || record[Object.keys(record)[0]] || null;
                    }
                    return null;
                  };
                  _proto43.hasGlyphForCodePoint = function hasGlyphForCodePoint(codePoint) {
                    return !!this._cmapProcessor.lookup(codePoint);
                  };
                  _proto43.glyphForCodePoint = function glyphForCodePoint(codePoint) {
                    return this.getGlyph(this._cmapProcessor.lookup(codePoint), [codePoint]);
                  };
                  _proto43.glyphsForString = function glyphsForString(string) {
                    var glyphs = [];
                    var len = string.length;
                    var idx = 0;
                    var last = -1;
                    var state = -1;
                    while (idx <= len) {
                      var code = 0;
                      var nextState = 0;
                      if (idx < len) {
                        code = string.charCodeAt(idx++);
                        if (55296 <= code && code <= 56319 && idx < len) {
                          var next = string.charCodeAt(idx);
                          if (56320 <= next && next <= 57343) {
                            idx++;
                            code = ((code & 1023) << 10) + (next & 1023) + 65536;
                          }
                        }
                        nextState = 65024 <= code && code <= 65039 || 917760 <= code && code <= 917999 ? 1 : 0;
                      } else {
                        idx++;
                      }
                      if (state === 0 && nextState === 1) {
                        glyphs.push(this.getGlyph(this._cmapProcessor.lookup(last, code), [last, code]));
                      } else if (state === 0 && nextState === 0) {
                        glyphs.push(this.glyphForCodePoint(last));
                      }
                      last = code;
                      state = nextState;
                    }
                    return glyphs;
                  };
                  _proto43.layout = function layout(string, userFeatures, script2, language, direction2) {
                    return this._layoutEngine.layout(string, userFeatures, script2, language, direction2);
                  };
                  _proto43.stringsForGlyph = function stringsForGlyph(gid) {
                    return this._layoutEngine.stringsForGlyph(gid);
                  };
                  _proto43.getAvailableFeatures = function getAvailableFeatures(script2, language) {
                    return this._layoutEngine.getAvailableFeatures(script2, language);
                  };
                  _proto43._getBaseGlyph = function _getBaseGlyph(glyph2, characters) {
                    if (characters === void 0) {
                      characters = [];
                    }
                    if (!this._glyphs[glyph2]) {
                      if (this.directory.tables.glyf) {
                        this._glyphs[glyph2] = new TTFGlyph(glyph2, characters, this);
                      } else if (this.directory.tables["CFF "] || this.directory.tables.CFF2) {
                        this._glyphs[glyph2] = new CFFGlyph(glyph2, characters, this);
                      }
                    }
                    return this._glyphs[glyph2] || null;
                  };
                  _proto43.getGlyph = function getGlyph2(glyph2, characters) {
                    if (characters === void 0) {
                      characters = [];
                    }
                    if (!this._glyphs[glyph2]) {
                      if (this.directory.tables.sbix) {
                        this._glyphs[glyph2] = new SBIXGlyph(glyph2, characters, this);
                      } else if (this.directory.tables.COLR && this.directory.tables.CPAL) {
                        this._glyphs[glyph2] = new COLRGlyph(glyph2, characters, this);
                      } else {
                        this._getBaseGlyph(glyph2, characters);
                      }
                    }
                    return this._glyphs[glyph2] || null;
                  };
                  _proto43.createSubset = function createSubset() {
                    if (this.directory.tables["CFF "]) {
                      return new CFFSubset(this);
                    }
                    return new TTFSubset(this);
                  };
                  _proto43.getVariation = function getVariation(settings) {
                    if (!(this.directory.tables.fvar && (this.directory.tables.gvar && this.directory.tables.glyf || this.directory.tables.CFF2))) {
                      throw new Error("Variations require a font with the fvar, gvar and glyf, or CFF2 tables.");
                    }
                    if (typeof settings === "string") {
                      settings = this.namedVariations[settings];
                    }
                    if (typeof settings !== "object") {
                      throw new Error("Variation settings must be either a variation name or settings object.");
                    }
                    var coords = this.fvar.axis.map(function(axis, i2) {
                      var axisTag = axis.axisTag.trim();
                      if (axisTag in settings) {
                        return Math.max(axis.minValue, Math.min(axis.maxValue, settings[axisTag]));
                      } else {
                        return axis.defaultValue;
                      }
                    });
                    var stream = new r.DecodeStream(this.stream.buffer);
                    stream.pos = this._directoryPos;
                    var font = new TTFFont2(stream, coords);
                    font._tables = this._tables;
                    return font;
                  };
                  _proto43.getFont = function getFont(name) {
                    return this.getVariation(name);
                  };
                  _createClass(TTFFont2, [{
                    key: "postscriptName",
                    get: function get() {
                      return this.getName("postscriptName");
                    }
                    /**
                     * The font's full name, e.g. "Helvetica Bold"
                     * @type {string}
                     */
                  }, {
                    key: "fullName",
                    get: function get() {
                      return this.getName("fullName");
                    }
                    /**
                     * The font's family name, e.g. "Helvetica"
                     * @type {string}
                     */
                  }, {
                    key: "familyName",
                    get: function get() {
                      return this.getName("fontFamily");
                    }
                    /**
                     * The font's sub-family, e.g. "Bold".
                     * @type {string}
                     */
                  }, {
                    key: "subfamilyName",
                    get: function get() {
                      return this.getName("fontSubfamily");
                    }
                    /**
                     * The font's copyright information
                     * @type {string}
                     */
                  }, {
                    key: "copyright",
                    get: function get() {
                      return this.getName("copyright");
                    }
                    /**
                     * The font's version number
                     * @type {string}
                     */
                  }, {
                    key: "version",
                    get: function get() {
                      return this.getName("version");
                    }
                    /**
                     * The fonts [ascender](https://en.wikipedia.org/wiki/Ascender_(typography))
                     * @type {number}
                     */
                  }, {
                    key: "ascent",
                    get: function get() {
                      return this.hhea.ascent;
                    }
                    /**
                     * The fonts [descender](https://en.wikipedia.org/wiki/Descender)
                     * @type {number}
                     */
                  }, {
                    key: "descent",
                    get: function get() {
                      return this.hhea.descent;
                    }
                    /**
                     * The amount of space that should be included between lines
                     * @type {number}
                     */
                  }, {
                    key: "lineGap",
                    get: function get() {
                      return this.hhea.lineGap;
                    }
                    /**
                     * The offset from the normal underline position that should be used
                     * @type {number}
                     */
                  }, {
                    key: "underlinePosition",
                    get: function get() {
                      return this.post.underlinePosition;
                    }
                    /**
                     * The weight of the underline that should be used
                     * @type {number}
                     */
                  }, {
                    key: "underlineThickness",
                    get: function get() {
                      return this.post.underlineThickness;
                    }
                    /**
                     * If this is an italic font, the angle the cursor should be drawn at to match the font design
                     * @type {number}
                     */
                  }, {
                    key: "italicAngle",
                    get: function get() {
                      return this.post.italicAngle;
                    }
                    /**
                     * The height of capital letters above the baseline.
                     * See [here](https://en.wikipedia.org/wiki/Cap_height) for more details.
                     * @type {number}
                     */
                  }, {
                    key: "capHeight",
                    get: function get() {
                      var os2 = this["OS/2"];
                      return os2 ? os2.capHeight : this.ascent;
                    }
                    /**
                     * The height of lower case letters in the font.
                     * See [here](https://en.wikipedia.org/wiki/X-height) for more details.
                     * @type {number}
                     */
                  }, {
                    key: "xHeight",
                    get: function get() {
                      var os2 = this["OS/2"];
                      return os2 ? os2.xHeight : 0;
                    }
                    /**
                     * The number of glyphs in the font.
                     * @type {number}
                     */
                  }, {
                    key: "numGlyphs",
                    get: function get() {
                      return this.maxp.numGlyphs;
                    }
                    /**
                     * The size of the fonts internal coordinate grid
                     * @type {number}
                     */
                  }, {
                    key: "unitsPerEm",
                    get: function get() {
                      return this.head.unitsPerEm;
                    }
                    /**
                     * The fonts bounding box, i.e. the box that encloses all glyphs in the font.
                     * @type {BBox}
                     */
                  }, {
                    key: "bbox",
                    get: function get() {
                      return Object.freeze(new BBox(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));
                    }
                  }, {
                    key: "_cmapProcessor",
                    get: function get() {
                      return new CmapProcessor(this.cmap);
                    }
                    /**
                     * An array of all of the unicode code points supported by the font.
                     * @type {number[]}
                     */
                  }, {
                    key: "characterSet",
                    get: function get() {
                      return this._cmapProcessor.getCharacterSet();
                    }
                  }, {
                    key: "_layoutEngine",
                    get: function get() {
                      return new LayoutEngine(this);
                    }
                  }, {
                    key: "availableFeatures",
                    get: function get() {
                      return this._layoutEngine.getAvailableFeatures();
                    }
                  }, {
                    key: "variationAxes",
                    get: function get() {
                      var res = {};
                      if (!this.fvar) {
                        return res;
                      }
                      for (var _iterator76 = _createForOfIteratorHelperLoose(this.fvar.axis), _step76; !(_step76 = _iterator76()).done; ) {
                        var axis = _step76.value;
                        res[axis.axisTag.trim()] = {
                          name: axis.name.en,
                          min: axis.minValue,
                          default: axis.defaultValue,
                          max: axis.maxValue
                        };
                      }
                      return res;
                    }
                    /**
                     * Returns an object describing the named variation instances
                     * that the font designer has specified. Keys are variation names
                     * and values are the variation settings for this instance.
                     *
                     * @type {object}
                     */
                  }, {
                    key: "namedVariations",
                    get: function get() {
                      var res = {};
                      if (!this.fvar) {
                        return res;
                      }
                      for (var _iterator77 = _createForOfIteratorHelperLoose(this.fvar.instance), _step77; !(_step77 = _iterator77()).done; ) {
                        var instance = _step77.value;
                        var settings = {};
                        for (var i2 = 0; i2 < this.fvar.axis.length; i2++) {
                          var axis = this.fvar.axis[i2];
                          settings[axis.axisTag.trim()] = instance.coord[i2];
                        }
                        res[instance.name.en] = settings;
                      }
                      return res;
                    }
                  }, {
                    key: "_variationProcessor",
                    get: function get() {
                      if (!this.fvar) {
                        return null;
                      }
                      var variationCoords = this.variationCoords;
                      if (!variationCoords && !this.CFF2) {
                        return null;
                      }
                      if (!variationCoords) {
                        variationCoords = this.fvar.axis.map(function(axis) {
                          return axis.defaultValue;
                        });
                      }
                      return new GlyphVariationProcessor(this, variationCoords);
                    }
                  }]);
                  return TTFFont2;
                }(), _applyDecoratedDescriptor(_class$4.prototype, "bbox", [cache], Object.getOwnPropertyDescriptor(_class$4.prototype, "bbox"), _class$4.prototype), _applyDecoratedDescriptor(_class$4.prototype, "_cmapProcessor", [cache], Object.getOwnPropertyDescriptor(_class$4.prototype, "_cmapProcessor"), _class$4.prototype), _applyDecoratedDescriptor(_class$4.prototype, "characterSet", [cache], Object.getOwnPropertyDescriptor(_class$4.prototype, "characterSet"), _class$4.prototype), _applyDecoratedDescriptor(_class$4.prototype, "_layoutEngine", [cache], Object.getOwnPropertyDescriptor(_class$4.prototype, "_layoutEngine"), _class$4.prototype), _applyDecoratedDescriptor(_class$4.prototype, "variationAxes", [cache], Object.getOwnPropertyDescriptor(_class$4.prototype, "variationAxes"), _class$4.prototype), _applyDecoratedDescriptor(_class$4.prototype, "namedVariations", [cache], Object.getOwnPropertyDescriptor(_class$4.prototype, "namedVariations"), _class$4.prototype), _applyDecoratedDescriptor(_class$4.prototype, "_variationProcessor", [cache], Object.getOwnPropertyDescriptor(_class$4.prototype, "_variationProcessor"), _class$4.prototype), _class$4);
                var WOFFDirectoryEntry = new r.Struct({
                  tag: new r.String(4),
                  offset: new r.Pointer(r.uint32, "void", {
                    type: "global"
                  }),
                  compLength: r.uint32,
                  length: r.uint32,
                  origChecksum: r.uint32
                });
                var WOFFDirectory = new r.Struct({
                  tag: new r.String(4),
                  // should be 'wOFF'
                  flavor: r.uint32,
                  length: r.uint32,
                  numTables: r.uint16,
                  reserved: new r.Reserved(r.uint16),
                  totalSfntSize: r.uint32,
                  majorVersion: r.uint16,
                  minorVersion: r.uint16,
                  metaOffset: r.uint32,
                  metaLength: r.uint32,
                  metaOrigLength: r.uint32,
                  privOffset: r.uint32,
                  privLength: r.uint32,
                  tables: new r.Array(WOFFDirectoryEntry, "numTables")
                });
                WOFFDirectory.process = function() {
                  var tables2 = {};
                  for (var _iterator78 = _createForOfIteratorHelperLoose(this.tables), _step78; !(_step78 = _iterator78()).done; ) {
                    var table = _step78.value;
                    tables2[table.tag] = table;
                  }
                  this.tables = tables2;
                };
                var WOFFFont = function(_TTFFont) {
                  _inheritsLoose(WOFFFont2, _TTFFont);
                  function WOFFFont2() {
                    return _TTFFont.apply(this, arguments) || this;
                  }
                  WOFFFont2.probe = function probe(buffer) {
                    return buffer.toString("ascii", 0, 4) === "wOFF";
                  };
                  var _proto44 = WOFFFont2.prototype;
                  _proto44._decodeDirectory = function _decodeDirectory() {
                    this.directory = WOFFDirectory.decode(this.stream, {
                      _startOffset: 0
                    });
                  };
                  _proto44._getTableStream = function _getTableStream(tag2) {
                    var table = this.directory.tables[tag2];
                    if (table) {
                      this.stream.pos = table.offset;
                      if (table.compLength < table.length) {
                        this.stream.pos += 2;
                        var outBuffer = Buffer.alloc(table.length);
                        var buf = inflate(this.stream.readBuffer(table.compLength - 2), outBuffer);
                        return new r.DecodeStream(buf);
                      } else {
                        return this.stream;
                      }
                    }
                    return null;
                  };
                  return WOFFFont2;
                }(TTFFont);
                var WOFF2Glyph = function(_TTFGlyph2) {
                  _inheritsLoose(WOFF2Glyph2, _TTFGlyph2);
                  function WOFF2Glyph2() {
                    return _TTFGlyph2.apply(this, arguments) || this;
                  }
                  var _proto45 = WOFF2Glyph2.prototype;
                  _proto45._decode = function _decode() {
                    return this._font._transformedGlyphs[this.id];
                  };
                  _proto45._getCBox = function _getCBox() {
                    return this.path.bbox;
                  };
                  return WOFF2Glyph2;
                }(TTFGlyph);
                var Base128 = {
                  decode: function decode(stream) {
                    var result = 0;
                    var iterable = [0, 1, 2, 3, 4];
                    for (var j = 0; j < iterable.length; j++) {
                      var code = stream.readUInt8();
                      if (result & 3758096384) {
                        throw new Error("Overflow");
                      }
                      result = result << 7 | code & 127;
                      if ((code & 128) === 0) {
                        return result;
                      }
                    }
                    throw new Error("Bad base 128 number");
                  }
                };
                var knownTags = ["cmap", "head", "hhea", "hmtx", "maxp", "name", "OS/2", "post", "cvt ", "fpgm", "glyf", "loca", "prep", "CFF ", "VORG", "EBDT", "EBLC", "gasp", "hdmx", "kern", "LTSH", "PCLT", "VDMX", "vhea", "vmtx", "BASE", "GDEF", "GPOS", "GSUB", "EBSC", "JSTF", "MATH", "CBDT", "CBLC", "COLR", "CPAL", "SVG ", "sbix", "acnt", "avar", "bdat", "bloc", "bsln", "cvar", "fdsc", "feat", "fmtx", "fvar", "gvar", "hsty", "just", "lcar", "mort", "morx", "opbd", "prop", "trak", "Zapf", "Silf", "Glat", "Gloc", "Feat", "Sill"];
                var WOFF2DirectoryEntry = new r.Struct({
                  flags: r.uint8,
                  customTag: new r.Optional(new r.String(4), function(t2) {
                    return (t2.flags & 63) === 63;
                  }),
                  tag: function tag2(t2) {
                    return t2.customTag || knownTags[t2.flags & 63];
                  },
                  // || (() => { throw new Error(`Bad tag: ${flags & 0x3f}`); })(); },
                  length: Base128,
                  transformVersion: function transformVersion(t2) {
                    return t2.flags >>> 6 & 3;
                  },
                  transformed: function transformed(t2) {
                    return t2.tag === "glyf" || t2.tag === "loca" ? t2.transformVersion === 0 : t2.transformVersion !== 0;
                  },
                  transformLength: new r.Optional(Base128, function(t2) {
                    return t2.transformed;
                  })
                });
                var WOFF2Directory = new r.Struct({
                  tag: new r.String(4),
                  // should be 'wOF2'
                  flavor: r.uint32,
                  length: r.uint32,
                  numTables: r.uint16,
                  reserved: new r.Reserved(r.uint16),
                  totalSfntSize: r.uint32,
                  totalCompressedSize: r.uint32,
                  majorVersion: r.uint16,
                  minorVersion: r.uint16,
                  metaOffset: r.uint32,
                  metaLength: r.uint32,
                  metaOrigLength: r.uint32,
                  privOffset: r.uint32,
                  privLength: r.uint32,
                  tables: new r.Array(WOFF2DirectoryEntry, "numTables")
                });
                WOFF2Directory.process = function() {
                  var tables2 = {};
                  for (var i2 = 0; i2 < this.tables.length; i2++) {
                    var table = this.tables[i2];
                    tables2[table.tag] = table;
                  }
                  return this.tables = tables2;
                };
                var WOFF2Font = function(_TTFFont2) {
                  _inheritsLoose(WOFF2Font2, _TTFFont2);
                  function WOFF2Font2() {
                    return _TTFFont2.apply(this, arguments) || this;
                  }
                  WOFF2Font2.probe = function probe(buffer) {
                    return buffer.toString("ascii", 0, 4) === "wOF2";
                  };
                  var _proto46 = WOFF2Font2.prototype;
                  _proto46._decodeDirectory = function _decodeDirectory() {
                    this.directory = WOFF2Directory.decode(this.stream);
                    this._dataPos = this.stream.pos;
                  };
                  _proto46._decompress = function _decompress() {
                    if (!this._decompressed) {
                      this.stream.pos = this._dataPos;
                      var buffer = this.stream.readBuffer(this.directory.totalCompressedSize);
                      var decompressedSize = 0;
                      for (var tag2 in this.directory.tables) {
                        var entry = this.directory.tables[tag2];
                        entry.offset = decompressedSize;
                        decompressedSize += entry.transformLength != null ? entry.transformLength : entry.length;
                      }
                      var decompressed = brotli(buffer, decompressedSize);
                      if (!decompressed) {
                        throw new Error("Error decoding compressed data in WOFF2");
                      }
                      this.stream = new r.DecodeStream(Buffer.from(decompressed));
                      this._decompressed = true;
                    }
                  };
                  _proto46._decodeTable = function _decodeTable(table) {
                    this._decompress();
                    return _TTFFont2.prototype._decodeTable.call(this, table);
                  };
                  _proto46._getBaseGlyph = function _getBaseGlyph(glyph2, characters) {
                    if (characters === void 0) {
                      characters = [];
                    }
                    if (!this._glyphs[glyph2]) {
                      if (this.directory.tables.glyf && this.directory.tables.glyf.transformed) {
                        if (!this._transformedGlyphs) {
                          this._transformGlyfTable();
                        }
                        return this._glyphs[glyph2] = new WOFF2Glyph(glyph2, characters, this);
                      } else {
                        return _TTFFont2.prototype._getBaseGlyph.call(this, glyph2, characters);
                      }
                    }
                  };
                  _proto46._transformGlyfTable = function _transformGlyfTable() {
                    this._decompress();
                    this.stream.pos = this.directory.tables.glyf.offset;
                    var table = GlyfTable.decode(this.stream);
                    var glyphs = [];
                    for (var index = 0; index < table.numGlyphs; index++) {
                      var glyph2 = {};
                      var nContours = table.nContours.readInt16BE();
                      glyph2.numberOfContours = nContours;
                      if (nContours > 0) {
                        var nPoints = [];
                        var totalPoints = 0;
                        for (var i2 = 0; i2 < nContours; i2++) {
                          var _r = read255UInt16(table.nPoints);
                          totalPoints += _r;
                          nPoints.push(totalPoints);
                        }
                        glyph2.points = decodeTriplet(table.flags, table.glyphs, totalPoints);
                        for (var _i = 0; _i < nContours; _i++) {
                          glyph2.points[nPoints[_i] - 1].endContour = true;
                        }
                        var instructionSize = read255UInt16(table.glyphs);
                      } else if (nContours < 0) {
                        var haveInstructions = TTFGlyph.prototype._decodeComposite.call({
                          _font: this
                        }, glyph2, table.composites);
                        if (haveInstructions) {
                          var instructionSize = read255UInt16(table.glyphs);
                        }
                      }
                      glyphs.push(glyph2);
                    }
                    this._transformedGlyphs = glyphs;
                  };
                  return WOFF2Font2;
                }(TTFFont);
                var Substream = function() {
                  function Substream2(length) {
                    this.length = length;
                    this._buf = new r.Buffer(length);
                  }
                  var _proto47 = Substream2.prototype;
                  _proto47.decode = function decode(stream, parent) {
                    return new r.DecodeStream(this._buf.decode(stream, parent));
                  };
                  return Substream2;
                }();
                var GlyfTable = new r.Struct({
                  version: r.uint32,
                  numGlyphs: r.uint16,
                  indexFormat: r.uint16,
                  nContourStreamSize: r.uint32,
                  nPointsStreamSize: r.uint32,
                  flagStreamSize: r.uint32,
                  glyphStreamSize: r.uint32,
                  compositeStreamSize: r.uint32,
                  bboxStreamSize: r.uint32,
                  instructionStreamSize: r.uint32,
                  nContours: new Substream("nContourStreamSize"),
                  nPoints: new Substream("nPointsStreamSize"),
                  flags: new Substream("flagStreamSize"),
                  glyphs: new Substream("glyphStreamSize"),
                  composites: new Substream("compositeStreamSize"),
                  bboxes: new Substream("bboxStreamSize"),
                  instructions: new Substream("instructionStreamSize")
                });
                var WORD_CODE = 253;
                var ONE_MORE_BYTE_CODE2 = 254;
                var ONE_MORE_BYTE_CODE1 = 255;
                var LOWEST_U_CODE = 253;
                function read255UInt16(stream) {
                  var code = stream.readUInt8();
                  if (code === WORD_CODE) {
                    return stream.readUInt16BE();
                  }
                  if (code === ONE_MORE_BYTE_CODE1) {
                    return stream.readUInt8() + LOWEST_U_CODE;
                  }
                  if (code === ONE_MORE_BYTE_CODE2) {
                    return stream.readUInt8() + LOWEST_U_CODE * 2;
                  }
                  return code;
                }
                function withSign(flag, baseval) {
                  return flag & 1 ? baseval : -baseval;
                }
                function decodeTriplet(flags, glyphs, nPoints) {
                  var y;
                  var x = y = 0;
                  var res = [];
                  for (var i2 = 0; i2 < nPoints; i2++) {
                    var dx = 0, dy = 0;
                    var flag = flags.readUInt8();
                    var onCurve = !(flag >> 7);
                    flag &= 127;
                    if (flag < 10) {
                      dx = 0;
                      dy = withSign(flag, ((flag & 14) << 7) + glyphs.readUInt8());
                    } else if (flag < 20) {
                      dx = withSign(flag, ((flag - 10 & 14) << 7) + glyphs.readUInt8());
                      dy = 0;
                    } else if (flag < 84) {
                      var b0 = flag - 20;
                      var b1 = glyphs.readUInt8();
                      dx = withSign(flag, 1 + (b0 & 48) + (b1 >> 4));
                      dy = withSign(flag >> 1, 1 + ((b0 & 12) << 2) + (b1 & 15));
                    } else if (flag < 120) {
                      var b0 = flag - 84;
                      dx = withSign(flag, 1 + (b0 / 12 << 8) + glyphs.readUInt8());
                      dy = withSign(flag >> 1, 1 + (b0 % 12 >> 2 << 8) + glyphs.readUInt8());
                    } else if (flag < 124) {
                      var b1 = glyphs.readUInt8();
                      var b2 = glyphs.readUInt8();
                      dx = withSign(flag, (b1 << 4) + (b2 >> 4));
                      dy = withSign(flag >> 1, ((b2 & 15) << 8) + glyphs.readUInt8());
                    } else {
                      dx = withSign(flag, glyphs.readUInt16BE());
                      dy = withSign(flag >> 1, glyphs.readUInt16BE());
                    }
                    x += dx;
                    y += dy;
                    res.push(new Point(onCurve, false, x, y));
                  }
                  return res;
                }
                var TTCHeader = new r.VersionedStruct(r.uint32, {
                  65536: {
                    numFonts: r.uint32,
                    offsets: new r.Array(r.uint32, "numFonts")
                  },
                  131072: {
                    numFonts: r.uint32,
                    offsets: new r.Array(r.uint32, "numFonts"),
                    dsigTag: r.uint32,
                    dsigLength: r.uint32,
                    dsigOffset: r.uint32
                  }
                });
                var TrueTypeCollection = function() {
                  TrueTypeCollection2.probe = function probe(buffer) {
                    return buffer.toString("ascii", 0, 4) === "ttcf";
                  };
                  function TrueTypeCollection2(stream) {
                    this.stream = stream;
                    if (stream.readString(4) !== "ttcf") {
                      throw new Error("Not a TrueType collection");
                    }
                    this.header = TTCHeader.decode(stream);
                  }
                  var _proto48 = TrueTypeCollection2.prototype;
                  _proto48.getFont = function getFont(name) {
                    for (var _iterator79 = _createForOfIteratorHelperLoose(this.header.offsets), _step79; !(_step79 = _iterator79()).done; ) {
                      var offset = _step79.value;
                      var stream = new r.DecodeStream(this.stream.buffer);
                      stream.pos = offset;
                      var font = new TTFFont(stream);
                      if (font.postscriptName === name) {
                        return font;
                      }
                    }
                    return null;
                  };
                  _createClass(TrueTypeCollection2, [{
                    key: "fonts",
                    get: function get() {
                      var fonts = [];
                      for (var _iterator80 = _createForOfIteratorHelperLoose(this.header.offsets), _step80; !(_step80 = _iterator80()).done; ) {
                        var offset = _step80.value;
                        var stream = new r.DecodeStream(this.stream.buffer);
                        stream.pos = offset;
                        fonts.push(new TTFFont(stream));
                      }
                      return fonts;
                    }
                  }]);
                  return TrueTypeCollection2;
                }();
                var DFontName = new r.String(r.uint8);
                var DFontData = new r.Struct({
                  len: r.uint32,
                  buf: new r.Buffer("len")
                });
                var Ref = new r.Struct({
                  id: r.uint16,
                  nameOffset: r.int16,
                  attr: r.uint8,
                  dataOffset: r.uint24,
                  handle: r.uint32
                });
                var Type = new r.Struct({
                  name: new r.String(4),
                  maxTypeIndex: r.uint16,
                  refList: new r.Pointer(r.uint16, new r.Array(Ref, function(t2) {
                    return t2.maxTypeIndex + 1;
                  }), {
                    type: "parent"
                  })
                });
                var TypeList = new r.Struct({
                  length: r.uint16,
                  types: new r.Array(Type, function(t2) {
                    return t2.length + 1;
                  })
                });
                var DFontMap = new r.Struct({
                  reserved: new r.Reserved(r.uint8, 24),
                  typeList: new r.Pointer(r.uint16, TypeList),
                  nameListOffset: new r.Pointer(r.uint16, "void")
                });
                var DFontHeader = new r.Struct({
                  dataOffset: r.uint32,
                  map: new r.Pointer(r.uint32, DFontMap),
                  dataLength: r.uint32,
                  mapLength: r.uint32
                });
                var DFont = function() {
                  DFont2.probe = function probe(buffer) {
                    var stream = new r.DecodeStream(buffer);
                    try {
                      var header = DFontHeader.decode(stream);
                    } catch (e) {
                      return false;
                    }
                    for (var _iterator81 = _createForOfIteratorHelperLoose(header.map.typeList.types), _step81; !(_step81 = _iterator81()).done; ) {
                      var type = _step81.value;
                      if (type.name === "sfnt") {
                        return true;
                      }
                    }
                    return false;
                  };
                  function DFont2(stream) {
                    this.stream = stream;
                    this.header = DFontHeader.decode(this.stream);
                    for (var _iterator82 = _createForOfIteratorHelperLoose(this.header.map.typeList.types), _step82; !(_step82 = _iterator82()).done; ) {
                      var type = _step82.value;
                      for (var _iterator83 = _createForOfIteratorHelperLoose(type.refList), _step83; !(_step83 = _iterator83()).done; ) {
                        var ref = _step83.value;
                        if (ref.nameOffset >= 0) {
                          this.stream.pos = ref.nameOffset + this.header.map.nameListOffset;
                          ref.name = DFontName.decode(this.stream);
                        } else {
                          ref.name = null;
                        }
                      }
                      if (type.name === "sfnt") {
                        this.sfnt = type;
                      }
                    }
                  }
                  var _proto49 = DFont2.prototype;
                  _proto49.getFont = function getFont(name) {
                    if (!this.sfnt) {
                      return null;
                    }
                    for (var _iterator84 = _createForOfIteratorHelperLoose(this.sfnt.refList), _step84; !(_step84 = _iterator84()).done; ) {
                      var ref = _step84.value;
                      var pos = this.header.dataOffset + ref.dataOffset + 4;
                      var stream = new r.DecodeStream(this.stream.buffer.slice(pos));
                      var font = new TTFFont(stream);
                      if (font.postscriptName === name) {
                        return font;
                      }
                    }
                    return null;
                  };
                  _createClass(DFont2, [{
                    key: "fonts",
                    get: function get() {
                      var fonts = [];
                      for (var _iterator85 = _createForOfIteratorHelperLoose(this.sfnt.refList), _step85; !(_step85 = _iterator85()).done; ) {
                        var ref = _step85.value;
                        var pos = this.header.dataOffset + ref.dataOffset + 4;
                        var stream = new r.DecodeStream(this.stream.buffer.slice(pos));
                        fonts.push(new TTFFont(stream));
                      }
                      return fonts;
                    }
                  }]);
                  return DFont2;
                }();
                fontkit.registerFormat(TTFFont);
                fontkit.registerFormat(WOFFFont);
                fontkit.registerFormat(WOFF2Font);
                fontkit.registerFormat(TrueTypeCollection);
                fontkit.registerFormat(DFont);
                module2.exports = fontkit;
              }
            ),
            /***/
            7337: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var UnicodeTrie = __webpack_require__2(4781);
                var base64 = __webpack_require__2(9742);
                var _require = __webpack_require__2(2055), BK = _require.BK, CR = _require.CR, LF = _require.LF, NL = _require.NL, SG = _require.SG, WJ = _require.WJ, SP = _require.SP, ZWJ = _require.ZWJ, BA = _require.BA, HY = _require.HY, NS = _require.NS, AI = _require.AI, AL = _require.AL, CJ = _require.CJ, HL = _require.HL, RI = _require.RI, SA = _require.SA, XX = _require.XX;
                var _require2 = __webpack_require__2(8383), DI_BRK = _require2.DI_BRK, IN_BRK = _require2.IN_BRK, CI_BRK = _require2.CI_BRK, CP_BRK = _require2.CP_BRK, PR_BRK = _require2.PR_BRK, pairTable = _require2.pairTable;
                var data = base64.toByteArray("AAgOAAAAAACA3QAAAe0OEvHtnXuMXUUdx+d2d2/33r237V3YSoFC11r6IGgbRFBEfFF5KCVCMYKFaKn8AYqmwUeqECFabUGQipUiNCkgSRElUkKwJRWtwSpJrZpCI4E2NQqiBsFGwWL8Tu6Md3Z23o9zbund5JM5c+b1m9/85nnOuXtTHyFrwXpwL9gBngTPgj+Dv4H9Ae4B0N9PSAMcDqaB0X57urmIs8AQ72SEnQ4+ABaBxWAJWAquENJ9BtdfANeCleBGcCv4NvgeuBv8AGwCm8FWlpbzOPw7wC7wFNgDngMvgpfAq2DCACF10ACHgaPAzIF2+PFwT2Th1P8OuO8FZ4MPggvAxWAp+A6VHe5ysILFvx7u6oF2+Wvg3g7uYvlT+TbC/TH4CdgCtoGtfW3/E2An8++Gu5eleR7uP8B+8BoLf4LFH6i23Vp1rB5a1Q7TGMeCUYYY18RcxF0gxT8H5b3dIw8X3iPkdxauPwQWgyVgWbVT30/h+mrwZan8r8L/FcEWVsJ/E1grpKXcwdLdI9y/H9cPgUerbbun0PadCHcbjQd+D55mafcx9y9wXwKvCLJUJiLdRH09ef4xupqE/KeCY8Bx4M3gbeBdYCE4G3wYXASWgGXgSibTcuaugHs9WA3WgNvBBha2Ee4D4GFNPTYL9x/D9XaJXwnXvwW7wDPgTzQd2A9eAwODhDTBCJgOZoETwEngtEFmF3DPAouY/0K4Swb9dbaMpbkS7nKP9CsCyrpOSrNK8K9kNnYL7q0DGwbb/XnjoDv3gQfBZvBz8GvwO/AHdr3Pkv4F4fplj3J79OgRBx8HypajR48ePXr06NGjx8HFv7pABhX/HRx7HqKjr9Y+y6PXg7X2WRoPm1Kzpz8CcWaweLPhHt/fPq95C65PZnmfDnchOLfWPo/7OLgQ15ewdJ+E++na2PMhyudw72bDGc01CP8aWAm+Dr4BVoHV4IZeWC+sF9YL64UlD1sD1oE7au0z0zK5p1YuZde/R49uJnYdez/62EPgkVr4c7pHkfYXivTbcW8n2A32gOekOH+F/5/gAOivE9IArXpbrmlwR+vljz9bJrV552RCvgQ2GXgRzJ9CyGVTxofdLd17Gv6jW4RcAG5ote/9FO4B8NZhQs4DN4O9kOFY6OFSsB48C/qGCFkAyERCzh9q+0WuA2sqHX4m+Smv4t6RjXYelItwvQ7sBtOahHwU3NYcn+5Q4pFmRz89evTocajxStM898/FfLSgrg8/sT5+zcLDTkXY+6S0C+E/l907SXO+Rt/Lujrxe1kmztPU70JDvSmXILwJWS9TxLuC3VtuycPGCoV+VfD41yvKW6W4d1O9/S5YtZ+Qtbi+k/m/D/eHYBPzb4G7DfyS+enZ42/qnXPFp+pjZdgD/yX0XcV6+93DF+H+G5AhtcxPIs/BoY5cg0g7RRGXx/8Ewo8Y6vhp/Bnwz2F5zId7CgunZ6Dv1uTF0585pNY7P9NdhPCPDI1Ncyn8l4OrwHKwguVB12WrNPnpoPW5BWluA3eCuxRl3cfyfFCom43NBjkeQ9h2Tzlzs7PL5CmD3UwHew26+KMm7AVHu8hJaL1fTtj29L3E/wi6oPvWvkY7bAjucKOYtpymKWdGo/3e5KxGR8YTGvmfZ4XW46RGmnMIG6excs6Ae46nPuh7pGXbvm/fOB91vLhRXvkmlkKuK8BnFTb8xYL6TyqugbzXJZCZ9tlVrO9+C+53G5134A8G1htsjdbvXoT/KEBPmwq04dS2v6UxNnxbAXV5gul4Z6J+tMtBZtv4+Qzy2Ndof+fwPHP/zsbg/QFz02tIM4B9ZRO0mp379NxxBpgD5gv3T8H16eAMcCZYxMIWw/2YEG8pri9n/qvgfr45fm67VtjPzmbpVrJ7NzL3VrjvF/Jdh+sN3M/cB+A+LOV/bVNdX13b0G9KtmrSHCo8jvqfGjFu7WiWP37E8s2+yv8ZwVbYRgvMAm9kvMkhjStzAZbIBGIR+ngAy2NSZ9f0Hv2bIIShCckU5k5sb+OdGGQ0BKqSPzeE1WFCgWXK5dO2rDD/COn9zTvEUfXJ4zT3c9DP2oH2+ZoAtc9RBr/mY0SLdGyap+Nxh6W0In2Sn5C8/W00c/7dXn63we1DtAHud9WZbFNimmFL2iIoqt8eDPQHptERIkNoO8prFVvblm13OaG6oGM+n7P4/RrRz2HdTktotxHFdZW5tvm72UWEtm9dQF6n++hU1FmVFL++L2Nsdt3/1IVrWaacda4Se91t+pHDVXF5HFd9pG7X14NNyePr6wkfPTRI+H6qDPvLqRM5DR2beZ8W95Divq0IWXXyy/d18Yq09ZhyY/fyPjafY37yta8ybD9l3W15+crXYhQ5rsj2Wkb7iDadon1c+tKI4p5NR6HjPl/vqvLm92uK8lTjWNntkwJTu9hkiJmHVf3S1V5UOii6PWL1nVqOkP5QI/b2L2o+Kqr/h9i0bHNl9HudnKn0btKBbZzItQ7n47Drmutg6P+ubZK7/5va0PU8XZS56DP4Isci07gUo3/fscdlfMyp6xR6dy0vt/275K1bJ8qkHI99bdK3v4vt4Gtzs7sEWa5aZH4NDz3yfWG368bXLlQ6GZYQ7/UL1y3mryroZ+nkZwK28SD1vlt+7sNd+lcR3Ji1RKq1WcvhftFzousYxftH7Ngu2pZubcGfD8eMizp5Y/uha/m69NNK5siSOapkcq2lTOOGvE4y9aPclFl20eXTvwoZO374ymob90Jx3Zfk2h/I849q7VNE+WXsj+ZFlJ96Xcd1PyD4ue2J69/Q9V+u9uPrQC7/sHRftjE+n+eQP2Ztl5Kc+0TX/WND8vP2iF23xO7lfO3XtKfLhUm/PE6Ze78RD/3Fknr8i907yWsoUx+M3S+0SNjcHyu7qg6+aYvqF671TLXfTzU+2uaTnOOzbFc+7yHoZE59npIL175kay/ZxlKMH6a+NSJdl90XKXytpbMpTr/kP5zJfqxQDzneYWTstxh9pPPdYJ/CL8alTBag+fFvHFXtQMutWxBloOUMMHS6GWSyVYS4pvgmexXtVjc/TFWk9ZnnZLt3+caI10/8Xkb+hsYlfeh+QOyPNQN1S7hv2nqivEVSj/Ex+1lu73Ib1olbu4jpfN4ddbWbHN+/mcpWfUem+g7RhK4833SuepHbN0d5PjKF1kUll3xPFc5d+btTW9uqdCHXwaQ7kw252ENIW9vKTdEfTLox+VPYT6r8XXUWq7tYuXyZnEAG+ic+pwyVdRLDp8wcOp0kEZNXzLyqw3f+yEkjMI1sFznk8ulDKcoKlcFVlz75qPyu9+U8YuvnqnfXNDn6t6neNr3xfHj4JEU500ma8SSkjjodptBlTLurbI7rTxUnhcxF6d9W76KRbd6G3DdVNj2qia/qD3KY2O90elLJocpHJc90Q7kqVLqaLlGUjYj+Pg00jD8Xk+Wnf5UAN8c8HGrvXKYi+4irnsoo09ctU29Fll2UraSyaxnTOar8DFw+w60St+cRNlzfm9E9y9CNUTZM5/7iOTWR6imOgaKf/pn6hJw/f8dDdS6u0tNhDN1ZOlGUoauTrqyQNvCd21Mjy8N/T7AixBkQrm3tRKS0tngDwrWYzobuLFwXV3WfP5uR9TGTXdvc3BRVjq18l3rbwmaS8c9QByR4m3Sb/lPVX2V/M4naDkV79GFmJDad2NaLOdpBpxsbvs+/YubgVPO5bn3h+75BahnEOU/EVb+yTL7vQeTQp04GH/twfTYaCv9ehe8XXdZ0Ic+IY94Hcik/9h0Zk35c7MdWXo737HM/y6dllPENj9zeuvq7vMMYam88fZnfU7nOHznf6/AdP+W8ffXv2q6uelDlE1N/Wx+Prb/MG8ARBVJ0eb7rz5Tf6sl5l/G9nizDnJLJudZoaNqU/hbsCPH73dhu+03aWPiZhW9/yLHf8IGvT1OtzwZJ56yG/7YvX5sSdn+yof6x5av2ebxcV1dOZ9pDVgSXys/36uLzG1s5Nvj7pKo9axm2zsueylxeT1lWlQ4rkuuzx5f3+VXPPGIhgbLnKp/rtiJdcz2lOtMpAtMZV27E/kRttyaF83dFbf3NdYwXx6sZpH0uVkZ/VslmOrspa24V1+O56u3TdmXpQdaJy36wLPm4LZVR7jyp/CLOmULtzeWZoqstuLS9rhzTmqwIe3LVia0f2OSP3c/71Ec8V0itv6JtONbOXdb3Oc5YdcTaQVFzRWg7+z6HydnHy+qPoWO+j1yq8anofifWl7ri97chNiq/z6KyM37t8333sJR/SF/3bUvd+z+8nV3KNPWfIvt3mfNZijFAZT8xfXSekLfOtl3rHCuPzxrEdT7U9UvRjn3HKV5/XTuo2i3n+E3L5L+3yN+TkH+z07ZGDlkviuXLcX3aL7b+8m+duhCzJonp/yF9wabPItZhJmJ/N8pVfvn31Fok7PeiYsalFON4bPnyuOO7Ru2G+S52fqB5DAt55bJtXf2LtJdQParCVevHlqcufduvKJuQ5yxxvA/Zw6W0l5D3+nz7a4wdieXxd+FS2SjPN7Z9XXDRp62/dMv4GTM22uwx1/iTe7zTUSfjf1Mqld36EHv2xvPoprMnGfGvIiDHk+/x+EQTP7fMOjl928f0/855OTnaJ5XeQsevVHNojO5147ePXLH681mDqOBhqef/Ivp+7PMF1Vxs02kMITLK30zp/k+FbX1RdP/w1b2OMt9hiR1bKLHfZ+XWT+4+ahqzVM8iUug81r5tfTf3+JB6DPFpk1zllLUu9523cpPLdlR6zTVP+bShGFd1lh/Td33rVdT44WqTtjqktOtc87osc8x5hM9vyLrK49v+Pvmp7De0/vyvLJvk1C3+1OOyLyG/aSSud1L/TlLq/BoZ5M2xNj66IFRlT9fcT4GqDYosQ3df/G0zlR5U4UVzjAJZPpW8NlLI5lOejzwq+eS4rnWZbsjTx7ZUrq4sXdrQPmAa82Pb0HVuyZl3rrrZ7Nal/ULzdy0zBUXrMaQcU18v6ncmxd9eM/1fkdQ24Tvu+paZ2q5S6z13+anlTyVfrv4aWz/desfFfn3WEj727rNGKHJdlqsM1VompjzT+shXv7F75dj3J3K3qY7QM7DcZ2L/Aw==");
                var classTrie = new UnicodeTrie(data);
                var mapClass = function mapClass2(c) {
                  switch (c) {
                    case AI:
                      return AL;
                    case SA:
                    case SG:
                    case XX:
                      return AL;
                    case CJ:
                      return NS;
                    default:
                      return c;
                  }
                };
                var mapFirst = function mapFirst2(c) {
                  switch (c) {
                    case LF:
                    case NL:
                      return BK;
                    case SP:
                      return WJ;
                    default:
                      return c;
                  }
                };
                var Break = function Break2(position, required) {
                  if (required === void 0) {
                    required = false;
                  }
                  this.position = position;
                  this.required = required;
                };
                var LineBreaker = function() {
                  function LineBreaker2(string) {
                    this.string = string;
                    this.pos = 0;
                    this.lastPos = 0;
                    this.curClass = null;
                    this.nextClass = null;
                    this.LB8a = false;
                    this.LB21a = false;
                    this.LB30a = 0;
                  }
                  var _proto = LineBreaker2.prototype;
                  _proto.nextCodePoint = function nextCodePoint() {
                    var code = this.string.charCodeAt(this.pos++);
                    var next = this.string.charCodeAt(this.pos);
                    if (55296 <= code && code <= 56319 && 56320 <= next && next <= 57343) {
                      this.pos++;
                      return (code - 55296) * 1024 + (next - 56320) + 65536;
                    }
                    return code;
                  };
                  _proto.nextCharClass = function nextCharClass() {
                    return mapClass(classTrie.get(this.nextCodePoint()));
                  };
                  _proto.getSimpleBreak = function getSimpleBreak() {
                    switch (this.nextClass) {
                      case SP:
                        return false;
                      case BK:
                      case LF:
                      case NL:
                        this.curClass = BK;
                        return false;
                      case CR:
                        this.curClass = CR;
                        return false;
                    }
                    return null;
                  };
                  _proto.getPairTableBreak = function getPairTableBreak(lastClass) {
                    var shouldBreak = false;
                    switch (pairTable[this.curClass][this.nextClass]) {
                      case DI_BRK:
                        shouldBreak = true;
                        break;
                      case IN_BRK:
                        shouldBreak = lastClass === SP;
                        break;
                      case CI_BRK:
                        shouldBreak = lastClass === SP;
                        if (!shouldBreak) {
                          shouldBreak = false;
                          return shouldBreak;
                        }
                        break;
                      case CP_BRK:
                        if (lastClass !== SP) {
                          return shouldBreak;
                        }
                        break;
                      case PR_BRK:
                        break;
                    }
                    if (this.LB8a) {
                      shouldBreak = false;
                    }
                    if (this.LB21a && (this.curClass === HY || this.curClass === BA)) {
                      shouldBreak = false;
                      this.LB21a = false;
                    } else {
                      this.LB21a = this.curClass === HL;
                    }
                    if (this.curClass === RI) {
                      this.LB30a++;
                      if (this.LB30a == 2 && this.nextClass === RI) {
                        shouldBreak = true;
                        this.LB30a = 0;
                      }
                    } else {
                      this.LB30a = 0;
                    }
                    this.curClass = this.nextClass;
                    return shouldBreak;
                  };
                  _proto.nextBreak = function nextBreak() {
                    if (this.curClass == null) {
                      var firstClass = this.nextCharClass();
                      this.curClass = mapFirst(firstClass);
                      this.nextClass = firstClass;
                      this.LB8a = firstClass === ZWJ;
                      this.LB30a = 0;
                    }
                    while (this.pos < this.string.length) {
                      this.lastPos = this.pos;
                      var lastClass = this.nextClass;
                      this.nextClass = this.nextCharClass();
                      if (this.curClass === BK || this.curClass === CR && this.nextClass !== LF) {
                        this.curClass = mapFirst(mapClass(this.nextClass));
                        return new Break(this.lastPos, true);
                      }
                      var shouldBreak = this.getSimpleBreak();
                      if (shouldBreak === null) {
                        shouldBreak = this.getPairTableBreak(lastClass);
                      }
                      this.LB8a = this.nextClass === ZWJ;
                      if (shouldBreak) {
                        return new Break(this.lastPos);
                      }
                    }
                    if (this.lastPos < this.string.length) {
                      this.lastPos = this.string.length;
                      return new Break(this.string.length);
                    }
                    return null;
                  };
                  return LineBreaker2;
                }();
                module2.exports = LineBreaker;
              }
            ),
            /***/
            4927: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                module2.exports = deprecate;
                function deprecate(fn, msg) {
                  if (config("noDeprecation")) {
                    return fn;
                  }
                  var warned = false;
                  function deprecated() {
                    if (!warned) {
                      if (config("throwDeprecation")) {
                        throw new Error(msg);
                      } else if (config("traceDeprecation")) {
                        console.trace(msg);
                      } else {
                        console.warn(msg);
                      }
                      warned = true;
                    }
                    return fn.apply(this, arguments);
                  }
                  return deprecated;
                }
                function config(name) {
                  try {
                    if (!__webpack_require__2.g.localStorage)
                      return false;
                  } catch (_) {
                    return false;
                  }
                  var val = __webpack_require__2.g.localStorage[name];
                  if (null == val)
                    return false;
                  return String(val).toLowerCase() === "true";
                }
              }
            ),
            /***/
            384: (
              /***/
              function(module2) {
                module2.exports = function isBuffer(arg) {
                  return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
                };
              }
            ),
            /***/
            5955: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var isArgumentsObject = __webpack_require__2(2584);
                var isGeneratorFunction = __webpack_require__2(8662);
                var whichTypedArray = __webpack_require__2(6430);
                var isTypedArray = __webpack_require__2(5692);
                function uncurryThis(f) {
                  return f.call.bind(f);
                }
                var BigIntSupported = typeof BigInt !== "undefined";
                var SymbolSupported = typeof Symbol !== "undefined";
                var ObjectToString = uncurryThis(Object.prototype.toString);
                var numberValue = uncurryThis(Number.prototype.valueOf);
                var stringValue = uncurryThis(String.prototype.valueOf);
                var booleanValue = uncurryThis(Boolean.prototype.valueOf);
                if (BigIntSupported) {
                  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
                }
                if (SymbolSupported) {
                  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
                }
                function checkBoxedPrimitive(value, prototypeValueOf) {
                  if (typeof value !== "object") {
                    return false;
                  }
                  try {
                    prototypeValueOf(value);
                    return true;
                  } catch (e) {
                    return false;
                  }
                }
                exports2.isArgumentsObject = isArgumentsObject;
                exports2.isGeneratorFunction = isGeneratorFunction;
                exports2.isTypedArray = isTypedArray;
                function isPromise(input) {
                  return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
                }
                exports2.isPromise = isPromise;
                function isArrayBufferView(value) {
                  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
                    return ArrayBuffer.isView(value);
                  }
                  return isTypedArray(value) || isDataView(value);
                }
                exports2.isArrayBufferView = isArrayBufferView;
                function isUint8Array(value) {
                  return whichTypedArray(value) === "Uint8Array";
                }
                exports2.isUint8Array = isUint8Array;
                function isUint8ClampedArray(value) {
                  return whichTypedArray(value) === "Uint8ClampedArray";
                }
                exports2.isUint8ClampedArray = isUint8ClampedArray;
                function isUint16Array(value) {
                  return whichTypedArray(value) === "Uint16Array";
                }
                exports2.isUint16Array = isUint16Array;
                function isUint32Array(value) {
                  return whichTypedArray(value) === "Uint32Array";
                }
                exports2.isUint32Array = isUint32Array;
                function isInt8Array(value) {
                  return whichTypedArray(value) === "Int8Array";
                }
                exports2.isInt8Array = isInt8Array;
                function isInt16Array(value) {
                  return whichTypedArray(value) === "Int16Array";
                }
                exports2.isInt16Array = isInt16Array;
                function isInt32Array(value) {
                  return whichTypedArray(value) === "Int32Array";
                }
                exports2.isInt32Array = isInt32Array;
                function isFloat32Array(value) {
                  return whichTypedArray(value) === "Float32Array";
                }
                exports2.isFloat32Array = isFloat32Array;
                function isFloat64Array(value) {
                  return whichTypedArray(value) === "Float64Array";
                }
                exports2.isFloat64Array = isFloat64Array;
                function isBigInt64Array(value) {
                  return whichTypedArray(value) === "BigInt64Array";
                }
                exports2.isBigInt64Array = isBigInt64Array;
                function isBigUint64Array(value) {
                  return whichTypedArray(value) === "BigUint64Array";
                }
                exports2.isBigUint64Array = isBigUint64Array;
                function isMapToString(value) {
                  return ObjectToString(value) === "[object Map]";
                }
                isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
                function isMap(value) {
                  if (typeof Map === "undefined") {
                    return false;
                  }
                  return isMapToString.working ? isMapToString(value) : value instanceof Map;
                }
                exports2.isMap = isMap;
                function isSetToString(value) {
                  return ObjectToString(value) === "[object Set]";
                }
                isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
                function isSet(value) {
                  if (typeof Set === "undefined") {
                    return false;
                  }
                  return isSetToString.working ? isSetToString(value) : value instanceof Set;
                }
                exports2.isSet = isSet;
                function isWeakMapToString(value) {
                  return ObjectToString(value) === "[object WeakMap]";
                }
                isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
                function isWeakMap(value) {
                  if (typeof WeakMap === "undefined") {
                    return false;
                  }
                  return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
                }
                exports2.isWeakMap = isWeakMap;
                function isWeakSetToString(value) {
                  return ObjectToString(value) === "[object WeakSet]";
                }
                isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
                function isWeakSet(value) {
                  return isWeakSetToString(value);
                }
                exports2.isWeakSet = isWeakSet;
                function isArrayBufferToString(value) {
                  return ObjectToString(value) === "[object ArrayBuffer]";
                }
                isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
                function isArrayBuffer(value) {
                  if (typeof ArrayBuffer === "undefined") {
                    return false;
                  }
                  return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
                }
                exports2.isArrayBuffer = isArrayBuffer;
                function isDataViewToString(value) {
                  return ObjectToString(value) === "[object DataView]";
                }
                isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
                function isDataView(value) {
                  if (typeof DataView === "undefined") {
                    return false;
                  }
                  return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
                }
                exports2.isDataView = isDataView;
                var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
                function isSharedArrayBufferToString(value) {
                  return ObjectToString(value) === "[object SharedArrayBuffer]";
                }
                function isSharedArrayBuffer(value) {
                  if (typeof SharedArrayBufferCopy === "undefined") {
                    return false;
                  }
                  if (typeof isSharedArrayBufferToString.working === "undefined") {
                    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
                  }
                  return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
                }
                exports2.isSharedArrayBuffer = isSharedArrayBuffer;
                function isAsyncFunction(value) {
                  return ObjectToString(value) === "[object AsyncFunction]";
                }
                exports2.isAsyncFunction = isAsyncFunction;
                function isMapIterator(value) {
                  return ObjectToString(value) === "[object Map Iterator]";
                }
                exports2.isMapIterator = isMapIterator;
                function isSetIterator(value) {
                  return ObjectToString(value) === "[object Set Iterator]";
                }
                exports2.isSetIterator = isSetIterator;
                function isGeneratorObject(value) {
                  return ObjectToString(value) === "[object Generator]";
                }
                exports2.isGeneratorObject = isGeneratorObject;
                function isWebAssemblyCompiledModule(value) {
                  return ObjectToString(value) === "[object WebAssembly.Module]";
                }
                exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
                function isNumberObject(value) {
                  return checkBoxedPrimitive(value, numberValue);
                }
                exports2.isNumberObject = isNumberObject;
                function isStringObject(value) {
                  return checkBoxedPrimitive(value, stringValue);
                }
                exports2.isStringObject = isStringObject;
                function isBooleanObject(value) {
                  return checkBoxedPrimitive(value, booleanValue);
                }
                exports2.isBooleanObject = isBooleanObject;
                function isBigIntObject(value) {
                  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
                }
                exports2.isBigIntObject = isBigIntObject;
                function isSymbolObject(value) {
                  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
                }
                exports2.isSymbolObject = isSymbolObject;
                function isBoxedPrimitive(value) {
                  return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
                }
                exports2.isBoxedPrimitive = isBoxedPrimitive;
                function isAnyArrayBuffer(value) {
                  return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
                }
                exports2.isAnyArrayBuffer = isAnyArrayBuffer;
                ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
                  Object.defineProperty(exports2, method, {
                    enumerable: false,
                    value: function() {
                      throw new Error(method + " is not supported in userland");
                    }
                  });
                });
              }
            ),
            /***/
            9539: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                var process = __webpack_require__2(4155);
                var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
                  var keys = Object.keys(obj);
                  var descriptors = {};
                  for (var i = 0; i < keys.length; i++) {
                    descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
                  }
                  return descriptors;
                };
                var formatRegExp = /%[sdj%]/g;
                exports2.format = function(f) {
                  if (!isString(f)) {
                    var objects = [];
                    for (var i = 0; i < arguments.length; i++) {
                      objects.push(inspect(arguments[i]));
                    }
                    return objects.join(" ");
                  }
                  var i = 1;
                  var args = arguments;
                  var len = args.length;
                  var str = String(f).replace(formatRegExp, function(x2) {
                    if (x2 === "%%")
                      return "%";
                    if (i >= len)
                      return x2;
                    switch (x2) {
                      case "%s":
                        return String(args[i++]);
                      case "%d":
                        return Number(args[i++]);
                      case "%j":
                        try {
                          return JSON.stringify(args[i++]);
                        } catch (_) {
                          return "[Circular]";
                        }
                      default:
                        return x2;
                    }
                  });
                  for (var x = args[i]; i < len; x = args[++i]) {
                    if (isNull(x) || !isObject(x)) {
                      str += " " + x;
                    } else {
                      str += " " + inspect(x);
                    }
                  }
                  return str;
                };
                exports2.deprecate = function(fn, msg) {
                  if (typeof process !== "undefined" && process.noDeprecation === true) {
                    return fn;
                  }
                  if (typeof process === "undefined") {
                    return function() {
                      return exports2.deprecate(fn, msg).apply(this, arguments);
                    };
                  }
                  var warned = false;
                  function deprecated() {
                    if (!warned) {
                      if (process.throwDeprecation) {
                        throw new Error(msg);
                      } else if (process.traceDeprecation) {
                        console.trace(msg);
                      } else {
                        console.error(msg);
                      }
                      warned = true;
                    }
                    return fn.apply(this, arguments);
                  }
                  return deprecated;
                };
                var debugs = {};
                var debugEnvRegex = /^$/;
                if (process.env.NODE_DEBUG) {
                  var debugEnv = process.env.NODE_DEBUG;
                  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
                  debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
                }
                exports2.debuglog = function(set) {
                  set = set.toUpperCase();
                  if (!debugs[set]) {
                    if (debugEnvRegex.test(set)) {
                      var pid = process.pid;
                      debugs[set] = function() {
                        var msg = exports2.format.apply(exports2, arguments);
                        console.error("%s %d: %s", set, pid, msg);
                      };
                    } else {
                      debugs[set] = function() {
                      };
                    }
                  }
                  return debugs[set];
                };
                function inspect(obj, opts) {
                  var ctx = {
                    seen: [],
                    stylize: stylizeNoColor
                  };
                  if (arguments.length >= 3)
                    ctx.depth = arguments[2];
                  if (arguments.length >= 4)
                    ctx.colors = arguments[3];
                  if (isBoolean(opts)) {
                    ctx.showHidden = opts;
                  } else if (opts) {
                    exports2._extend(ctx, opts);
                  }
                  if (isUndefined(ctx.showHidden))
                    ctx.showHidden = false;
                  if (isUndefined(ctx.depth))
                    ctx.depth = 2;
                  if (isUndefined(ctx.colors))
                    ctx.colors = false;
                  if (isUndefined(ctx.customInspect))
                    ctx.customInspect = true;
                  if (ctx.colors)
                    ctx.stylize = stylizeWithColor;
                  return formatValue(ctx, obj, ctx.depth);
                }
                exports2.inspect = inspect;
                inspect.colors = {
                  "bold": [1, 22],
                  "italic": [3, 23],
                  "underline": [4, 24],
                  "inverse": [7, 27],
                  "white": [37, 39],
                  "grey": [90, 39],
                  "black": [30, 39],
                  "blue": [34, 39],
                  "cyan": [36, 39],
                  "green": [32, 39],
                  "magenta": [35, 39],
                  "red": [31, 39],
                  "yellow": [33, 39]
                };
                inspect.styles = {
                  "special": "cyan",
                  "number": "yellow",
                  "boolean": "yellow",
                  "undefined": "grey",
                  "null": "bold",
                  "string": "green",
                  "date": "magenta",
                  // "name": intentionally not styling
                  "regexp": "red"
                };
                function stylizeWithColor(str, styleType) {
                  var style = inspect.styles[styleType];
                  if (style) {
                    return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
                  } else {
                    return str;
                  }
                }
                function stylizeNoColor(str, styleType) {
                  return str;
                }
                function arrayToHash(array) {
                  var hash = {};
                  array.forEach(function(val, idx) {
                    hash[val] = true;
                  });
                  return hash;
                }
                function formatValue(ctx, value, recurseTimes) {
                  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
                  value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
                  !(value.constructor && value.constructor.prototype === value)) {
                    var ret = value.inspect(recurseTimes, ctx);
                    if (!isString(ret)) {
                      ret = formatValue(ctx, ret, recurseTimes);
                    }
                    return ret;
                  }
                  var primitive = formatPrimitive(ctx, value);
                  if (primitive) {
                    return primitive;
                  }
                  var keys = Object.keys(value);
                  var visibleKeys = arrayToHash(keys);
                  if (ctx.showHidden) {
                    keys = Object.getOwnPropertyNames(value);
                  }
                  if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
                    return formatError(value);
                  }
                  if (keys.length === 0) {
                    if (isFunction(value)) {
                      var name = value.name ? ": " + value.name : "";
                      return ctx.stylize("[Function" + name + "]", "special");
                    }
                    if (isRegExp(value)) {
                      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                    }
                    if (isDate(value)) {
                      return ctx.stylize(Date.prototype.toString.call(value), "date");
                    }
                    if (isError(value)) {
                      return formatError(value);
                    }
                  }
                  var base = "", array = false, braces = ["{", "}"];
                  if (isArray(value)) {
                    array = true;
                    braces = ["[", "]"];
                  }
                  if (isFunction(value)) {
                    var n = value.name ? ": " + value.name : "";
                    base = " [Function" + n + "]";
                  }
                  if (isRegExp(value)) {
                    base = " " + RegExp.prototype.toString.call(value);
                  }
                  if (isDate(value)) {
                    base = " " + Date.prototype.toUTCString.call(value);
                  }
                  if (isError(value)) {
                    base = " " + formatError(value);
                  }
                  if (keys.length === 0 && (!array || value.length == 0)) {
                    return braces[0] + base + braces[1];
                  }
                  if (recurseTimes < 0) {
                    if (isRegExp(value)) {
                      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                    } else {
                      return ctx.stylize("[Object]", "special");
                    }
                  }
                  ctx.seen.push(value);
                  var output;
                  if (array) {
                    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                  } else {
                    output = keys.map(function(key) {
                      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                    });
                  }
                  ctx.seen.pop();
                  return reduceToSingleString(output, base, braces);
                }
                function formatPrimitive(ctx, value) {
                  if (isUndefined(value))
                    return ctx.stylize("undefined", "undefined");
                  if (isString(value)) {
                    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                    return ctx.stylize(simple, "string");
                  }
                  if (isNumber(value))
                    return ctx.stylize("" + value, "number");
                  if (isBoolean(value))
                    return ctx.stylize("" + value, "boolean");
                  if (isNull(value))
                    return ctx.stylize("null", "null");
                }
                function formatError(value) {
                  return "[" + Error.prototype.toString.call(value) + "]";
                }
                function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                  var output = [];
                  for (var i = 0, l = value.length; i < l; ++i) {
                    if (hasOwnProperty(value, String(i))) {
                      output.push(formatProperty(
                        ctx,
                        value,
                        recurseTimes,
                        visibleKeys,
                        String(i),
                        true
                      ));
                    } else {
                      output.push("");
                    }
                  }
                  keys.forEach(function(key) {
                    if (!key.match(/^\d+$/)) {
                      output.push(formatProperty(
                        ctx,
                        value,
                        recurseTimes,
                        visibleKeys,
                        key,
                        true
                      ));
                    }
                  });
                  return output;
                }
                function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                  var name, str, desc;
                  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
                  if (desc.get) {
                    if (desc.set) {
                      str = ctx.stylize("[Getter/Setter]", "special");
                    } else {
                      str = ctx.stylize("[Getter]", "special");
                    }
                  } else {
                    if (desc.set) {
                      str = ctx.stylize("[Setter]", "special");
                    }
                  }
                  if (!hasOwnProperty(visibleKeys, key)) {
                    name = "[" + key + "]";
                  }
                  if (!str) {
                    if (ctx.seen.indexOf(desc.value) < 0) {
                      if (isNull(recurseTimes)) {
                        str = formatValue(ctx, desc.value, null);
                      } else {
                        str = formatValue(ctx, desc.value, recurseTimes - 1);
                      }
                      if (str.indexOf("\n") > -1) {
                        if (array) {
                          str = str.split("\n").map(function(line) {
                            return "  " + line;
                          }).join("\n").slice(2);
                        } else {
                          str = "\n" + str.split("\n").map(function(line) {
                            return "   " + line;
                          }).join("\n");
                        }
                      }
                    } else {
                      str = ctx.stylize("[Circular]", "special");
                    }
                  }
                  if (isUndefined(name)) {
                    if (array && key.match(/^\d+$/)) {
                      return str;
                    }
                    name = JSON.stringify("" + key);
                    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                      name = name.slice(1, -1);
                      name = ctx.stylize(name, "name");
                    } else {
                      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                      name = ctx.stylize(name, "string");
                    }
                  }
                  return name + ": " + str;
                }
                function reduceToSingleString(output, base, braces) {
                  var numLinesEst = 0;
                  var length = output.reduce(function(prev, cur) {
                    numLinesEst++;
                    if (cur.indexOf("\n") >= 0)
                      numLinesEst++;
                    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
                  }, 0);
                  if (length > 60) {
                    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
                  }
                  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
                }
                exports2.types = __webpack_require__2(5955);
                function isArray(ar) {
                  return Array.isArray(ar);
                }
                exports2.isArray = isArray;
                function isBoolean(arg) {
                  return typeof arg === "boolean";
                }
                exports2.isBoolean = isBoolean;
                function isNull(arg) {
                  return arg === null;
                }
                exports2.isNull = isNull;
                function isNullOrUndefined(arg) {
                  return arg == null;
                }
                exports2.isNullOrUndefined = isNullOrUndefined;
                function isNumber(arg) {
                  return typeof arg === "number";
                }
                exports2.isNumber = isNumber;
                function isString(arg) {
                  return typeof arg === "string";
                }
                exports2.isString = isString;
                function isSymbol(arg) {
                  return typeof arg === "symbol";
                }
                exports2.isSymbol = isSymbol;
                function isUndefined(arg) {
                  return arg === void 0;
                }
                exports2.isUndefined = isUndefined;
                function isRegExp(re) {
                  return isObject(re) && objectToString(re) === "[object RegExp]";
                }
                exports2.isRegExp = isRegExp;
                exports2.types.isRegExp = isRegExp;
                function isObject(arg) {
                  return typeof arg === "object" && arg !== null;
                }
                exports2.isObject = isObject;
                function isDate(d) {
                  return isObject(d) && objectToString(d) === "[object Date]";
                }
                exports2.isDate = isDate;
                exports2.types.isDate = isDate;
                function isError(e) {
                  return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
                }
                exports2.isError = isError;
                exports2.types.isNativeError = isError;
                function isFunction(arg) {
                  return typeof arg === "function";
                }
                exports2.isFunction = isFunction;
                function isPrimitive(arg) {
                  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
                  typeof arg === "undefined";
                }
                exports2.isPrimitive = isPrimitive;
                exports2.isBuffer = __webpack_require__2(384);
                function objectToString(o) {
                  return Object.prototype.toString.call(o);
                }
                function pad(n) {
                  return n < 10 ? "0" + n.toString(10) : n.toString(10);
                }
                var months = [
                  "Jan",
                  "Feb",
                  "Mar",
                  "Apr",
                  "May",
                  "Jun",
                  "Jul",
                  "Aug",
                  "Sep",
                  "Oct",
                  "Nov",
                  "Dec"
                ];
                function timestamp() {
                  var d = /* @__PURE__ */ new Date();
                  var time = [
                    pad(d.getHours()),
                    pad(d.getMinutes()),
                    pad(d.getSeconds())
                  ].join(":");
                  return [d.getDate(), months[d.getMonth()], time].join(" ");
                }
                exports2.log = function() {
                  console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
                };
                exports2.inherits = __webpack_require__2(5717);
                exports2._extend = function(origin, add) {
                  if (!add || !isObject(add))
                    return origin;
                  var keys = Object.keys(add);
                  var i = keys.length;
                  while (i--) {
                    origin[keys[i]] = add[keys[i]];
                  }
                  return origin;
                };
                function hasOwnProperty(obj, prop) {
                  return Object.prototype.hasOwnProperty.call(obj, prop);
                }
                var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
                exports2.promisify = function promisify(original) {
                  if (typeof original !== "function")
                    throw new TypeError('The "original" argument must be of type Function');
                  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
                    var fn = original[kCustomPromisifiedSymbol];
                    if (typeof fn !== "function") {
                      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                    }
                    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                      value: fn,
                      enumerable: false,
                      writable: false,
                      configurable: true
                    });
                    return fn;
                  }
                  function fn() {
                    var promiseResolve, promiseReject;
                    var promise = new Promise(function(resolve, reject) {
                      promiseResolve = resolve;
                      promiseReject = reject;
                    });
                    var args = [];
                    for (var i = 0; i < arguments.length; i++) {
                      args.push(arguments[i]);
                    }
                    args.push(function(err, value) {
                      if (err) {
                        promiseReject(err);
                      } else {
                        promiseResolve(value);
                      }
                    });
                    try {
                      original.apply(this, args);
                    } catch (err) {
                      promiseReject(err);
                    }
                    return promise;
                  }
                  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
                  if (kCustomPromisifiedSymbol)
                    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                      value: fn,
                      enumerable: false,
                      writable: false,
                      configurable: true
                    });
                  return Object.defineProperties(
                    fn,
                    getOwnPropertyDescriptors(original)
                  );
                };
                exports2.promisify.custom = kCustomPromisifiedSymbol;
                function callbackifyOnRejected(reason, cb) {
                  if (!reason) {
                    var newReason = new Error("Promise was rejected with a falsy value");
                    newReason.reason = reason;
                    reason = newReason;
                  }
                  return cb(reason);
                }
                function callbackify(original) {
                  if (typeof original !== "function") {
                    throw new TypeError('The "original" argument must be of type Function');
                  }
                  function callbackified() {
                    var args = [];
                    for (var i = 0; i < arguments.length; i++) {
                      args.push(arguments[i]);
                    }
                    var maybeCb = args.pop();
                    if (typeof maybeCb !== "function") {
                      throw new TypeError("The last argument must be of type Function");
                    }
                    var self2 = this;
                    var cb = function() {
                      return maybeCb.apply(self2, arguments);
                    };
                    original.apply(this, args).then(
                      function(ret) {
                        process.nextTick(cb.bind(null, null, ret));
                      },
                      function(rej) {
                        process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
                      }
                    );
                  }
                  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
                  Object.defineProperties(
                    callbackified,
                    getOwnPropertyDescriptors(original)
                  );
                  return callbackified;
                }
                exports2.callbackify = callbackify;
              }
            ),
            /***/
            6430: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var forEach = __webpack_require__2(4029);
                var availableTypedArrays = __webpack_require__2(3083);
                var callBound = __webpack_require__2(1924);
                var gOPD = __webpack_require__2(7296);
                var $toString = callBound("Object.prototype.toString");
                var hasToStringTag = __webpack_require__2(6410)();
                var g = typeof globalThis === "undefined" ? __webpack_require__2.g : globalThis;
                var typedArrays = availableTypedArrays();
                var $slice = callBound("String.prototype.slice");
                var toStrTags = {};
                var getPrototypeOf = Object.getPrototypeOf;
                if (hasToStringTag && gOPD && getPrototypeOf) {
                  forEach(typedArrays, function(typedArray) {
                    if (typeof g[typedArray] === "function") {
                      var arr = new g[typedArray]();
                      if (Symbol.toStringTag in arr) {
                        var proto = getPrototypeOf(arr);
                        var descriptor = gOPD(proto, Symbol.toStringTag);
                        if (!descriptor) {
                          var superProto = getPrototypeOf(proto);
                          descriptor = gOPD(superProto, Symbol.toStringTag);
                        }
                        toStrTags[typedArray] = descriptor.get;
                      }
                    }
                  });
                }
                var tryTypedArrays = function tryAllTypedArrays(value) {
                  var foundName = false;
                  forEach(toStrTags, function(getter, typedArray) {
                    if (!foundName) {
                      try {
                        var name = getter.call(value);
                        if (name === typedArray) {
                          foundName = name;
                        }
                      } catch (e) {
                      }
                    }
                  });
                  return foundName;
                };
                var isTypedArray = __webpack_require__2(5692);
                module2.exports = function whichTypedArray(value) {
                  if (!isTypedArray(value)) {
                    return false;
                  }
                  if (!hasToStringTag || !(Symbol.toStringTag in value)) {
                    return $slice($toString(value), 8, -1);
                  }
                  return tryTypedArrays(value);
                };
              }
            ),
            /***/
            6513: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                module2.exports = __webpack_require__2(5011);
              }
            ),
            /***/
            5011: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                (function() {
                  var sax;
                  if (module2.exports && !__webpack_require__2.g.xmldocAssumeBrowser) {
                    sax = __webpack_require__2(6099);
                  } else {
                    sax = this.sax;
                    if (!sax) {
                      throw new Error(
                        "Expected sax to be defined. Make sure you're including sax.js before this file."
                      );
                    }
                  }
                  function XmlElement(tag) {
                    var parser = delegates[delegates.length - 1].parser;
                    this.name = tag.name;
                    this.attr = tag.attributes;
                    this.val = "";
                    this.children = [];
                    this.firstChild = null;
                    this.lastChild = null;
                    this.line = parser.line;
                    this.column = parser.column;
                    this.position = parser.position;
                    this.startTagPosition = parser.startTagPosition;
                  }
                  XmlElement.prototype._addChild = function(child) {
                    this.children.push(child);
                    if (!this.firstChild)
                      this.firstChild = child;
                    this.lastChild = child;
                  };
                  XmlElement.prototype._opentag = function(tag) {
                    var child = new XmlElement(tag);
                    this._addChild(child);
                    delegates.unshift(child);
                  };
                  XmlElement.prototype._closetag = function() {
                    delegates.shift();
                  };
                  XmlElement.prototype._text = function(text) {
                    if (typeof this.children === "undefined")
                      return;
                    this.val += text;
                    this._addChild(new XmlTextNode(text));
                  };
                  XmlElement.prototype._cdata = function(cdata) {
                    this.val += cdata;
                    this._addChild(new XmlCDataNode(cdata));
                  };
                  XmlElement.prototype._comment = function(comment) {
                    if (typeof this.children === "undefined")
                      return;
                    this._addChild(new XmlCommentNode(comment));
                  };
                  XmlElement.prototype._error = function(err) {
                    throw err;
                  };
                  XmlElement.prototype.eachChild = function(iterator, context) {
                    for (var i = 0, l = this.children.length; i < l; i++)
                      if (this.children[i].type === "element") {
                        if (iterator.call(context, this.children[i], i, this.children) === false)
                          return;
                      }
                  };
                  XmlElement.prototype.childNamed = function(name) {
                    for (var i = 0, l = this.children.length; i < l; i++) {
                      var child = this.children[i];
                      if (child.name === name)
                        return child;
                    }
                    return void 0;
                  };
                  XmlElement.prototype.childrenNamed = function(name) {
                    var matches = [];
                    for (var i = 0, l = this.children.length; i < l; i++)
                      if (this.children[i].name === name)
                        matches.push(this.children[i]);
                    return matches;
                  };
                  XmlElement.prototype.childWithAttribute = function(name, value) {
                    for (var i = 0, l = this.children.length; i < l; i++) {
                      var child = this.children[i];
                      if (child.type === "element" && (value && child.attr[name] === value || !value && child.attr[name]))
                        return child;
                    }
                    return void 0;
                  };
                  XmlElement.prototype.descendantsNamed = function(name) {
                    var matches = [];
                    for (var i = 0, l = this.children.length; i < l; i++) {
                      var child = this.children[i];
                      if (child.type === "element") {
                        if (child.name === name)
                          matches.push(child);
                        matches = matches.concat(child.descendantsNamed(name));
                      }
                    }
                    return matches;
                  };
                  XmlElement.prototype.descendantWithPath = function(path) {
                    var descendant = this;
                    var components = path.split(".");
                    for (var i = 0, l = components.length; i < l; i++)
                      if (descendant && descendant.type === "element")
                        descendant = descendant.childNamed(components[i]);
                      else
                        return void 0;
                    return descendant;
                  };
                  XmlElement.prototype.valueWithPath = function(path) {
                    var components = path.split("@");
                    var descendant = this.descendantWithPath(components[0]);
                    if (descendant)
                      return components.length > 1 ? descendant.attr[components[1]] : descendant.val;
                    else
                      return void 0;
                  };
                  XmlElement.prototype.toString = function(options) {
                    return this.toStringWithIndent("", options);
                  };
                  XmlElement.prototype.toStringWithIndent = function(indent, options) {
                    var s = indent + "<" + this.name;
                    var linebreak = options && options.compressed ? "" : "\n";
                    var preserveWhitespace = options && options.preserveWhitespace;
                    for (var name in this.attr)
                      if (Object.prototype.hasOwnProperty.call(this.attr, name))
                        s += " " + name + '="' + escapeXML(this.attr[name]) + '"';
                    if (this.children.length === 1 && this.children[0].type !== "element") {
                      s += ">" + this.children[0].toString(options) + "</" + this.name + ">";
                    } else if (this.children.length) {
                      s += ">" + linebreak;
                      var childIndent = indent + (options && options.compressed ? "" : "  ");
                      for (var i = 0, l = this.children.length; i < l; i++) {
                        s += this.children[i].toStringWithIndent(childIndent, options) + linebreak;
                      }
                      s += indent + "</" + this.name + ">";
                    } else if (options && options.html) {
                      var whiteList = [
                        "area",
                        "base",
                        "br",
                        "col",
                        "embed",
                        "frame",
                        "hr",
                        "img",
                        "input",
                        "keygen",
                        "link",
                        "menuitem",
                        "meta",
                        "param",
                        "source",
                        "track",
                        "wbr"
                      ];
                      if (whiteList.indexOf(this.name) !== -1)
                        s += "/>";
                      else
                        s += "></" + this.name + ">";
                    } else {
                      s += "/>";
                    }
                    return s;
                  };
                  function XmlTextNode(text) {
                    this.text = text;
                  }
                  XmlTextNode.prototype.toString = function(options) {
                    return formatText(escapeXML(this.text), options);
                  };
                  XmlTextNode.prototype.toStringWithIndent = function(indent, options) {
                    return indent + this.toString(options);
                  };
                  function XmlCDataNode(cdata) {
                    this.cdata = cdata;
                  }
                  XmlCDataNode.prototype.toString = function(options) {
                    return "<![CDATA[" + formatText(this.cdata, options) + "]]>";
                  };
                  XmlCDataNode.prototype.toStringWithIndent = function(indent, options) {
                    return indent + this.toString(options);
                  };
                  function XmlCommentNode(comment) {
                    this.comment = comment;
                  }
                  XmlCommentNode.prototype.toString = function(options) {
                    return "<!--" + formatText(escapeXML(this.comment), options) + "-->";
                  };
                  XmlCommentNode.prototype.toStringWithIndent = function(indent, options) {
                    return indent + this.toString(options);
                  };
                  XmlElement.prototype.type = "element";
                  XmlTextNode.prototype.type = "text";
                  XmlCDataNode.prototype.type = "cdata";
                  XmlCommentNode.prototype.type = "comment";
                  function XmlDocument(xml) {
                    xml && (xml = xml.toString().trim());
                    if (!xml)
                      throw new Error("No XML to parse!");
                    this.doctype = "";
                    this.parser = sax.parser(true);
                    addParserEvents(this.parser);
                    delegates = [this];
                    this.parser.write(xml);
                    delete this.parser;
                  }
                  extend(XmlDocument.prototype, XmlElement.prototype);
                  XmlDocument.prototype._opentag = function(tag) {
                    if (typeof this.children === "undefined")
                      XmlElement.call(this, tag);
                    else
                      XmlElement.prototype._opentag.apply(this, arguments);
                  };
                  XmlDocument.prototype._doctype = function(doctype) {
                    this.doctype += doctype;
                  };
                  var delegates = null;
                  function addParserEvents(parser) {
                    parser.onopentag = parser_opentag;
                    parser.onclosetag = parser_closetag;
                    parser.ontext = parser_text;
                    parser.oncdata = parser_cdata;
                    parser.oncomment = parser_comment;
                    parser.ondoctype = parser_doctype;
                    parser.onerror = parser_error;
                  }
                  function parser_opentag() {
                    delegates[0] && delegates[0]._opentag.apply(delegates[0], arguments);
                  }
                  function parser_closetag() {
                    delegates[0] && delegates[0]._closetag.apply(delegates[0], arguments);
                  }
                  function parser_text() {
                    delegates[0] && delegates[0]._text.apply(delegates[0], arguments);
                  }
                  function parser_cdata() {
                    delegates[0] && delegates[0]._cdata.apply(delegates[0], arguments);
                  }
                  function parser_comment() {
                    delegates[0] && delegates[0]._comment.apply(delegates[0], arguments);
                  }
                  function parser_doctype() {
                    delegates[0] && delegates[0]._doctype.apply(delegates[0], arguments);
                  }
                  function parser_error() {
                    delegates[0] && delegates[0]._error.apply(delegates[0], arguments);
                  }
                  function extend(destination, source) {
                    for (var prop in source)
                      if (source.hasOwnProperty(prop))
                        destination[prop] = source[prop];
                  }
                  function escapeXML(value) {
                    return value.toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&apos;").replace(/"/g, "&quot;");
                  }
                  function formatText(text, options) {
                    var finalText = text;
                    if (options && options.trimmed && text.length > 25) {
                      finalText = finalText.substring(0, 25).trim() + "";
                    }
                    if (!(options && options.preserveWhitespace)) {
                      finalText = finalText.trim();
                    }
                    return finalText;
                  }
                  if (module2.exports && !__webpack_require__2.g.xmldocAssumeBrowser) {
                    module2.exports.XmlDocument = XmlDocument;
                    module2.exports.XmlElement = XmlElement;
                    module2.exports.XmlTextNode = XmlTextNode;
                    module2.exports.XmlCDataNode = XmlCDataNode;
                    module2.exports.XmlCommentNode = XmlCommentNode;
                  } else {
                    this.XmlDocument = XmlDocument;
                    this.XmlElement = XmlElement;
                    this.XmlTextNode = XmlTextNode;
                    this.XmlCDataNode = XmlCDataNode;
                    this.XmlCommentNode = XmlCommentNode;
                  }
                })();
              }
            ),
            /***/
            6255: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                if (typeof window !== "undefined" && !window.Promise) {
                  __webpack_require__2(3867);
                }
                __webpack_require__2(4667);
                var fetchUrl = function(url, headers) {
                  return new Promise(function(resolve, reject) {
                    var xhr = new XMLHttpRequest();
                    xhr.open("GET", url, true);
                    for (var headerName in headers) {
                      xhr.setRequestHeader(headerName, headers[headerName]);
                    }
                    xhr.responseType = "arraybuffer";
                    xhr.onreadystatechange = function() {
                      if (xhr.readyState !== 4) {
                        return;
                      }
                      var ok = xhr.status >= 200 && xhr.status < 300;
                      if (!ok) {
                        setTimeout(function() {
                          reject(new TypeError('Failed to fetch (url: "' + url + '")'));
                        }, 0);
                      }
                    };
                    xhr.onload = function() {
                      var ok = xhr.status >= 200 && xhr.status < 300;
                      if (ok) {
                        resolve(xhr.response);
                      }
                    };
                    xhr.onerror = function() {
                      setTimeout(function() {
                        reject(new TypeError('Network request failed (url: "' + url + '")'));
                      }, 0);
                    };
                    xhr.ontimeout = function() {
                      setTimeout(function() {
                        reject(new TypeError('Network request failed (url: "' + url + '")'));
                      }, 0);
                    };
                    xhr.send();
                  });
                };
                function URLBrowserResolver(fs) {
                  this.fs = fs;
                  this.resolving = {};
                }
                URLBrowserResolver.prototype.resolve = function(url, headers) {
                  if (!this.resolving[url]) {
                    var _this = this;
                    this.resolving[url] = new Promise(function(resolve, reject) {
                      if (url.toLowerCase().indexOf("https://") === 0 || url.toLowerCase().indexOf("http://") === 0) {
                        if (_this.fs.existsSync(url)) {
                          resolve();
                        } else {
                          fetchUrl(url, headers).then(function(buffer) {
                            _this.fs.writeFileSync(url, buffer);
                            resolve();
                          }, function(result) {
                            reject(result);
                          });
                        }
                      } else {
                        resolve();
                      }
                    });
                  }
                  return this.resolving[url];
                };
                URLBrowserResolver.prototype.resolved = function() {
                  var _this = this;
                  return new Promise(function(resolve, reject) {
                    Promise.all(Object.values(_this.resolving)).then(function() {
                      resolve();
                    }, function(result) {
                      reject(result);
                    });
                  });
                };
                module2.exports = URLBrowserResolver;
              }
            ),
            /***/
            4275: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var Buffer = __webpack_require__2(8823)["Buffer"];
                var isFunction = __webpack_require__2(6225).isFunction;
                var isUndefined = __webpack_require__2(6225).isUndefined;
                var isNull = __webpack_require__2(6225).isNull;
                var FileSaver = __webpack_require__2(2984);
                var saveAs = FileSaver.saveAs;
                var defaultClientFonts = {
                  Roboto: {
                    normal: "Roboto-Regular.ttf",
                    bold: "Roboto-Medium.ttf",
                    italics: "Roboto-Italic.ttf",
                    bolditalics: "Roboto-MediumItalic.ttf"
                  }
                };
                function Document(docDefinition, tableLayouts, fonts, vfs) {
                  this.docDefinition = docDefinition;
                  this.tableLayouts = tableLayouts || null;
                  this.fonts = fonts || defaultClientFonts;
                  this.vfs = vfs;
                }
                function canCreatePdf() {
                  try {
                    var arr = new Uint8Array(1);
                    var proto = { foo: function() {
                      return 42;
                    } };
                    Object.setPrototypeOf(proto, Uint8Array.prototype);
                    Object.setPrototypeOf(arr, proto);
                    return arr.foo() === 42;
                  } catch (e) {
                    return false;
                  }
                }
                Document.prototype._createDoc = function(options, cb) {
                  var getExtendedUrl = function(url2) {
                    if (typeof url2 === "object") {
                      return { url: url2.url, headers: url2.headers };
                    }
                    return { url: url2, headers: {} };
                  };
                  options = options || {};
                  if (this.tableLayouts) {
                    options.tableLayouts = this.tableLayouts;
                  }
                  var PdfPrinter = __webpack_require__2(8617);
                  var printer = new PdfPrinter(this.fonts);
                  __webpack_require__2(3857).bindFS(this.vfs);
                  if (!isFunction(cb)) {
                    var doc = printer.createPdfKitDocument(this.docDefinition, options);
                    return doc;
                  }
                  var URLBrowserResolver = __webpack_require__2(6255);
                  var urlResolver = new URLBrowserResolver(__webpack_require__2(3857));
                  for (var font in this.fonts) {
                    if (this.fonts.hasOwnProperty(font)) {
                      if (this.fonts[font].normal) {
                        if (Array.isArray(this.fonts[font].normal)) {
                          var url = getExtendedUrl(this.fonts[font].normal[0]);
                          urlResolver.resolve(url.url, url.headers);
                          this.fonts[font].normal[0] = url.url;
                        } else {
                          var url = getExtendedUrl(this.fonts[font].normal);
                          urlResolver.resolve(url.url, url.headers);
                          this.fonts[font].normal = url.url;
                        }
                      }
                      if (this.fonts[font].bold) {
                        if (Array.isArray(this.fonts[font].bold)) {
                          var url = getExtendedUrl(this.fonts[font].bold[0]);
                          urlResolver.resolve(url.url, url.headers);
                          this.fonts[font].bold[0] = url.url;
                        } else {
                          var url = getExtendedUrl(this.fonts[font].bold);
                          urlResolver.resolve(url.url, url.headers);
                          this.fonts[font].bold = url.url;
                        }
                      }
                      if (this.fonts[font].italics) {
                        if (Array.isArray(this.fonts[font].italics)) {
                          var url = getExtendedUrl(this.fonts[font].italics[0]);
                          urlResolver.resolve(url.url, url.headers);
                          this.fonts[font].italics[0] = url.url;
                        } else {
                          var url = getExtendedUrl(this.fonts[font].italics);
                          urlResolver.resolve(url.url, url.headers);
                          this.fonts[font].italics = url.url;
                        }
                      }
                      if (this.fonts[font].bolditalics) {
                        if (Array.isArray(this.fonts[font].bolditalics)) {
                          var url = getExtendedUrl(this.fonts[font].bolditalics[0]);
                          urlResolver.resolve(url.url, url.headers);
                          this.fonts[font].bolditalics[0] = url.url;
                        } else {
                          var url = getExtendedUrl(this.fonts[font].bolditalics);
                          urlResolver.resolve(url.url, url.headers);
                          this.fonts[font].bolditalics = url.url;
                        }
                      }
                    }
                  }
                  if (this.docDefinition.images) {
                    for (var image in this.docDefinition.images) {
                      if (this.docDefinition.images.hasOwnProperty(image)) {
                        var url = getExtendedUrl(this.docDefinition.images[image]);
                        urlResolver.resolve(url.url, url.headers);
                        this.docDefinition.images[image] = url.url;
                      }
                    }
                  }
                  var _this = this;
                  urlResolver.resolved().then(function() {
                    var doc2 = printer.createPdfKitDocument(_this.docDefinition, options);
                    cb(doc2);
                  }, function(result) {
                    throw result;
                  });
                };
                Document.prototype._flushDoc = function(doc, callback) {
                  var chunks = [];
                  var result;
                  doc.on("readable", function() {
                    var chunk;
                    while ((chunk = doc.read(9007199254740991)) !== null) {
                      chunks.push(chunk);
                    }
                  });
                  doc.on("end", function() {
                    result = Buffer.concat(chunks);
                    callback(result, doc._pdfMakePages);
                  });
                  doc.end();
                };
                Document.prototype._getPages = function(options, cb) {
                  if (!cb) {
                    throw "_getPages is an async method and needs a callback argument";
                  }
                  var _this = this;
                  this._createDoc(options, function(doc) {
                    _this._flushDoc(doc, function(ignoreBuffer, pages) {
                      cb(pages);
                    });
                  });
                };
                Document.prototype._bufferToBlob = function(buffer) {
                  var blob;
                  try {
                    blob = new Blob([buffer], { type: "application/pdf" });
                  } catch (e) {
                    if (e.name === "InvalidStateError") {
                      var byteArray = new Uint8Array(buffer);
                      blob = new Blob([byteArray.buffer], { type: "application/pdf" });
                    }
                  }
                  if (!blob) {
                    throw "Could not generate blob";
                  }
                  return blob;
                };
                Document.prototype._openWindow = function() {
                  var win = window.open("", "_blank");
                  if (win === null) {
                    throw "Open PDF in new window blocked by browser";
                  }
                  return win;
                };
                Document.prototype._openPdf = function(options, win) {
                  if (!win) {
                    win = this._openWindow();
                  }
                  try {
                    this.getBlob(function(result) {
                      var urlCreator = window.URL || window.webkitURL;
                      var pdfUrl = urlCreator.createObjectURL(result);
                      win.location.href = pdfUrl;
                    }, options);
                  } catch (e) {
                    win.close();
                    throw e;
                  }
                };
                Document.prototype.open = function(options, win) {
                  options = options || {};
                  options.autoPrint = false;
                  win = win || null;
                  this._openPdf(options, win);
                };
                Document.prototype.print = function(options, win) {
                  options = options || {};
                  options.autoPrint = true;
                  win = win || null;
                  this._openPdf(options, win);
                };
                Document.prototype.download = function(defaultFileName, cb, options) {
                  if (isFunction(defaultFileName)) {
                    if (!isUndefined(cb)) {
                      options = cb;
                    }
                    cb = defaultFileName;
                    defaultFileName = null;
                  }
                  defaultFileName = defaultFileName || "file.pdf";
                  this.getBlob(function(result) {
                    saveAs(result, defaultFileName);
                    if (isFunction(cb)) {
                      cb();
                    }
                  }, options);
                };
                Document.prototype.getBase64 = function(cb, options) {
                  if (!cb) {
                    throw "getBase64 is an async method and needs a callback argument";
                  }
                  this.getBuffer(function(buffer) {
                    cb(buffer.toString("base64"));
                  }, options);
                };
                Document.prototype.getDataUrl = function(cb, options) {
                  if (!cb) {
                    throw "getDataUrl is an async method and needs a callback argument";
                  }
                  this.getBuffer(function(buffer) {
                    cb("data:application/pdf;base64," + buffer.toString("base64"));
                  }, options);
                };
                Document.prototype.getBlob = function(cb, options) {
                  if (!cb) {
                    throw "getBlob is an async method and needs a callback argument";
                  }
                  var that = this;
                  this.getBuffer(function(result) {
                    var blob = that._bufferToBlob(result);
                    cb(blob);
                  }, options);
                };
                Document.prototype.getBuffer = function(cb, options) {
                  if (!cb) {
                    throw "getBuffer is an async method and needs a callback argument";
                  }
                  var _this = this;
                  this._createDoc(options, function(doc) {
                    _this._flushDoc(doc, function(buffer) {
                      cb(buffer);
                    });
                  });
                };
                Document.prototype.getStream = function(options, cb) {
                  if (!isFunction(cb)) {
                    var doc = this._createDoc(options);
                    return doc;
                  }
                  this._createDoc(options, function(doc2) {
                    cb(doc2);
                  });
                };
                module2.exports = {
                  createPdf: function(docDefinition, tableLayouts, fonts, vfs) {
                    if (!canCreatePdf()) {
                      throw "Your browser does not provide the level of support needed";
                    }
                    return new Document(
                      docDefinition,
                      tableLayouts || __webpack_require__2.g.pdfMake.tableLayouts,
                      fonts || __webpack_require__2.g.pdfMake.fonts,
                      vfs || __webpack_require__2.g.pdfMake.vfs
                    );
                  }
                };
              }
            ),
            /***/
            3857: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var __dirname = "/";
                var Buffer = __webpack_require__2(8823)["Buffer"];
                function VirtualFileSystem() {
                  this.fileSystem = {};
                  this.dataSystem = {};
                }
                VirtualFileSystem.prototype.existsSync = function(filename) {
                  filename = fixFilename(filename);
                  return typeof this.fileSystem[filename] !== "undefined" || typeof this.dataSystem[filename] !== "undefined";
                };
                VirtualFileSystem.prototype.readFileSync = function(filename, options) {
                  filename = fixFilename(filename);
                  var dataContent = this.dataSystem[filename];
                  if (typeof dataContent === "string" && options === "utf8") {
                    return dataContent;
                  }
                  if (dataContent) {
                    return new Buffer(dataContent, typeof dataContent === "string" ? "base64" : void 0);
                  }
                  var content = this.fileSystem[filename];
                  if (content) {
                    return content;
                  }
                  throw "File '" + filename + "' not found in virtual file system";
                };
                VirtualFileSystem.prototype.writeFileSync = function(filename, content) {
                  this.fileSystem[fixFilename(filename)] = content;
                };
                VirtualFileSystem.prototype.bindFS = function(data) {
                  this.dataSystem = data || {};
                };
                function fixFilename(filename) {
                  if (filename.indexOf(__dirname) === 0) {
                    filename = filename.substring(__dirname.length);
                  }
                  if (filename.indexOf("/") === 0) {
                    filename = filename.substring(1);
                  }
                  return filename;
                }
                module2.exports = new VirtualFileSystem();
              }
            ),
            /***/
            4498: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isString = __webpack_require__2(6225).isString;
                function buildColumnWidths(columns, availableWidth) {
                  var autoColumns = [], autoMin = 0, autoMax = 0, starColumns = [], starMaxMin = 0, starMaxMax = 0, fixedColumns = [], initial_availableWidth = availableWidth;
                  columns.forEach(function(column) {
                    if (isAutoColumn(column)) {
                      autoColumns.push(column);
                      autoMin += column._minWidth;
                      autoMax += column._maxWidth;
                    } else if (isStarColumn(column)) {
                      starColumns.push(column);
                      starMaxMin = Math.max(starMaxMin, column._minWidth);
                      starMaxMax = Math.max(starMaxMax, column._maxWidth);
                    } else {
                      fixedColumns.push(column);
                    }
                  });
                  fixedColumns.forEach(function(col) {
                    if (isString(col.width) && /\d+%/.test(col.width)) {
                      col.width = parseFloat(col.width) * initial_availableWidth / 100;
                    }
                    if (col.width < col._minWidth && col.elasticWidth) {
                      col._calcWidth = col._minWidth;
                    } else {
                      col._calcWidth = col.width;
                    }
                    availableWidth -= col._calcWidth;
                  });
                  var minW = autoMin + starMaxMin * starColumns.length;
                  var maxW = autoMax + starMaxMax * starColumns.length;
                  if (minW >= availableWidth) {
                    autoColumns.forEach(function(col) {
                      col._calcWidth = col._minWidth;
                    });
                    starColumns.forEach(function(col) {
                      col._calcWidth = starMaxMin;
                    });
                  } else {
                    if (maxW < availableWidth) {
                      autoColumns.forEach(function(col) {
                        col._calcWidth = col._maxWidth;
                        availableWidth -= col._calcWidth;
                      });
                    } else {
                      var W = availableWidth - minW;
                      var D = maxW - minW;
                      autoColumns.forEach(function(col) {
                        var d = col._maxWidth - col._minWidth;
                        col._calcWidth = col._minWidth + d * W / D;
                        availableWidth -= col._calcWidth;
                      });
                    }
                    if (starColumns.length > 0) {
                      var starSize = availableWidth / starColumns.length;
                      starColumns.forEach(function(col) {
                        col._calcWidth = starSize;
                      });
                    }
                  }
                }
                function isAutoColumn(column) {
                  return column.width === "auto";
                }
                function isStarColumn(column) {
                  return column.width === null || column.width === void 0 || column.width === "*" || column.width === "star";
                }
                function measureMinMax(columns) {
                  var result = { min: 0, max: 0 };
                  var maxStar = { min: 0, max: 0 };
                  var starCount = 0;
                  for (var i = 0, l = columns.length; i < l; i++) {
                    var c = columns[i];
                    if (isStarColumn(c)) {
                      maxStar.min = Math.max(maxStar.min, c._minWidth);
                      maxStar.max = Math.max(maxStar.max, c._maxWidth);
                      starCount++;
                    } else if (isAutoColumn(c)) {
                      result.min += c._minWidth;
                      result.max += c._maxWidth;
                    } else {
                      result.min += c.width !== void 0 && c.width || c._minWidth;
                      result.max += c.width !== void 0 && c.width || c._maxWidth;
                    }
                  }
                  if (starCount) {
                    result.min += starCount * maxStar.min;
                    result.max += starCount * maxStar.max;
                  }
                  return result;
                }
                module2.exports = {
                  buildColumnWidths,
                  measureMinMax,
                  isAutoColumn,
                  isStarColumn
                };
              }
            ),
            /***/
            1728: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var TextTools = __webpack_require__2(1350);
                var StyleContextStack = __webpack_require__2(7597);
                var ColumnCalculator = __webpack_require__2(4498);
                var isString = __webpack_require__2(6225).isString;
                var isNumber = __webpack_require__2(6225).isNumber;
                var isObject = __webpack_require__2(6225).isObject;
                var isArray = __webpack_require__2(6225).isArray;
                var fontStringify = __webpack_require__2(6225).fontStringify;
                var getNodeId = __webpack_require__2(6225).getNodeId;
                var pack = __webpack_require__2(6225).pack;
                var qrEncoder = __webpack_require__2(145);
                function DocMeasure(fontProvider, styleDictionary, defaultStyle, imageMeasure, svgMeasure, tableLayouts, images) {
                  this.textTools = new TextTools(fontProvider);
                  this.styleStack = new StyleContextStack(styleDictionary, defaultStyle);
                  this.imageMeasure = imageMeasure;
                  this.svgMeasure = svgMeasure;
                  this.tableLayouts = tableLayouts;
                  this.images = images;
                  this.autoImageIndex = 1;
                }
                DocMeasure.prototype.measureDocument = function(docStructure) {
                  return this.measureNode(docStructure);
                };
                DocMeasure.prototype.measureNode = function(node) {
                  var self2 = this;
                  return this.styleStack.auto(node, function() {
                    node._margin = getNodeMargin(node);
                    if (node.columns) {
                      return extendMargins(self2.measureColumns(node));
                    } else if (node.stack) {
                      return extendMargins(self2.measureVerticalContainer(node));
                    } else if (node.ul) {
                      return extendMargins(self2.measureUnorderedList(node));
                    } else if (node.ol) {
                      return extendMargins(self2.measureOrderedList(node));
                    } else if (node.table) {
                      return extendMargins(self2.measureTable(node));
                    } else if (node.text !== void 0) {
                      return extendMargins(self2.measureLeaf(node));
                    } else if (node.toc) {
                      return extendMargins(self2.measureToc(node));
                    } else if (node.image) {
                      return extendMargins(self2.measureImage(node));
                    } else if (node.svg) {
                      return extendMargins(self2.measureSVG(node));
                    } else if (node.canvas) {
                      return extendMargins(self2.measureCanvas(node));
                    } else if (node.qr) {
                      return extendMargins(self2.measureQr(node));
                    } else {
                      throw "Unrecognized document structure: " + JSON.stringify(node, fontStringify);
                    }
                  });
                  function extendMargins(node2) {
                    var margin = node2._margin;
                    if (margin) {
                      node2._minWidth += margin[0] + margin[2];
                      node2._maxWidth += margin[0] + margin[2];
                    }
                    return node2;
                  }
                  function getNodeMargin() {
                    function processSingleMargins(node2, currentMargin) {
                      if (node2.marginLeft || node2.marginTop || node2.marginRight || node2.marginBottom) {
                        return [
                          node2.marginLeft || currentMargin[0] || 0,
                          node2.marginTop || currentMargin[1] || 0,
                          node2.marginRight || currentMargin[2] || 0,
                          node2.marginBottom || currentMargin[3] || 0
                        ];
                      }
                      return currentMargin;
                    }
                    function flattenStyleArray(styleArray2) {
                      var flattenedStyles = {};
                      for (var i = styleArray2.length - 1; i >= 0; i--) {
                        var styleName = styleArray2[i];
                        var style = self2.styleStack.styleDictionary[styleName];
                        for (var key in style) {
                          if (style.hasOwnProperty(key)) {
                            flattenedStyles[key] = style[key];
                          }
                        }
                      }
                      return flattenedStyles;
                    }
                    function convertMargin(margin2) {
                      if (isNumber(margin2)) {
                        margin2 = [margin2, margin2, margin2, margin2];
                      } else if (isArray(margin2)) {
                        if (margin2.length === 2) {
                          margin2 = [margin2[0], margin2[1], margin2[0], margin2[1]];
                        }
                      }
                      return margin2;
                    }
                    var margin = [void 0, void 0, void 0, void 0];
                    if (node.style) {
                      var styleArray = isArray(node.style) ? node.style : [node.style];
                      var flattenedStyleArray = flattenStyleArray(styleArray);
                      if (flattenedStyleArray) {
                        margin = processSingleMargins(flattenedStyleArray, margin);
                      }
                      if (flattenedStyleArray.margin) {
                        margin = convertMargin(flattenedStyleArray.margin);
                      }
                    }
                    margin = processSingleMargins(node, margin);
                    if (node.margin) {
                      margin = convertMargin(node.margin);
                    }
                    if (margin[0] === void 0 && margin[1] === void 0 && margin[2] === void 0 && margin[3] === void 0) {
                      return null;
                    } else {
                      return margin;
                    }
                  }
                };
                DocMeasure.prototype.convertIfBase64Image = function(node) {
                  if (/^data:image\/(jpeg|jpg|png);base64,/.test(node.image)) {
                    var label = "$$pdfmake$$" + this.autoImageIndex++;
                    this.images[label] = node.image;
                    node.image = label;
                  }
                };
                DocMeasure.prototype.measureImageWithDimensions = function(node, dimensions) {
                  if (node.fit) {
                    var factor = dimensions.width / dimensions.height > node.fit[0] / node.fit[1] ? node.fit[0] / dimensions.width : node.fit[1] / dimensions.height;
                    node._width = node._minWidth = node._maxWidth = dimensions.width * factor;
                    node._height = dimensions.height * factor;
                  } else {
                    node._width = node._minWidth = node._maxWidth = node.width || dimensions.width;
                    node._height = node.height || dimensions.height * node._width / dimensions.width;
                    if (isNumber(node.maxWidth) && node.maxWidth < node._width) {
                      node._width = node._minWidth = node._maxWidth = node.maxWidth;
                      node._height = node._width * dimensions.height / dimensions.width;
                    }
                    if (isNumber(node.maxHeight) && node.maxHeight < node._height) {
                      node._height = node.maxHeight;
                      node._width = node._minWidth = node._maxWidth = node._height * dimensions.width / dimensions.height;
                    }
                    if (isNumber(node.minWidth) && node.minWidth > node._width) {
                      node._width = node._minWidth = node._maxWidth = node.minWidth;
                      node._height = node._width * dimensions.height / dimensions.width;
                    }
                    if (isNumber(node.minHeight) && node.minHeight > node._height) {
                      node._height = node.minHeight;
                      node._width = node._minWidth = node._maxWidth = node._height * dimensions.width / dimensions.height;
                    }
                  }
                  node._alignment = this.styleStack.getProperty("alignment");
                };
                DocMeasure.prototype.measureImage = function(node) {
                  if (this.images) {
                    this.convertIfBase64Image(node);
                  }
                  var dimensions = this.imageMeasure.measureImage(node.image);
                  this.measureImageWithDimensions(node, dimensions);
                  return node;
                };
                DocMeasure.prototype.measureSVG = function(node) {
                  var dimensions = this.svgMeasure.measureSVG(node.svg);
                  this.measureImageWithDimensions(node, dimensions);
                  node.font = this.styleStack.getProperty("font");
                  node.svg = this.svgMeasure.writeDimensions(node.svg, {
                    width: node._width,
                    height: node._height
                  });
                  return node;
                };
                DocMeasure.prototype.measureLeaf = function(node) {
                  if (node._textRef && node._textRef._textNodeRef.text) {
                    node.text = node._textRef._textNodeRef.text;
                  }
                  var styleStack = this.styleStack.clone();
                  styleStack.push(node);
                  var data = this.textTools.buildInlines(node.text, styleStack);
                  node._inlines = data.items;
                  node._minWidth = data.minWidth;
                  node._maxWidth = data.maxWidth;
                  return node;
                };
                DocMeasure.prototype.measureToc = function(node) {
                  if (node.toc.title) {
                    node.toc.title = this.measureNode(node.toc.title);
                  }
                  if (node.toc._items.length > 0) {
                    var body = [];
                    var textStyle = node.toc.textStyle || {};
                    var numberStyle = node.toc.numberStyle || textStyle;
                    var textMargin = node.toc.textMargin || [0, 0, 0, 0];
                    for (var i = 0, l = node.toc._items.length; i < l; i++) {
                      var item = node.toc._items[i];
                      var lineStyle = item._textNodeRef.tocStyle || textStyle;
                      var lineMargin = item._textNodeRef.tocMargin || textMargin;
                      var lineNumberStyle = item._textNodeRef.tocNumberStyle || numberStyle;
                      var destination = getNodeId(item._nodeRef);
                      body.push([
                        { text: item._textNodeRef.text, linkToDestination: destination, alignment: "left", style: lineStyle, margin: lineMargin },
                        { text: "00000", linkToDestination: destination, alignment: "right", _tocItemRef: item._nodeRef, style: lineNumberStyle, margin: [0, lineMargin[1], 0, lineMargin[3]] }
                      ]);
                    }
                    node.toc._table = {
                      table: {
                        dontBreakRows: true,
                        widths: ["*", "auto"],
                        body
                      },
                      layout: "noBorders"
                    };
                    node.toc._table = this.measureNode(node.toc._table);
                  }
                  return node;
                };
                DocMeasure.prototype.measureVerticalContainer = function(node) {
                  var items = node.stack;
                  node._minWidth = 0;
                  node._maxWidth = 0;
                  for (var i = 0, l = items.length; i < l; i++) {
                    items[i] = this.measureNode(items[i]);
                    node._minWidth = Math.max(node._minWidth, items[i]._minWidth);
                    node._maxWidth = Math.max(node._maxWidth, items[i]._maxWidth);
                  }
                  return node;
                };
                DocMeasure.prototype.gapSizeForList = function() {
                  return this.textTools.sizeOfString("9. ", this.styleStack);
                };
                DocMeasure.prototype.buildUnorderedMarker = function(styleStack, gapSize, type) {
                  function buildDisc(gapSize2, color2) {
                    var radius = gapSize2.fontSize / 6;
                    return {
                      canvas: [{
                        x: radius,
                        y: gapSize2.height / gapSize2.lineHeight + gapSize2.descender - gapSize2.fontSize / 3,
                        r1: radius,
                        r2: radius,
                        type: "ellipse",
                        color: color2
                      }]
                    };
                  }
                  function buildSquare(gapSize2, color2) {
                    var size = gapSize2.fontSize / 3;
                    return {
                      canvas: [{
                        x: 0,
                        y: gapSize2.height / gapSize2.lineHeight + gapSize2.descender - gapSize2.fontSize / 3 - size / 2,
                        h: size,
                        w: size,
                        type: "rect",
                        color: color2
                      }]
                    };
                  }
                  function buildCircle(gapSize2, color2) {
                    var radius = gapSize2.fontSize / 6;
                    return {
                      canvas: [{
                        x: radius,
                        y: gapSize2.height / gapSize2.lineHeight + gapSize2.descender - gapSize2.fontSize / 3,
                        r1: radius,
                        r2: radius,
                        type: "ellipse",
                        lineColor: color2
                      }]
                    };
                  }
                  var marker;
                  var color = styleStack.getProperty("markerColor") || styleStack.getProperty("color") || "black";
                  switch (type) {
                    case "circle":
                      marker = buildCircle(gapSize, color);
                      break;
                    case "square":
                      marker = buildSquare(gapSize, color);
                      break;
                    case "none":
                      marker = {};
                      break;
                    case "disc":
                    default:
                      marker = buildDisc(gapSize, color);
                      break;
                  }
                  marker._minWidth = marker._maxWidth = gapSize.width;
                  marker._minHeight = marker._maxHeight = gapSize.height;
                  return marker;
                };
                DocMeasure.prototype.buildOrderedMarker = function(counter, styleStack, type, separator) {
                  function prepareAlpha(counter2) {
                    function toAlpha(num) {
                      return (num >= 26 ? toAlpha((num / 26 >> 0) - 1) : "") + "abcdefghijklmnopqrstuvwxyz"[num % 26 >> 0];
                    }
                    if (counter2 < 1) {
                      return counter2.toString();
                    }
                    return toAlpha(counter2 - 1);
                  }
                  function prepareRoman(counter2) {
                    if (counter2 < 1 || counter2 > 4999) {
                      return counter2.toString();
                    }
                    var num = counter2;
                    var lookup = { M: 1e3, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 }, roman = "", i;
                    for (i in lookup) {
                      while (num >= lookup[i]) {
                        roman += i;
                        num -= lookup[i];
                      }
                    }
                    return roman;
                  }
                  function prepareDecimal(counter2) {
                    return counter2.toString();
                  }
                  var counterText;
                  switch (type) {
                    case "none":
                      counterText = null;
                      break;
                    case "upper-alpha":
                      counterText = prepareAlpha(counter).toUpperCase();
                      break;
                    case "lower-alpha":
                      counterText = prepareAlpha(counter);
                      break;
                    case "upper-roman":
                      counterText = prepareRoman(counter);
                      break;
                    case "lower-roman":
                      counterText = prepareRoman(counter).toLowerCase();
                      break;
                    case "decimal":
                    default:
                      counterText = prepareDecimal(counter);
                      break;
                  }
                  if (counterText === null) {
                    return {};
                  }
                  if (separator) {
                    if (isArray(separator)) {
                      if (separator[0]) {
                        counterText = separator[0] + counterText;
                      }
                      if (separator[1]) {
                        counterText += separator[1];
                      }
                      counterText += " ";
                    } else {
                      counterText += separator + " ";
                    }
                  }
                  var textArray = { text: counterText };
                  var markerColor = styleStack.getProperty("markerColor");
                  if (markerColor) {
                    textArray.color = markerColor;
                  }
                  return { _inlines: this.textTools.buildInlines(textArray, styleStack).items };
                };
                DocMeasure.prototype.measureUnorderedList = function(node) {
                  var style = this.styleStack.clone();
                  var items = node.ul;
                  node.type = node.type || "disc";
                  node._gapSize = this.gapSizeForList();
                  node._minWidth = 0;
                  node._maxWidth = 0;
                  for (var i = 0, l = items.length; i < l; i++) {
                    var item = items[i] = this.measureNode(items[i]);
                    if (!item.ol && !item.ul) {
                      item.listMarker = this.buildUnorderedMarker(style, node._gapSize, item.listType || node.type);
                    }
                    node._minWidth = Math.max(node._minWidth, items[i]._minWidth + node._gapSize.width);
                    node._maxWidth = Math.max(node._maxWidth, items[i]._maxWidth + node._gapSize.width);
                  }
                  return node;
                };
                DocMeasure.prototype.measureOrderedList = function(node) {
                  var style = this.styleStack.clone();
                  var items = node.ol;
                  node.type = node.type || "decimal";
                  node.separator = node.separator || ".";
                  node.reversed = node.reversed || false;
                  if (!isNumber(node.start)) {
                    node.start = node.reversed ? items.length : 1;
                  }
                  node._gapSize = this.gapSizeForList();
                  node._minWidth = 0;
                  node._maxWidth = 0;
                  var counter = node.start;
                  for (var i = 0, l = items.length; i < l; i++) {
                    var item = items[i] = this.measureNode(items[i]);
                    if (!item.ol && !item.ul) {
                      var counterValue = isNumber(item.counter) ? item.counter : counter;
                      item.listMarker = this.buildOrderedMarker(counterValue, style, item.listType || node.type, node.separator);
                      if (item.listMarker._inlines) {
                        node._gapSize.width = Math.max(node._gapSize.width, item.listMarker._inlines[0].width);
                      }
                    }
                    node._minWidth = Math.max(node._minWidth, items[i]._minWidth);
                    node._maxWidth = Math.max(node._maxWidth, items[i]._maxWidth);
                    if (node.reversed) {
                      counter--;
                    } else {
                      counter++;
                    }
                  }
                  node._minWidth += node._gapSize.width;
                  node._maxWidth += node._gapSize.width;
                  for (var i = 0, l = items.length; i < l; i++) {
                    var item = items[i];
                    if (!item.ol && !item.ul) {
                      item.listMarker._minWidth = item.listMarker._maxWidth = node._gapSize.width;
                    }
                  }
                  return node;
                };
                DocMeasure.prototype.measureColumns = function(node) {
                  var columns = node.columns;
                  node._gap = this.styleStack.getProperty("columnGap") || 0;
                  for (var i = 0, l = columns.length; i < l; i++) {
                    columns[i] = this.measureNode(columns[i]);
                  }
                  var measures = ColumnCalculator.measureMinMax(columns);
                  var numGaps = columns.length > 0 ? columns.length - 1 : 0;
                  node._minWidth = measures.min + node._gap * numGaps;
                  node._maxWidth = measures.max + node._gap * numGaps;
                  return node;
                };
                DocMeasure.prototype.measureTable = function(node) {
                  extendTableWidths(node);
                  node._layout = getLayout(this.tableLayouts);
                  node._offsets = getOffsets(node._layout);
                  var colSpans = [];
                  var col, row, cols, rows;
                  for (col = 0, cols = node.table.body[0].length; col < cols; col++) {
                    var c = node.table.widths[col];
                    c._minWidth = 0;
                    c._maxWidth = 0;
                    for (row = 0, rows = node.table.body.length; row < rows; row++) {
                      var rowData = node.table.body[row];
                      var data = rowData[col];
                      if (data === void 0) {
                        console.error("Malformed table row ", rowData, "in node ", node);
                        throw "Malformed table row, a cell is undefined.";
                      }
                      if (data === null) {
                        data = "";
                      }
                      if (!data._span) {
                        data = rowData[col] = this.styleStack.auto(data, measureCb(this, data));
                        if (data.colSpan && data.colSpan > 1) {
                          markSpans(rowData, col, data.colSpan);
                          colSpans.push({ col, span: data.colSpan, minWidth: data._minWidth, maxWidth: data._maxWidth });
                        } else {
                          c._minWidth = Math.max(c._minWidth, data._minWidth);
                          c._maxWidth = Math.max(c._maxWidth, data._maxWidth);
                        }
                      }
                      if (data.rowSpan && data.rowSpan > 1) {
                        markVSpans(node.table, row, col, data.rowSpan);
                      }
                    }
                  }
                  extendWidthsForColSpans();
                  var measures = ColumnCalculator.measureMinMax(node.table.widths);
                  node._minWidth = measures.min + node._offsets.total;
                  node._maxWidth = measures.max + node._offsets.total;
                  return node;
                  function measureCb(_this, data2) {
                    return function() {
                      if (isObject(data2)) {
                        data2.fillColor = _this.styleStack.getProperty("fillColor");
                        data2.fillOpacity = _this.styleStack.getProperty("fillOpacity");
                      }
                      return _this.measureNode(data2);
                    };
                  }
                  function getLayout(tableLayouts) {
                    var layout = node.layout;
                    if (isString(layout)) {
                      layout = tableLayouts[layout];
                    }
                    var defaultLayout = {
                      hLineWidth: function(i, node2) {
                        return 1;
                      },
                      vLineWidth: function(i, node2) {
                        return 1;
                      },
                      hLineColor: function(i, node2) {
                        return "black";
                      },
                      vLineColor: function(i, node2) {
                        return "black";
                      },
                      hLineStyle: function(i, node2) {
                        return null;
                      },
                      vLineStyle: function(i, node2) {
                        return null;
                      },
                      paddingLeft: function(i, node2) {
                        return 4;
                      },
                      paddingRight: function(i, node2) {
                        return 4;
                      },
                      paddingTop: function(i, node2) {
                        return 2;
                      },
                      paddingBottom: function(i, node2) {
                        return 2;
                      },
                      fillColor: function(i, node2) {
                        return null;
                      },
                      fillOpacity: function(i, node2) {
                        return 1;
                      },
                      defaultBorder: true
                    };
                    return pack(defaultLayout, layout);
                  }
                  function getOffsets(layout) {
                    var offsets = [];
                    var totalOffset = 0;
                    var prevRightPadding = 0;
                    for (var i = 0, l = node.table.widths.length; i < l; i++) {
                      var lOffset = prevRightPadding + layout.vLineWidth(i, node) + layout.paddingLeft(i, node);
                      offsets.push(lOffset);
                      totalOffset += lOffset;
                      prevRightPadding = layout.paddingRight(i, node);
                    }
                    totalOffset += prevRightPadding + layout.vLineWidth(node.table.widths.length, node);
                    return {
                      total: totalOffset,
                      offsets
                    };
                  }
                  function extendWidthsForColSpans() {
                    var q, j;
                    for (var i = 0, l = colSpans.length; i < l; i++) {
                      var span = colSpans[i];
                      var currentMinMax = getMinMax(span.col, span.span, node._offsets);
                      var minDifference = span.minWidth - currentMinMax.minWidth;
                      var maxDifference = span.maxWidth - currentMinMax.maxWidth;
                      if (minDifference > 0) {
                        q = minDifference / span.span;
                        for (j = 0; j < span.span; j++) {
                          node.table.widths[span.col + j]._minWidth += q;
                        }
                      }
                      if (maxDifference > 0) {
                        q = maxDifference / span.span;
                        for (j = 0; j < span.span; j++) {
                          node.table.widths[span.col + j]._maxWidth += q;
                        }
                      }
                    }
                  }
                  function getMinMax(col2, span, offsets) {
                    var result = { minWidth: 0, maxWidth: 0 };
                    for (var i = 0; i < span; i++) {
                      result.minWidth += node.table.widths[col2 + i]._minWidth + (i ? offsets.offsets[col2 + i] : 0);
                      result.maxWidth += node.table.widths[col2 + i]._maxWidth + (i ? offsets.offsets[col2 + i] : 0);
                    }
                    return result;
                  }
                  function markSpans(rowData2, col2, span) {
                    for (var i = 1; i < span; i++) {
                      rowData2[col2 + i] = {
                        _span: true,
                        _minWidth: 0,
                        _maxWidth: 0,
                        rowSpan: rowData2[col2].rowSpan
                      };
                    }
                  }
                  function markVSpans(table, row2, col2, span) {
                    for (var i = 1; i < span; i++) {
                      table.body[row2 + i][col2] = {
                        _span: true,
                        _minWidth: 0,
                        _maxWidth: 0,
                        fillColor: table.body[row2][col2].fillColor,
                        fillOpacity: table.body[row2][col2].fillOpacity
                      };
                    }
                  }
                  function extendTableWidths(node2) {
                    if (!node2.table.widths) {
                      node2.table.widths = "auto";
                    }
                    if (isString(node2.table.widths)) {
                      node2.table.widths = [node2.table.widths];
                      while (node2.table.widths.length < node2.table.body[0].length) {
                        node2.table.widths.push(node2.table.widths[node2.table.widths.length - 1]);
                      }
                    }
                    for (var i = 0, l = node2.table.widths.length; i < l; i++) {
                      var w = node2.table.widths[i];
                      if (isNumber(w) || isString(w)) {
                        node2.table.widths[i] = { width: w };
                      }
                    }
                  }
                };
                DocMeasure.prototype.measureCanvas = function(node) {
                  var w = 0, h = 0;
                  for (var i = 0, l = node.canvas.length; i < l; i++) {
                    var vector = node.canvas[i];
                    switch (vector.type) {
                      case "ellipse":
                        w = Math.max(w, vector.x + vector.r1);
                        h = Math.max(h, vector.y + vector.r2);
                        break;
                      case "rect":
                        w = Math.max(w, vector.x + vector.w);
                        h = Math.max(h, vector.y + vector.h);
                        break;
                      case "line":
                        w = Math.max(w, vector.x1, vector.x2);
                        h = Math.max(h, vector.y1, vector.y2);
                        break;
                      case "polyline":
                        for (var i2 = 0, l2 = vector.points.length; i2 < l2; i2++) {
                          w = Math.max(w, vector.points[i2].x);
                          h = Math.max(h, vector.points[i2].y);
                        }
                        break;
                    }
                  }
                  node._minWidth = node._maxWidth = w;
                  node._minHeight = node._maxHeight = h;
                  node._alignment = this.styleStack.getProperty("alignment");
                  return node;
                };
                DocMeasure.prototype.measureQr = function(node) {
                  node = qrEncoder.measure(node);
                  node._alignment = this.styleStack.getProperty("alignment");
                  return node;
                };
                module2.exports = DocMeasure;
              }
            ),
            /***/
            4889: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var Buffer = __webpack_require__2(8823)["Buffer"];
                var isString = __webpack_require__2(6225).isString;
                var isNumber = __webpack_require__2(6225).isNumber;
                var isBoolean = __webpack_require__2(6225).isBoolean;
                var isArray = __webpack_require__2(6225).isArray;
                var isUndefined = __webpack_require__2(6225).isUndefined;
                var fontStringify = __webpack_require__2(6225).fontStringify;
                function DocPreprocessor() {
                }
                DocPreprocessor.prototype.preprocessDocument = function(docStructure) {
                  this.parentNode = null;
                  this.tocs = [];
                  this.nodeReferences = [];
                  return this.preprocessNode(docStructure);
                };
                DocPreprocessor.prototype.preprocessNode = function(node) {
                  if (isArray(node)) {
                    node = { stack: node };
                  } else if (isString(node)) {
                    node = { text: node };
                  } else if (isNumber(node) || isBoolean(node)) {
                    node = { text: node.toString() };
                  } else if (node === void 0 || node === null) {
                    node = { text: "" };
                  } else if (Object.keys(node).length === 0) {
                    node = { text: "" };
                  } else if ("text" in node && (node.text === void 0 || node.text === null)) {
                    node.text = "";
                  }
                  if (node.columns) {
                    return this.preprocessColumns(node);
                  } else if (node.stack) {
                    return this.preprocessVerticalContainer(node);
                  } else if (node.ul) {
                    return this.preprocessList(node);
                  } else if (node.ol) {
                    return this.preprocessList(node);
                  } else if (node.table) {
                    return this.preprocessTable(node);
                  } else if (node.text !== void 0) {
                    return this.preprocessText(node);
                  } else if (node.toc) {
                    return this.preprocessToc(node);
                  } else if (node.image) {
                    return this.preprocessImage(node);
                  } else if (node.svg) {
                    return this.preprocessSVG(node);
                  } else if (node.canvas) {
                    return this.preprocessCanvas(node);
                  } else if (node.qr) {
                    return this.preprocessQr(node);
                  } else if (node.pageReference || node.textReference) {
                    return this.preprocessText(node);
                  } else {
                    throw "Unrecognized document structure: " + JSON.stringify(node, fontStringify);
                  }
                };
                DocPreprocessor.prototype.preprocessColumns = function(node) {
                  var columns = node.columns;
                  for (var i = 0, l = columns.length; i < l; i++) {
                    columns[i] = this.preprocessNode(columns[i]);
                  }
                  return node;
                };
                DocPreprocessor.prototype.preprocessVerticalContainer = function(node) {
                  var items = node.stack;
                  for (var i = 0, l = items.length; i < l; i++) {
                    items[i] = this.preprocessNode(items[i]);
                  }
                  return node;
                };
                DocPreprocessor.prototype.preprocessList = function(node) {
                  var items = node.ul || node.ol;
                  for (var i = 0, l = items.length; i < l; i++) {
                    items[i] = this.preprocessNode(items[i]);
                  }
                  return node;
                };
                DocPreprocessor.prototype.preprocessTable = function(node) {
                  var col, row, cols, rows;
                  for (col = 0, cols = node.table.body[0].length; col < cols; col++) {
                    for (row = 0, rows = node.table.body.length; row < rows; row++) {
                      var rowData = node.table.body[row];
                      var data = rowData[col];
                      if (data !== void 0) {
                        if (data === null) {
                          data = "";
                        }
                        if (!data._span) {
                          rowData[col] = this.preprocessNode(data);
                        }
                      }
                    }
                  }
                  return node;
                };
                DocPreprocessor.prototype.preprocessText = function(node) {
                  if (node.tocItem) {
                    if (!isArray(node.tocItem)) {
                      node.tocItem = [node.tocItem];
                    }
                    for (var i = 0, l = node.tocItem.length; i < l; i++) {
                      if (!isString(node.tocItem[i])) {
                        node.tocItem[i] = "_default_";
                      }
                      var tocItemId = node.tocItem[i];
                      if (!this.tocs[tocItemId]) {
                        this.tocs[tocItemId] = { toc: { _items: [], _pseudo: true } };
                      }
                      if (!node.id) {
                        node.id = "toc-" + tocItemId + "-" + this.tocs[tocItemId].toc._items.length;
                      }
                      var tocItemRef = {
                        _nodeRef: this._getNodeForNodeRef(node),
                        _textNodeRef: node
                      };
                      this.tocs[tocItemId].toc._items.push(tocItemRef);
                    }
                  }
                  if (node.id) {
                    if (this.nodeReferences[node.id]) {
                      if (!this.nodeReferences[node.id]._pseudo) {
                        throw "Node id '" + node.id + "' already exists";
                      }
                      this.nodeReferences[node.id]._nodeRef = this._getNodeForNodeRef(node);
                      this.nodeReferences[node.id]._textNodeRef = node;
                      this.nodeReferences[node.id]._pseudo = false;
                    } else {
                      this.nodeReferences[node.id] = {
                        _nodeRef: this._getNodeForNodeRef(node),
                        _textNodeRef: node
                      };
                    }
                  }
                  if (node.pageReference) {
                    if (!this.nodeReferences[node.pageReference]) {
                      this.nodeReferences[node.pageReference] = {
                        _nodeRef: {},
                        _textNodeRef: {},
                        _pseudo: true
                      };
                    }
                    node.text = "00000";
                    node.linkToDestination = node.pageReference;
                    node._pageRef = this.nodeReferences[node.pageReference];
                  }
                  if (node.textReference) {
                    if (!this.nodeReferences[node.textReference]) {
                      this.nodeReferences[node.textReference] = { _nodeRef: {}, _pseudo: true };
                    }
                    node.text = "";
                    node.linkToDestination = node.textReference;
                    node._textRef = this.nodeReferences[node.textReference];
                  }
                  if (node.text && node.text.text) {
                    node.text = [this.preprocessNode(node.text)];
                  } else if (isArray(node.text)) {
                    var isSetParentNode = false;
                    if (this.parentNode === null) {
                      this.parentNode = node;
                      isSetParentNode = true;
                    }
                    for (var i = 0, l = node.text.length; i < l; i++) {
                      node.text[i] = this.preprocessNode(node.text[i]);
                    }
                    if (isSetParentNode) {
                      this.parentNode = null;
                    }
                  }
                  return node;
                };
                DocPreprocessor.prototype.preprocessToc = function(node) {
                  if (!node.toc.id) {
                    node.toc.id = "_default_";
                  }
                  node.toc.title = node.toc.title ? this.preprocessNode(node.toc.title) : null;
                  node.toc._items = [];
                  if (this.tocs[node.toc.id]) {
                    if (!this.tocs[node.toc.id].toc._pseudo) {
                      throw "TOC '" + node.toc.id + "' already exists";
                    }
                    node.toc._items = this.tocs[node.toc.id].toc._items;
                  }
                  this.tocs[node.toc.id] = node;
                  return node;
                };
                DocPreprocessor.prototype.preprocessImage = function(node) {
                  if (!isUndefined(node.image.type) && !isUndefined(node.image.data) && node.image.type === "Buffer" && isArray(node.image.data)) {
                    node.image = Buffer.from(node.image.data);
                  }
                  return node;
                };
                DocPreprocessor.prototype.preprocessSVG = function(node) {
                  return node;
                };
                DocPreprocessor.prototype.preprocessCanvas = function(node) {
                  return node;
                };
                DocPreprocessor.prototype.preprocessQr = function(node) {
                  return node;
                };
                DocPreprocessor.prototype._getNodeForNodeRef = function(node) {
                  if (this.parentNode) {
                    return this.parentNode;
                  }
                  return node;
                };
                module2.exports = DocPreprocessor;
              }
            ),
            /***/
            3858: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var TraversalTracker = __webpack_require__2(8537);
                var isString = __webpack_require__2(6225).isString;
                function DocumentContext(pageSize, pageMargins) {
                  this.pages = [];
                  this.pageMargins = pageMargins;
                  this.x = pageMargins.left;
                  this.availableWidth = pageSize.width - pageMargins.left - pageMargins.right;
                  this.availableHeight = 0;
                  this.page = -1;
                  this.snapshots = [];
                  this.endingCell = null;
                  this.tracker = new TraversalTracker();
                  this.backgroundLength = [];
                  this.addPage(pageSize);
                }
                DocumentContext.prototype.beginColumnGroup = function() {
                  this.snapshots.push({
                    x: this.x,
                    y: this.y,
                    availableHeight: this.availableHeight,
                    availableWidth: this.availableWidth,
                    page: this.page,
                    bottomMost: {
                      x: this.x,
                      y: this.y,
                      availableHeight: this.availableHeight,
                      availableWidth: this.availableWidth,
                      page: this.page
                    },
                    endingCell: this.endingCell,
                    lastColumnWidth: this.lastColumnWidth
                  });
                  this.lastColumnWidth = 0;
                };
                DocumentContext.prototype.beginColumn = function(width, offset, endingCell) {
                  var saved = this.snapshots[this.snapshots.length - 1];
                  this.calculateBottomMost(saved);
                  this.endingCell = endingCell;
                  this.page = saved.page;
                  this.x = this.x + this.lastColumnWidth + (offset || 0);
                  this.y = saved.y;
                  this.availableWidth = width;
                  this.availableHeight = saved.availableHeight;
                  this.lastColumnWidth = width;
                };
                DocumentContext.prototype.calculateBottomMost = function(destContext) {
                  if (this.endingCell) {
                    this.saveContextInEndingCell(this.endingCell);
                    this.endingCell = null;
                  } else {
                    destContext.bottomMost = bottomMostContext(this, destContext.bottomMost);
                  }
                };
                DocumentContext.prototype.markEnding = function(endingCell) {
                  this.page = endingCell._columnEndingContext.page;
                  this.x = endingCell._columnEndingContext.x;
                  this.y = endingCell._columnEndingContext.y;
                  this.availableWidth = endingCell._columnEndingContext.availableWidth;
                  this.availableHeight = endingCell._columnEndingContext.availableHeight;
                  this.lastColumnWidth = endingCell._columnEndingContext.lastColumnWidth;
                };
                DocumentContext.prototype.saveContextInEndingCell = function(endingCell) {
                  endingCell._columnEndingContext = {
                    page: this.page,
                    x: this.x,
                    y: this.y,
                    availableHeight: this.availableHeight,
                    availableWidth: this.availableWidth,
                    lastColumnWidth: this.lastColumnWidth
                  };
                };
                DocumentContext.prototype.completeColumnGroup = function(height) {
                  var saved = this.snapshots.pop();
                  this.calculateBottomMost(saved);
                  this.endingCell = null;
                  this.x = saved.x;
                  var y = saved.bottomMost.y;
                  if (height) {
                    if (saved.page === saved.bottomMost.page) {
                      if (saved.y + height > y) {
                        y = saved.y + height;
                      }
                    } else {
                      y += height;
                    }
                  }
                  this.y = y;
                  this.page = saved.bottomMost.page;
                  this.availableWidth = saved.availableWidth;
                  this.availableHeight = saved.bottomMost.availableHeight;
                  if (height) {
                    this.availableHeight -= y - saved.bottomMost.y;
                  }
                  this.lastColumnWidth = saved.lastColumnWidth;
                };
                DocumentContext.prototype.addMargin = function(left, right) {
                  this.x += left;
                  this.availableWidth -= left + (right || 0);
                };
                DocumentContext.prototype.moveDown = function(offset) {
                  this.y += offset;
                  this.availableHeight -= offset;
                  return this.availableHeight > 0;
                };
                DocumentContext.prototype.initializePage = function() {
                  this.y = this.pageMargins.top;
                  this.availableHeight = this.getCurrentPage().pageSize.height - this.pageMargins.top - this.pageMargins.bottom;
                  this.pageSnapshot().availableWidth = this.getCurrentPage().pageSize.width - this.pageMargins.left - this.pageMargins.right;
                };
                DocumentContext.prototype.pageSnapshot = function() {
                  if (this.snapshots[0]) {
                    return this.snapshots[0];
                  } else {
                    return this;
                  }
                };
                DocumentContext.prototype.moveTo = function(x, y) {
                  if (x !== void 0 && x !== null) {
                    this.x = x;
                    this.availableWidth = this.getCurrentPage().pageSize.width - this.x - this.pageMargins.right;
                  }
                  if (y !== void 0 && y !== null) {
                    this.y = y;
                    this.availableHeight = this.getCurrentPage().pageSize.height - this.y - this.pageMargins.bottom;
                  }
                };
                DocumentContext.prototype.moveToRelative = function(x, y) {
                  if (x !== void 0 && x !== null) {
                    this.x = this.x + x;
                  }
                  if (y !== void 0 && y !== null) {
                    this.y = this.y + y;
                  }
                };
                DocumentContext.prototype.beginDetachedBlock = function() {
                  this.snapshots.push({
                    x: this.x,
                    y: this.y,
                    availableHeight: this.availableHeight,
                    availableWidth: this.availableWidth,
                    page: this.page,
                    endingCell: this.endingCell,
                    lastColumnWidth: this.lastColumnWidth
                  });
                };
                DocumentContext.prototype.endDetachedBlock = function() {
                  var saved = this.snapshots.pop();
                  this.x = saved.x;
                  this.y = saved.y;
                  this.availableWidth = saved.availableWidth;
                  this.availableHeight = saved.availableHeight;
                  this.page = saved.page;
                  this.endingCell = saved.endingCell;
                  this.lastColumnWidth = saved.lastColumnWidth;
                };
                function pageOrientation(pageOrientationString, currentPageOrientation) {
                  if (pageOrientationString === void 0) {
                    return currentPageOrientation;
                  } else if (isString(pageOrientationString) && pageOrientationString.toLowerCase() === "landscape") {
                    return "landscape";
                  } else {
                    return "portrait";
                  }
                }
                var getPageSize = function(currentPage, newPageOrientation) {
                  newPageOrientation = pageOrientation(newPageOrientation, currentPage.pageSize.orientation);
                  if (newPageOrientation !== currentPage.pageSize.orientation) {
                    return {
                      orientation: newPageOrientation,
                      width: currentPage.pageSize.height,
                      height: currentPage.pageSize.width
                    };
                  } else {
                    return {
                      orientation: currentPage.pageSize.orientation,
                      width: currentPage.pageSize.width,
                      height: currentPage.pageSize.height
                    };
                  }
                };
                DocumentContext.prototype.moveToNextPage = function(pageOrientation2) {
                  var nextPageIndex = this.page + 1;
                  var prevPage = this.page;
                  var prevY = this.y;
                  var createNewPage = nextPageIndex >= this.pages.length;
                  if (createNewPage) {
                    var currentAvailableWidth = this.availableWidth;
                    var currentPageOrientation = this.getCurrentPage().pageSize.orientation;
                    var pageSize = getPageSize(this.getCurrentPage(), pageOrientation2);
                    this.addPage(pageSize);
                    if (currentPageOrientation === pageSize.orientation) {
                      this.availableWidth = currentAvailableWidth;
                    }
                  } else {
                    this.page = nextPageIndex;
                    this.initializePage();
                  }
                  return {
                    newPageCreated: createNewPage,
                    prevPage,
                    prevY,
                    y: this.y
                  };
                };
                DocumentContext.prototype.addPage = function(pageSize) {
                  var page = { items: [], pageSize };
                  this.pages.push(page);
                  this.backgroundLength.push(0);
                  this.page = this.pages.length - 1;
                  this.initializePage();
                  this.tracker.emit("pageAdded");
                  return page;
                };
                DocumentContext.prototype.getCurrentPage = function() {
                  if (this.page < 0 || this.page >= this.pages.length) {
                    return null;
                  }
                  return this.pages[this.page];
                };
                DocumentContext.prototype.getCurrentPosition = function() {
                  var pageSize = this.getCurrentPage().pageSize;
                  var innerHeight = pageSize.height - this.pageMargins.top - this.pageMargins.bottom;
                  var innerWidth = pageSize.width - this.pageMargins.left - this.pageMargins.right;
                  return {
                    pageNumber: this.page + 1,
                    pageOrientation: pageSize.orientation,
                    pageInnerHeight: innerHeight,
                    pageInnerWidth: innerWidth,
                    left: this.x,
                    top: this.y,
                    verticalRatio: (this.y - this.pageMargins.top) / innerHeight,
                    horizontalRatio: (this.x - this.pageMargins.left) / innerWidth
                  };
                };
                function bottomMostContext(c1, c2) {
                  var r;
                  if (c1.page > c2.page) {
                    r = c1;
                  } else if (c2.page > c1.page) {
                    r = c2;
                  } else {
                    r = c1.y > c2.y ? c1 : c2;
                  }
                  return {
                    page: r.page,
                    x: r.x,
                    y: r.y,
                    availableHeight: r.availableHeight,
                    availableWidth: r.availableWidth
                  };
                }
                module2.exports = DocumentContext;
              }
            ),
            /***/
            1196: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var Line = __webpack_require__2(4775);
                var isNumber = __webpack_require__2(6225).isNumber;
                var pack = __webpack_require__2(6225).pack;
                var offsetVector = __webpack_require__2(6225).offsetVector;
                var DocumentContext = __webpack_require__2(3858);
                function ElementWriter(context, tracker) {
                  this.context = context;
                  this.contextStack = [];
                  this.tracker = tracker;
                }
                function addPageItem(page, item, index) {
                  if (index === null || index === void 0 || index < 0 || index > page.items.length) {
                    page.items.push(item);
                  } else {
                    page.items.splice(index, 0, item);
                  }
                }
                ElementWriter.prototype.addLine = function(line, dontUpdateContextPosition, index) {
                  var height = line.getHeight();
                  var context = this.context;
                  var page = context.getCurrentPage(), position = this.getCurrentPositionOnPage();
                  if (context.availableHeight < height || !page) {
                    return false;
                  }
                  line.x = context.x + (line.x || 0);
                  line.y = context.y + (line.y || 0);
                  this.alignLine(line);
                  addPageItem(page, {
                    type: "line",
                    item: line
                  }, index);
                  this.tracker.emit("lineAdded", line);
                  if (!dontUpdateContextPosition) {
                    context.moveDown(height);
                  }
                  return position;
                };
                ElementWriter.prototype.alignLine = function(line) {
                  var width = this.context.availableWidth;
                  var lineWidth = line.getWidth();
                  var alignment = line.inlines && line.inlines.length > 0 && line.inlines[0].alignment;
                  var offset = 0;
                  switch (alignment) {
                    case "right":
                      offset = width - lineWidth;
                      break;
                    case "center":
                      offset = (width - lineWidth) / 2;
                      break;
                  }
                  if (offset) {
                    line.x = (line.x || 0) + offset;
                  }
                  if (alignment === "justify" && !line.newLineForced && !line.lastLineInParagraph && line.inlines.length > 1) {
                    var additionalSpacing = (width - lineWidth) / (line.inlines.length - 1);
                    for (var i = 1, l = line.inlines.length; i < l; i++) {
                      offset = i * additionalSpacing;
                      line.inlines[i].x += offset;
                      line.inlines[i].justifyShift = additionalSpacing;
                    }
                  }
                };
                ElementWriter.prototype.addImage = function(image, index, type) {
                  var context = this.context;
                  var page = context.getCurrentPage(), position = this.getCurrentPositionOnPage();
                  if (!page || image.absolutePosition === void 0 && context.availableHeight < image._height && page.items.length > 0) {
                    return false;
                  }
                  if (image._x === void 0) {
                    image._x = image.x || 0;
                  }
                  image.x = context.x + image._x;
                  image.y = context.y;
                  this.alignImage(image);
                  addPageItem(page, {
                    type: type || "image",
                    item: image
                  }, index);
                  context.moveDown(image._height);
                  return position;
                };
                ElementWriter.prototype.addSVG = function(image, index) {
                  return this.addImage(image, index, "svg");
                };
                ElementWriter.prototype.addQr = function(qr, index) {
                  var context = this.context;
                  var page = context.getCurrentPage(), position = this.getCurrentPositionOnPage();
                  if (!page || qr.absolutePosition === void 0 && context.availableHeight < qr._height) {
                    return false;
                  }
                  if (qr._x === void 0) {
                    qr._x = qr.x || 0;
                  }
                  qr.x = context.x + qr._x;
                  qr.y = context.y;
                  this.alignImage(qr);
                  for (var i = 0, l = qr._canvas.length; i < l; i++) {
                    var vector = qr._canvas[i];
                    vector.x += qr.x;
                    vector.y += qr.y;
                    this.addVector(vector, true, true, index);
                  }
                  context.moveDown(qr._height);
                  return position;
                };
                ElementWriter.prototype.alignImage = function(image) {
                  var width = this.context.availableWidth;
                  var imageWidth = image._minWidth;
                  var offset = 0;
                  switch (image._alignment) {
                    case "right":
                      offset = width - imageWidth;
                      break;
                    case "center":
                      offset = (width - imageWidth) / 2;
                      break;
                  }
                  if (offset) {
                    image.x = (image.x || 0) + offset;
                  }
                };
                ElementWriter.prototype.alignCanvas = function(node) {
                  var width = this.context.availableWidth;
                  var canvasWidth = node._minWidth;
                  var offset = 0;
                  switch (node._alignment) {
                    case "right":
                      offset = width - canvasWidth;
                      break;
                    case "center":
                      offset = (width - canvasWidth) / 2;
                      break;
                  }
                  if (offset) {
                    node.canvas.forEach(function(vector) {
                      offsetVector(vector, offset, 0);
                    });
                  }
                };
                ElementWriter.prototype.addVector = function(vector, ignoreContextX, ignoreContextY, index) {
                  var context = this.context;
                  var page = context.getCurrentPage(), position = this.getCurrentPositionOnPage();
                  if (page) {
                    offsetVector(vector, ignoreContextX ? 0 : context.x, ignoreContextY ? 0 : context.y);
                    addPageItem(page, {
                      type: "vector",
                      item: vector
                    }, index);
                    return position;
                  }
                };
                ElementWriter.prototype.beginClip = function(width, height) {
                  var ctx = this.context;
                  var page = ctx.getCurrentPage();
                  page.items.push({
                    type: "beginClip",
                    item: { x: ctx.x, y: ctx.y, width, height }
                  });
                  return true;
                };
                ElementWriter.prototype.endClip = function() {
                  var ctx = this.context;
                  var page = ctx.getCurrentPage();
                  page.items.push({
                    type: "endClip"
                  });
                  return true;
                };
                function cloneLine(line) {
                  var result = new Line(line.maxWidth);
                  for (var key in line) {
                    if (line.hasOwnProperty(key)) {
                      result[key] = line[key];
                    }
                  }
                  return result;
                }
                ElementWriter.prototype.addFragment = function(block, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition) {
                  var ctx = this.context;
                  var page = ctx.getCurrentPage();
                  if (!useBlockXOffset && block.height > ctx.availableHeight) {
                    return false;
                  }
                  block.items.forEach(function(item) {
                    switch (item.type) {
                      case "line":
                        var l = cloneLine(item.item);
                        if (l._node) {
                          l._node.positions[0].pageNumber = ctx.page + 1;
                        }
                        l.x = (l.x || 0) + (useBlockXOffset ? block.xOffset || 0 : ctx.x);
                        l.y = (l.y || 0) + (useBlockYOffset ? block.yOffset || 0 : ctx.y);
                        page.items.push({
                          type: "line",
                          item: l
                        });
                        break;
                      case "vector":
                        var v = pack(item.item);
                        offsetVector(v, useBlockXOffset ? block.xOffset || 0 : ctx.x, useBlockYOffset ? block.yOffset || 0 : ctx.y);
                        page.items.push({
                          type: "vector",
                          item: v
                        });
                        break;
                      case "image":
                      case "svg":
                        var img = pack(item.item);
                        img.x = (img.x || 0) + (useBlockXOffset ? block.xOffset || 0 : ctx.x);
                        img.y = (img.y || 0) + (useBlockYOffset ? block.yOffset || 0 : ctx.y);
                        page.items.push({
                          type: item.type,
                          item: img
                        });
                        break;
                    }
                  });
                  if (!dontUpdateContextPosition) {
                    ctx.moveDown(block.height);
                  }
                  return true;
                };
                ElementWriter.prototype.pushContext = function(contextOrWidth, height) {
                  if (contextOrWidth === void 0) {
                    height = this.context.getCurrentPage().height - this.context.pageMargins.top - this.context.pageMargins.bottom;
                    contextOrWidth = this.context.availableWidth;
                  }
                  if (isNumber(contextOrWidth)) {
                    contextOrWidth = new DocumentContext({ width: contextOrWidth, height }, { left: 0, right: 0, top: 0, bottom: 0 });
                  }
                  this.contextStack.push(this.context);
                  this.context = contextOrWidth;
                };
                ElementWriter.prototype.popContext = function() {
                  this.context = this.contextStack.pop();
                };
                ElementWriter.prototype.getCurrentPositionOnPage = function() {
                  return (this.contextStack[0] || this.context).getCurrentPosition();
                };
                module2.exports = ElementWriter;
              }
            ),
            /***/
            2249: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isArray = __webpack_require__2(6225).isArray;
                function typeName(bold, italics) {
                  var type = "normal";
                  if (bold && italics) {
                    type = "bolditalics";
                  } else if (bold) {
                    type = "bold";
                  } else if (italics) {
                    type = "italics";
                  }
                  return type;
                }
                function FontProvider(fontDescriptors, pdfKitDoc) {
                  this.fonts = {};
                  this.pdfKitDoc = pdfKitDoc;
                  this.fontCache = {};
                  for (var font in fontDescriptors) {
                    if (fontDescriptors.hasOwnProperty(font)) {
                      var fontDef = fontDescriptors[font];
                      this.fonts[font] = {
                        normal: fontDef.normal,
                        bold: fontDef.bold,
                        italics: fontDef.italics,
                        bolditalics: fontDef.bolditalics
                      };
                    }
                  }
                }
                FontProvider.prototype.getFontType = function(bold, italics) {
                  return typeName(bold, italics);
                };
                FontProvider.prototype.getFontFile = function(familyName, bold, italics) {
                  var type = this.getFontType(bold, italics);
                  if (!this.fonts[familyName] || !this.fonts[familyName][type]) {
                    return null;
                  }
                  return this.fonts[familyName][type];
                };
                FontProvider.prototype.provideFont = function(familyName, bold, italics) {
                  var type = this.getFontType(bold, italics);
                  if (this.getFontFile(familyName, bold, italics) === null) {
                    throw new Error("Font '" + familyName + "' in style '" + type + "' is not defined in the font section of the document definition.");
                  }
                  this.fontCache[familyName] = this.fontCache[familyName] || {};
                  if (!this.fontCache[familyName][type]) {
                    var def = this.fonts[familyName][type];
                    if (!isArray(def)) {
                      def = [def];
                    }
                    this.fontCache[familyName][type] = this.pdfKitDoc.font.apply(this.pdfKitDoc, def)._font;
                  }
                  return this.fontCache[familyName][type];
                };
                module2.exports = FontProvider;
              }
            ),
            /***/
            6225: (
              /***/
              function(module2) {
                "use strict";
                function isString(variable) {
                  return typeof variable === "string" || variable instanceof String;
                }
                function isNumber(variable) {
                  return typeof variable === "number" || variable instanceof Number;
                }
                function isBoolean(variable) {
                  return typeof variable === "boolean";
                }
                function isArray(variable) {
                  return Array.isArray(variable);
                }
                function isFunction(variable) {
                  return typeof variable === "function";
                }
                function isObject(variable) {
                  return variable !== null && typeof variable === "object";
                }
                function isNull(variable) {
                  return variable === null;
                }
                function isUndefined(variable) {
                  return variable === void 0;
                }
                function pack() {
                  var result = {};
                  for (var i = 0, l = arguments.length; i < l; i++) {
                    var obj = arguments[i];
                    if (obj) {
                      for (var key in obj) {
                        if (obj.hasOwnProperty(key)) {
                          result[key] = obj[key];
                        }
                      }
                    }
                  }
                  return result;
                }
                function offsetVector(vector, x, y) {
                  switch (vector.type) {
                    case "ellipse":
                    case "rect":
                      vector.x += x;
                      vector.y += y;
                      break;
                    case "line":
                      vector.x1 += x;
                      vector.x2 += x;
                      vector.y1 += y;
                      vector.y2 += y;
                      break;
                    case "polyline":
                      for (var i = 0, l = vector.points.length; i < l; i++) {
                        vector.points[i].x += x;
                        vector.points[i].y += y;
                      }
                      break;
                  }
                }
                function fontStringify(key, val) {
                  if (key === "font") {
                    return "font";
                  }
                  return val;
                }
                function getNodeId(node) {
                  if (node.id) {
                    return node.id;
                  }
                  if (isArray(node.text)) {
                    for (var i = 0, l = node.text.length; i < l; i++) {
                      var n = node.text[i];
                      var nodeId = getNodeId(n);
                      if (nodeId) {
                        return nodeId;
                      }
                    }
                  }
                  return null;
                }
                function isPattern(color) {
                  return isArray(color) && color.length === 2;
                }
                function getPattern(color, patterns) {
                  return [patterns[color[0]], color[1]];
                }
                module2.exports = {
                  isString,
                  isNumber,
                  isBoolean,
                  isArray,
                  isFunction,
                  isObject,
                  isNull,
                  isUndefined,
                  pack,
                  fontStringify,
                  offsetVector,
                  getNodeId,
                  isPattern,
                  getPattern
                };
              }
            ),
            /***/
            3090: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var Buffer = __webpack_require__2(8823)["Buffer"];
                var fs = __webpack_require__2(3857);
                function ImageMeasure(pdfKitDoc, imageDictionary) {
                  this.pdfKitDoc = pdfKitDoc;
                  this.imageDictionary = imageDictionary || {};
                }
                ImageMeasure.prototype.measureImage = function(src) {
                  var image;
                  var that = this;
                  if (!this.pdfKitDoc._imageRegistry[src]) {
                    try {
                      image = this.pdfKitDoc.openImage(realImageSrc(src));
                      if (!image) {
                        throw "No image";
                      }
                    } catch (error) {
                      throw "Invalid image: " + error.toString() + "\nImages dictionary should contain dataURL entries (or local file paths in node.js)";
                    }
                    image.embed(this.pdfKitDoc);
                    this.pdfKitDoc._imageRegistry[src] = image;
                  } else {
                    image = this.pdfKitDoc._imageRegistry[src];
                  }
                  return { width: image.width, height: image.height };
                  function realImageSrc(src2) {
                    var img = that.imageDictionary[src2];
                    if (!img) {
                      return src2;
                    }
                    if (fs.existsSync(img)) {
                      return fs.readFileSync(img);
                    }
                    var index = img.indexOf("base64,");
                    if (index < 0) {
                      return that.imageDictionary[src2];
                    }
                    return Buffer.from(img.substring(index + 7), "base64");
                  }
                };
                module2.exports = ImageMeasure;
              }
            ),
            /***/
            2678: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var TraversalTracker = __webpack_require__2(8537);
                var DocPreprocessor = __webpack_require__2(4889);
                var DocMeasure = __webpack_require__2(1728);
                var DocumentContext = __webpack_require__2(3858);
                var PageElementWriter = __webpack_require__2(2912);
                var ColumnCalculator = __webpack_require__2(4498);
                var TableProcessor = __webpack_require__2(9342);
                var Line = __webpack_require__2(4775);
                var isString = __webpack_require__2(6225).isString;
                var isArray = __webpack_require__2(6225).isArray;
                var isUndefined = __webpack_require__2(6225).isUndefined;
                var isNull = __webpack_require__2(6225).isNull;
                var pack = __webpack_require__2(6225).pack;
                var offsetVector = __webpack_require__2(6225).offsetVector;
                var fontStringify = __webpack_require__2(6225).fontStringify;
                var getNodeId = __webpack_require__2(6225).getNodeId;
                var isFunction = __webpack_require__2(6225).isFunction;
                var TextTools = __webpack_require__2(1350);
                var StyleContextStack = __webpack_require__2(7597);
                var isNumber = __webpack_require__2(6225).isNumber;
                function addAll(target, otherArray) {
                  otherArray.forEach(function(item) {
                    target.push(item);
                  });
                }
                function LayoutBuilder(pageSize, pageMargins, imageMeasure, svgMeasure) {
                  this.pageSize = pageSize;
                  this.pageMargins = pageMargins;
                  this.tracker = new TraversalTracker();
                  this.imageMeasure = imageMeasure;
                  this.svgMeasure = svgMeasure;
                  this.tableLayouts = {};
                }
                LayoutBuilder.prototype.registerTableLayouts = function(tableLayouts) {
                  this.tableLayouts = pack(this.tableLayouts, tableLayouts);
                };
                LayoutBuilder.prototype.layoutDocument = function(docStructure, fontProvider, styleDictionary, defaultStyle, background, header, footer, images, watermark, pageBreakBeforeFct) {
                  function addPageBreaksIfNecessary(linearNodeList, pages) {
                    if (!isFunction(pageBreakBeforeFct)) {
                      return false;
                    }
                    linearNodeList = linearNodeList.filter(function(node2) {
                      return node2.positions.length > 0;
                    });
                    linearNodeList.forEach(function(node2) {
                      var nodeInfo = {};
                      [
                        "id",
                        "text",
                        "ul",
                        "ol",
                        "table",
                        "image",
                        "qr",
                        "canvas",
                        "svg",
                        "columns",
                        "headlineLevel",
                        "style",
                        "pageBreak",
                        "pageOrientation",
                        "width",
                        "height"
                      ].forEach(function(key) {
                        if (node2[key] !== void 0) {
                          nodeInfo[key] = node2[key];
                        }
                      });
                      nodeInfo.startPosition = node2.positions[0];
                      nodeInfo.pageNumbers = Array.from(new Set(node2.positions.map(function(node3) {
                        return node3.pageNumber;
                      })));
                      nodeInfo.pages = pages.length;
                      nodeInfo.stack = isArray(node2.stack);
                      node2.nodeInfo = nodeInfo;
                    });
                    for (var index = 0; index < linearNodeList.length; index++) {
                      var node = linearNodeList[index];
                      if (node.pageBreak !== "before" && !node.pageBreakCalculated) {
                        node.pageBreakCalculated = true;
                        var pageNumber = node.nodeInfo.pageNumbers[0];
                        var followingNodesOnPage = [];
                        var nodesOnNextPage = [];
                        var previousNodesOnPage = [];
                        if (pageBreakBeforeFct.length > 1) {
                          for (var ii = index + 1, l = linearNodeList.length; ii < l; ii++) {
                            if (linearNodeList[ii].nodeInfo.pageNumbers.indexOf(pageNumber) > -1) {
                              followingNodesOnPage.push(linearNodeList[ii].nodeInfo);
                            }
                            if (pageBreakBeforeFct.length > 2 && linearNodeList[ii].nodeInfo.pageNumbers.indexOf(pageNumber + 1) > -1) {
                              nodesOnNextPage.push(linearNodeList[ii].nodeInfo);
                            }
                          }
                        }
                        if (pageBreakBeforeFct.length > 3) {
                          for (var ii = 0; ii < index; ii++) {
                            if (linearNodeList[ii].nodeInfo.pageNumbers.indexOf(pageNumber) > -1) {
                              previousNodesOnPage.push(linearNodeList[ii].nodeInfo);
                            }
                          }
                        }
                        if (pageBreakBeforeFct(node.nodeInfo, followingNodesOnPage, nodesOnNextPage, previousNodesOnPage)) {
                          node.pageBreak = "before";
                          return true;
                        }
                      }
                    }
                    return false;
                  }
                  this.docPreprocessor = new DocPreprocessor();
                  this.docMeasure = new DocMeasure(fontProvider, styleDictionary, defaultStyle, this.imageMeasure, this.svgMeasure, this.tableLayouts, images);
                  function resetXYs(result2) {
                    result2.linearNodeList.forEach(function(node) {
                      node.resetXY();
                    });
                  }
                  var result = this.tryLayoutDocument(docStructure, fontProvider, styleDictionary, defaultStyle, background, header, footer, images, watermark);
                  while (addPageBreaksIfNecessary(result.linearNodeList, result.pages)) {
                    resetXYs(result);
                    result = this.tryLayoutDocument(docStructure, fontProvider, styleDictionary, defaultStyle, background, header, footer, images, watermark);
                  }
                  return result.pages;
                };
                LayoutBuilder.prototype.tryLayoutDocument = function(docStructure, fontProvider, styleDictionary, defaultStyle, background, header, footer, images, watermark, pageBreakBeforeFct) {
                  this.linearNodeList = [];
                  docStructure = this.docPreprocessor.preprocessDocument(docStructure);
                  docStructure = this.docMeasure.measureDocument(docStructure);
                  this.writer = new PageElementWriter(
                    new DocumentContext(this.pageSize, this.pageMargins),
                    this.tracker
                  );
                  var _this = this;
                  this.writer.context().tracker.startTracking("pageAdded", function() {
                    _this.addBackground(background);
                  });
                  this.addBackground(background);
                  this.processNode(docStructure);
                  this.addHeadersAndFooters(header, footer);
                  if (watermark != null) {
                    this.addWatermark(watermark, fontProvider, defaultStyle);
                  }
                  return { pages: this.writer.context().pages, linearNodeList: this.linearNodeList };
                };
                LayoutBuilder.prototype.addBackground = function(background) {
                  var backgroundGetter = isFunction(background) ? background : function() {
                    return background;
                  };
                  var context = this.writer.context();
                  var pageSize = context.getCurrentPage().pageSize;
                  var pageBackground = backgroundGetter(context.page + 1, pageSize);
                  if (pageBackground) {
                    this.writer.beginUnbreakableBlock(pageSize.width, pageSize.height);
                    pageBackground = this.docPreprocessor.preprocessDocument(pageBackground);
                    this.processNode(this.docMeasure.measureDocument(pageBackground));
                    this.writer.commitUnbreakableBlock(0, 0);
                    context.backgroundLength[context.page] += pageBackground.positions.length;
                  }
                };
                LayoutBuilder.prototype.addStaticRepeatable = function(headerOrFooter, sizeFunction) {
                  this.addDynamicRepeatable(function() {
                    return JSON.parse(JSON.stringify(headerOrFooter));
                  }, sizeFunction);
                };
                LayoutBuilder.prototype.addDynamicRepeatable = function(nodeGetter, sizeFunction) {
                  var pages = this.writer.context().pages;
                  for (var pageIndex = 0, l = pages.length; pageIndex < l; pageIndex++) {
                    this.writer.context().page = pageIndex;
                    var node = nodeGetter(pageIndex + 1, l, this.writer.context().pages[pageIndex].pageSize);
                    if (node) {
                      var sizes = sizeFunction(this.writer.context().getCurrentPage().pageSize, this.pageMargins);
                      this.writer.beginUnbreakableBlock(sizes.width, sizes.height);
                      node = this.docPreprocessor.preprocessDocument(node);
                      this.processNode(this.docMeasure.measureDocument(node));
                      this.writer.commitUnbreakableBlock(sizes.x, sizes.y);
                    }
                  }
                };
                LayoutBuilder.prototype.addHeadersAndFooters = function(header, footer) {
                  var headerSizeFct = function(pageSize, pageMargins) {
                    return {
                      x: 0,
                      y: 0,
                      width: pageSize.width,
                      height: pageMargins.top
                    };
                  };
                  var footerSizeFct = function(pageSize, pageMargins) {
                    return {
                      x: 0,
                      y: pageSize.height - pageMargins.bottom,
                      width: pageSize.width,
                      height: pageMargins.bottom
                    };
                  };
                  if (isFunction(header)) {
                    this.addDynamicRepeatable(header, headerSizeFct);
                  } else if (header) {
                    this.addStaticRepeatable(header, headerSizeFct);
                  }
                  if (isFunction(footer)) {
                    this.addDynamicRepeatable(footer, footerSizeFct);
                  } else if (footer) {
                    this.addStaticRepeatable(footer, footerSizeFct);
                  }
                };
                LayoutBuilder.prototype.addWatermark = function(watermark, fontProvider, defaultStyle) {
                  if (isString(watermark)) {
                    watermark = { "text": watermark };
                  }
                  if (!watermark.text) {
                    return;
                  }
                  watermark.font = watermark.font || defaultStyle.font || "Roboto";
                  watermark.fontSize = watermark.fontSize || "auto";
                  watermark.color = watermark.color || "black";
                  watermark.opacity = isNumber(watermark.opacity) ? watermark.opacity : 0.6;
                  watermark.bold = watermark.bold || false;
                  watermark.italics = watermark.italics || false;
                  watermark.angle = !isUndefined(watermark.angle) && !isNull(watermark.angle) ? watermark.angle : null;
                  if (watermark.angle === null) {
                    watermark.angle = Math.atan2(this.pageSize.height, this.pageSize.width) * -180 / Math.PI;
                  }
                  if (watermark.fontSize === "auto") {
                    watermark.fontSize = getWatermarkFontSize(this.pageSize, watermark, fontProvider);
                  }
                  var watermarkObject = {
                    text: watermark.text,
                    font: fontProvider.provideFont(watermark.font, watermark.bold, watermark.italics),
                    fontSize: watermark.fontSize,
                    color: watermark.color,
                    opacity: watermark.opacity,
                    angle: watermark.angle
                  };
                  watermarkObject._size = getWatermarkSize(watermark, fontProvider);
                  var pages = this.writer.context().pages;
                  for (var i = 0, l = pages.length; i < l; i++) {
                    pages[i].watermark = watermarkObject;
                  }
                  function getWatermarkSize(watermark2, fontProvider2) {
                    var textTools = new TextTools(fontProvider2);
                    var styleContextStack = new StyleContextStack(null, { font: watermark2.font, bold: watermark2.bold, italics: watermark2.italics });
                    styleContextStack.push({
                      fontSize: watermark2.fontSize
                    });
                    var size = textTools.sizeOfString(watermark2.text, styleContextStack);
                    var rotatedSize = textTools.sizeOfRotatedText(watermark2.text, watermark2.angle, styleContextStack);
                    return { size, rotatedSize };
                  }
                  function getWatermarkFontSize(pageSize, watermark2, fontProvider2) {
                    var textTools = new TextTools(fontProvider2);
                    var styleContextStack = new StyleContextStack(null, { font: watermark2.font, bold: watermark2.bold, italics: watermark2.italics });
                    var rotatedSize;
                    var a = 0;
                    var b = 1e3;
                    var c = (a + b) / 2;
                    while (Math.abs(a - b) > 1) {
                      styleContextStack.push({
                        fontSize: c
                      });
                      rotatedSize = textTools.sizeOfRotatedText(watermark2.text, watermark2.angle, styleContextStack);
                      if (rotatedSize.width > pageSize.width) {
                        b = c;
                        c = (a + b) / 2;
                      } else if (rotatedSize.width < pageSize.width) {
                        if (rotatedSize.height > pageSize.height) {
                          b = c;
                          c = (a + b) / 2;
                        } else {
                          a = c;
                          c = (a + b) / 2;
                        }
                      }
                      styleContextStack.pop();
                    }
                    return c;
                  }
                };
                function decorateNode(node) {
                  var x = node.x, y = node.y;
                  node.positions = [];
                  if (isArray(node.canvas)) {
                    node.canvas.forEach(function(vector) {
                      var x2 = vector.x, y2 = vector.y, x1 = vector.x1, y1 = vector.y1, x22 = vector.x2, y22 = vector.y2;
                      vector.resetXY = function() {
                        vector.x = x2;
                        vector.y = y2;
                        vector.x1 = x1;
                        vector.y1 = y1;
                        vector.x2 = x22;
                        vector.y2 = y22;
                      };
                    });
                  }
                  node.resetXY = function() {
                    node.x = x;
                    node.y = y;
                    if (isArray(node.canvas)) {
                      node.canvas.forEach(function(vector) {
                        vector.resetXY();
                      });
                    }
                  };
                }
                LayoutBuilder.prototype.processNode = function(node) {
                  var self2 = this;
                  this.linearNodeList.push(node);
                  decorateNode(node);
                  applyMargins(function() {
                    var unbreakable = node.unbreakable;
                    if (unbreakable) {
                      self2.writer.beginUnbreakableBlock();
                    }
                    var absPosition = node.absolutePosition;
                    if (absPosition) {
                      self2.writer.context().beginDetachedBlock();
                      self2.writer.context().moveTo(absPosition.x || 0, absPosition.y || 0);
                    }
                    var relPosition = node.relativePosition;
                    if (relPosition) {
                      self2.writer.context().beginDetachedBlock();
                      self2.writer.context().moveToRelative(relPosition.x || 0, relPosition.y || 0);
                    }
                    if (node.stack) {
                      self2.processVerticalContainer(node);
                    } else if (node.columns) {
                      self2.processColumns(node);
                    } else if (node.ul) {
                      self2.processList(false, node);
                    } else if (node.ol) {
                      self2.processList(true, node);
                    } else if (node.table) {
                      self2.processTable(node);
                    } else if (node.text !== void 0) {
                      self2.processLeaf(node);
                    } else if (node.toc) {
                      self2.processToc(node);
                    } else if (node.image) {
                      self2.processImage(node);
                    } else if (node.svg) {
                      self2.processSVG(node);
                    } else if (node.canvas) {
                      self2.processCanvas(node);
                    } else if (node.qr) {
                      self2.processQr(node);
                    } else if (!node._span) {
                      throw "Unrecognized document structure: " + JSON.stringify(node, fontStringify);
                    }
                    if (absPosition || relPosition) {
                      self2.writer.context().endDetachedBlock();
                    }
                    if (unbreakable) {
                      self2.writer.commitUnbreakableBlock();
                    }
                  });
                  function applyMargins(callback) {
                    var margin = node._margin;
                    if (node.pageBreak === "before") {
                      self2.writer.moveToNextPage(node.pageOrientation);
                    } else if (node.pageBreak === "beforeOdd") {
                      self2.writer.moveToNextPage(node.pageOrientation);
                      if ((self2.writer.context().page + 1) % 2 === 1) {
                        self2.writer.moveToNextPage(node.pageOrientation);
                      }
                    } else if (node.pageBreak === "beforeEven") {
                      self2.writer.moveToNextPage(node.pageOrientation);
                      if ((self2.writer.context().page + 1) % 2 === 0) {
                        self2.writer.moveToNextPage(node.pageOrientation);
                      }
                    }
                    if (margin) {
                      self2.writer.context().moveDown(margin[1]);
                      self2.writer.context().addMargin(margin[0], margin[2]);
                    }
                    callback();
                    if (margin) {
                      self2.writer.context().addMargin(-margin[0], -margin[2]);
                      self2.writer.context().moveDown(margin[3]);
                    }
                    if (node.pageBreak === "after") {
                      self2.writer.moveToNextPage(node.pageOrientation);
                    } else if (node.pageBreak === "afterOdd") {
                      self2.writer.moveToNextPage(node.pageOrientation);
                      if ((self2.writer.context().page + 1) % 2 === 1) {
                        self2.writer.moveToNextPage(node.pageOrientation);
                      }
                    } else if (node.pageBreak === "afterEven") {
                      self2.writer.moveToNextPage(node.pageOrientation);
                      if ((self2.writer.context().page + 1) % 2 === 0) {
                        self2.writer.moveToNextPage(node.pageOrientation);
                      }
                    }
                  }
                };
                LayoutBuilder.prototype.processVerticalContainer = function(node) {
                  var self2 = this;
                  node.stack.forEach(function(item) {
                    self2.processNode(item);
                    addAll(node.positions, item.positions);
                  });
                };
                LayoutBuilder.prototype.processColumns = function(columnNode) {
                  var columns = columnNode.columns;
                  var availableWidth = this.writer.context().availableWidth;
                  var gaps = gapArray(columnNode._gap);
                  if (gaps) {
                    availableWidth -= (gaps.length - 1) * columnNode._gap;
                  }
                  ColumnCalculator.buildColumnWidths(columns, availableWidth);
                  var result = this.processRow(columns, columns, gaps);
                  addAll(columnNode.positions, result.positions);
                  function gapArray(gap) {
                    if (!gap) {
                      return null;
                    }
                    var gaps2 = [];
                    gaps2.push(0);
                    for (var i = columns.length - 1; i > 0; i--) {
                      gaps2.push(gap);
                    }
                    return gaps2;
                  }
                };
                LayoutBuilder.prototype.processRow = function(columns, widths, gaps, tableBody, tableRow, height) {
                  var self2 = this;
                  var pageBreaks = [], positions = [];
                  this.tracker.auto("pageChanged", storePageBreakData, function() {
                    widths = widths || columns;
                    self2.writer.context().beginColumnGroup();
                    for (var i = 0, l = columns.length; i < l; i++) {
                      var column = columns[i];
                      var width = widths[i]._calcWidth;
                      var leftOffset = colLeftOffset(i);
                      if (column.colSpan && column.colSpan > 1) {
                        for (var j = 1; j < column.colSpan; j++) {
                          width += widths[++i]._calcWidth + gaps[i];
                        }
                      }
                      self2.writer.context().beginColumn(width, leftOffset, getEndingCell(column, i));
                      if (!column._span) {
                        self2.processNode(column);
                        addAll(positions, column.positions);
                      } else if (column._columnEndingContext) {
                        self2.writer.context().markEnding(column);
                      }
                    }
                    self2.writer.context().completeColumnGroup(height);
                  });
                  return { pageBreaks, positions };
                  function storePageBreakData(data) {
                    var pageDesc;
                    for (var i = 0, l = pageBreaks.length; i < l; i++) {
                      var desc = pageBreaks[i];
                      if (desc.prevPage === data.prevPage) {
                        pageDesc = desc;
                        break;
                      }
                    }
                    if (!pageDesc) {
                      pageDesc = data;
                      pageBreaks.push(pageDesc);
                    }
                    pageDesc.prevY = Math.max(pageDesc.prevY, data.prevY);
                    pageDesc.y = Math.min(pageDesc.y, data.y);
                  }
                  function colLeftOffset(i) {
                    if (gaps && gaps.length > i) {
                      return gaps[i];
                    }
                    return 0;
                  }
                  function getEndingCell(column, columnIndex) {
                    if (column.rowSpan && column.rowSpan > 1) {
                      var endingRow = tableRow + column.rowSpan - 1;
                      if (endingRow >= tableBody.length) {
                        throw "Row span for column " + columnIndex + " (with indexes starting from 0) exceeded row count";
                      }
                      return tableBody[endingRow][columnIndex];
                    }
                    return null;
                  }
                };
                LayoutBuilder.prototype.processList = function(orderedList, node) {
                  var self2 = this, items = orderedList ? node.ol : node.ul, gapSize = node._gapSize;
                  this.writer.context().addMargin(gapSize.width);
                  var nextMarker;
                  this.tracker.auto("lineAdded", addMarkerToFirstLeaf, function() {
                    items.forEach(function(item) {
                      nextMarker = item.listMarker;
                      self2.processNode(item);
                      addAll(node.positions, item.positions);
                    });
                  });
                  this.writer.context().addMargin(-gapSize.width);
                  function addMarkerToFirstLeaf(line) {
                    if (nextMarker) {
                      var marker = nextMarker;
                      nextMarker = null;
                      if (marker.canvas) {
                        var vector = marker.canvas[0];
                        offsetVector(vector, -marker._minWidth, 0);
                        self2.writer.addVector(vector);
                      } else if (marker._inlines) {
                        var markerLine = new Line(self2.pageSize.width);
                        markerLine.addInline(marker._inlines[0]);
                        markerLine.x = -marker._minWidth;
                        markerLine.y = line.getAscenderHeight() - markerLine.getAscenderHeight();
                        self2.writer.addLine(markerLine, true);
                      }
                    }
                  }
                };
                LayoutBuilder.prototype.processTable = function(tableNode) {
                  var processor = new TableProcessor(tableNode);
                  processor.beginTable(this.writer);
                  var rowHeights = tableNode.table.heights;
                  for (var i = 0, l = tableNode.table.body.length; i < l; i++) {
                    processor.beginRow(i, this.writer);
                    var height;
                    if (isFunction(rowHeights)) {
                      height = rowHeights(i);
                    } else if (isArray(rowHeights)) {
                      height = rowHeights[i];
                    } else {
                      height = rowHeights;
                    }
                    if (height === "auto") {
                      height = void 0;
                    }
                    var result = this.processRow(tableNode.table.body[i], tableNode.table.widths, tableNode._offsets.offsets, tableNode.table.body, i, height);
                    addAll(tableNode.positions, result.positions);
                    processor.endRow(i, this.writer, result.pageBreaks);
                  }
                  processor.endTable(this.writer);
                };
                LayoutBuilder.prototype.processLeaf = function(node) {
                  var line = this.buildNextLine(node);
                  if (line && (node.tocItem || node.id)) {
                    line._node = node;
                  }
                  var currentHeight = line ? line.getHeight() : 0;
                  var maxHeight = node.maxHeight || -1;
                  if (line) {
                    var nodeId = getNodeId(node);
                    if (nodeId) {
                      line.id = nodeId;
                    }
                  }
                  if (node._tocItemRef) {
                    line._pageNodeRef = node._tocItemRef;
                  }
                  if (node._pageRef) {
                    line._pageNodeRef = node._pageRef._nodeRef;
                  }
                  if (line && line.inlines && isArray(line.inlines)) {
                    for (var i = 0, l = line.inlines.length; i < l; i++) {
                      if (line.inlines[i]._tocItemRef) {
                        line.inlines[i]._pageNodeRef = line.inlines[i]._tocItemRef;
                      }
                      if (line.inlines[i]._pageRef) {
                        line.inlines[i]._pageNodeRef = line.inlines[i]._pageRef._nodeRef;
                      }
                    }
                  }
                  while (line && (maxHeight === -1 || currentHeight < maxHeight)) {
                    var positions = this.writer.addLine(line);
                    node.positions.push(positions);
                    line = this.buildNextLine(node);
                    if (line) {
                      currentHeight += line.getHeight();
                    }
                  }
                };
                LayoutBuilder.prototype.processToc = function(node) {
                  if (node.toc.title) {
                    this.processNode(node.toc.title);
                  }
                  if (node.toc._table) {
                    this.processNode(node.toc._table);
                  }
                };
                LayoutBuilder.prototype.buildNextLine = function(textNode) {
                  function cloneInline(inline2) {
                    var newInline2 = inline2.constructor();
                    for (var key in inline2) {
                      newInline2[key] = inline2[key];
                    }
                    return newInline2;
                  }
                  if (!textNode._inlines || textNode._inlines.length === 0) {
                    return null;
                  }
                  var line = new Line(this.writer.context().availableWidth);
                  var textTools = new TextTools(null);
                  var isForceContinue = false;
                  while (textNode._inlines && textNode._inlines.length > 0 && (line.hasEnoughSpaceForInline(textNode._inlines[0], textNode._inlines.slice(1)) || isForceContinue)) {
                    var isHardWrap = false;
                    var inline = textNode._inlines.shift();
                    isForceContinue = false;
                    if (!inline.noWrap && inline.text.length > 1 && inline.width > line.getAvailableWidth()) {
                      var widthPerChar = inline.width / inline.text.length;
                      var maxChars = Math.floor(line.getAvailableWidth() / widthPerChar);
                      if (maxChars < 1) {
                        maxChars = 1;
                      }
                      if (maxChars < inline.text.length) {
                        var newInline = cloneInline(inline);
                        newInline.text = inline.text.substr(maxChars);
                        inline.text = inline.text.substr(0, maxChars);
                        newInline.width = textTools.widthOfString(newInline.text, newInline.font, newInline.fontSize, newInline.characterSpacing, newInline.fontFeatures);
                        inline.width = textTools.widthOfString(inline.text, inline.font, inline.fontSize, inline.characterSpacing, inline.fontFeatures);
                        textNode._inlines.unshift(newInline);
                        isHardWrap = true;
                      }
                    }
                    line.addInline(inline);
                    isForceContinue = inline.noNewLine && !isHardWrap;
                  }
                  line.lastLineInParagraph = textNode._inlines.length === 0;
                  return line;
                };
                LayoutBuilder.prototype.processImage = function(node) {
                  var position = this.writer.addImage(node);
                  node.positions.push(position);
                };
                LayoutBuilder.prototype.processSVG = function(node) {
                  var position = this.writer.addSVG(node);
                  node.positions.push(position);
                };
                LayoutBuilder.prototype.processCanvas = function(node) {
                  var height = node._minHeight;
                  if (node.absolutePosition === void 0 && this.writer.context().availableHeight < height) {
                    this.writer.moveToNextPage();
                  }
                  this.writer.alignCanvas(node);
                  node.canvas.forEach(function(vector) {
                    var position = this.writer.addVector(vector);
                    node.positions.push(position);
                  }, this);
                  this.writer.context().moveDown(height);
                };
                LayoutBuilder.prototype.processQr = function(node) {
                  var position = this.writer.addQr(node);
                  node.positions.push(position);
                };
                module2.exports = LayoutBuilder;
              }
            ),
            /***/
            4775: (
              /***/
              function(module2) {
                "use strict";
                function Line(maxWidth) {
                  this.maxWidth = maxWidth;
                  this.leadingCut = 0;
                  this.trailingCut = 0;
                  this.inlineWidths = 0;
                  this.inlines = [];
                }
                Line.prototype.getAscenderHeight = function() {
                  var y = 0;
                  this.inlines.forEach(function(inline) {
                    y = Math.max(y, inline.font.ascender / 1e3 * inline.fontSize);
                  });
                  return y;
                };
                Line.prototype.hasEnoughSpaceForInline = function(inline, nextInlines) {
                  nextInlines = nextInlines || [];
                  if (this.inlines.length === 0) {
                    return true;
                  }
                  if (this.newLineForced) {
                    return false;
                  }
                  var inlineWidth = inline.width;
                  var inlineTrailingCut = inline.trailingCut || 0;
                  if (inline.noNewLine) {
                    for (var i = 0, l = nextInlines.length; i < l; i++) {
                      var nextInline = nextInlines[i];
                      inlineWidth += nextInline.width;
                      inlineTrailingCut += nextInline.trailingCut || 0;
                      if (!nextInline.noNewLine) {
                        break;
                      }
                    }
                  }
                  return this.inlineWidths + inlineWidth - this.leadingCut - inlineTrailingCut <= this.maxWidth;
                };
                Line.prototype.addInline = function(inline) {
                  if (this.inlines.length === 0) {
                    this.leadingCut = inline.leadingCut || 0;
                  }
                  this.trailingCut = inline.trailingCut || 0;
                  inline.x = this.inlineWidths - this.leadingCut;
                  this.inlines.push(inline);
                  this.inlineWidths += inline.width;
                  if (inline.lineEnd) {
                    this.newLineForced = true;
                  }
                };
                Line.prototype.getWidth = function() {
                  return this.inlineWidths - this.leadingCut - this.trailingCut;
                };
                Line.prototype.getAvailableWidth = function() {
                  return this.maxWidth - this.getWidth();
                };
                Line.prototype.getHeight = function() {
                  var max = 0;
                  this.inlines.forEach(function(item) {
                    max = Math.max(max, item.height || 0);
                  });
                  return max;
                };
                module2.exports = Line;
              }
            ),
            /***/
            2912: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isUndefined = __webpack_require__2(6225).isUndefined;
                var ElementWriter = __webpack_require__2(1196);
                function PageElementWriter(context, tracker) {
                  this.transactionLevel = 0;
                  this.repeatables = [];
                  this.tracker = tracker;
                  this.writer = new ElementWriter(context, tracker);
                }
                function fitOnPage(self2, addFct) {
                  var position = addFct(self2);
                  if (!position) {
                    self2.moveToNextPage();
                    position = addFct(self2);
                  }
                  return position;
                }
                PageElementWriter.prototype.addLine = function(line, dontUpdateContextPosition, index) {
                  return fitOnPage(this, function(self2) {
                    return self2.writer.addLine(line, dontUpdateContextPosition, index);
                  });
                };
                PageElementWriter.prototype.addImage = function(image, index) {
                  return fitOnPage(this, function(self2) {
                    return self2.writer.addImage(image, index);
                  });
                };
                PageElementWriter.prototype.addSVG = function(image, index) {
                  return fitOnPage(this, function(self2) {
                    return self2.writer.addSVG(image, index);
                  });
                };
                PageElementWriter.prototype.addQr = function(qr, index) {
                  return fitOnPage(this, function(self2) {
                    return self2.writer.addQr(qr, index);
                  });
                };
                PageElementWriter.prototype.addVector = function(vector, ignoreContextX, ignoreContextY, index) {
                  return this.writer.addVector(vector, ignoreContextX, ignoreContextY, index);
                };
                PageElementWriter.prototype.beginClip = function(width, height) {
                  return this.writer.beginClip(width, height);
                };
                PageElementWriter.prototype.endClip = function() {
                  return this.writer.endClip();
                };
                PageElementWriter.prototype.alignCanvas = function(node) {
                  this.writer.alignCanvas(node);
                };
                PageElementWriter.prototype.addFragment = function(fragment, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition) {
                  if (!this.writer.addFragment(fragment, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition)) {
                    this.moveToNextPage();
                    this.writer.addFragment(fragment, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition);
                  }
                };
                PageElementWriter.prototype.moveToNextPage = function(pageOrientation) {
                  var nextPage = this.writer.context.moveToNextPage(pageOrientation);
                  this.repeatables.forEach(function(rep) {
                    if (isUndefined(rep.insertedOnPages[this.writer.context.page])) {
                      rep.insertedOnPages[this.writer.context.page] = true;
                      this.writer.addFragment(rep, true);
                    } else {
                      this.writer.context.moveDown(rep.height);
                    }
                  }, this);
                  this.writer.tracker.emit("pageChanged", {
                    prevPage: nextPage.prevPage,
                    prevY: nextPage.prevY,
                    y: this.writer.context.y
                  });
                };
                PageElementWriter.prototype.beginUnbreakableBlock = function(width, height) {
                  if (this.transactionLevel++ === 0) {
                    this.originalX = this.writer.context.x;
                    this.writer.pushContext(width, height);
                  }
                };
                PageElementWriter.prototype.commitUnbreakableBlock = function(forcedX, forcedY) {
                  if (--this.transactionLevel === 0) {
                    var unbreakableContext = this.writer.context;
                    this.writer.popContext();
                    var nbPages = unbreakableContext.pages.length;
                    if (nbPages > 0) {
                      var fragment = unbreakableContext.pages[0];
                      fragment.xOffset = forcedX;
                      fragment.yOffset = forcedY;
                      if (nbPages > 1) {
                        if (forcedX !== void 0 || forcedY !== void 0) {
                          fragment.height = unbreakableContext.getCurrentPage().pageSize.height - unbreakableContext.pageMargins.top - unbreakableContext.pageMargins.bottom;
                        } else {
                          fragment.height = this.writer.context.getCurrentPage().pageSize.height - this.writer.context.pageMargins.top - this.writer.context.pageMargins.bottom;
                          for (var i = 0, l = this.repeatables.length; i < l; i++) {
                            fragment.height -= this.repeatables[i].height;
                          }
                        }
                      } else {
                        fragment.height = unbreakableContext.y;
                      }
                      if (forcedX !== void 0 || forcedY !== void 0) {
                        this.writer.addFragment(fragment, true, true, true);
                      } else {
                        this.addFragment(fragment);
                      }
                    }
                  }
                };
                PageElementWriter.prototype.currentBlockToRepeatable = function() {
                  var unbreakableContext = this.writer.context;
                  var rep = { items: [] };
                  unbreakableContext.pages[0].items.forEach(function(item) {
                    rep.items.push(item);
                  });
                  rep.xOffset = this.originalX;
                  rep.height = unbreakableContext.y;
                  rep.insertedOnPages = [];
                  return rep;
                };
                PageElementWriter.prototype.pushToRepeatables = function(rep) {
                  this.repeatables.push(rep);
                };
                PageElementWriter.prototype.popFromRepeatables = function() {
                  this.repeatables.pop();
                };
                PageElementWriter.prototype.context = function() {
                  return this.writer.context;
                };
                module2.exports = PageElementWriter;
              }
            ),
            /***/
            6079: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                function _interopDefault(ex) {
                  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
                }
                var PdfKit = _interopDefault(__webpack_require__2(5219));
                function getEngineInstance() {
                  return PdfKit;
                }
                function createPdfDocument(options) {
                  options = options || {};
                  return new PdfKit(options);
                }
                module2.exports = {
                  getEngineInstance,
                  createPdfDocument
                };
              }
            ),
            /***/
            8617: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var PdfKitEngine = __webpack_require__2(6079);
                var FontProvider = __webpack_require__2(2249);
                var LayoutBuilder = __webpack_require__2(2678);
                var sizes = __webpack_require__2(4762);
                var ImageMeasure = __webpack_require__2(3090);
                var SVGMeasure = __webpack_require__2(7601);
                var textDecorator = __webpack_require__2(3497);
                var TextTools = __webpack_require__2(1350);
                var isFunction = __webpack_require__2(6225).isFunction;
                var isString = __webpack_require__2(6225).isString;
                var isNumber = __webpack_require__2(6225).isNumber;
                var isBoolean = __webpack_require__2(6225).isBoolean;
                var isArray = __webpack_require__2(6225).isArray;
                var isUndefined = __webpack_require__2(6225).isUndefined;
                var isPattern = __webpack_require__2(6225).isPattern;
                var getPattern = __webpack_require__2(6225).getPattern;
                var SVGtoPDF = __webpack_require__2(8071);
                var findFont = function(fonts, requiredFonts, defaultFont) {
                  for (var i = 0; i < requiredFonts.length; i++) {
                    var requiredFont = requiredFonts[i].toLowerCase();
                    for (var font in fonts) {
                      if (font.toLowerCase() === requiredFont) {
                        return font;
                      }
                    }
                  }
                  return defaultFont;
                };
                function PdfPrinter(fontDescriptors) {
                  this.fontDescriptors = fontDescriptors;
                }
                PdfPrinter.prototype.createPdfKitDocument = function(docDefinition, options) {
                  options = options || {};
                  docDefinition.version = docDefinition.version || "1.3";
                  docDefinition.compress = isBoolean(docDefinition.compress) ? docDefinition.compress : true;
                  docDefinition.images = docDefinition.images || {};
                  docDefinition.pageMargins = docDefinition.pageMargins !== void 0 && docDefinition.pageMargins !== null ? docDefinition.pageMargins : 40;
                  var pageSize = fixPageSize(docDefinition.pageSize, docDefinition.pageOrientation);
                  var pdfOptions = {
                    size: [pageSize.width, pageSize.height],
                    pdfVersion: docDefinition.version,
                    compress: docDefinition.compress,
                    userPassword: docDefinition.userPassword,
                    ownerPassword: docDefinition.ownerPassword,
                    permissions: docDefinition.permissions,
                    fontLayoutCache: isBoolean(options.fontLayoutCache) ? options.fontLayoutCache : true,
                    bufferPages: options.bufferPages || false,
                    autoFirstPage: false,
                    info: createMetadata(docDefinition),
                    font: null
                  };
                  this.pdfKitDoc = PdfKitEngine.createPdfDocument(pdfOptions);
                  this.fontProvider = new FontProvider(this.fontDescriptors, this.pdfKitDoc);
                  var builder = new LayoutBuilder(pageSize, fixPageMargins(docDefinition.pageMargins), new ImageMeasure(this.pdfKitDoc, docDefinition.images), new SVGMeasure());
                  registerDefaultTableLayouts(builder);
                  if (options.tableLayouts) {
                    builder.registerTableLayouts(options.tableLayouts);
                  }
                  var pages = builder.layoutDocument(docDefinition.content, this.fontProvider, docDefinition.styles || {}, docDefinition.defaultStyle || {
                    fontSize: 12,
                    font: "Roboto"
                  }, docDefinition.background, docDefinition.header, docDefinition.footer, docDefinition.images, docDefinition.watermark, docDefinition.pageBreakBefore);
                  var maxNumberPages = docDefinition.maxPagesNumber || -1;
                  if (isNumber(maxNumberPages) && maxNumberPages > -1) {
                    pages = pages.slice(0, maxNumberPages);
                  }
                  if (pageSize.height === Infinity) {
                    var pageHeight = calculatePageHeight(pages, docDefinition.pageMargins);
                    this.pdfKitDoc.options.size = [pageSize.width, pageHeight];
                  }
                  var patterns = createPatterns(docDefinition.patterns || {}, this.pdfKitDoc);
                  renderPages(pages, this.fontProvider, this.pdfKitDoc, patterns, options.progressCallback);
                  if (options.autoPrint) {
                    var printActionRef = this.pdfKitDoc.ref({
                      Type: "Action",
                      S: "Named",
                      N: "Print"
                    });
                    this.pdfKitDoc._root.data.OpenAction = printActionRef;
                    printActionRef.end();
                  }
                  return this.pdfKitDoc;
                };
                function createMetadata(docDefinition) {
                  function standardizePropertyKey(key2) {
                    var standardProperties = [
                      "Title",
                      "Author",
                      "Subject",
                      "Keywords",
                      "Creator",
                      "Producer",
                      "CreationDate",
                      "ModDate",
                      "Trapped"
                    ];
                    var standardizedKey = key2.charAt(0).toUpperCase() + key2.slice(1);
                    if (standardProperties.indexOf(standardizedKey) !== -1) {
                      return standardizedKey;
                    }
                    return key2.replace(/\s+/g, "");
                  }
                  var info = {
                    Producer: "pdfmake",
                    Creator: "pdfmake"
                  };
                  if (docDefinition.info) {
                    for (var key in docDefinition.info) {
                      var value = docDefinition.info[key];
                      if (value) {
                        key = standardizePropertyKey(key);
                        info[key] = value;
                      }
                    }
                  }
                  return info;
                }
                function calculatePageHeight(pages, margins) {
                  function getItemHeight(item) {
                    if (isFunction(item.item.getHeight)) {
                      return item.item.getHeight();
                    } else if (item.item._height) {
                      return item.item._height;
                    } else if (item.type === "vector") {
                      if (typeof item.item.y1 !== "undefined") {
                        return item.item.y1 > item.item.y2 ? item.item.y1 : item.item.y2;
                      } else {
                        return item.item.h;
                      }
                    } else {
                      return 0;
                    }
                  }
                  function getBottomPosition(item) {
                    var top = item.item.y || 0;
                    var height2 = getItemHeight(item);
                    return top + height2;
                  }
                  var fixedMargins = fixPageMargins(margins || 40);
                  var height = fixedMargins.top;
                  pages.forEach(function(page) {
                    page.items.forEach(function(item) {
                      var bottomPosition = getBottomPosition(item);
                      if (bottomPosition > height) {
                        height = bottomPosition;
                      }
                    });
                  });
                  height += fixedMargins.bottom;
                  return height;
                }
                function fixPageSize(pageSize, pageOrientation) {
                  function isNeedSwapPageSizes(pageOrientation2) {
                    if (isString(pageOrientation2)) {
                      pageOrientation2 = pageOrientation2.toLowerCase();
                      return pageOrientation2 === "portrait" && size.width > size.height || pageOrientation2 === "landscape" && size.width < size.height;
                    }
                    return false;
                  }
                  if (pageSize && pageSize.height === "auto") {
                    pageSize.height = Infinity;
                  }
                  var size = pageSize2widthAndHeight(pageSize || "A4");
                  if (isNeedSwapPageSizes(pageOrientation)) {
                    size = { width: size.height, height: size.width };
                  }
                  size.orientation = size.width > size.height ? "landscape" : "portrait";
                  return size;
                }
                function fixPageMargins(margin) {
                  if (isNumber(margin)) {
                    margin = { left: margin, right: margin, top: margin, bottom: margin };
                  } else if (isArray(margin)) {
                    if (margin.length === 2) {
                      margin = { left: margin[0], top: margin[1], right: margin[0], bottom: margin[1] };
                    } else if (margin.length === 4) {
                      margin = { left: margin[0], top: margin[1], right: margin[2], bottom: margin[3] };
                    } else {
                      throw "Invalid pageMargins definition";
                    }
                  }
                  return margin;
                }
                function registerDefaultTableLayouts(layoutBuilder) {
                  layoutBuilder.registerTableLayouts({
                    noBorders: {
                      hLineWidth: function(i) {
                        return 0;
                      },
                      vLineWidth: function(i) {
                        return 0;
                      },
                      paddingLeft: function(i) {
                        return i && 4 || 0;
                      },
                      paddingRight: function(i, node) {
                        return i < node.table.widths.length - 1 ? 4 : 0;
                      }
                    },
                    headerLineOnly: {
                      hLineWidth: function(i, node) {
                        if (i === 0 || i === node.table.body.length) {
                          return 0;
                        }
                        return i === node.table.headerRows ? 2 : 0;
                      },
                      vLineWidth: function(i) {
                        return 0;
                      },
                      paddingLeft: function(i) {
                        return i === 0 ? 0 : 8;
                      },
                      paddingRight: function(i, node) {
                        return i === node.table.widths.length - 1 ? 0 : 8;
                      }
                    },
                    lightHorizontalLines: {
                      hLineWidth: function(i, node) {
                        if (i === 0 || i === node.table.body.length) {
                          return 0;
                        }
                        return i === node.table.headerRows ? 2 : 1;
                      },
                      vLineWidth: function(i) {
                        return 0;
                      },
                      hLineColor: function(i) {
                        return i === 1 ? "black" : "#aaa";
                      },
                      paddingLeft: function(i) {
                        return i === 0 ? 0 : 8;
                      },
                      paddingRight: function(i, node) {
                        return i === node.table.widths.length - 1 ? 0 : 8;
                      }
                    }
                  });
                }
                function pageSize2widthAndHeight(pageSize) {
                  if (isString(pageSize)) {
                    var size = sizes[pageSize.toUpperCase()];
                    if (!size) {
                      throw "Page size " + pageSize + " not recognized";
                    }
                    return { width: size[0], height: size[1] };
                  }
                  return pageSize;
                }
                function updatePageOrientationInOptions(currentPage, pdfKitDoc) {
                  var previousPageOrientation = pdfKitDoc.options.size[0] > pdfKitDoc.options.size[1] ? "landscape" : "portrait";
                  if (currentPage.pageSize.orientation !== previousPageOrientation) {
                    var width = pdfKitDoc.options.size[0];
                    var height = pdfKitDoc.options.size[1];
                    pdfKitDoc.options.size = [height, width];
                  }
                }
                function renderPages(pages, fontProvider, pdfKitDoc, patterns, progressCallback) {
                  pdfKitDoc._pdfMakePages = pages;
                  pdfKitDoc.addPage();
                  var totalItems = 0;
                  if (progressCallback) {
                    pages.forEach(function(page2) {
                      totalItems += page2.items.length;
                    });
                  }
                  var renderedItems = 0;
                  progressCallback = progressCallback || function() {
                  };
                  for (var i = 0; i < pages.length; i++) {
                    if (i > 0) {
                      updatePageOrientationInOptions(pages[i], pdfKitDoc);
                      pdfKitDoc.addPage(pdfKitDoc.options);
                    }
                    var page = pages[i];
                    for (var ii = 0, il = page.items.length; ii < il; ii++) {
                      var item = page.items[ii];
                      switch (item.type) {
                        case "vector":
                          renderVector(item.item, patterns, pdfKitDoc);
                          break;
                        case "line":
                          renderLine(item.item, item.item.x, item.item.y, patterns, pdfKitDoc);
                          break;
                        case "image":
                          renderImage(item.item, item.item.x, item.item.y, pdfKitDoc);
                          break;
                        case "svg":
                          renderSVG(item.item, item.item.x, item.item.y, pdfKitDoc, fontProvider);
                          break;
                        case "beginClip":
                          beginClip(item.item, pdfKitDoc);
                          break;
                        case "endClip":
                          endClip(pdfKitDoc);
                          break;
                      }
                      renderedItems++;
                      progressCallback(renderedItems / totalItems);
                    }
                    if (page.watermark) {
                      renderWatermark(page, pdfKitDoc);
                    }
                  }
                }
                function offsetText(y, inline) {
                  var newY = y;
                  if (inline.sup) {
                    newY -= inline.fontSize * 0.75;
                  }
                  if (inline.sub) {
                    newY += inline.fontSize * 0.35;
                  }
                  return newY;
                }
                function renderLine(line, x, y, patterns, pdfKitDoc) {
                  function preparePageNodeRefLine(_pageNodeRef, inline2) {
                    var newWidth;
                    var diffWidth;
                    var textTools = new TextTools(null);
                    if (isUndefined(_pageNodeRef.positions)) {
                      throw "Page reference id not found";
                    }
                    var pageNumber = _pageNodeRef.positions[0].pageNumber.toString();
                    inline2.text = pageNumber;
                    newWidth = textTools.widthOfString(inline2.text, inline2.font, inline2.fontSize, inline2.characterSpacing, inline2.fontFeatures);
                    diffWidth = inline2.width - newWidth;
                    inline2.width = newWidth;
                    switch (inline2.alignment) {
                      case "right":
                        inline2.x += diffWidth;
                        break;
                      case "center":
                        inline2.x += diffWidth / 2;
                        break;
                    }
                  }
                  if (line._pageNodeRef) {
                    preparePageNodeRefLine(line._pageNodeRef, line.inlines[0]);
                  }
                  x = x || 0;
                  y = y || 0;
                  var lineHeight = line.getHeight();
                  var ascenderHeight = line.getAscenderHeight();
                  var descent = lineHeight - ascenderHeight;
                  textDecorator.drawBackground(line, x, y, patterns, pdfKitDoc);
                  for (var i = 0, l = line.inlines.length; i < l; i++) {
                    var inline = line.inlines[i];
                    var shiftToBaseline = lineHeight - inline.font.ascender / 1e3 * inline.fontSize - descent;
                    if (inline._pageNodeRef) {
                      preparePageNodeRefLine(inline._pageNodeRef, inline);
                    }
                    var options = {
                      lineBreak: false,
                      textWidth: inline.width,
                      characterSpacing: inline.characterSpacing,
                      wordCount: 1,
                      link: inline.link
                    };
                    if (inline.linkToDestination) {
                      options.goTo = inline.linkToDestination;
                    }
                    if (line.id && i === 0) {
                      options.destination = line.id;
                    }
                    if (inline.fontFeatures) {
                      options.features = inline.fontFeatures;
                    }
                    var opacity = isNumber(inline.opacity) ? inline.opacity : 1;
                    pdfKitDoc.opacity(opacity);
                    pdfKitDoc.fill(inline.color || "black");
                    pdfKitDoc._font = inline.font;
                    pdfKitDoc.fontSize(inline.fontSize);
                    var shiftedY = offsetText(y + shiftToBaseline, inline);
                    pdfKitDoc.text(inline.text, x + inline.x, shiftedY, options);
                    if (inline.linkToPage) {
                      var _ref = pdfKitDoc.ref({ Type: "Action", S: "GoTo", D: [inline.linkToPage, 0, 0] }).end();
                      pdfKitDoc.annotate(x + inline.x, shiftedY, inline.width, inline.height, {
                        Subtype: "Link",
                        Dest: [inline.linkToPage - 1, "XYZ", null, null, null]
                      });
                    }
                  }
                  textDecorator.drawDecorations(line, x, y, pdfKitDoc);
                }
                function renderWatermark(page, pdfKitDoc) {
                  var watermark = page.watermark;
                  pdfKitDoc.fill(watermark.color);
                  pdfKitDoc.opacity(watermark.opacity);
                  pdfKitDoc.save();
                  pdfKitDoc.rotate(watermark.angle, { origin: [pdfKitDoc.page.width / 2, pdfKitDoc.page.height / 2] });
                  var x = pdfKitDoc.page.width / 2 - watermark._size.size.width / 2;
                  var y = pdfKitDoc.page.height / 2 - watermark._size.size.height / 2;
                  pdfKitDoc._font = watermark.font;
                  pdfKitDoc.fontSize(watermark.fontSize);
                  pdfKitDoc.text(watermark.text, x, y, { lineBreak: false });
                  pdfKitDoc.restore();
                }
                function renderVector(vector, patterns, pdfKitDoc) {
                  pdfKitDoc.lineWidth(vector.lineWidth || 1);
                  if (vector.dash) {
                    pdfKitDoc.dash(vector.dash.length, { space: vector.dash.space || vector.dash.length, phase: vector.dash.phase || 0 });
                  } else {
                    pdfKitDoc.undash();
                  }
                  pdfKitDoc.lineJoin(vector.lineJoin || "miter");
                  pdfKitDoc.lineCap(vector.lineCap || "butt");
                  var gradient = null;
                  switch (vector.type) {
                    case "ellipse":
                      pdfKitDoc.ellipse(vector.x, vector.y, vector.r1, vector.r2);
                      if (vector.linearGradient) {
                        gradient = pdfKitDoc.linearGradient(vector.x - vector.r1, vector.y, vector.x + vector.r1, vector.y);
                      }
                      break;
                    case "rect":
                      if (vector.r) {
                        pdfKitDoc.roundedRect(vector.x, vector.y, vector.w, vector.h, vector.r);
                      } else {
                        pdfKitDoc.rect(vector.x, vector.y, vector.w, vector.h);
                      }
                      if (vector.linearGradient) {
                        gradient = pdfKitDoc.linearGradient(vector.x, vector.y, vector.x + vector.w, vector.y);
                      }
                      break;
                    case "line":
                      pdfKitDoc.moveTo(vector.x1, vector.y1);
                      pdfKitDoc.lineTo(vector.x2, vector.y2);
                      break;
                    case "polyline":
                      if (vector.points.length === 0) {
                        break;
                      }
                      pdfKitDoc.moveTo(vector.points[0].x, vector.points[0].y);
                      for (var i = 1, l = vector.points.length; i < l; i++) {
                        pdfKitDoc.lineTo(vector.points[i].x, vector.points[i].y);
                      }
                      if (vector.points.length > 1) {
                        var p1 = vector.points[0];
                        var pn = vector.points[vector.points.length - 1];
                        if (vector.closePath || p1.x === pn.x && p1.y === pn.y) {
                          pdfKitDoc.closePath();
                        }
                      }
                      break;
                    case "path":
                      pdfKitDoc.path(vector.d);
                      break;
                  }
                  if (vector.linearGradient && gradient) {
                    var step = 1 / (vector.linearGradient.length - 1);
                    for (var i = 0; i < vector.linearGradient.length; i++) {
                      gradient.stop(i * step, vector.linearGradient[i]);
                    }
                    vector.color = gradient;
                  }
                  if (isPattern(vector.color)) {
                    vector.color = getPattern(vector.color, patterns);
                  }
                  var fillOpacity = isNumber(vector.fillOpacity) ? vector.fillOpacity : 1;
                  var strokeOpacity = isNumber(vector.strokeOpacity) ? vector.strokeOpacity : 1;
                  if (vector.color && vector.lineColor) {
                    pdfKitDoc.fillColor(vector.color, fillOpacity);
                    pdfKitDoc.strokeColor(vector.lineColor, strokeOpacity);
                    pdfKitDoc.fillAndStroke();
                  } else if (vector.color) {
                    pdfKitDoc.fillColor(vector.color, fillOpacity);
                    pdfKitDoc.fill();
                  } else {
                    pdfKitDoc.strokeColor(vector.lineColor || "black", strokeOpacity);
                    pdfKitDoc.stroke();
                  }
                }
                function renderImage(image, x, y, pdfKitDoc) {
                  var opacity = isNumber(image.opacity) ? image.opacity : 1;
                  pdfKitDoc.opacity(opacity);
                  if (image.cover) {
                    var align = image.cover.align || "center";
                    var valign = image.cover.valign || "center";
                    var width = image.cover.width ? image.cover.width : image.width;
                    var height = image.cover.height ? image.cover.height : image.height;
                    pdfKitDoc.save();
                    pdfKitDoc.rect(image.x, image.y, width, height).clip();
                    pdfKitDoc.image(image.image, image.x, image.y, { cover: [width, height], align, valign });
                    pdfKitDoc.restore();
                  } else {
                    pdfKitDoc.image(image.image, image.x, image.y, { width: image._width, height: image._height });
                  }
                  if (image.link) {
                    pdfKitDoc.link(image.x, image.y, image._width, image._height, image.link);
                  }
                  if (image.linkToPage) {
                    pdfKitDoc.ref({ Type: "Action", S: "GoTo", D: [image.linkToPage, 0, 0] }).end();
                    pdfKitDoc.annotate(image.x, image.y, image._width, image._height, { Subtype: "Link", Dest: [image.linkToPage - 1, "XYZ", null, null, null] });
                  }
                  if (image.linkToDestination) {
                    pdfKitDoc.goTo(image.x, image.y, image._width, image._height, image.linkToDestination);
                  }
                }
                function renderSVG(svg, x, y, pdfKitDoc, fontProvider) {
                  var options = Object.assign({ width: svg._width, height: svg._height, assumePt: true }, svg.options);
                  options.fontCallback = function(family, bold, italic) {
                    var fontsFamily = family.split(",").map(function(f) {
                      return f.trim().replace(/('|")/g, "");
                    });
                    var font = findFont(fontProvider.fonts, fontsFamily, svg.font || "Roboto");
                    var fontFile = fontProvider.getFontFile(font, bold, italic);
                    if (fontFile === null) {
                      var type = fontProvider.getFontType(bold, italic);
                      throw new Error("Font '" + font + "' in style '" + type + "' is not defined in the font section of the document definition.");
                    }
                    return fontFile;
                  };
                  SVGtoPDF(pdfKitDoc, svg.svg, svg.x, svg.y, options);
                }
                function beginClip(rect, pdfKitDoc) {
                  pdfKitDoc.save();
                  pdfKitDoc.addContent("" + rect.x + " " + rect.y + " " + rect.width + " " + rect.height + " re");
                  pdfKitDoc.clip();
                }
                function endClip(pdfKitDoc) {
                  pdfKitDoc.restore();
                }
                function createPatterns(patternDefinitions, pdfKitDoc) {
                  var patterns = {};
                  Object.keys(patternDefinitions).forEach(function(p) {
                    var pattern = patternDefinitions[p];
                    patterns[p] = pdfKitDoc.pattern(pattern.boundingBox, pattern.xStep, pattern.yStep, pattern.pattern, pattern.colored);
                  });
                  return patterns;
                }
                module2.exports = PdfPrinter;
              }
            ),
            /***/
            145: (
              /***/
              function(module2) {
                "use strict";
                var VERSIONS = [
                  null,
                  [[10, 7, 17, 13], [1, 1, 1, 1], []],
                  [[16, 10, 28, 22], [1, 1, 1, 1], [4, 16]],
                  [[26, 15, 22, 18], [1, 1, 2, 2], [4, 20]],
                  [[18, 20, 16, 26], [2, 1, 4, 2], [4, 24]],
                  [[24, 26, 22, 18], [2, 1, 4, 4], [4, 28]],
                  [[16, 18, 28, 24], [4, 2, 4, 4], [4, 32]],
                  [[18, 20, 26, 18], [4, 2, 5, 6], [4, 20, 36]],
                  [[22, 24, 26, 22], [4, 2, 6, 6], [4, 22, 40]],
                  [[22, 30, 24, 20], [5, 2, 8, 8], [4, 24, 44]],
                  [[26, 18, 28, 24], [5, 4, 8, 8], [4, 26, 48]],
                  [[30, 20, 24, 28], [5, 4, 11, 8], [4, 28, 52]],
                  [[22, 24, 28, 26], [8, 4, 11, 10], [4, 30, 56]],
                  [[22, 26, 22, 24], [9, 4, 16, 12], [4, 32, 60]],
                  [[24, 30, 24, 20], [9, 4, 16, 16], [4, 24, 44, 64]],
                  [[24, 22, 24, 30], [10, 6, 18, 12], [4, 24, 46, 68]],
                  [[28, 24, 30, 24], [10, 6, 16, 17], [4, 24, 48, 72]],
                  [[28, 28, 28, 28], [11, 6, 19, 16], [4, 28, 52, 76]],
                  [[26, 30, 28, 28], [13, 6, 21, 18], [4, 28, 54, 80]],
                  [[26, 28, 26, 26], [14, 7, 25, 21], [4, 28, 56, 84]],
                  [[26, 28, 28, 30], [16, 8, 25, 20], [4, 32, 60, 88]],
                  [[26, 28, 30, 28], [17, 8, 25, 23], [4, 26, 48, 70, 92]],
                  [[28, 28, 24, 30], [17, 9, 34, 23], [4, 24, 48, 72, 96]],
                  [[28, 30, 30, 30], [18, 9, 30, 25], [4, 28, 52, 76, 100]],
                  [[28, 30, 30, 30], [20, 10, 32, 27], [4, 26, 52, 78, 104]],
                  [[28, 26, 30, 30], [21, 12, 35, 29], [4, 30, 56, 82, 108]],
                  [[28, 28, 30, 28], [23, 12, 37, 34], [4, 28, 56, 84, 112]],
                  [[28, 30, 30, 30], [25, 12, 40, 34], [4, 32, 60, 88, 116]],
                  [[28, 30, 30, 30], [26, 13, 42, 35], [4, 24, 48, 72, 96, 120]],
                  [[28, 30, 30, 30], [28, 14, 45, 38], [4, 28, 52, 76, 100, 124]],
                  [[28, 30, 30, 30], [29, 15, 48, 40], [4, 24, 50, 76, 102, 128]],
                  [[28, 30, 30, 30], [31, 16, 51, 43], [4, 28, 54, 80, 106, 132]],
                  [[28, 30, 30, 30], [33, 17, 54, 45], [4, 32, 58, 84, 110, 136]],
                  [[28, 30, 30, 30], [35, 18, 57, 48], [4, 28, 56, 84, 112, 140]],
                  [[28, 30, 30, 30], [37, 19, 60, 51], [4, 32, 60, 88, 116, 144]],
                  [[28, 30, 30, 30], [38, 19, 63, 53], [4, 28, 52, 76, 100, 124, 148]],
                  [[28, 30, 30, 30], [40, 20, 66, 56], [4, 22, 48, 74, 100, 126, 152]],
                  [[28, 30, 30, 30], [43, 21, 70, 59], [4, 26, 52, 78, 104, 130, 156]],
                  [[28, 30, 30, 30], [45, 22, 74, 62], [4, 30, 56, 82, 108, 134, 160]],
                  [[28, 30, 30, 30], [47, 24, 77, 65], [4, 24, 52, 80, 108, 136, 164]],
                  [[28, 30, 30, 30], [49, 25, 81, 68], [4, 28, 56, 84, 112, 140, 168]]
                ];
                var MODE_TERMINATOR = 0;
                var MODE_NUMERIC = 1, MODE_ALPHANUMERIC = 2, MODE_OCTET = 4, MODE_KANJI = 8;
                var NUMERIC_REGEXP = /^\d*$/;
                var ALPHANUMERIC_REGEXP = /^[A-Za-z0-9 $%*+\-./:]*$/;
                var ALPHANUMERIC_OUT_REGEXP = /^[A-Z0-9 $%*+\-./:]*$/;
                var ECCLEVEL_L = 1, ECCLEVEL_M = 0, ECCLEVEL_Q = 3, ECCLEVEL_H = 2;
                var GF256_MAP = [], GF256_INVMAP = [-1];
                for (var i = 0, v = 1; i < 255; ++i) {
                  GF256_MAP.push(v);
                  GF256_INVMAP[v] = i;
                  v = v * 2 ^ (v >= 128 ? 285 : 0);
                }
                var GF256_GENPOLY = [[]];
                for (var i = 0; i < 30; ++i) {
                  var prevpoly = GF256_GENPOLY[i], poly = [];
                  for (var j = 0; j <= i; ++j) {
                    var a = j < i ? GF256_MAP[prevpoly[j]] : 0;
                    var b = GF256_MAP[(i + (prevpoly[j - 1] || 0)) % 255];
                    poly.push(GF256_INVMAP[a ^ b]);
                  }
                  GF256_GENPOLY.push(poly);
                }
                var ALPHANUMERIC_MAP = {};
                for (var i = 0; i < 45; ++i) {
                  ALPHANUMERIC_MAP["0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".charAt(i)] = i;
                }
                var MASKFUNCS = [
                  function(i2, j2) {
                    return (i2 + j2) % 2 === 0;
                  },
                  function(i2, j2) {
                    return i2 % 2 === 0;
                  },
                  function(i2, j2) {
                    return j2 % 3 === 0;
                  },
                  function(i2, j2) {
                    return (i2 + j2) % 3 === 0;
                  },
                  function(i2, j2) {
                    return ((i2 / 2 | 0) + (j2 / 3 | 0)) % 2 === 0;
                  },
                  function(i2, j2) {
                    return i2 * j2 % 2 + i2 * j2 % 3 === 0;
                  },
                  function(i2, j2) {
                    return (i2 * j2 % 2 + i2 * j2 % 3) % 2 === 0;
                  },
                  function(i2, j2) {
                    return ((i2 + j2) % 2 + i2 * j2 % 3) % 2 === 0;
                  }
                ];
                var needsverinfo = function(ver) {
                  return ver > 6;
                };
                var getsizebyver = function(ver) {
                  return 4 * ver + 17;
                };
                var nfullbits = function(ver) {
                  var v2 = VERSIONS[ver];
                  var nbits = 16 * ver * ver + 128 * ver + 64;
                  if (needsverinfo(ver))
                    nbits -= 36;
                  if (v2[2].length) {
                    nbits -= 25 * v2[2].length * v2[2].length - 10 * v2[2].length - 55;
                  }
                  return nbits;
                };
                var ndatabits = function(ver, ecclevel) {
                  var nbits = nfullbits(ver) & ~7;
                  var v2 = VERSIONS[ver];
                  nbits -= 8 * v2[0][ecclevel] * v2[1][ecclevel];
                  return nbits;
                };
                var ndatalenbits = function(ver, mode) {
                  switch (mode) {
                    case MODE_NUMERIC:
                      return ver < 10 ? 10 : ver < 27 ? 12 : 14;
                    case MODE_ALPHANUMERIC:
                      return ver < 10 ? 9 : ver < 27 ? 11 : 13;
                    case MODE_OCTET:
                      return ver < 10 ? 8 : 16;
                    case MODE_KANJI:
                      return ver < 10 ? 8 : ver < 27 ? 10 : 12;
                  }
                };
                var getmaxdatalen = function(ver, mode, ecclevel) {
                  var nbits = ndatabits(ver, ecclevel) - 4 - ndatalenbits(ver, mode);
                  switch (mode) {
                    case MODE_NUMERIC:
                      return (nbits / 10 | 0) * 3 + (nbits % 10 < 4 ? 0 : nbits % 10 < 7 ? 1 : 2);
                    case MODE_ALPHANUMERIC:
                      return (nbits / 11 | 0) * 2 + (nbits % 11 < 6 ? 0 : 1);
                    case MODE_OCTET:
                      return nbits / 8 | 0;
                    case MODE_KANJI:
                      return nbits / 13 | 0;
                  }
                };
                var validatedata = function(mode, data) {
                  switch (mode) {
                    case MODE_NUMERIC:
                      if (!data.match(NUMERIC_REGEXP))
                        return null;
                      return data;
                    case MODE_ALPHANUMERIC:
                      if (!data.match(ALPHANUMERIC_REGEXP))
                        return null;
                      return data.toUpperCase();
                    case MODE_OCTET:
                      if (typeof data === "string") {
                        var newdata = [];
                        for (var i2 = 0; i2 < data.length; ++i2) {
                          var ch = data.charCodeAt(i2);
                          if (ch < 128) {
                            newdata.push(ch);
                          } else if (ch < 2048) {
                            newdata.push(
                              192 | ch >> 6,
                              128 | ch & 63
                            );
                          } else if (ch < 65536) {
                            newdata.push(
                              224 | ch >> 12,
                              128 | ch >> 6 & 63,
                              128 | ch & 63
                            );
                          } else {
                            newdata.push(
                              240 | ch >> 18,
                              128 | ch >> 12 & 63,
                              128 | ch >> 6 & 63,
                              128 | ch & 63
                            );
                          }
                        }
                        return newdata;
                      } else {
                        return data;
                      }
                  }
                };
                var encode = function(ver, mode, data, maxbuflen) {
                  var buf = [];
                  var bits = 0, remaining = 8;
                  var datalen = data.length;
                  var pack = function(x, n) {
                    if (n >= remaining) {
                      buf.push(bits | x >> (n -= remaining));
                      while (n >= 8)
                        buf.push(x >> (n -= 8) & 255);
                      bits = 0;
                      remaining = 8;
                    }
                    if (n > 0)
                      bits |= (x & (1 << n) - 1) << (remaining -= n);
                  };
                  var nlenbits = ndatalenbits(ver, mode);
                  pack(mode, 4);
                  pack(datalen, nlenbits);
                  switch (mode) {
                    case MODE_NUMERIC:
                      for (var i2 = 2; i2 < datalen; i2 += 3) {
                        pack(parseInt(data.substring(i2 - 2, i2 + 1), 10), 10);
                      }
                      pack(parseInt(data.substring(i2 - 2), 10), [0, 4, 7][datalen % 3]);
                      break;
                    case MODE_ALPHANUMERIC:
                      for (var i2 = 1; i2 < datalen; i2 += 2) {
                        pack(ALPHANUMERIC_MAP[data.charAt(i2 - 1)] * 45 + ALPHANUMERIC_MAP[data.charAt(i2)], 11);
                      }
                      if (datalen % 2 == 1) {
                        pack(ALPHANUMERIC_MAP[data.charAt(i2 - 1)], 6);
                      }
                      break;
                    case MODE_OCTET:
                      for (var i2 = 0; i2 < datalen; ++i2) {
                        pack(data[i2], 8);
                      }
                      break;
                  }
                  pack(MODE_TERMINATOR, 4);
                  if (remaining < 8)
                    buf.push(bits);
                  while (buf.length + 1 < maxbuflen)
                    buf.push(236, 17);
                  if (buf.length < maxbuflen)
                    buf.push(236);
                  return buf;
                };
                var calculateecc = function(poly2, genpoly) {
                  var modulus = poly2.slice(0);
                  var polylen = poly2.length, genpolylen = genpoly.length;
                  for (var i2 = 0; i2 < genpolylen; ++i2)
                    modulus.push(0);
                  for (var i2 = 0; i2 < polylen; ) {
                    var quotient = GF256_INVMAP[modulus[i2++]];
                    if (quotient >= 0) {
                      for (var j2 = 0; j2 < genpolylen; ++j2) {
                        modulus[i2 + j2] ^= GF256_MAP[(quotient + genpoly[j2]) % 255];
                      }
                    }
                  }
                  return modulus.slice(polylen);
                };
                var augumenteccs = function(poly2, nblocks, genpoly) {
                  var subsizes = [];
                  var subsize = poly2.length / nblocks | 0, subsize0 = 0;
                  var pivot = nblocks - poly2.length % nblocks;
                  for (var i2 = 0; i2 < pivot; ++i2) {
                    subsizes.push(subsize0);
                    subsize0 += subsize;
                  }
                  for (var i2 = pivot; i2 < nblocks; ++i2) {
                    subsizes.push(subsize0);
                    subsize0 += subsize + 1;
                  }
                  subsizes.push(subsize0);
                  var eccs = [];
                  for (var i2 = 0; i2 < nblocks; ++i2) {
                    eccs.push(calculateecc(poly2.slice(subsizes[i2], subsizes[i2 + 1]), genpoly));
                  }
                  var result = [];
                  var nitemsperblock = poly2.length / nblocks | 0;
                  for (var i2 = 0; i2 < nitemsperblock; ++i2) {
                    for (var j2 = 0; j2 < nblocks; ++j2) {
                      result.push(poly2[subsizes[j2] + i2]);
                    }
                  }
                  for (var j2 = pivot; j2 < nblocks; ++j2) {
                    result.push(poly2[subsizes[j2 + 1] - 1]);
                  }
                  for (var i2 = 0; i2 < genpoly.length; ++i2) {
                    for (var j2 = 0; j2 < nblocks; ++j2) {
                      result.push(eccs[j2][i2]);
                    }
                  }
                  return result;
                };
                var augumentbch = function(poly2, p, genpoly, q) {
                  var modulus = poly2 << q;
                  for (var i2 = p - 1; i2 >= 0; --i2) {
                    if (modulus >> q + i2 & 1)
                      modulus ^= genpoly << i2;
                  }
                  return poly2 << q | modulus;
                };
                var makebasematrix = function(ver) {
                  var v2 = VERSIONS[ver], n = getsizebyver(ver);
                  var matrix = [], reserved = [];
                  for (var i2 = 0; i2 < n; ++i2) {
                    matrix.push([]);
                    reserved.push([]);
                  }
                  var blit = function(y, x, h, w, bits) {
                    for (var i3 = 0; i3 < h; ++i3) {
                      for (var j3 = 0; j3 < w; ++j3) {
                        matrix[y + i3][x + j3] = bits[i3] >> j3 & 1;
                        reserved[y + i3][x + j3] = 1;
                      }
                    }
                  };
                  blit(0, 0, 9, 9, [127, 65, 93, 93, 93, 65, 383, 0, 64]);
                  blit(n - 8, 0, 8, 9, [256, 127, 65, 93, 93, 93, 65, 127]);
                  blit(0, n - 8, 9, 8, [254, 130, 186, 186, 186, 130, 254, 0, 0]);
                  for (var i2 = 9; i2 < n - 8; ++i2) {
                    matrix[6][i2] = matrix[i2][6] = ~i2 & 1;
                    reserved[6][i2] = reserved[i2][6] = 1;
                  }
                  var aligns = v2[2], m = aligns.length;
                  for (var i2 = 0; i2 < m; ++i2) {
                    var minj = i2 === 0 || i2 === m - 1 ? 1 : 0, maxj = i2 === 0 ? m - 1 : m;
                    for (var j2 = minj; j2 < maxj; ++j2) {
                      blit(aligns[i2], aligns[j2], 5, 5, [31, 17, 21, 17, 31]);
                    }
                  }
                  if (needsverinfo(ver)) {
                    var code = augumentbch(ver, 6, 7973, 12);
                    var k = 0;
                    for (var i2 = 0; i2 < 6; ++i2) {
                      for (var j2 = 0; j2 < 3; ++j2) {
                        matrix[i2][n - 11 + j2] = matrix[n - 11 + j2][i2] = code >> k++ & 1;
                        reserved[i2][n - 11 + j2] = reserved[n - 11 + j2][i2] = 1;
                      }
                    }
                  }
                  return { matrix, reserved };
                };
                var putdata = function(matrix, reserved, buf) {
                  var n = matrix.length;
                  var k = 0, dir = -1;
                  for (var i2 = n - 1; i2 >= 0; i2 -= 2) {
                    if (i2 == 6)
                      --i2;
                    var jj = dir < 0 ? n - 1 : 0;
                    for (var j2 = 0; j2 < n; ++j2) {
                      for (var ii = i2; ii > i2 - 2; --ii) {
                        if (!reserved[jj][ii]) {
                          matrix[jj][ii] = buf[k >> 3] >> (~k & 7) & 1;
                          ++k;
                        }
                      }
                      jj += dir;
                    }
                    dir = -dir;
                  }
                  return matrix;
                };
                var maskdata = function(matrix, reserved, mask) {
                  var maskf = MASKFUNCS[mask];
                  var n = matrix.length;
                  for (var i2 = 0; i2 < n; ++i2) {
                    for (var j2 = 0; j2 < n; ++j2) {
                      if (!reserved[i2][j2])
                        matrix[i2][j2] ^= maskf(i2, j2);
                    }
                  }
                  return matrix;
                };
                var putformatinfo = function(matrix, reserved, ecclevel, mask) {
                  var n = matrix.length;
                  var code = augumentbch(ecclevel << 3 | mask, 5, 1335, 10) ^ 21522;
                  for (var i2 = 0; i2 < 15; ++i2) {
                    var r = [0, 1, 2, 3, 4, 5, 7, 8, n - 7, n - 6, n - 5, n - 4, n - 3, n - 2, n - 1][i2];
                    var c = [n - 1, n - 2, n - 3, n - 4, n - 5, n - 6, n - 7, n - 8, 7, 5, 4, 3, 2, 1, 0][i2];
                    matrix[r][8] = matrix[8][c] = code >> i2 & 1;
                  }
                  return matrix;
                };
                var evaluatematrix = function(matrix) {
                  var PENALTY_CONSECUTIVE = 3;
                  var PENALTY_TWOBYTWO = 3;
                  var PENALTY_FINDERLIKE = 40;
                  var PENALTY_DENSITY = 10;
                  var evaluategroup = function(groups2) {
                    var score2 = 0;
                    for (var i3 = 0; i3 < groups2.length; ++i3) {
                      if (groups2[i3] >= 5)
                        score2 += PENALTY_CONSECUTIVE + (groups2[i3] - 5);
                    }
                    for (var i3 = 5; i3 < groups2.length; i3 += 2) {
                      var p2 = groups2[i3];
                      if (groups2[i3 - 1] == p2 && groups2[i3 - 2] == 3 * p2 && groups2[i3 - 3] == p2 && groups2[i3 - 4] == p2 && (groups2[i3 - 5] >= 4 * p2 || groups2[i3 + 1] >= 4 * p2)) {
                        score2 += PENALTY_FINDERLIKE;
                      }
                    }
                    return score2;
                  };
                  var n = matrix.length;
                  var score = 0, nblacks = 0;
                  for (var i2 = 0; i2 < n; ++i2) {
                    var row = matrix[i2];
                    var groups;
                    groups = [0];
                    for (var j2 = 0; j2 < n; ) {
                      var k;
                      for (k = 0; j2 < n && row[j2]; ++k)
                        ++j2;
                      groups.push(k);
                      for (k = 0; j2 < n && !row[j2]; ++k)
                        ++j2;
                      groups.push(k);
                    }
                    score += evaluategroup(groups);
                    groups = [0];
                    for (var j2 = 0; j2 < n; ) {
                      var k;
                      for (k = 0; j2 < n && matrix[j2][i2]; ++k)
                        ++j2;
                      groups.push(k);
                      for (k = 0; j2 < n && !matrix[j2][i2]; ++k)
                        ++j2;
                      groups.push(k);
                    }
                    score += evaluategroup(groups);
                    var nextrow = matrix[i2 + 1] || [];
                    nblacks += row[0];
                    for (var j2 = 1; j2 < n; ++j2) {
                      var p = row[j2];
                      nblacks += p;
                      if (row[j2 - 1] == p && nextrow[j2] === p && nextrow[j2 - 1] === p) {
                        score += PENALTY_TWOBYTWO;
                      }
                    }
                  }
                  score += PENALTY_DENSITY * (Math.abs(nblacks / n / n - 0.5) / 0.05 | 0);
                  return score;
                };
                var generate = function(data, ver, mode, ecclevel, mask) {
                  var v2 = VERSIONS[ver];
                  var buf = encode(ver, mode, data, ndatabits(ver, ecclevel) >> 3);
                  buf = augumenteccs(buf, v2[1][ecclevel], GF256_GENPOLY[v2[0][ecclevel]]);
                  var result = makebasematrix(ver);
                  var matrix = result.matrix, reserved = result.reserved;
                  putdata(matrix, reserved, buf);
                  if (mask < 0) {
                    maskdata(matrix, reserved, 0);
                    putformatinfo(matrix, reserved, ecclevel, 0);
                    var bestmask = 0, bestscore = evaluatematrix(matrix);
                    maskdata(matrix, reserved, 0);
                    for (mask = 1; mask < 8; ++mask) {
                      maskdata(matrix, reserved, mask);
                      putformatinfo(matrix, reserved, ecclevel, mask);
                      var score = evaluatematrix(matrix);
                      if (bestscore > score) {
                        bestscore = score;
                        bestmask = mask;
                      }
                      maskdata(matrix, reserved, mask);
                    }
                    mask = bestmask;
                  }
                  maskdata(matrix, reserved, mask);
                  putformatinfo(matrix, reserved, ecclevel, mask);
                  return matrix;
                };
                function generateFrame(data, options) {
                  var MODES = {
                    "numeric": MODE_NUMERIC,
                    "alphanumeric": MODE_ALPHANUMERIC,
                    "octet": MODE_OCTET
                  };
                  var ECCLEVELS = {
                    "L": ECCLEVEL_L,
                    "M": ECCLEVEL_M,
                    "Q": ECCLEVEL_Q,
                    "H": ECCLEVEL_H
                  };
                  options = options || {};
                  var ver = options.version || -1;
                  var ecclevel = ECCLEVELS[(options.eccLevel || "L").toUpperCase()];
                  var mode = options.mode ? MODES[options.mode.toLowerCase()] : -1;
                  var mask = "mask" in options ? options.mask : -1;
                  if (mode < 0) {
                    if (typeof data === "string") {
                      if (data.match(NUMERIC_REGEXP)) {
                        mode = MODE_NUMERIC;
                      } else if (data.match(ALPHANUMERIC_OUT_REGEXP)) {
                        mode = MODE_ALPHANUMERIC;
                      } else {
                        mode = MODE_OCTET;
                      }
                    } else {
                      mode = MODE_OCTET;
                    }
                  } else if (!(mode == MODE_NUMERIC || mode == MODE_ALPHANUMERIC || mode == MODE_OCTET)) {
                    throw "invalid or unsupported mode";
                  }
                  data = validatedata(mode, data);
                  if (data === null)
                    throw "invalid data format";
                  if (ecclevel < 0 || ecclevel > 3)
                    throw "invalid ECC level";
                  if (ver < 0) {
                    for (ver = 1; ver <= 40; ++ver) {
                      if (data.length <= getmaxdatalen(ver, mode, ecclevel))
                        break;
                    }
                    if (ver > 40)
                      throw "too large data for the Qr format";
                  } else if (ver < 1 || ver > 40) {
                    throw "invalid Qr version! should be between 1 and 40";
                  }
                  if (mask != -1 && (mask < 0 || mask > 8))
                    throw "invalid mask";
                  return generate(data, ver, mode, ecclevel, mask);
                }
                function buildCanvas(data, options) {
                  var canvas = [];
                  var background = options.background || "#fff";
                  var foreground = options.foreground || "#000";
                  var matrix = generateFrame(data, options);
                  var n = matrix.length;
                  var modSize = Math.floor(options.fit ? options.fit / n : 5);
                  var size = n * modSize;
                  canvas.push({
                    type: "rect",
                    x: 0,
                    y: 0,
                    w: size,
                    h: size,
                    lineWidth: 0,
                    color: background
                  });
                  for (var i2 = 0; i2 < n; ++i2) {
                    for (var j2 = 0; j2 < n; ++j2) {
                      if (matrix[i2][j2]) {
                        canvas.push({
                          type: "rect",
                          x: modSize * j2,
                          y: modSize * i2,
                          w: modSize,
                          h: modSize,
                          lineWidth: 0,
                          color: foreground
                        });
                      }
                    }
                  }
                  return {
                    canvas,
                    size
                  };
                }
                function measure(node) {
                  var cd = buildCanvas(node.qr, node);
                  node._canvas = cd.canvas;
                  node._width = node._height = node._minWidth = node._maxWidth = node._minHeight = node._maxHeight = cd.size;
                  return node;
                }
                module2.exports = {
                  measure
                };
              }
            ),
            /***/
            4762: (
              /***/
              function(module2) {
                "use strict";
                module2.exports = {
                  "4A0": [4767.87, 6740.79],
                  "2A0": [3370.39, 4767.87],
                  A0: [2383.94, 3370.39],
                  A1: [1683.78, 2383.94],
                  A2: [1190.55, 1683.78],
                  A3: [841.89, 1190.55],
                  A4: [595.28, 841.89],
                  A5: [419.53, 595.28],
                  A6: [297.64, 419.53],
                  A7: [209.76, 297.64],
                  A8: [147.4, 209.76],
                  A9: [104.88, 147.4],
                  A10: [73.7, 104.88],
                  B0: [2834.65, 4008.19],
                  B1: [2004.09, 2834.65],
                  B2: [1417.32, 2004.09],
                  B3: [1000.63, 1417.32],
                  B4: [708.66, 1000.63],
                  B5: [498.9, 708.66],
                  B6: [354.33, 498.9],
                  B7: [249.45, 354.33],
                  B8: [175.75, 249.45],
                  B9: [124.72, 175.75],
                  B10: [87.87, 124.72],
                  C0: [2599.37, 3676.54],
                  C1: [1836.85, 2599.37],
                  C2: [1298.27, 1836.85],
                  C3: [918.43, 1298.27],
                  C4: [649.13, 918.43],
                  C5: [459.21, 649.13],
                  C6: [323.15, 459.21],
                  C7: [229.61, 323.15],
                  C8: [161.57, 229.61],
                  C9: [113.39, 161.57],
                  C10: [79.37, 113.39],
                  RA0: [2437.8, 3458.27],
                  RA1: [1729.13, 2437.8],
                  RA2: [1218.9, 1729.13],
                  RA3: [864.57, 1218.9],
                  RA4: [609.45, 864.57],
                  SRA0: [2551.18, 3628.35],
                  SRA1: [1814.17, 2551.18],
                  SRA2: [1275.59, 1814.17],
                  SRA3: [907.09, 1275.59],
                  SRA4: [637.8, 907.09],
                  EXECUTIVE: [521.86, 756],
                  FOLIO: [612, 936],
                  LEGAL: [612, 1008],
                  LETTER: [612, 792],
                  TABLOID: [792, 1224]
                };
              }
            ),
            /***/
            7597: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isString = __webpack_require__2(6225).isString;
                var isArray = __webpack_require__2(6225).isArray;
                var isUndefined = __webpack_require__2(6225).isUndefined;
                var isNull = __webpack_require__2(6225).isNull;
                function StyleContextStack(styleDictionary, defaultStyle) {
                  this.defaultStyle = defaultStyle || {};
                  this.styleDictionary = styleDictionary;
                  this.styleOverrides = [];
                }
                StyleContextStack.prototype.clone = function() {
                  var stack = new StyleContextStack(this.styleDictionary, this.defaultStyle);
                  this.styleOverrides.forEach(function(item) {
                    stack.styleOverrides.push(item);
                  });
                  return stack;
                };
                StyleContextStack.prototype.push = function(styleNameOrOverride) {
                  this.styleOverrides.push(styleNameOrOverride);
                };
                StyleContextStack.prototype.pop = function(howMany) {
                  howMany = howMany || 1;
                  while (howMany-- > 0) {
                    this.styleOverrides.pop();
                  }
                };
                StyleContextStack.prototype.autopush = function(item) {
                  if (isString(item)) {
                    return 0;
                  }
                  var styleNames = [];
                  if (item.style) {
                    if (isArray(item.style)) {
                      styleNames = item.style;
                    } else {
                      styleNames = [item.style];
                    }
                  }
                  for (var i = 0, l = styleNames.length; i < l; i++) {
                    this.push(styleNames[i]);
                  }
                  var styleProperties = [
                    "font",
                    "fontSize",
                    "fontFeatures",
                    "bold",
                    "italics",
                    "alignment",
                    "color",
                    "columnGap",
                    "fillColor",
                    "fillOpacity",
                    "decoration",
                    "decorationStyle",
                    "decorationColor",
                    "background",
                    "lineHeight",
                    "characterSpacing",
                    "noWrap",
                    "markerColor",
                    "leadingIndent",
                    "sup",
                    "sub"
                    //'tableCellPadding'
                    // 'cellBorder',
                    // 'headerCellBorder',
                    // 'oddRowCellBorder',
                    // 'evenRowCellBorder',
                    // 'tableBorder'
                  ];
                  var styleOverrideObject = {};
                  var pushStyleOverrideObject = false;
                  styleProperties.forEach(function(key) {
                    if (!isUndefined(item[key]) && !isNull(item[key])) {
                      styleOverrideObject[key] = item[key];
                      pushStyleOverrideObject = true;
                    }
                  });
                  if (pushStyleOverrideObject) {
                    this.push(styleOverrideObject);
                  }
                  return styleNames.length + (pushStyleOverrideObject ? 1 : 0);
                };
                StyleContextStack.prototype.auto = function(item, callback) {
                  var pushedItems = this.autopush(item);
                  var result = callback();
                  if (pushedItems > 0) {
                    this.pop(pushedItems);
                  }
                  return result;
                };
                StyleContextStack.prototype.getProperty = function(property) {
                  if (this.styleOverrides) {
                    for (var i = this.styleOverrides.length - 1; i >= 0; i--) {
                      var item = this.styleOverrides[i];
                      if (isString(item)) {
                        var style = this.styleDictionary[item];
                        if (style && !isUndefined(style[property]) && !isNull(style[property])) {
                          return style[property];
                        }
                      } else if (!isUndefined(item[property]) && !isNull(item[property])) {
                        return item[property];
                      }
                    }
                  }
                  return this.defaultStyle && this.defaultStyle[property];
                };
                module2.exports = StyleContextStack;
              }
            ),
            /***/
            7601: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var xmldoc = __webpack_require__2(6513);
                function stripUnits(textVal) {
                  var n = parseFloat(textVal);
                  if (typeof n !== "number" || isNaN(n)) {
                    return void 0;
                  }
                  return n;
                }
                function parseSVG(svgString) {
                  var doc;
                  try {
                    doc = new xmldoc.XmlDocument(svgString);
                  } catch (err) {
                    throw new Error("SVGMeasure: " + err);
                  }
                  if (doc.name !== "svg") {
                    throw new Error("SVGMeasure: expected <svg> document");
                  }
                  return doc;
                }
                function SVGMeasure() {
                }
                SVGMeasure.prototype.measureSVG = function(svgString) {
                  var doc = parseSVG(svgString);
                  var docWidth = stripUnits(doc.attr.width);
                  var docHeight = stripUnits(doc.attr.height);
                  if ((docWidth == void 0 || docHeight == void 0) && typeof doc.attr.viewBox == "string") {
                    var viewBoxParts = doc.attr.viewBox.split(/[,\s]+/);
                    if (viewBoxParts.length !== 4) {
                      throw new Error("Unexpected svg viewbox format, should have 4 entries but found: '" + doc.attr.viewBox + "'");
                    }
                    if (docWidth == void 0) {
                      docWidth = stripUnits(viewBoxParts[2]);
                    }
                    if (docHeight == void 0) {
                      docHeight = stripUnits(viewBoxParts[3]);
                    }
                  }
                  return {
                    width: docWidth,
                    height: docHeight
                  };
                };
                SVGMeasure.prototype.writeDimensions = function(svgString, dimensions) {
                  var doc = parseSVG(svgString);
                  doc.attr.width = "" + dimensions.width;
                  doc.attr.height = "" + dimensions.height;
                  return doc.toString();
                };
                module2.exports = SVGMeasure;
              }
            ),
            /***/
            9342: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ColumnCalculator = __webpack_require__2(4498);
                var isFunction = __webpack_require__2(6225).isFunction;
                var isNumber = __webpack_require__2(6225).isNumber;
                function TableProcessor(tableNode) {
                  this.tableNode = tableNode;
                }
                TableProcessor.prototype.beginTable = function(writer) {
                  var tableNode;
                  var availableWidth;
                  var self2 = this;
                  tableNode = this.tableNode;
                  this.offsets = tableNode._offsets;
                  this.layout = tableNode._layout;
                  availableWidth = writer.context().availableWidth - this.offsets.total;
                  ColumnCalculator.buildColumnWidths(tableNode.table.widths, availableWidth);
                  this.tableWidth = tableNode._offsets.total + getTableInnerContentWidth();
                  this.rowSpanData = prepareRowSpanData();
                  this.cleanUpRepeatables = false;
                  this.headerRows = tableNode.table.headerRows || 0;
                  this.rowsWithoutPageBreak = this.headerRows + (tableNode.table.keepWithHeaderRows || 0);
                  this.dontBreakRows = tableNode.table.dontBreakRows || false;
                  if (this.rowsWithoutPageBreak) {
                    writer.beginUnbreakableBlock();
                  }
                  prepareCellBorders(this.tableNode.table.body);
                  this.drawHorizontalLine(0, writer);
                  function getTableInnerContentWidth() {
                    var width = 0;
                    tableNode.table.widths.forEach(function(w) {
                      width += w._calcWidth;
                    });
                    return width;
                  }
                  function prepareRowSpanData() {
                    var rsd = [];
                    var x = 0;
                    var lastWidth = 0;
                    rsd.push({ left: 0, rowSpan: 0 });
                    for (var i = 0, l = self2.tableNode.table.body[0].length; i < l; i++) {
                      var paddings = self2.layout.paddingLeft(i, self2.tableNode) + self2.layout.paddingRight(i, self2.tableNode);
                      var lBorder = self2.layout.vLineWidth(i, self2.tableNode);
                      lastWidth = paddings + lBorder + self2.tableNode.table.widths[i]._calcWidth;
                      rsd[rsd.length - 1].width = lastWidth;
                      x += lastWidth;
                      rsd.push({ left: x, rowSpan: 0, width: 0 });
                    }
                    return rsd;
                  }
                  function prepareCellBorders(body) {
                    for (var rowIndex = 0; rowIndex < body.length; rowIndex++) {
                      var row = body[rowIndex];
                      for (var colIndex = 0; colIndex < row.length; colIndex++) {
                        var cell = row[colIndex];
                        if (cell.border) {
                          var rowSpan = cell.rowSpan || 1;
                          var colSpan = cell.colSpan || 1;
                          for (var rowOffset = 0; rowOffset < rowSpan; rowOffset++) {
                            if (cell.border[0] !== void 0 && rowOffset > 0) {
                              setBorder(rowIndex + rowOffset, colIndex, 0, cell.border[0]);
                            }
                            if (cell.border[2] !== void 0) {
                              setBorder(rowIndex + rowOffset, colIndex + colSpan - 1, 2, cell.border[2]);
                            }
                          }
                          for (var colOffset = 0; colOffset < colSpan; colOffset++) {
                            if (cell.border[1] !== void 0 && colOffset > 0) {
                              setBorder(rowIndex, colIndex + colOffset, 1, cell.border[1]);
                            }
                            if (cell.border[3] !== void 0) {
                              setBorder(rowIndex + rowSpan - 1, colIndex + colOffset, 3, cell.border[3]);
                            }
                          }
                        }
                      }
                    }
                    function setBorder(rowIndex2, colIndex2, borderIndex, borderValue) {
                      var cell2 = body[rowIndex2][colIndex2];
                      cell2.border = cell2.border || {};
                      cell2.border[borderIndex] = borderValue;
                    }
                  }
                };
                TableProcessor.prototype.onRowBreak = function(rowIndex, writer) {
                  var self2 = this;
                  return function() {
                    var offset = self2.rowPaddingTop + (!self2.headerRows ? self2.topLineWidth : 0);
                    writer.context().availableHeight -= self2.reservedAtBottom;
                    writer.context().moveDown(offset);
                  };
                };
                TableProcessor.prototype.beginRow = function(rowIndex, writer) {
                  this.topLineWidth = this.layout.hLineWidth(rowIndex, this.tableNode);
                  this.rowPaddingTop = this.layout.paddingTop(rowIndex, this.tableNode);
                  this.bottomLineWidth = this.layout.hLineWidth(rowIndex + 1, this.tableNode);
                  this.rowPaddingBottom = this.layout.paddingBottom(rowIndex, this.tableNode);
                  this.rowCallback = this.onRowBreak(rowIndex, writer);
                  writer.tracker.startTracking("pageChanged", this.rowCallback);
                  if (this.dontBreakRows) {
                    writer.beginUnbreakableBlock();
                  }
                  this.rowTopY = writer.context().y;
                  this.reservedAtBottom = this.bottomLineWidth + this.rowPaddingBottom;
                  writer.context().availableHeight -= this.reservedAtBottom;
                  writer.context().moveDown(this.rowPaddingTop);
                };
                TableProcessor.prototype.drawHorizontalLine = function(lineIndex, writer, overrideY) {
                  var lineWidth = this.layout.hLineWidth(lineIndex, this.tableNode);
                  if (lineWidth) {
                    var style = this.layout.hLineStyle(lineIndex, this.tableNode);
                    var dash;
                    if (style && style.dash) {
                      dash = style.dash;
                    }
                    var offset = lineWidth / 2;
                    var currentLine = null;
                    var body = this.tableNode.table.body;
                    var cellAbove;
                    var currentCell;
                    var rowCellAbove;
                    for (var i = 0, l = this.rowSpanData.length; i < l; i++) {
                      var data = this.rowSpanData[i];
                      var shouldDrawLine = !data.rowSpan;
                      var borderColor = null;
                      if (shouldDrawLine && i < l - 1) {
                        var topBorder = false, bottomBorder = false, rowBottomBorder = false;
                        if (lineIndex > 0) {
                          cellAbove = body[lineIndex - 1][i];
                          bottomBorder = cellAbove.border ? cellAbove.border[3] : this.layout.defaultBorder;
                          if (bottomBorder && cellAbove.borderColor) {
                            borderColor = cellAbove.borderColor[3];
                          }
                        }
                        if (lineIndex < body.length) {
                          currentCell = body[lineIndex][i];
                          topBorder = currentCell.border ? currentCell.border[1] : this.layout.defaultBorder;
                          if (topBorder && borderColor == null && currentCell.borderColor) {
                            borderColor = currentCell.borderColor[1];
                          }
                        }
                        shouldDrawLine = topBorder || bottomBorder;
                      }
                      if (cellAbove && cellAbove._rowSpanCurrentOffset) {
                        rowCellAbove = body[lineIndex - 1 - cellAbove._rowSpanCurrentOffset][i];
                        rowBottomBorder = rowCellAbove && rowCellAbove.border ? rowCellAbove.border[3] : this.layout.defaultBorder;
                        if (rowBottomBorder && rowCellAbove && rowCellAbove.borderColor) {
                          borderColor = rowCellAbove.borderColor[3];
                        }
                      }
                      if (borderColor == null) {
                        borderColor = isFunction(this.layout.hLineColor) ? this.layout.hLineColor(lineIndex, this.tableNode, i) : this.layout.hLineColor;
                      }
                      if (!currentLine && shouldDrawLine) {
                        currentLine = { left: data.left, width: 0 };
                      }
                      if (shouldDrawLine) {
                        var colSpanIndex = 0;
                        if (rowCellAbove && rowCellAbove.colSpan && rowBottomBorder) {
                          while (rowCellAbove.colSpan > colSpanIndex) {
                            currentLine.width += this.rowSpanData[i + colSpanIndex++].width || 0;
                          }
                          i += colSpanIndex - 1;
                        } else if (cellAbove && cellAbove.colSpan && bottomBorder) {
                          while (cellAbove.colSpan > colSpanIndex) {
                            currentLine.width += this.rowSpanData[i + colSpanIndex++].width || 0;
                          }
                          i += colSpanIndex - 1;
                        } else if (currentCell && currentCell.colSpan && topBorder) {
                          while (currentCell.colSpan > colSpanIndex) {
                            currentLine.width += this.rowSpanData[i + colSpanIndex++].width || 0;
                          }
                          i += colSpanIndex - 1;
                        } else {
                          currentLine.width += this.rowSpanData[i].width || 0;
                        }
                      }
                      var y = (overrideY || 0) + offset;
                      if (shouldDrawLine) {
                        if (currentLine && currentLine.width) {
                          writer.addVector({
                            type: "line",
                            x1: currentLine.left,
                            x2: currentLine.left + currentLine.width,
                            y1: y,
                            y2: y,
                            lineWidth,
                            dash,
                            lineColor: borderColor
                          }, false, overrideY);
                          currentLine = null;
                          borderColor = null;
                          cellAbove = null;
                          currentCell = null;
                          rowCellAbove = null;
                        }
                      }
                    }
                    writer.context().moveDown(lineWidth);
                  }
                };
                TableProcessor.prototype.drawVerticalLine = function(x, y0, y1, vLineColIndex, writer, vLineRowIndex, beforeVLineColIndex) {
                  var width = this.layout.vLineWidth(vLineColIndex, this.tableNode);
                  if (width === 0) {
                    return;
                  }
                  var style = this.layout.vLineStyle(vLineColIndex, this.tableNode);
                  var dash;
                  if (style && style.dash) {
                    dash = style.dash;
                  }
                  var body = this.tableNode.table.body;
                  var cellBefore;
                  var currentCell;
                  var borderColor;
                  if (vLineColIndex > 0) {
                    cellBefore = body[vLineRowIndex][beforeVLineColIndex];
                    if (cellBefore && cellBefore.borderColor) {
                      if (cellBefore.border ? cellBefore.border[2] : this.layout.defaultBorder) {
                        borderColor = cellBefore.borderColor[2];
                      }
                    }
                  }
                  if (borderColor == null && vLineColIndex < body.length) {
                    currentCell = body[vLineRowIndex][vLineColIndex];
                    if (currentCell && currentCell.borderColor) {
                      if (currentCell.border ? currentCell.border[0] : this.layout.defaultBorder) {
                        borderColor = currentCell.borderColor[0];
                      }
                    }
                  }
                  if (borderColor == null && cellBefore && cellBefore._rowSpanCurrentOffset) {
                    var rowCellBeforeAbove = body[vLineRowIndex - cellBefore._rowSpanCurrentOffset][beforeVLineColIndex];
                    if (rowCellBeforeAbove.borderColor) {
                      if (rowCellBeforeAbove.border ? rowCellBeforeAbove.border[2] : this.layout.defaultBorder) {
                        borderColor = rowCellBeforeAbove.borderColor[2];
                      }
                    }
                  }
                  if (borderColor == null && currentCell && currentCell._rowSpanCurrentOffset) {
                    var rowCurrentCellAbove = body[vLineRowIndex - currentCell._rowSpanCurrentOffset][vLineColIndex];
                    if (rowCurrentCellAbove.borderColor) {
                      if (rowCurrentCellAbove.border ? rowCurrentCellAbove.border[2] : this.layout.defaultBorder) {
                        borderColor = rowCurrentCellAbove.borderColor[2];
                      }
                    }
                  }
                  if (borderColor == null) {
                    borderColor = isFunction(this.layout.vLineColor) ? this.layout.vLineColor(vLineColIndex, this.tableNode, vLineRowIndex) : this.layout.vLineColor;
                  }
                  writer.addVector({
                    type: "line",
                    x1: x + width / 2,
                    x2: x + width / 2,
                    y1: y0,
                    y2: y1,
                    lineWidth: width,
                    dash,
                    lineColor: borderColor
                  }, false, true);
                  cellBefore = null;
                  currentCell = null;
                  borderColor = null;
                };
                TableProcessor.prototype.endTable = function(writer) {
                  if (this.cleanUpRepeatables) {
                    writer.popFromRepeatables();
                  }
                };
                TableProcessor.prototype.endRow = function(rowIndex, writer, pageBreaks) {
                  var l, i;
                  var self2 = this;
                  writer.tracker.stopTracking("pageChanged", this.rowCallback);
                  writer.context().moveDown(this.layout.paddingBottom(rowIndex, this.tableNode));
                  writer.context().availableHeight += this.reservedAtBottom;
                  var endingPage = writer.context().page;
                  var endingY = writer.context().y;
                  var xs = getLineXs();
                  var ys = [];
                  var hasBreaks = pageBreaks && pageBreaks.length > 0;
                  var body = this.tableNode.table.body;
                  ys.push({
                    y0: this.rowTopY,
                    page: hasBreaks ? pageBreaks[0].prevPage : endingPage
                  });
                  if (hasBreaks) {
                    for (i = 0, l = pageBreaks.length; i < l; i++) {
                      var pageBreak = pageBreaks[i];
                      ys[ys.length - 1].y1 = pageBreak.prevY;
                      ys.push({ y0: pageBreak.y, page: pageBreak.prevPage + 1 });
                    }
                  }
                  ys[ys.length - 1].y1 = endingY;
                  var skipOrphanePadding = ys[0].y1 - ys[0].y0 === this.rowPaddingTop;
                  for (var yi = skipOrphanePadding ? 1 : 0, yl = ys.length; yi < yl; yi++) {
                    var willBreak = yi < ys.length - 1;
                    var rowBreakWithoutHeader = yi > 0 && !this.headerRows;
                    var hzLineOffset = rowBreakWithoutHeader ? 0 : this.topLineWidth;
                    var y1 = ys[yi].y0;
                    var y2 = ys[yi].y1;
                    if (willBreak) {
                      y2 = y2 + this.rowPaddingBottom;
                    }
                    if (writer.context().page != ys[yi].page) {
                      writer.context().page = ys[yi].page;
                      this.reservedAtBottom = 0;
                    }
                    for (i = 0, l = xs.length; i < l; i++) {
                      var leftCellBorder = false;
                      var rightCellBorder = false;
                      var colIndex = xs[i].index;
                      if (colIndex < body[rowIndex].length) {
                        var cell = body[rowIndex][colIndex];
                        leftCellBorder = cell.border ? cell.border[0] : this.layout.defaultBorder;
                        rightCellBorder = cell.border ? cell.border[2] : this.layout.defaultBorder;
                      }
                      if (colIndex > 0 && !leftCellBorder) {
                        var cell = body[rowIndex][colIndex - 1];
                        leftCellBorder = cell.border ? cell.border[2] : this.layout.defaultBorder;
                      }
                      if (colIndex + 1 < body[rowIndex].length && !rightCellBorder) {
                        var cell = body[rowIndex][colIndex + 1];
                        rightCellBorder = cell.border ? cell.border[0] : this.layout.defaultBorder;
                      }
                      if (leftCellBorder) {
                        this.drawVerticalLine(xs[i].x, y1 - hzLineOffset, y2 + this.bottomLineWidth, xs[i].index, writer, rowIndex, xs[i - 1] ? xs[i - 1].index : null);
                      }
                      if (i < l - 1) {
                        var fillColor = body[rowIndex][colIndex].fillColor;
                        var fillOpacity = body[rowIndex][colIndex].fillOpacity;
                        if (!fillColor) {
                          fillColor = isFunction(this.layout.fillColor) ? this.layout.fillColor(rowIndex, this.tableNode, colIndex) : this.layout.fillColor;
                        }
                        if (!isNumber(fillOpacity)) {
                          fillOpacity = isFunction(this.layout.fillOpacity) ? this.layout.fillOpacity(rowIndex, this.tableNode, colIndex) : this.layout.fillOpacity;
                        }
                        var overlayPattern = body[rowIndex][colIndex].overlayPattern;
                        var overlayOpacity = body[rowIndex][colIndex].overlayOpacity;
                        if (fillColor || overlayPattern) {
                          var widthLeftBorder = leftCellBorder ? this.layout.vLineWidth(colIndex, this.tableNode) : 0;
                          var widthRightBorder;
                          if ((colIndex === 0 || colIndex + 1 == body[rowIndex].length) && !rightCellBorder) {
                            widthRightBorder = this.layout.vLineWidth(colIndex + 1, this.tableNode);
                          } else if (rightCellBorder) {
                            widthRightBorder = this.layout.vLineWidth(colIndex + 1, this.tableNode) / 2;
                          } else {
                            widthRightBorder = 0;
                          }
                          var x1f = this.dontBreakRows ? xs[i].x + widthLeftBorder : xs[i].x + widthLeftBorder / 2;
                          var y1f = this.dontBreakRows ? y1 : y1 - hzLineOffset / 2;
                          var x2f = xs[i + 1].x + widthRightBorder;
                          var y2f = this.dontBreakRows ? y2 + this.bottomLineWidth : y2 + this.bottomLineWidth / 2;
                          var bgWidth = x2f - x1f;
                          var bgHeight = y2f - y1f;
                          if (fillColor) {
                            writer.addVector({
                              type: "rect",
                              x: x1f,
                              y: y1f,
                              w: bgWidth,
                              h: bgHeight,
                              lineWidth: 0,
                              color: fillColor,
                              fillOpacity
                            }, false, true, writer.context().backgroundLength[writer.context().page]);
                          }
                          if (overlayPattern) {
                            writer.addVector({
                              type: "rect",
                              x: x1f,
                              y: y1f,
                              w: bgWidth,
                              h: bgHeight,
                              lineWidth: 0,
                              color: overlayPattern,
                              fillOpacity: overlayOpacity
                            }, false, true);
                          }
                        }
                      }
                    }
                    if (willBreak && this.layout.hLineWhenBroken !== false) {
                      this.drawHorizontalLine(rowIndex + 1, writer, y2);
                    }
                    if (rowBreakWithoutHeader && this.layout.hLineWhenBroken !== false) {
                      this.drawHorizontalLine(rowIndex, writer, y1);
                    }
                  }
                  writer.context().page = endingPage;
                  writer.context().y = endingY;
                  var row = this.tableNode.table.body[rowIndex];
                  for (i = 0, l = row.length; i < l; i++) {
                    if (row[i].rowSpan) {
                      this.rowSpanData[i].rowSpan = row[i].rowSpan;
                      if (row[i].colSpan && row[i].colSpan > 1) {
                        for (var j = 1; j < row[i].rowSpan; j++) {
                          this.tableNode.table.body[rowIndex + j][i]._colSpan = row[i].colSpan;
                        }
                      }
                      if (row[i].rowSpan && row[i].rowSpan > 1) {
                        for (var j = 1; j < row[i].rowSpan; j++) {
                          this.tableNode.table.body[rowIndex + j][i]._rowSpanCurrentOffset = j;
                        }
                      }
                    }
                    if (this.rowSpanData[i].rowSpan > 0) {
                      this.rowSpanData[i].rowSpan--;
                    }
                  }
                  this.drawHorizontalLine(rowIndex + 1, writer);
                  if (this.headerRows && rowIndex === this.headerRows - 1) {
                    this.headerRepeatable = writer.currentBlockToRepeatable();
                  }
                  if (this.dontBreakRows) {
                    writer.tracker.auto(
                      "pageChanged",
                      function() {
                        if (!self2.headerRows && self2.layout.hLineWhenBroken !== false) {
                          self2.drawHorizontalLine(rowIndex, writer);
                        }
                      },
                      function() {
                        writer.commitUnbreakableBlock();
                      }
                    );
                  }
                  if (this.headerRepeatable && (rowIndex === this.rowsWithoutPageBreak - 1 || rowIndex === this.tableNode.table.body.length - 1)) {
                    writer.commitUnbreakableBlock();
                    writer.pushToRepeatables(this.headerRepeatable);
                    this.cleanUpRepeatables = true;
                    this.headerRepeatable = null;
                  }
                  function getLineXs() {
                    var result = [];
                    var cols = 0;
                    for (var i2 = 0, l2 = self2.tableNode.table.body[rowIndex].length; i2 < l2; i2++) {
                      if (!cols) {
                        result.push({ x: self2.rowSpanData[i2].left, index: i2 });
                        var item = self2.tableNode.table.body[rowIndex][i2];
                        cols = item._colSpan || item.colSpan || 0;
                      }
                      if (cols > 0) {
                        cols--;
                      }
                    }
                    result.push({ x: self2.rowSpanData[self2.rowSpanData.length - 1].left, index: self2.rowSpanData.length - 1 });
                    return result;
                  }
                };
                module2.exports = TableProcessor;
              }
            ),
            /***/
            3497: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isArray = __webpack_require__2(6225).isArray;
                var isPattern = __webpack_require__2(6225).isPattern;
                var getPattern = __webpack_require__2(6225).getPattern;
                function groupDecorations(line) {
                  var groups = [], currentGroup = null;
                  for (var i = 0, l = line.inlines.length; i < l; i++) {
                    var inline = line.inlines[i];
                    var decoration = inline.decoration;
                    if (!decoration) {
                      currentGroup = null;
                      continue;
                    }
                    if (!isArray(decoration)) {
                      decoration = [decoration];
                    }
                    var color = inline.decorationColor || inline.color || "black";
                    var style = inline.decorationStyle || "solid";
                    for (var ii = 0, ll = decoration.length; ii < ll; ii++) {
                      var decorationItem = decoration[ii];
                      if (!currentGroup || decorationItem !== currentGroup.decoration || style !== currentGroup.decorationStyle || color !== currentGroup.decorationColor) {
                        currentGroup = {
                          line,
                          decoration: decorationItem,
                          decorationColor: color,
                          decorationStyle: style,
                          inlines: [inline]
                        };
                        groups.push(currentGroup);
                      } else {
                        currentGroup.inlines.push(inline);
                      }
                    }
                  }
                  return groups;
                }
                function drawDecoration(group, x, y, pdfKitDoc) {
                  function maxInline() {
                    var max = 0;
                    for (var i2 = 0, l = group.inlines.length; i2 < l; i2++) {
                      var inline = group.inlines[i2];
                      max = inline.fontSize > max ? i2 : max;
                    }
                    return group.inlines[max];
                  }
                  function width() {
                    var sum = 0;
                    for (var i2 = 0, l = group.inlines.length; i2 < l; i2++) {
                      var justifyShift = group.inlines[i2].justifyShift || 0;
                      sum += group.inlines[i2].width + justifyShift;
                    }
                    return sum;
                  }
                  var firstInline = group.inlines[0], biggerInline = maxInline(), totalWidth = width(), lineAscent = group.line.getAscenderHeight(), ascent = biggerInline.font.ascender / 1e3 * biggerInline.fontSize, height = biggerInline.height, descent = height - ascent;
                  var lw = 0.5 + Math.floor(Math.max(biggerInline.fontSize - 8, 0) / 2) * 0.12;
                  switch (group.decoration) {
                    case "underline":
                      y += lineAscent + descent * 0.45;
                      break;
                    case "overline":
                      y += lineAscent - ascent * 0.85;
                      break;
                    case "lineThrough":
                      y += lineAscent - ascent * 0.25;
                      break;
                    default:
                      throw "Unkown decoration : " + group.decoration;
                  }
                  pdfKitDoc.save();
                  if (group.decorationStyle === "double") {
                    var gap = Math.max(0.5, lw * 2);
                    pdfKitDoc.fillColor(group.decorationColor).rect(x + firstInline.x, y - lw / 2, totalWidth, lw / 2).fill().rect(x + firstInline.x, y + gap - lw / 2, totalWidth, lw / 2).fill();
                  } else if (group.decorationStyle === "dashed") {
                    var nbDashes = Math.ceil(totalWidth / (3.96 + 2.84));
                    var rdx = x + firstInline.x;
                    pdfKitDoc.rect(rdx, y, totalWidth, lw).clip();
                    pdfKitDoc.fillColor(group.decorationColor);
                    for (var i = 0; i < nbDashes; i++) {
                      pdfKitDoc.rect(rdx, y - lw / 2, 3.96, lw).fill();
                      rdx += 3.96 + 2.84;
                    }
                  } else if (group.decorationStyle === "dotted") {
                    var nbDots = Math.ceil(totalWidth / (lw * 3));
                    var rx = x + firstInline.x;
                    pdfKitDoc.rect(rx, y, totalWidth, lw).clip();
                    pdfKitDoc.fillColor(group.decorationColor);
                    for (var ii = 0; ii < nbDots; ii++) {
                      pdfKitDoc.rect(rx, y - lw / 2, lw, lw).fill();
                      rx += lw * 3;
                    }
                  } else if (group.decorationStyle === "wavy") {
                    var sh = 0.7, sv = 1;
                    var nbWaves = Math.ceil(totalWidth / (sh * 2)) + 1;
                    var rwx = x + firstInline.x - 1;
                    pdfKitDoc.rect(x + firstInline.x, y - sv, totalWidth, y + sv).clip();
                    pdfKitDoc.lineWidth(0.24);
                    pdfKitDoc.moveTo(rwx, y);
                    for (var iii = 0; iii < nbWaves; iii++) {
                      pdfKitDoc.bezierCurveTo(rwx + sh, y - sv, rwx + sh * 2, y - sv, rwx + sh * 3, y).bezierCurveTo(rwx + sh * 4, y + sv, rwx + sh * 5, y + sv, rwx + sh * 6, y);
                      rwx += sh * 6;
                    }
                    pdfKitDoc.stroke(group.decorationColor);
                  } else {
                    pdfKitDoc.fillColor(group.decorationColor).rect(x + firstInline.x, y - lw / 2, totalWidth, lw).fill();
                  }
                  pdfKitDoc.restore();
                }
                function drawDecorations(line, x, y, pdfKitDoc) {
                  var groups = groupDecorations(line);
                  for (var i = 0, l = groups.length; i < l; i++) {
                    drawDecoration(groups[i], x, y, pdfKitDoc);
                  }
                }
                function drawBackground(line, x, y, patterns, pdfKitDoc) {
                  var height = line.getHeight();
                  for (var i = 0, l = line.inlines.length; i < l; i++) {
                    var inline = line.inlines[i];
                    if (!inline.background) {
                      continue;
                    }
                    var color = inline.background;
                    if (isPattern(inline.background)) {
                      color = getPattern(inline.background, patterns);
                    }
                    var justifyShift = inline.justifyShift || 0;
                    pdfKitDoc.fillColor(color).rect(x + inline.x - justifyShift, y, inline.width + justifyShift, height).fill();
                  }
                }
                module2.exports = {
                  drawBackground,
                  drawDecorations
                };
              }
            ),
            /***/
            1350: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isString = __webpack_require__2(6225).isString;
                var isNumber = __webpack_require__2(6225).isNumber;
                var isObject = __webpack_require__2(6225).isObject;
                var isArray = __webpack_require__2(6225).isArray;
                var isUndefined = __webpack_require__2(6225).isUndefined;
                var LineBreaker = __webpack_require__2(7337);
                var LEADING = /^(\s)+/g;
                var TRAILING = /(\s)+$/g;
                function TextTools(fontProvider) {
                  this.fontProvider = fontProvider;
                }
                TextTools.prototype.buildInlines = function(textArray, styleContextStack) {
                  var measured = measure(this.fontProvider, textArray, styleContextStack);
                  var minWidth = 0, maxWidth = 0, currentLineWidth;
                  measured.forEach(function(inline) {
                    minWidth = Math.max(minWidth, inline.width - inline.leadingCut - inline.trailingCut);
                    if (!currentLineWidth) {
                      currentLineWidth = { width: 0, leadingCut: inline.leadingCut, trailingCut: 0 };
                    }
                    currentLineWidth.width += inline.width;
                    currentLineWidth.trailingCut = inline.trailingCut;
                    maxWidth = Math.max(maxWidth, getTrimmedWidth(currentLineWidth));
                    if (inline.lineEnd) {
                      currentLineWidth = null;
                    }
                  });
                  if (getStyleProperty({}, styleContextStack, "noWrap", false)) {
                    minWidth = maxWidth;
                  }
                  return {
                    items: measured,
                    minWidth,
                    maxWidth
                  };
                  function getTrimmedWidth(item) {
                    return Math.max(0, item.width - item.leadingCut - item.trailingCut);
                  }
                };
                TextTools.prototype.sizeOfString = function(text, styleContextStack) {
                  text = text ? text.toString().replace(/\t/g, "    ") : "";
                  var fontName = getStyleProperty({}, styleContextStack, "font", "Roboto");
                  var fontSize = getStyleProperty({}, styleContextStack, "fontSize", 12);
                  var fontFeatures = getStyleProperty({}, styleContextStack, "fontFeatures", null);
                  var bold = getStyleProperty({}, styleContextStack, "bold", false);
                  var italics = getStyleProperty({}, styleContextStack, "italics", false);
                  var lineHeight = getStyleProperty({}, styleContextStack, "lineHeight", 1);
                  var characterSpacing = getStyleProperty({}, styleContextStack, "characterSpacing", 0);
                  var font = this.fontProvider.provideFont(fontName, bold, italics);
                  return {
                    width: widthOfString(text, font, fontSize, characterSpacing, fontFeatures),
                    height: font.lineHeight(fontSize) * lineHeight,
                    fontSize,
                    lineHeight,
                    ascender: font.ascender / 1e3 * fontSize,
                    descender: font.descender / 1e3 * fontSize
                  };
                };
                TextTools.prototype.sizeOfRotatedText = function(text, angle, styleContextStack) {
                  var angleRad = angle * Math.PI / -180;
                  var size = this.sizeOfString(text, styleContextStack);
                  return {
                    width: Math.abs(size.height * Math.sin(angleRad)) + Math.abs(size.width * Math.cos(angleRad)),
                    height: Math.abs(size.width * Math.sin(angleRad)) + Math.abs(size.height * Math.cos(angleRad))
                  };
                };
                TextTools.prototype.widthOfString = function(text, font, fontSize, characterSpacing, fontFeatures) {
                  return widthOfString(text, font, fontSize, characterSpacing, fontFeatures);
                };
                function splitWords(text, noWrap) {
                  var results = [];
                  text = text.replace(/\t/g, "    ");
                  if (noWrap) {
                    results.push({ text });
                    return results;
                  }
                  var breaker = new LineBreaker(text);
                  var last = 0;
                  var bk;
                  while (bk = breaker.nextBreak()) {
                    var word = text.slice(last, bk.position);
                    if (bk.required || word.match(/\r?\n$|\r$/)) {
                      word = word.replace(/\r?\n$|\r$/, "");
                      results.push({ text: word, lineEnd: true });
                    } else {
                      results.push({ text: word });
                    }
                    last = bk.position;
                  }
                  return results;
                }
                function copyStyle(source, destination) {
                  destination = destination || {};
                  source = source || {};
                  for (var key in source) {
                    if (key != "text" && source.hasOwnProperty(key)) {
                      destination[key] = source[key];
                    }
                  }
                  return destination;
                }
                function normalizeTextArray(array, styleContextStack) {
                  function flatten(array2) {
                    return array2.reduce(function(prev, cur) {
                      var current = isArray(cur.text) ? flatten(cur.text) : cur;
                      var more = [].concat(current).some(Array.isArray);
                      return prev.concat(more ? flatten(current) : current);
                    }, []);
                  }
                  function getOneWord(index, words2, noWrap2) {
                    if (isUndefined(words2[index])) {
                      return null;
                    }
                    if (words2[index].lineEnd) {
                      return null;
                    }
                    var word = words2[index].text;
                    if (noWrap2) {
                      var tmpWords = splitWords(normalizeString(word), false);
                      if (isUndefined(tmpWords[tmpWords.length - 1])) {
                        return null;
                      }
                      word = tmpWords[tmpWords.length - 1].text;
                    }
                    return word;
                  }
                  var results = [];
                  if (!isArray(array)) {
                    array = [array];
                  }
                  array = flatten(array);
                  var lastWord = null;
                  for (var i = 0, l = array.length; i < l; i++) {
                    var item = array[i];
                    var style = null;
                    var words;
                    var noWrap = getStyleProperty(item || {}, styleContextStack, "noWrap", false);
                    if (isObject(item)) {
                      if (item._textRef && item._textRef._textNodeRef.text) {
                        item.text = item._textRef._textNodeRef.text;
                      }
                      words = splitWords(normalizeString(item.text), noWrap);
                      style = copyStyle(item);
                    } else {
                      words = splitWords(normalizeString(item), noWrap);
                    }
                    if (lastWord && words.length) {
                      var firstWord = getOneWord(0, words, noWrap);
                      var wrapWords = splitWords(normalizeString(lastWord + firstWord), false);
                      if (wrapWords.length === 1) {
                        results[results.length - 1].noNewLine = true;
                      }
                    }
                    for (var i2 = 0, l2 = words.length; i2 < l2; i2++) {
                      var result = {
                        text: words[i2].text
                      };
                      if (words[i2].lineEnd) {
                        result.lineEnd = true;
                      }
                      copyStyle(style, result);
                      results.push(result);
                    }
                    lastWord = null;
                    if (i + 1 < l) {
                      lastWord = getOneWord(words.length - 1, words, noWrap);
                    }
                  }
                  return results;
                }
                function normalizeString(value) {
                  if (value === void 0 || value === null) {
                    return "";
                  } else if (isNumber(value)) {
                    return value.toString();
                  } else if (isString(value)) {
                    return value;
                  } else {
                    return value.toString();
                  }
                }
                function getStyleProperty(item, styleContextStack, property, defaultValue) {
                  var value;
                  if (item[property] !== void 0 && item[property] !== null) {
                    return item[property];
                  }
                  if (!styleContextStack) {
                    return defaultValue;
                  }
                  styleContextStack.auto(item, function() {
                    value = styleContextStack.getProperty(property);
                  });
                  if (value !== null && value !== void 0) {
                    return value;
                  } else {
                    return defaultValue;
                  }
                }
                function measure(fontProvider, textArray, styleContextStack) {
                  var normalized = normalizeTextArray(textArray, styleContextStack);
                  if (normalized.length) {
                    var leadingIndent = getStyleProperty(normalized[0], styleContextStack, "leadingIndent", 0);
                    if (leadingIndent) {
                      normalized[0].leadingCut = -leadingIndent;
                      normalized[0].leadingIndent = leadingIndent;
                    }
                  }
                  normalized.forEach(function(item) {
                    var fontName = getStyleProperty(item, styleContextStack, "font", "Roboto");
                    var fontSize = getStyleProperty(item, styleContextStack, "fontSize", 12);
                    var fontFeatures = getStyleProperty(item, styleContextStack, "fontFeatures", null);
                    var bold = getStyleProperty(item, styleContextStack, "bold", false);
                    var italics = getStyleProperty(item, styleContextStack, "italics", false);
                    var color = getStyleProperty(item, styleContextStack, "color", "black");
                    var decoration = getStyleProperty(item, styleContextStack, "decoration", null);
                    var decorationColor = getStyleProperty(item, styleContextStack, "decorationColor", null);
                    var decorationStyle = getStyleProperty(item, styleContextStack, "decorationStyle", null);
                    var background = getStyleProperty(item, styleContextStack, "background", null);
                    var lineHeight = getStyleProperty(item, styleContextStack, "lineHeight", 1);
                    var characterSpacing = getStyleProperty(item, styleContextStack, "characterSpacing", 0);
                    var link = getStyleProperty(item, styleContextStack, "link", null);
                    var linkToPage = getStyleProperty(item, styleContextStack, "linkToPage", null);
                    var linkToDestination = getStyleProperty(item, styleContextStack, "linkToDestination", null);
                    var noWrap = getStyleProperty(item, styleContextStack, "noWrap", null);
                    var preserveLeadingSpaces = getStyleProperty(item, styleContextStack, "preserveLeadingSpaces", false);
                    var preserveTrailingSpaces = getStyleProperty(item, styleContextStack, "preserveTrailingSpaces", false);
                    var opacity = getStyleProperty(item, styleContextStack, "opacity", 1);
                    var sup = getStyleProperty(item, styleContextStack, "sup", false);
                    var sub = getStyleProperty(item, styleContextStack, "sub", false);
                    if ((sup || sub) && item.fontSize === void 0) {
                      fontSize *= 0.58;
                    }
                    var font = fontProvider.provideFont(fontName, bold, italics);
                    item.width = widthOfString(item.text, font, fontSize, characterSpacing, fontFeatures);
                    item.height = font.lineHeight(fontSize) * lineHeight;
                    if (!item.leadingCut) {
                      item.leadingCut = 0;
                    }
                    var leadingSpaces;
                    if (!preserveLeadingSpaces && (leadingSpaces = item.text.match(LEADING))) {
                      item.leadingCut += widthOfString(leadingSpaces[0], font, fontSize, characterSpacing, fontFeatures);
                    }
                    var trailingSpaces;
                    if (!preserveTrailingSpaces && (trailingSpaces = item.text.match(TRAILING))) {
                      item.trailingCut = widthOfString(trailingSpaces[0], font, fontSize, characterSpacing, fontFeatures);
                    } else {
                      item.trailingCut = 0;
                    }
                    item.alignment = getStyleProperty(item, styleContextStack, "alignment", "left");
                    item.font = font;
                    item.fontSize = fontSize;
                    item.fontFeatures = fontFeatures;
                    item.characterSpacing = characterSpacing;
                    item.color = color;
                    item.decoration = decoration;
                    item.decorationColor = decorationColor;
                    item.decorationStyle = decorationStyle;
                    item.background = background;
                    item.link = link;
                    item.linkToPage = linkToPage;
                    item.linkToDestination = linkToDestination;
                    item.noWrap = noWrap;
                    item.opacity = opacity;
                    item.sup = sup;
                    item.sub = sub;
                  });
                  return normalized;
                }
                function widthOfString(text, font, fontSize, characterSpacing, fontFeatures) {
                  return font.widthOfString(text, fontSize, fontFeatures) + (characterSpacing || 0) * (text.length - 1);
                }
                module2.exports = TextTools;
              }
            ),
            /***/
            8537: (
              /***/
              function(module2) {
                "use strict";
                function TraversalTracker() {
                  this.events = {};
                }
                TraversalTracker.prototype.startTracking = function(event, callback) {
                  var callbacks = this.events[event] || (this.events[event] = []);
                  if (callbacks.indexOf(callback) < 0) {
                    callbacks.push(callback);
                  }
                };
                TraversalTracker.prototype.stopTracking = function(event, callback) {
                  var callbacks = this.events[event];
                  if (!callbacks) {
                    return;
                  }
                  var index = callbacks.indexOf(callback);
                  if (index >= 0) {
                    callbacks.splice(index, 1);
                  }
                };
                TraversalTracker.prototype.emit = function(event) {
                  var args = Array.prototype.slice.call(arguments, 1);
                  var callbacks = this.events[event];
                  if (!callbacks) {
                    return;
                  }
                  callbacks.forEach(function(callback) {
                    callback.apply(this, args);
                  });
                };
                TraversalTracker.prototype.auto = function(event, callback, innerFunction) {
                  this.startTracking(event, callback);
                  innerFunction();
                  this.stopTracking(event, callback);
                };
                module2.exports = TraversalTracker;
              }
            ),
            /***/
            2480: (
              /***/
              function() {
              }
            ),
            /***/
            5832: (
              /***/
              function() {
              }
            ),
            /***/
            9862: (
              /***/
              function() {
              }
            ),
            /***/
            964: (
              /***/
              function() {
              }
            ),
            /***/
            3083: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var possibleNames = [
                  "BigInt64Array",
                  "BigUint64Array",
                  "Float32Array",
                  "Float64Array",
                  "Int16Array",
                  "Int32Array",
                  "Int8Array",
                  "Uint16Array",
                  "Uint32Array",
                  "Uint8Array",
                  "Uint8ClampedArray"
                ];
                var g = typeof globalThis === "undefined" ? __webpack_require__2.g : globalThis;
                module2.exports = function availableTypedArrays() {
                  var out = [];
                  for (var i = 0; i < possibleNames.length; i++) {
                    if (typeof g[possibleNames[i]] === "function") {
                      out[out.length] = possibleNames[i];
                    }
                  }
                  return out;
                };
              }
            ),
            /***/
            3631: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var $c5L0i$base64js = __webpack_require__2(9742);
                var $c5L0i$unicodetrie = __webpack_require__2(4781);
                function $parcel$interopDefault(a) {
                  return a && a.__esModule ? a.default : a;
                }
                function $parcel$defineInteropFlag(a) {
                  Object.defineProperty(a, "__esModule", { value: true, configurable: true });
                }
                function $parcel$export(e, n, v, s) {
                  Object.defineProperty(e, n, { get: v, set: s, enumerable: true, configurable: true });
                }
                $parcel$defineInteropFlag(module2.exports);
                $parcel$export(module2.exports, "getCategory", () => $43d7963e56408b24$export$410364bbb673ddbc);
                $parcel$export(module2.exports, "getCombiningClass", () => $43d7963e56408b24$export$c03b919c6651ed55);
                $parcel$export(module2.exports, "getScript", () => $43d7963e56408b24$export$941569448d136665);
                $parcel$export(module2.exports, "getEastAsianWidth", () => $43d7963e56408b24$export$92f6187db8ca6d26);
                $parcel$export(module2.exports, "getNumericValue", () => $43d7963e56408b24$export$7d1258ebb7625a0d);
                $parcel$export(module2.exports, "isAlphabetic", () => $43d7963e56408b24$export$52c8ea63abd07594);
                $parcel$export(module2.exports, "isDigit", () => $43d7963e56408b24$export$727d9dbc4fbb948f);
                $parcel$export(module2.exports, "isPunctuation", () => $43d7963e56408b24$export$a5b49f4dc6a07d2c);
                $parcel$export(module2.exports, "isLowerCase", () => $43d7963e56408b24$export$7b6804e8df61fcf5);
                $parcel$export(module2.exports, "isUpperCase", () => $43d7963e56408b24$export$aebd617640818cda);
                $parcel$export(module2.exports, "isTitleCase", () => $43d7963e56408b24$export$de8b4ee23b2cf823);
                $parcel$export(module2.exports, "isWhiteSpace", () => $43d7963e56408b24$export$3c52dd84024ae72c);
                $parcel$export(module2.exports, "isBaseForm", () => $43d7963e56408b24$export$a11bdcffe109e74b);
                $parcel$export(module2.exports, "isMark", () => $43d7963e56408b24$export$e33ad6871e762338);
                $parcel$export(module2.exports, "default", () => $43d7963e56408b24$export$2e2bcd8739ae039);
                var $29668e65f2091c2c$exports = {};
                $29668e65f2091c2c$exports = JSON.parse('{"categories":["Cc","Zs","Po","Sc","Ps","Pe","Sm","Pd","Nd","Lu","Sk","Pc","Ll","So","Lo","Pi","Cf","No","Pf","Lt","Lm","Mn","Me","Mc","Nl","Zl","Zp","Cs","Co"],"combiningClasses":["Not_Reordered","Above","Above_Right","Below","Attached_Above_Right","Attached_Below","Overlay","Iota_Subscript","Double_Below","Double_Above","Below_Right","Above_Left","CCC10","CCC11","CCC12","CCC13","CCC14","CCC15","CCC16","CCC17","CCC18","CCC19","CCC20","CCC21","CCC22","CCC23","CCC24","CCC25","CCC30","CCC31","CCC32","CCC27","CCC28","CCC29","CCC33","CCC34","CCC35","CCC36","Nukta","Virama","CCC84","CCC91","CCC103","CCC107","CCC118","CCC122","CCC129","CCC130","CCC132","Attached_Above","Below_Left","Left","Kana_Voicing","CCC26","Right"],"scripts":["Common","Latin","Bopomofo","Inherited","Greek","Coptic","Cyrillic","Armenian","Hebrew","Arabic","Syriac","Thaana","Nko","Samaritan","Mandaic","Devanagari","Bengali","Gurmukhi","Gujarati","Oriya","Tamil","Telugu","Kannada","Malayalam","Sinhala","Thai","Lao","Tibetan","Myanmar","Georgian","Hangul","Ethiopic","Cherokee","Canadian_Aboriginal","Ogham","Runic","Tagalog","Hanunoo","Buhid","Tagbanwa","Khmer","Mongolian","Limbu","Tai_Le","New_Tai_Lue","Buginese","Tai_Tham","Balinese","Sundanese","Batak","Lepcha","Ol_Chiki","Braille","Glagolitic","Tifinagh","Han","Hiragana","Katakana","Yi","Lisu","Vai","Bamum","Syloti_Nagri","Phags_Pa","Saurashtra","Kayah_Li","Rejang","Javanese","Cham","Tai_Viet","Meetei_Mayek","null","Linear_B","Lycian","Carian","Old_Italic","Gothic","Old_Permic","Ugaritic","Old_Persian","Deseret","Shavian","Osmanya","Osage","Elbasan","Caucasian_Albanian","Linear_A","Cypriot","Imperial_Aramaic","Palmyrene","Nabataean","Hatran","Phoenician","Lydian","Meroitic_Hieroglyphs","Meroitic_Cursive","Kharoshthi","Old_South_Arabian","Old_North_Arabian","Manichaean","Avestan","Inscriptional_Parthian","Inscriptional_Pahlavi","Psalter_Pahlavi","Old_Turkic","Old_Hungarian","Hanifi_Rohingya","Old_Sogdian","Sogdian","Elymaic","Brahmi","Kaithi","Sora_Sompeng","Chakma","Mahajani","Sharada","Khojki","Multani","Khudawadi","Grantha","Newa","Tirhuta","Siddham","Modi","Takri","Ahom","Dogra","Warang_Citi","Nandinagari","Zanabazar_Square","Soyombo","Pau_Cin_Hau","Bhaiksuki","Marchen","Masaram_Gondi","Gunjala_Gondi","Makasar","Cuneiform","Egyptian_Hieroglyphs","Anatolian_Hieroglyphs","Mro","Bassa_Vah","Pahawh_Hmong","Medefaidrin","Miao","Tangut","Nushu","Duployan","SignWriting","Nyiakeng_Puachue_Hmong","Wancho","Mende_Kikakui","Adlam"],"eaw":["N","Na","A","W","H","F"]}');
                const $43d7963e56408b24$var$trie = new (0, $parcel$interopDefault($c5L0i$unicodetrie))((0, $parcel$interopDefault($c5L0i$base64js)).toByteArray("AAARAAAAAADwfAEAZXl5ONRt+/5bPVFZimRfKoTQJNm37CGE7Iw0j3UsTWKsoyI7kwyyTiEUzSD7NiEzhWYijH0wMVkHE4Mx49fzfo+3nuP4/fdZjvv+XNd5n/d9nef1WZvmKhTxiZndzDQBSEYQqxqKwnsKvGQucFh+6t6cJ792ePQBZv5S9yXSwkyjf/P4T7mTNnIAv1dOVhMlR9lflbUL9JeJguqsjvG9NTj/wLb566VAURnLo2vvRi89S3gW/33ihh2eXpDn40BIW7REl/7coRKIhAFlAiOtbLDTt6mMb4GzMF1gNnvX/sBxtbsAIjfztCNcQjcNDtLThRvuXu5M5g/CBjaLBE4lJm4qy/oZD97+IJryApcXfgWYlkvWbhfXgujOJKVu8B+ozqTLbxyJ5kNiR75CxDqfBM9eOlDMmGeoZ0iQbbS5VUplIwI+ZNXEKQVJxlwqjhOY7w3XwPesbLK5JZE+Tt4X8q8km0dzInsPPzbscrjBMVjF5mOHSeRdJVgKUjLTHiHqXSPkep8N/zFk8167KLp75f6RndkvzdfB6Uz3MmqvRArzdCbs1/iRZjYPLLF3U8Qs+H+Rb8iK51a6NIV2V9+07uJsTGFWpPz8J++7iRu2B6eAKlK/kujrLthwaD/7a6J5w90TusnH1JMAc+gNrql4aspOUG/RrsxUKmPzhHgP4Bleru+6Vfc/MBjgXVx7who94nPn7MPFrnwQP7g0k0Dq0h2GSKO6fTZ8nLodN1SiOUj/5EL/Xo1DBvRm0wmrh3x6phcJ20/9CuMr5h8WPqXMSasLoLHoufTmE7mzYrs6B0dY7KjuCogKqsvxnxAwXWvd9Puc9PnE8DOHT2INHxRlIyVHrqZahtfV2E/A2PDdtA3ewlRHMtFIBKO/T4IozWTQZ+mb+gdKuk/ZHrqloucKdsOSJmlWTSntWjcxVMjUmroXLM10I6TwDLnBq4LP69TxgVeyGsd8yHvhF8ydPlrNRSNs9EP7WmeuSE7Lu10JbOuQcJw/63sDp68wB9iwP5AO+mBpV0R5VDDeyQUFCel1G+4KHBgEVFS0YK+m2sXLWLuGTlkVAd97WwKKdacjWElRCuDRauf33l/yVcDF6sVPKeTes99FC1NpNWcpieGSV/IbO8PCTy5pbUR1U8lxzf4T+y6fZMxOz3LshkQLeeDSd0WmUrQgajmbktrxsb2AZ0ACw2Vgni+gV/m+KvCRWLg08Clx7uhql+v9XySGcjjOHlsp8vBw/e8HS7dtiqF6T/XcSXuaMW66GF1g4q9YyBadHqy3Y5jin1c7yZos6BBr6dsomSHxiUHanYtcYQwnMMZhRhOnaYJeyJzaRuukyCUh48+e/BUvk/aEfDp8ag+jD64BHxNnQ5v/E7WRk7eLjGV13I3oqy45YNONi/1op1oDr7rPjkhPsTXgUpQtGDPlIs55KhQaic9kSGs/UrZ2QKQOflB8MTEQxRF9pullToWO7Eplan6mcMRFnUu2441yxi23x+KqKlr7RWWsi9ZXMWlr8vfP3llk1m2PRj0yudccxBuoa7VfIgRmnFPGX6Pm1WIfMm/Rm4n/xTn8IGqA0GWuqgu48pEUO0U9nN+ZdIvFpPb7VDPphIfRZxznlHeVFebkd9l+raXy9BpTMcIUIvBfgHEb6ndGo8VUkxpief14KjzFOcaANfgvFpvyY8lE8lE4raHizLpluPzMks1hx/e1Hok5yV0p7qQH7GaYeMzzZTFvRpv6k6iaJ4yNqzBvN8J7B430h2wFm1IBPcqbou33G7/NWPgopl4Mllla6e24L3TOTVNkza2zv3QKuDWTeDpClCEYgTQ+5vEBSQZs/rMF50+sm4jofTgWLqgX1x3TkrDEVaRqfY/xZizFZ3Y8/DFEFD31VSfBQ5raEB6nHnZh6ddehtclQJ8fBrldyIh99LNnV32HzKEej04hk6SYjdauCa4aYW0ru/QxvQRGzLKOAQszf3ixJypTW3WWL6BLSF2EMCMIw7OUvWBC6A/gDc2D1jvBapMCc7ztx6jYczwTKsRLL6dMNXb83HS8kdD0pTMMj161zbVHkU0mhSHo9SlBDDXdN6hDvRGizmohtIyR3ot8tF5iUG4GLNcXeGvBudSFrHu+bVZb9jirNVG+rQPI51A7Hu8/b0UeaIaZ4UgDO68PkYx3PE2HWpKapJ764Kxt5TFYpywMy4DLQqVRy11I7SOLhxUFmqiEK52NaijWArIfCg6qG8q5eSiwRCJb1R7GDJG74TrYgx/lVq7w9++Kh929xSJEaoSse5fUOQg9nMAnIZv+7fwVRcNv3gOHI46Vb5jYUC66PYHO6lS+TOmvEQjuYmx4RkffYGxqZIp/DPWNHAixbRBc+XKE3JEOgs4jIwu/dSAwhydruOGF39co91aTs85JJ3Z/LpXoF43hUwJsb/M1Chzdn8HX8vLXnqWUKvRhNLpfAF4PTFqva1sBQG0J+59HyYfmQ3oa4/sxZdapVLlo/fooxSXi/dOEQWIWq8E0FkttEyTFXR2aNMPINMIzZwCNEheYTVltsdaLkMyKoEUluPNAYCM2IG3br0DLy0fVNWKHtbSKbBjfiw7Lu06gQFalC7RC9BwRMSpLYDUo9pDtDfzwUiPJKLJ2LGcSphWBadOI/iJjNqUHV7ucG8yC6+iNM9QYElqBR7ECFXrcTgWQ3eG/tCWacT9bxIkfmxPmi3vOd36KxihAJA73vWNJ+Y9oapXNscVSVqS5g15xOWND/WuUCcA9YAAg6WFbjHamrblZ5c0L6Zx1X58ZittGcfDKU697QRSqW/g+RofNRyvrWMrBn44cPvkRe2HdTu/Cq01C5/riWPHZyXPKHuSDDdW8c1XPgd6ogvLh20qEIu8c19sqr4ufyHrwh37ZN5MkvY1dsGmEz9pUBTxWrvvhNyODyX2Q1k/fbX/T/vbHNcBrmjgDtvBdtZrVtiIg5iXQuzO/DEMvRX8Mi1zymSlt92BGILeKItjoShJXE/H7xwnf0Iewb8BFieJ9MflEBCQYEDm8eZniiEPfGoaYiiEdhQxHQNr2AuRdmbL9mcl18Kumh+HEZLp6z+j35ML9zTbUwahUZCyQQOgQrGfdfQtaR/OYJ/9dYXb2TWZFMijfCA8Nov4sa5FFDUe1T68h4q08WDE7JbbDiej4utRMR9ontevxlXv6LuJTXt1YEv8bDzEt683PuSsIN0afvu0rcBu9AbXZbkOG3K3AhtqQ28N23lXm7S3Yn6KXmAhBhz+GeorJJ4XxO/b3vZk2LXp42+QvsVxGSNVpfSctIFMTR1bD9t70i6sfNF3WKz/uKDEDCpzzztwhL45lsw89H2IpWN10sXHRlhDse9KCdpP5qNNpU84cTY+aiqswqR8XZ9ea0KbVRwRuOGQU3csAtV2fSbnq47U6es6rKlWLWhg3s/B9C9g+oTyp6RtIldR51OOkP5/6nSy6itUVPcMNOp4M/hDdKOz3uK6srbdxOrc2cJgr1Sg02oBxxSky6V7JaG+ziNwlfqnjnvh2/uq1lKfbp+qpwq/D/5OI5gkFl5CejKGxfc2YVJfGqc4E0x5e9PHK2ukbHNI7/RZV6LNe65apbTGjoCaQls0txPPbmQbCQn+/upCoXRZy9yzorWJvZ0KWcbXlBxU/d5I4ERUTxMuVWhSMmF677LNN7NnLwsmKawXkCgbrpcluOl0WChR1qhtSrxGXHu251dEItYhYX3snvn1gS2uXuzdTxCJjZtjsip0iT2sDC0qMS7Bk9su2NyXjFK5/f5ZoWwofg3DtTyjaFqspnOOTSh8xK/CKUFS57guVEkw9xoQuRCwwEO9Lu9z2vYxSa9NFV8DvSxv2C4WYLYF8Nrc4DzWkzNsk81JJOlZ/LYJrGCoj4MmZpnf3AXmzxT4rtl9jsqljEyedz468SGKdBiQzyz/qWKEhFg45ZczlZZ3KGL3l6sn+3TTa3zMVMhPa1obGp/z+fvY0QXTrJTf1XAT3EtQdUfYYlmWZyvPZ/6rWwU7UOQei7pVE0osgN94Iy+T1+omE6z4Rh2O20FjgBeK2y1mcoFiMDOJvuZPn5Moy9fmFH3wyfKvn4+TwfLvt/lHTTVnvrtoUWRBiQXhiNM8nE6ZoWeux/Z0b2unRcdUzdDpmL7CAgd1ToRXwgmHTZOgiGtVT+xr1QH9ObebRTT4NzL+XSpLuuWp62GqQvJVTPoZOeJCb6gIwd9XHMftQ+Kc08IKKdKQANSJ1a2gve3JdRhO0+tNiYzWAZfd7isoeBu67W7xuK8WX7nhJURld98Inb0t/dWOSau/kDvV4DJo/cImw9AO2Gvq0F2n0M7yIZKL8amMbjYld+qFls7hq8Acvq97K2PrCaomuUiesu7qNanGupEl6J/iem8lyr/NMnsTr6o41PO0yhQh3hPFN0wJP7S830je9iTBLzUNgYH+gUZpROo3rN2qgCI+6GewpX8w8CH+ro6QrWiStqmcMzVa3vEel+3/dDxMp0rDv1Q6wTMS3K64zTT6RWzK1y643im25Ja7X2ePCV2mTswd/4jshZPo4bLnerqIosq/hy2bKUAmVn9n4oun1+a0DIZ56UhVwmZHdUNpLa8gmPvxS1eNvCF1T0wo1wKPdCJi0qOrWz7oYRTzgTtkzEzZn308XSLwUog4OWGKJzCn/3FfF9iA32dZHSv30pRCM3KBY9WZoRhtdK/ChHk6DEQBsfV6tN2o1Cn0mLtPBfnkS+qy1L2xfFe9TQPtDE1Be44RTl82E9hPT2rS2+93LFbzhQQO3C/hD2jRFH3BWWbasAfuMhRJFcTri73eE835y016s22DjoFJ862WvLj69fu2TgSF3RHia9D5DSitlQAXYCnbdqjPkR287Lh6dCHDapos+eFDvcZPP2edPmTFxznJE/EBLoQQ0Qmn9EkZOyJmHxMbvKYb8o21ZHmv5YLqgsEPk9gWZwYQY9wLqGXuax/8QlV5qDaPbq9pLPT1yp+zOWKmraEy1OUJI7zdEcEmvBpbdwLrDCgEb2xX8S/nxZgjK4bRi+pbOmbh8bEeoPvU/L9ndx9kntlDALbdAvp0O8ZC3zSUnFg4cePsw7jxewWvL7HRSBLUn6J7vTH9uld5N76JFPgBCdXGF221oEJk++XfRwXplLSyrVO7HFWBEs99nTazKveW3HpbD4dH/YmdAl+lwbSt8BQWyTG7jAsACI7bPPUU9hI9XUHWqQOuezHzUjnx5Qqs6T1qNHfTTHleDtmqK7flA9a0gz2nycIpz1FHBuWxKNtUeTdqP29Fb3tv+tl5JyBqXoR+vCsdzZwZUhf6Lu8bvkB9yQP4x7GGegB0ym0Lpl03Q7e+C0cDsm9GSDepCDji7nUslLyYyluPfvLyKaDSX4xpR+nVYQjQQn5F8KbY1gbIVLiK1J3mW90zTyR1bqApX2BlWh7KG8LAY9/S9nWC0XXh9pZZo6xuir12T43rkaGfQssbQyIslA7uJnSHOV22NhlNtUo0czxPAsXhh8tIQYaTM4l/yAlZlydTcXhlG22Gs/n3BxKBd/3ZjYwg3NaUurVXhNB+afVnFfNr9TbC9ksNdvwpNfeHanyJ8M6GrIVfLlYAPv0ILe4dn0Z+BJSbJkN7eZY/c6+6ttDYcIDeUKIDXqUSE42Xdh5nRbuaObozjht0HJ5H1e+em+NJi/+8kQlyjCbJpPckwThZeIF9/u7lrVIKNeJLCN/TpPAeXxvd31/CUDWHK9MuP1V1TJgngzi4V0qzS3SW3Qy5UiGHqg02wQa5tsEl9s/X9nNMosgLlUgZSfCBj1DiypLfhr9/r0nR0XY2tmhDOcUS4E7cqa4EJBhzqvpbZa35Q5Iz5EqmhYiOGDAYk606Tv74+KGfPjKVuP15rIzgW0I7/niOu9el/sn2bRye0gV+GrePDRDMHjwO1lEdeXH8N+UTO3IoN18kpI3tPxz+fY+n2MGMSGFHAx/83tKeJOl+2i+f1O9v6FfEDBbqrw+lpM8Anav7zHNr7hE78nXUtPNodMbCnITWA7Ma/IHlZ50F9hWge/wzOvSbtqFVFtkS8Of2nssjZwbSFdU+VO8z6tCEc9UA9ACxT5zIUeSrkBB/v1krOpm7bVMrGxEKfI6LcnpB4D8bvn2hDKGqKrJaVAJuDaBEY3F7eXyqnFWlOoFV/8ZLspZiZd7orXLhd4mhHQgbuKbHjJWUzrnm0Dxw/LJLzXCkh7slMxKo8uxZIWZfdKHlfI7uj3LP6ARAuWdF7ZmZ7daOKqKGbz5LxOggTgS39oEioYmrqkCeUDvbxkBYKeHhcLmMN8dMF01ZMb32IpL/cH8R7VHQSI5I0YfL14g9d7P/6cjB1JXXxbozEDbsrPdmL8ph7QW10jio+v7YsqHKQ6xrBbOVtxU0/nFfzUGZwIBLwyUvg49ii+54nv9FyECBpURnQK4Ox6N7lw5fsjdd5l/2SwBcAHMJoyjO1Pifye2dagaOwCVMqdJWAo77pvBe0zdJcTWu5fdzPNfV2p1pc7/JKQ8zhKkwsOELUDhXygPJ5oR8Vpk2lsCen3D3QOQp2zdrSZHjVBstDF/wWO98rrkQ6/7zt/Drip7OHIug1lomNdmRaHRrjmqeodn22sesQQPgzimPOMqC60a5+i/UYh51uZm+ijWkkaI2xjrBO2558DZNZMiuDQlaVAvBy2wLn/bR3FrNzfnO/9oDztYqxZrr7JMIhqmrochbqmQnKowxW29bpqTaJu7kW1VotC72QkYX8OoDDdMDwV1kJRk3mufgJBzf+iwFRJ7XWQwO5ujVglgFgHtycWiMLx5N+6XU+TulLabWjOzoao03fniUW0xvIJNPbk7CQlFZd/RCOPvgQbLjh5ITE8NVJeKt3HGr6JTnFdIzcVOlEtwqbIIX0IM7saC+4N5047MTJ9+Wn11EhyEPIlwsHE5utCeXRjQzlrR+R1Cf/qDzcNbqLXdk3J7gQ39VUrrEkS/VMWjjg+t2oYrqB0tUZClcUF6+LBC3EQ7KnGIwm/qjZX4GKPtjTX1zQKV6nPAb2t/Rza5IqKRf8i2DFEhV/YSifX0YwsiF6TQnp48Gr65TFq0zUe6LGjiY7fq0LSGKL1VnC6ESI2yxvt3XqBx53B3gSlGFeJcPbUbonW1E9E9m4NfuwPh+t5QjRxX34lvBPVxwQd7aeTd+r9dw5CiP1pt8wMZoMdni7GapYdo6KPgeQKcmlFfq4UYhvV0IBgeiR3RnTMBaqDqpZrTRyLdsp4l0IXZTdErfH0sN3dqBG5vRIx3VgCYcHmmkqJ8Hyu3s9K9uBD1d8cZUEx3qYcF5vsqeRpF1GOg8emeWM2OmBlWPdZ6qAXwm3nENFyh+kvXk132PfWAlN0kb7yh4fz2T7VWUY/hEXX5DvxGABC03XRpyOG8t/u3Gh5tZdpsSV9AWaxJN7zwhVglgII1gV28tUViyqn4UMdIh5t+Ea2zo7PO48oba0TwQbiSZOH4YhD578kPF3reuaP7LujPMsjHmaDuId9XEaZBCJhbXJbRg5VCk3KJpryH/+8S3wdhR47pdFcmpZG2p0Bpjp/VbvalgIZMllYX5L31aMPdt1J7r/7wbixt0Mnz2ZvNGTARHPVD+2O1D8SGpWXlVnP2ekgon55YiinADDynyaXtZDXueVqbuTi8z8cHHK325pgqM+mWZwzHeEreMvhZopAScXM14SJHpGwZyRljMlDvcMm9FZ/1e9+r/puOnpXOtc9Iu2fmgBfEP9cGW1Fzb1rGlfJ08pACtq1ZW18bf2cevebzVeHbaA50G9qoUp39JWdPHbYkPCRXjt4gzlq3Cxge28Mky8MoS/+On72kc+ZI2xBtgJytpAQHQ1zrEddMIVyR5urX6yBNu8v5lKC8eLdGKTJtbgIZ3ZyTzSfWmx9f+cvcJe8yM39K/djkp2aUTE/9m2Lj5jg7b8vdRAer7DO3SyLNHs1CAm5x5iAdh2yGJYivArZbCBNY88Tw+w+C1Tbt7wK3zl2rzTHo/D8/gb3c3mYrnEIEipYqPUcdWjnTsSw471O3EUN7Gtg4NOAs9PJrxm03VuZKa5xwXAYCjt7Gs01Km6T2DhOYUMoFcCSu7Hk1p3yP1eG+M3v3Q5luAze6WwBnZIYO0TCucPWK+UJ36KoJ8Y+vpavhLO8g5ed704IjlQdfemrMu//EvPYXTQSGIPPfiagJS9nMqP5IvkxN9pvuJz7h8carPXTKMq8jnTeL0STan6dnLTAqwIswcIwWDR2KwbGddAVN8SYWRB7kfBfBRkSXzvHlIF8D6jo64kUzYk5o/n8oLjKqat0rdXvQ86MkwQGMnnlcasqPPT2+mVtUGb32KuH6cyZQenrRG11TArcAl27+nvOMBDe++EKHf4YdyGf7mznzOz33cFFGEcv329p4qG2hoaQ8ULiMyVz6ENcxhoqGnFIdupcn7GICQWuw3yO3W8S33mzCcMYJ8ywc7U7rmaQf/W5K63Gr4bVTpXOyOp4tbaPyIaatBNpXqlmQUTSZXjxPr19+73PSaT+QnI35YsWn6WpfJjRtK8vlJZoTSgjaRU39AGCkWOZtifJrnefCrqwTKDFmuWUCukEsYcRrMzCoit28wYpP7kSVjMD8WJYQiNc2blMjuqYegmf6SsfC1jqz8XzghMlOX+gn/MKZmgljszrmehEa4V98VreJDxYvHr3j7IeJB9/sBZV41BWT/AZAjuC5XorlIPnZgBAniBEhanp0/0+qZmEWDpu8ige1hUPIyTo6T6gDEcFhWSoduNh8YSu65KgMOGBw7VlNYzNIgwHtq9KP2yyTVysqX5v12sf7D+vQUdR2dRDvCV40rIInXSLWT/yrC6ExOQxBJwIDbeZcl3z1yR5Rj3l8IGpxspapnvBL+fwupA3b6fkFceID9wgiM1ILB0cHVdvo/R4xg8yqKXT8efl0GnGX1/27FUYeUW2L/GNRGGWVGp3i91oaJkb4rybENHre9a2P5viz/yqk8ngWUUS+Kv+fu+9BLFnfLiLXOFcIeBJLhnayCiuDRSqcx0Qu68gVsGYc6EHD500Fkt+gpDj6gvr884n8wZ5o6q7xtL5wA0beXQnffWYkZrs2NGIRgQbsc5NB302SVx+R4ROvmgZaR8wBcji128BMfJ9kcvJ4DC+bQ57kRmv5yxgU4ngZfn0/JNZ8JBwxjTqS+s9kjJFG1unGUGLwMiIuXUD9EFhNIJuyCEAmVZSIGKH4G6v1gRR1LyzQKH2ZqiI1DnHMoDEZspbDjTeaFIAbSvjSq3A+n46y9hhVM8wIpnARSXyzmOD96d9UXvFroSPgGw1dq2vdEqDq9fJN1EbL2WulNmHkFDvxSO9ZT/RX/Bw2gA/BrF90XrJACereVfbV/YXaKfp77Nmx5NjEIUlxojsy7iN7nBHSZigfsbFyVOX1ZTeCCxvqnRSExP4lk5ZeYlRu9caaa743TWNdchRIhEWwadsBIe245C8clpaZ4zrPsk+OwXzxWCvRRumyNSLW5KWaSJyJU95cwheK76gr7228spZ3hmTtLyrfM2QRFqZFMR8/Q6yWfVgwTdfX2Ry4w3+eAO/5VT5nFb5NlzXPvBEAWrNZ6Q3jbH0RF4vcbp+fDngf/ywpoyNQtjrfvcq93AVb1RDWRghvyqgI2BkMr1rwYi8gizZ0G9GmPpMeqPerAQ0dJbzx+KAFM4IBq6iSLpZHUroeyfd9o5o+4fR2EtsZBoJORQEA4SW0CmeXSnblx2e9QkCHIodyqV6+g5ETEpZsLqnd/Na60EKPX/tQpPEcO+COIBPcQdszDzSiHGyQFPly/7KciUh1u+mFfxTCHGv9nn2WqndGgeGjQ/kr02qmTBX7Hc1qiEvgiSz1Tz/sy7Es29wvn6FrDGPP7asXlhOaiHxOctPvTptFA1kHFUk8bME7SsTSnGbFbUrssxrq70LhoSh5OwvQna+w84XdXhZb2sloJ4ZsCg3j+PrjJL08/JBi5zGd6ud/ZxhmcGKLOXPcNunQq5ESW92iJvfsuRrNYtawWwSmNhPYoFj2QqWNF0ffLpGt/ad24RJ8vkb5sXkpyKXmvFG5Vcdzf/44k3PBL/ojJ52+kWGzOArnyp5f969oV3J2c4Li27Nkova9VwRNVKqN0V+gV+mTHitgkXV30aWd3A1RSildEleiNPA+5cp+3+T7X+xfHiRZXQ1s4FA9TxIcnveQs9JSZ5r5qNmgqlW4zMtZ6rYNvgmyVcywKtu8ZxnSbS5vXlBV+NXdIfi3+xzrnJ0TkFL+Un8v1PWOC2PPFCjVPq7qTH7mOpzOYj/b4h0ceT+eHgr97Jqhb1ziVfeANzfN8bFUhPKBi7hJBCukQnB0aGjFTYLJPXL26lQ2b80xrOD5cFWgA8hz3St0e69kwNnD3+nX3gy12FjrjO+ddRvvvfyV3SWbXcxqNHfmsb9u1TV+wHTb9B07/L2sB8WUHJ9eeNomDyysEWZ0deqEhH/oWI2oiEh526gvAK1Nx2kIhNvkYR+tPYHEa9j+nd1VBpQP1uzSjIDO+fDDB7uy029rRjDC5Sk6aKczyz1D5uA9Lu+Rrrapl8JXNL3VRllNQH2K1ZFxOpX8LprttfqQ56MbPM0IttUheXWD/mROOeFqGUbL+kUOVlXLTFX/525g4faLEFO4qWWdmOXMNvVjpIVTWt650HfQjX9oT3Dg5Au6+v1/Ci78La6ZOngYCFPT1AUwxQuZ0yt5xKdNXLaDTISMTeCj16XTryhM36K2mfGRIgot71voWs8tTpL/f1rvcwv3LSDf+/G8THCT7NpfHWcW+lsF/ol8q9Bi6MezNTqp0rpp/kJRiVfNrX/w27cRRTu8RIIqtUblBMkxy4jwAVqCjUJkiPBj2cAoVloG8B2/N5deLdMhDb7xs5nhd3dubJhuj8WbaFRyu1L678DHhhA+rMimNo4C1kGpp0tD/qnCfCFHejpf0LJX43OTr578PY0tnIIrlWyNYyuR/ie6j2xNb1OV6u0dOX/1Dtcd7+ya9W+rY2LmnyQMtk8SMLTon8RAdwOaN2tNg5zVnDKlmVeOxPV2vhHIo9QEPV7jc3f+zVDquiNg1OaHX3cZXJDRY5MJpo+VanAcmqp4oasYLG+wrXUL5vJU0kqk2hGEskhP+Jjigrz1l6QnEwp6n8PMVeJp70Ii6ppeaK9GhF6fJE00ceLyxv08tKiPat4QdxZFgSbQknnEiCLD8Qc1rjazVKM3r3gXnnMeONgdz/yFV1q+haaN+wnF3Fn4uYCI9XsKOuVwDD0LsCO/f0gj5cmxCFcr7sclIcefWjvore+3aSU474cyqDVxH7w1RX3CHsaqsMRX17ZLgjsDXws3kLm2XJdM3Ku383UXqaHqsywzPhx7NFir0Fqjym/w6cxD2U9ypa3dx7Z12w/fi3Jps8sqJ8f8Ah8aZAvkHXvIRyrsxK7rrFaNNdNvjI8+3Emri195DCNa858anj2Qdny6Czshkn4N2+1m+k5S8sunX3Ja7I+JutRzg1mc2e9Yc0Zv9PZn1SwhxIdU9sXwZRTd/J5FoUm0e+PYREeHg3oc2YYzGf2xfJxXExt4pT3RfDRHvMXLUmoXOy63xv5pLuhOEax0dRgSywZ/GH+YBXFgCeTU0hZ8SPEFsn8punp1Kurd1KgXxUZ+la3R5+4ePGR4ZF5UQtOa83+Vj8zh80dfzbhxWCeoJnQ4dkZJM4drzknZOOKx2n3WrvJnzFIS8p0xeic+M3ZRVXIp10tV2DyYKwRxLzulPwzHcLlYTxl4PF7v8l106Azr+6wBFejbq/3P72C/0j78cepY9990/d4eAurn2lqdGKLU8FffnMw7cY7pVeXJRMU73Oxwi2g2vh/+4gX8dvbjfojn/eLVhhYl8GthwCQ50KcZq4z2JeW5eeOnJWFQEnVxDoG459TaC4zXybECEoJ0V5q1tXrQbDMtUxeTV6Pdt1/zJuc7TJoV/9YZFWxUtCf6Ou3Vd/vR/vG0138hJQrHkNeoep5dLe+6umcSquKvMaFpm3EZHDBOvCi0XYyIFHMgX7Cqp3JVXlxJFwQfHSaIUEbI2u1lBVUdlNw4Qa9UsLPEK94Qiln3pyKxQVCeNlx8yd7EegVNQBkFLabKvnietYVB4IPZ1fSor82arbgYec8aSdFMaIluYTYuNx32SxfrjKUdPGq+UNp5YpydoEG3xVLixtmHO9zXxKAnHnPuH2fPGrjx0GcuCDEU+yXUtXh6nfUL+cykws1gJ5vkfYFaFBr9PdCXvVf35OJQxzUMmWjv0W6uGJK11uAGDqSpOwCf6rouSIjPVgw57cJCOQ4b9tkI/Y5WNon9Swe72aZryKo8d+HyHBEdWJKrkary0LIGczA4Irq353Wc0Zga3om7UQiAGCvIl8GGyaqz5zH+1gMP5phWUCpKtttWIyicz09vXg76GxkmiGSMQ06Z9X8BUwqOtauDbPIf4rpK/yYoeAHxJ9soXS9VDe1Aw+awOOxaN8foLrif0TXBvQ55dtRtulRq9emFDBxlQcqKCaD8NeTSE7FOHvcjf/+oKbbtRqz9gbofoc2EzQ3pL6W5JdfJzAWmOk8oeoECe90lVMruwl/ltM015P/zIPazqvdvFmLNVHMIZrwiQ2tIKtGh6PDVH+85ew3caqVt2BsDv5rOcu3G9srQWd7NmgtzCRUXLYknYRSwtH9oUtkqyN3CfP20xQ1faXQl4MEmjQehWR6GmGnkdpYNQYeIG408yAX7uCZmYUic9juOfb+Re28+OVOB+scYK4DaPcBe+5wmji9gymtkMpKo4UKqCz7yxzuN8VIlx9yNozpRJpNaWHtaZVEqP45n2JemTlYBSmNIK1FuSYAUQ1yBLnKxevrjayd+h2i8PjdB3YY6b0nr3JuOXGpPMyh4V2dslpR3DFEvgpsBLqhqLDOWP4yEvIL6f21PpA7/8B"));
                const $43d7963e56408b24$var$log2 = Math.log2 || ((n) => Math.log(n) / Math.LN2);
                const $43d7963e56408b24$var$bits = (n) => $43d7963e56408b24$var$log2(n) + 1 | 0;
                const $43d7963e56408b24$var$CATEGORY_BITS = $43d7963e56408b24$var$bits((0, $parcel$interopDefault($29668e65f2091c2c$exports)).categories.length - 1);
                const $43d7963e56408b24$var$COMBINING_BITS = $43d7963e56408b24$var$bits((0, $parcel$interopDefault($29668e65f2091c2c$exports)).combiningClasses.length - 1);
                const $43d7963e56408b24$var$SCRIPT_BITS = $43d7963e56408b24$var$bits((0, $parcel$interopDefault($29668e65f2091c2c$exports)).scripts.length - 1);
                const $43d7963e56408b24$var$EAW_BITS = $43d7963e56408b24$var$bits((0, $parcel$interopDefault($29668e65f2091c2c$exports)).eaw.length - 1);
                const $43d7963e56408b24$var$NUMBER_BITS = 10;
                const $43d7963e56408b24$var$CATEGORY_SHIFT = $43d7963e56408b24$var$COMBINING_BITS + $43d7963e56408b24$var$SCRIPT_BITS + $43d7963e56408b24$var$EAW_BITS + $43d7963e56408b24$var$NUMBER_BITS;
                const $43d7963e56408b24$var$COMBINING_SHIFT = $43d7963e56408b24$var$SCRIPT_BITS + $43d7963e56408b24$var$EAW_BITS + $43d7963e56408b24$var$NUMBER_BITS;
                const $43d7963e56408b24$var$SCRIPT_SHIFT = $43d7963e56408b24$var$EAW_BITS + $43d7963e56408b24$var$NUMBER_BITS;
                const $43d7963e56408b24$var$EAW_SHIFT = $43d7963e56408b24$var$NUMBER_BITS;
                const $43d7963e56408b24$var$CATEGORY_MASK = (1 << $43d7963e56408b24$var$CATEGORY_BITS) - 1;
                const $43d7963e56408b24$var$COMBINING_MASK = (1 << $43d7963e56408b24$var$COMBINING_BITS) - 1;
                const $43d7963e56408b24$var$SCRIPT_MASK = (1 << $43d7963e56408b24$var$SCRIPT_BITS) - 1;
                const $43d7963e56408b24$var$EAW_MASK = (1 << $43d7963e56408b24$var$EAW_BITS) - 1;
                const $43d7963e56408b24$var$NUMBER_MASK = (1 << $43d7963e56408b24$var$NUMBER_BITS) - 1;
                function $43d7963e56408b24$export$410364bbb673ddbc(codePoint) {
                  const val = $43d7963e56408b24$var$trie.get(codePoint);
                  return (0, $parcel$interopDefault($29668e65f2091c2c$exports)).categories[val >> $43d7963e56408b24$var$CATEGORY_SHIFT & $43d7963e56408b24$var$CATEGORY_MASK];
                }
                function $43d7963e56408b24$export$c03b919c6651ed55(codePoint) {
                  const val = $43d7963e56408b24$var$trie.get(codePoint);
                  return (0, $parcel$interopDefault($29668e65f2091c2c$exports)).combiningClasses[val >> $43d7963e56408b24$var$COMBINING_SHIFT & $43d7963e56408b24$var$COMBINING_MASK];
                }
                function $43d7963e56408b24$export$941569448d136665(codePoint) {
                  const val = $43d7963e56408b24$var$trie.get(codePoint);
                  return (0, $parcel$interopDefault($29668e65f2091c2c$exports)).scripts[val >> $43d7963e56408b24$var$SCRIPT_SHIFT & $43d7963e56408b24$var$SCRIPT_MASK];
                }
                function $43d7963e56408b24$export$92f6187db8ca6d26(codePoint) {
                  const val = $43d7963e56408b24$var$trie.get(codePoint);
                  return (0, $parcel$interopDefault($29668e65f2091c2c$exports)).eaw[val >> $43d7963e56408b24$var$EAW_SHIFT & $43d7963e56408b24$var$EAW_MASK];
                }
                function $43d7963e56408b24$export$7d1258ebb7625a0d(codePoint) {
                  let val = $43d7963e56408b24$var$trie.get(codePoint);
                  let num = val & $43d7963e56408b24$var$NUMBER_MASK;
                  if (num === 0)
                    return null;
                  else if (num <= 50)
                    return num - 1;
                  else if (num < 480) {
                    const numerator = (num >> 4) - 12;
                    const denominator = (num & 15) + 1;
                    return numerator / denominator;
                  } else if (num < 768) {
                    val = (num >> 5) - 14;
                    let exp = (num & 31) + 2;
                    while (exp > 0) {
                      val *= 10;
                      exp--;
                    }
                    return val;
                  } else {
                    val = (num >> 2) - 191;
                    let exp = (num & 3) + 1;
                    while (exp > 0) {
                      val *= 60;
                      exp--;
                    }
                    return val;
                  }
                }
                function $43d7963e56408b24$export$52c8ea63abd07594(codePoint) {
                  const category = $43d7963e56408b24$export$410364bbb673ddbc(codePoint);
                  return category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Nl";
                }
                function $43d7963e56408b24$export$727d9dbc4fbb948f(codePoint) {
                  return $43d7963e56408b24$export$410364bbb673ddbc(codePoint) === "Nd";
                }
                function $43d7963e56408b24$export$a5b49f4dc6a07d2c(codePoint) {
                  const category = $43d7963e56408b24$export$410364bbb673ddbc(codePoint);
                  return category === "Pc" || category === "Pd" || category === "Pe" || category === "Pf" || category === "Pi" || category === "Po" || category === "Ps";
                }
                function $43d7963e56408b24$export$7b6804e8df61fcf5(codePoint) {
                  return $43d7963e56408b24$export$410364bbb673ddbc(codePoint) === "Ll";
                }
                function $43d7963e56408b24$export$aebd617640818cda(codePoint) {
                  return $43d7963e56408b24$export$410364bbb673ddbc(codePoint) === "Lu";
                }
                function $43d7963e56408b24$export$de8b4ee23b2cf823(codePoint) {
                  return $43d7963e56408b24$export$410364bbb673ddbc(codePoint) === "Lt";
                }
                function $43d7963e56408b24$export$3c52dd84024ae72c(codePoint) {
                  const category = $43d7963e56408b24$export$410364bbb673ddbc(codePoint);
                  return category === "Zs" || category === "Zl" || category === "Zp";
                }
                function $43d7963e56408b24$export$a11bdcffe109e74b(codePoint) {
                  const category = $43d7963e56408b24$export$410364bbb673ddbc(codePoint);
                  return category === "Nd" || category === "No" || category === "Nl" || category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Me" || category === "Mc";
                }
                function $43d7963e56408b24$export$e33ad6871e762338(codePoint) {
                  const category = $43d7963e56408b24$export$410364bbb673ddbc(codePoint);
                  return category === "Mn" || category === "Me" || category === "Mc";
                }
                var $43d7963e56408b24$export$2e2bcd8739ae039 = {
                  getCategory: $43d7963e56408b24$export$410364bbb673ddbc,
                  getCombiningClass: $43d7963e56408b24$export$c03b919c6651ed55,
                  getScript: $43d7963e56408b24$export$941569448d136665,
                  getEastAsianWidth: $43d7963e56408b24$export$92f6187db8ca6d26,
                  getNumericValue: $43d7963e56408b24$export$7d1258ebb7625a0d,
                  isAlphabetic: $43d7963e56408b24$export$52c8ea63abd07594,
                  isDigit: $43d7963e56408b24$export$727d9dbc4fbb948f,
                  isPunctuation: $43d7963e56408b24$export$a5b49f4dc6a07d2c,
                  isLowerCase: $43d7963e56408b24$export$7b6804e8df61fcf5,
                  isUpperCase: $43d7963e56408b24$export$aebd617640818cda,
                  isTitleCase: $43d7963e56408b24$export$de8b4ee23b2cf823,
                  isWhiteSpace: $43d7963e56408b24$export$3c52dd84024ae72c,
                  isBaseForm: $43d7963e56408b24$export$a11bdcffe109e74b,
                  isMark: $43d7963e56408b24$export$e33ad6871e762338
                };
              }
            ),
            /***/
            3480: (
              /***/
              function(module2) {
                "use strict";
                module2.exports = JSON.parse('[["8740",""],["8767",""],["87a1",""],["8840","",4,""],["88a1",""],["8940",""],["8943",""],["8946",""],["894c",""],["89a1",""],["89ab",""],["89b0",""],["89b5",""],["89c1",""],["89c5",""],["8a40",""],["8a43",""],["8a64",""],["8a76",""],["8aa1",""],["8aac",""],["8ab2",""],["8abb",""],["8ac9",""],["8ace",""],["8adf",""],["8af6",""],["8b40",""],["8b55",""],["8ba1",""],["8bde",""],["8c40",""],["8ca1",""],["8ca7",""],["8cc9",""],["8cce",""],["8ce6",""],["8d40",""],["8d42",""],["8da1",""],["8e40",""],["8ea1",""],["8f40",""],["8fa1",""],["9040",""],["90a1",""],["9140",""],["91a1",""],["9240",""],["92a1",""],["9340",""],["93a1",""],["9440",""],["94a1",""],["9540",""],["95a1",""],["9640",""],["96a1",""],["9740",""],["97a1",""],["9840",""],["98a1",""],["9940",""],["99a1",""],["9a40",""],["9aa1",""],["9b40",""],["9b62",""],["9ba1",""],["9c40",""],["9ca1",""],["9d40",""],["9da1",""],["9e40",""],["9ea1",""],["9ead",""],["9ec5",""],["9ef5",""],["9f40",""],["9f4f",""],["9fa1",""],["9fae",""],["9fb2",""],["9fc1",""],["9fc9",""],["9fdb",""],["9fe7",""],["9feb",""],["9ff0",""],["a040",""],["a055",""],["a058",""],["a05b",""],["a063",""],["a073",""],["a0a1",""],["a0a6",""],["a0ae",""],["a0b0",""],["a0d4",""],["a0e2",""],["a3c0","",31,""],["c6a1","",9,"",9,"",9,"",23],["c740","",58,""],["c7a1","",81,"",5,"",4],["c840","",26,"",25,""],["c8a1",""],["c8cd",""],["c8f5",""],["f9fe",""],["fa40",""],["faa1",""],["fb40",""],["fba1",""],["fc40",""],["fca1",""],["fd40",""],["fda1",""],["fe40",""],["fea1",""]]');
              }
            ),
            /***/
            3336: (
              /***/
              function(module2) {
                "use strict";
                module2.exports = JSON.parse('[["0","\\u0000",127,""],["8140","",5,"",9,"",6,""],["8180","",6,"",4,"",4,"",5,""],["8240","",4,"",8,"",4,"",11],["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],["8340","",17,"",5,"",10,"",4,"",9,""],["8380","",5,"",13,"",28,"",4,"",4,"",5],["8440","",5,"",5,""],["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],["8540","",9,""],["8580","",4,"",6,"",4,"",4,"",7,""],["8640","",4,"",5,"",4,"",5,""],["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],["8740","",7,"",11,"",4,"",4],["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],["8840","",9,"",4,"",4,""],["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],["8940","",5,"",6,"",4,"",5,"",4,"",16,""],["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],["8a40","",4,"",12,""],["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],["8b40","",8,"",17,"",6,"",13,""],["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],["8c40","",7,""],["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],["8d40","",5,"",5,"",5,"",6,"",9,"",4],["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],["8e40","",21,"",12,"",6,"",12,""],["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],["8f40","",5,"",11,"",8,""],["8f80","",6,"",14,"",5,"",5,"",4,""],["9040","",4,"",4,"",6,""],["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],["9140","",6,"",6,"",18,"",4,""],["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],["9240","",6,"",5,""],["9280","",5,"",7,"",6,""],["9340","",6,"",4,"",4,"",5,""],["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],["9440","",24,"",7,"",7,"",4,"",8],["9480","",4,"",4,"",14,"",7,"",7,""],["9540","",4,"",4,"",6,""],["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],["9640","",5,"",4,""],["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],["9740","",7,"",8,"",7,"",9,""],["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],["9840","",4,"",5,"",9,""],["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],["9980","",114,"",6],["9a40","",11,"",7,"",13,""],["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],["9b40","",4,""],["9b80","",5,"",4,"",4,"",5,""],["9c40","",7,""],["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],["9d40","",7,"",4,"",9,"",6,""],["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],["9e40","",7,"",32,"",7,"",6,"",6],["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],["9f40","",6,"",10,"",4,"",10,"",7,""],["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],["a040","",9,"",5,"",9,"",11,"",19],["a080","",9,"",6,"",4,"",11,"",11,"",6,""],["a1a1","",7,""],["a2a1","",9],["a2b1","",19,"",19,"",9],["a2e5","",9],["a2f1","",11],["a3a1","",88,""],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a6e0",""],["a6ee",""],["a6f4",""],["a7a1","",5,"",25],["a7d1","",5,"",25],["a840","",35,"",6],["a880","",7,""],["a8a1",""],["a8bd",""],["a8c0",""],["a8c5","",36],["a940","",8,""],["a959",""],["a95c",""],["a960","",9,"",8],["a980","",4,""],["a996",""],["a9a4","",75],["aa40","",5,"",5,"",8],["aa80","",7,"",10,""],["ab40","",11,"",4,"",5,"",4],["ab80","",6,"",4],["ac40","",10,"",8,"",5,"",4,"",11],["ac80","",6,"",12,"",4,""],["ad40","",10,"",7,"",15,"",12],["ad80","",9,"",8,"",6,""],["ae40","",6,"",7,"",4,""],["ae80","",7,"",6,"",4,""],["af40","",4,""],["af80",""],["b040","",6,"",5,"",4,"",6,"",7,""],["b080","",7,"",8,"",9,""],["b140","",4,"",7,"",10,""],["b180","",4,"",7,"",7,""],["b240","",11,"",5,"",11,"",4],["b280","",12,"",8,"",4,""],["b340","",5,""],["b380","",11,"",7,"",6,""],["b440","",7,"",9],["b480","",4,"",5,"",6,""],["b540","",5,"",9,"",4,"",14,"",4,"",8,""],["b580","",6,"",4,""],["b640","",6,"",11,"",10,"",4,"",5,""],["b680","",6,"",4,""],["b740","",14,"",5,"",9,"",4,"",16],["b780","",6,""],["b840","",4,"",10,"",10,"",9,"",5,""],["b880","",4,""],["b940","",5,"",10,"",6,""],["b980","",7,""],["ba40","",4,"",4,"",7,"",5,""],["ba80","",4,"",5,"",12,"",5,""],["bb40","",9,"",36,"",5,"",9],["bb80","",6,"",4,""],["bc40","",6,"",6,"",5,"",7,"",13,"",5],["bc80","",14,"",6,""],["bd40","",54,"",7],["bd80","",32,""],["be40","",12,"",6,"",42],["be80","",32,""],["bf40","",62],["bf80","",4,"",4,"",21,""],["c040","",35,"",23,""],["c080","",6,"",9,""],["c140","",4,"",7,"",4,"",4,"",6,""],["c180","",4,"",4,"",5,""],["c240","",6,"",5,""],["c280","",13,"",5,"",11,""],["c340","",5,"",4,"",6,""],["c380","",12,"",4,""],["c440","",5,"",4,"",4,"",5,"",4,""],["c480","",7,"",5,"",6,""],["c540","",14,"",4,"",5,"",4,"",5,""],["c580","",7,"",7,""],["c640",""],["c680","",4,"",9,""],["c740","",4,"",4,"",6,"",6,"",6,""],["c780",""],["c840","",4,"",5,"",5,"",7,"",5,"",7,""],["c880","",6,"",4,"",4,""],["c940","",4,"",7,"",12,""],["c980","",4,"",4,"",10,""],["ca40","",8,"",8,"",9,"",4,"",10],["ca80","",4,"",8,""],["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],["cb80","",5,"",6,"",14,""],["cc40","",4,"",10,"",15,"",13,""],["cc80","",11,"",4,"",7,""],["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],["cd80",""],["ce40","",6,"",5,"",7,""],["ce80","",4,"",6,"",4,""],["cf40","",4,"",4,"",6,"",9],["cf80","",5,"",7,"",4,""],["d040","",13,"",5,"",5,"",5,"",6,""],["d080","",4,"",4,"",5,""],["d140","",4,"",4,"",6,"",5],["d180","",4,"",4,"",4,""],["d240","",8,"",24,"",5,"",19,""],["d280","",26,""],["d340","",30,"",6],["d380","",4,"",5,"",21,""],["d440","",31,"",8,"",21],["d480","",25,"",6,""],["d540","",7,"",7,"",46],["d580","",32,""],["d640","",34,"",27],["d680","",30,""],["d740","",31,"",4,"",25],["d780","",24,""],["d840","",8,"",7,"",5,"",6,"",6,"",6,""],["d880","",6,"",20,""],["d940","",62],["d980","",32,""],["da40","",14,"",8,"",4,"",9,""],["da80","",12,""],["db40","",6,"",7,"",4,""],["db80","",4,"",5,"",11,""],["dc40","",4,"",6,"",6,"",11,"",6,"",7],["dc80","",10,"",21,""],["dd40","",62],["dd80","",32,""],["de40","",32,""],["de80","",4,""],["df40","",5,"",4,"",4,"",5,"",4,"",6,""],["df80","",4,""],["e040","",19,""],["e080","",10,"",6,"",8,""],["e140","",4,"",6,"",5,"",5,""],["e180","",10,"",9,"",8,""],["e240","",62],["e280","",32,"",5,""],["e340","",45,"",16],["e380","",7,"",24,""],["e440","",5,"",24,"",31],["e480","",32,""],["e540","",51,"",10],["e580","",31,""],["e640","",34,"",27],["e680","",29,""],["e740","",7,"",54],["e780","",32,"",6,"",4,""],["e840","",14,"",43,""],["e880","",20,""],["e940","",7,"",42],["e980","",32,""],["ea40","",27,"",6,""],["ea80","",4,"",12,""],["eb40","",9,"",7,"",9,"",6,""],["eb80","",4,""],["ec40","",8,"",4,"",18,"",7],["ec80","",4,"",7,"",4,"",4,""],["ed40","",6,"",46],["ed80","",4,"",23,""],["ee40","",62],["ee80","",32,"",4,"",6,""],["ef40","",5,"",37,"",4],["ef80","",30,"",4,"",8,""],["f040","",4,"",28,"",26],["f080","",9,"",12,"",4,"",6,""],["f140","",10,"",47],["f180","",32,""],["f240","",62],["f280","",32,""],["f340","",17,"",6,"",4,""],["f380","",8,"",6,""],["f440","",5,"",10,"",10,"",7,"",5],["f480","",32,""],["f540","",62],["f580","",32,""],["f640","",62],["f680","",32,"",5,"",5,"",4,"",7,""],["f740","",62],["f780","",4,"",4,""],["f840","",62],["f880","",32],["f940","",62],["f980","",32],["fa40","",62],["fa80","",32],["fb40","",27,"",9,""],["fb80","",5,"",8,"",5,""],["fc40","",8,"",4,"",8,"",6],["fc80","",4,"",5,"",8,""],["fd40","",4,"",4,"",10,"",38],["fd80","",5,"",11,"",4,""],["fe40",""]]');
              }
            ),
            /***/
            7348: (
              /***/
              function(module2) {
                "use strict";
                module2.exports = JSON.parse('[["0","\\u0000",127],["8141","",4,"",6,""],["8161","",9,"",5,""],["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],["8241","",7,"",5],["8261","",6,"",5,""],["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],["8341","",5,"",5,"",7],["8361","",18,""],["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],["8441","",5,"",8],["8461","",18],["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],["8541","",5,"",4,"",6,"",4],["8561","",5,"",5,"",6,""],["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],["8641","",6,"",5,""],["8661","",6,"",10],["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],["8741","",9,"",15],["8761","",18,""],["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],["8841","",4,"",5,"",6,"",4],["8861","",4,""],["8881","",15,"",4,"",6,"",5,"",54,""],["8941","",6,"",5,""],["8961","",10,"",5,""],["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],["8a41","",10,"",6,""],["8a61","",4,"",18,""],["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],["8b41","",5,"",4,"",6,""],["8b61","",6,"",8],["8b81","",52,"",4,"",6,"",5,"",18,"",18],["8c41","",15,"",4],["8c61","",6,"",5,"",6,"",5],["8c81","",12,"",26,"",50,"",5,"",16],["8d41","",16,"",8],["8d61","",17,""],["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],["8e41","",6,"",5,"",8],["8e61","",4,"",19],["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],["8f41","",7,"",17],["8f61","",7,"",6,"",4],["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],["9041","",6,"",5,""],["9061","",5,"",15],["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],["9141","",6,"",5],["9161","",9,"",5],["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],["9241","",7,"",4,""],["9261","",7,"",7,"",4],["9281","",21,"",18,"",6,"",7,"",6,"",35,""],["9341","",4,""],["9361","",6,"",8],["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],["9441","",5,"",5,"",8],["9461","",5,"",6,"",12],["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],["9541","",11,"",5,""],["9561","",6,"",5,""],["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],["9641","",23,""],["9661","",6,"",5,"",8],["9681","",10,"",5,"",13,"",33,"",6,"",44],["9741","",16,"",8],["9761","",17,"",7],["9781","",11,"",5,"",6,"",89,""],["9841","",16,"",5,""],["9861","",6,"",15],["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],["9941","",6,"",5,""],["9961","",6,"",5,""],["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],["9a41","",16],["9a61","",6,"",6,""],["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],["9b41","",6,"",8],["9b61","",17,"",7],["9b81","",25,"",4,"",5,"",50,"",22,""],["9c41","",4,"",5,"",5],["9c61","",8,"",6,"",9],["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],["9d41","",13,"",8],["9d61","",25],["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],["9e41","",7,"",9,""],["9e61","",4,"",6,""],["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],["9f41","",5,"",4,"",5,""],["9f61","",6,"",5,""],["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],["a041","",5,"",6,""],["a061","",5,"",13],["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],["a141","",18,""],["a161","",6,"",5,""],["a181","",14,"",5,"",4,"",9,""],["a241","",5,"",18],["a261","",6,"",18],["a281","",7,"",6,"",7,""],["a341","",6,"",10,""],["a361","",6,"",16],["a381","",16,"",4,"",58,"",32,""],["a441","",5,""],["a461","",5,"",12],["a481","",28,"",93],["a541","",4,"",6,"",5,""],["a561","",17,"",5,""],["a581","",16,"",14,"",9],["a5b0","",9],["a5c1","",16,"",6],["a5e1","",16,"",6],["a641","",19,""],["a661","",5,"",5,"",6],["a681","",6,"",18,"",7],["a741","",4,"",6,"",7],["a761","",22,""],["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],["a841","",10,"",14],["a861","",18,"",6],["a881","",19,"",11,""],["a8a6",""],["a8a8",""],["a8b1","",27,"",25,"",14,""],["a941","",14,"",10],["a961","",18],["a981","",14,"",6,"",27,"",25,"",14,""],["aa41","",6,"",4,""],["aa61","",4,"",5,"",6,""],["aa81","",29,"",82],["ab41","",6,"",5,""],["ab61","",6,"",5,"",5],["ab81","",8,"",6,"",12,"",85],["ac41","",5,"",6,""],["ac61","",11,"",4],["ac81","",28,"",5,"",25],["acd1","",5,"",25],["ad41","",6,"",5,"",7],["ad61","",6,"",10,""],["ad81","",5,"",18,""],["ae41","",5,"",16],["ae61","",5,"",6,"",4],["ae81","",6,"",5,""],["af41","",19],["af61","",13,"",5,""],["af81","",5,"",6,"",5,""],["b041","",5,"",5,"",12],["b061","",5,"",19],["b081","",13,"",6,"",5,"",7,"",4,""],["b141","",6,"",5,""],["b161","",6,"",5,"",11],["b181","",14,"",6,""],["b241","",6,"",5,""],["b261","",18,"",5,""],["b281","",5,"",18,"",6,""],["b341","",19,""],["b361","",5,"",5,"",5],["b381","",5,"",5,"",19,"",4,""],["b441","",5,"",6,"",5],["b461","",6,"",10,""],["b481","",6,"",18,"",4,"",4,""],["b541","",14,"",5],["b561","",5,"",5,"",4],["b581","",6,"",5,"",11,""],["b641","",7,"",17],["b661","",15,""],["b681","",5,"",6,"",5,""],["b741","",13,"",6,""],["b761","",20,""],["b781","",6,"",14,""],["b841","",7,"",17],["b861","",8,"",13],["b881","",5,"",24,"",4,""],["b941","",6,"",5,""],["b961","",14,"",6,""],["b981","",22,"",4,"",4,""],["ba41","",5,"",6,""],["ba61","",5,"",4,"",5],["ba81","",6,"",9,""],["bb41","",4,"",5,"",4,""],["bb61","",6,"",5,""],["bb81","",31,""],["bc41","",17,""],["bc61","",5,"",6,""],["bc81","",4,"",6,"",5,"",5,"",4,""],["bd41","",7,"",7,""],["bd61","",5,"",13],["bd81","",5,"",25,""],["be41","",7,"",14],["be61","",7,"",7,""],["be81","",4,"",4,"",5,"",8,"",6,""],["bf41","",10,"",14],["bf61","",18,""],["bf81","",5,"",7,"",6,"",5,""],["c041","",5,"",6,"",5],["c061","",25],["c081","",6,"",5,"",7,""],["c141","",5,"",6,""],["c161","",19,""],["c181","",31,""],["c241","",4,"",5,""],["c261","",4,"",5,"",6,""],["c281","",5,"",7,"",9,""],["c341","",4],["c361","",4,"",5,"",11],["c381","",5,"",7,"",5,""],["c441","",7,"",7,""],["c461","",5,"",4],["c481","",5,"",11,""],["c541","",6,"",5,""],["c561","",6,"",5,"",4],["c581","",6,"",5,""],["c641","",6,"",5],["c6a1",""],["c7a1",""],["c8a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1","",5,"",4,""],["d2a1","",4,"",5,"",10,"",7,"",5,""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f5a1",""],["f6a1",""],["f7a1",""],["f8a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fda1",""]]');
              }
            ),
            /***/
            4284: (
              /***/
              function(module2) {
                "use strict";
                module2.exports = JSON.parse('[["0","\\u0000",127],["a140",""],["a1a1","",4,""],["a240","",7,""],["a2a1","",9,"",9,"",8,"",25,"",21],["a340","",16,"",6,"",16,"",6,"",10],["a3a1","",25,""],["a3e1",""],["a440",""],["a4a1",""],["a540",""],["a5a1",""],["a640",""],["a6a1",""],["a740",""],["a7a1",""],["a840",""],["a8a1",""],["a940",""],["a9a1",""],["aa40",""],["aaa1",""],["ab40",""],["aba1",""],["ac40",""],["aca1",""],["ad40",""],["ada1",""],["ae40",""],["aea1",""],["af40",""],["afa1",""],["b040",""],["b0a1",""],["b140",""],["b1a1",""],["b240",""],["b2a1",""],["b340",""],["b3a1",""],["b440",""],["b4a1",""],["b540",""],["b5a1",""],["b640",""],["b6a1",""],["b740",""],["b7a1",""],["b840",""],["b8a1",""],["b940",""],["b9a1",""],["ba40",""],["baa1",""],["bb40",""],["bba1",""],["bc40",""],["bca1",""],["bd40",""],["bda1",""],["be40",""],["bea1",""],["bf40",""],["bfa1",""],["c040",""],["c0a1",""],["c140",""],["c1a1",""],["c240",""],["c2a1",""],["c340",""],["c3a1",""],["c440",""],["c4a1",""],["c540",""],["c5a1",""],["c640",""],["c940",""],["c9a1",""],["ca40",""],["caa1",""],["cb40",""],["cba1",""],["cc40",""],["cca1",""],["cd40",""],["cda1",""],["ce40",""],["cea1",""],["cf40",""],["cfa1",""],["d040",""],["d0a1",""],["d140",""],["d1a1",""],["d240",""],["d2a1",""],["d340",""],["d3a1",""],["d440",""],["d4a1",""],["d540",""],["d5a1",""],["d640",""],["d6a1",""],["d740",""],["d7a1",""],["d840",""],["d8a1",""],["d940",""],["d9a1",""],["da40",""],["daa1",""],["db40",""],["dba1",""],["dc40",""],["dca1",""],["dd40",""],["dda1",""],["de40",""],["dea1",""],["df40",""],["dfa1",""],["e040",""],["e0a1",""],["e140",""],["e1a1",""],["e240",""],["e2a1",""],["e340",""],["e3a1",""],["e440",""],["e4a1",""],["e540",""],["e5a1",""],["e640",""],["e6a1",""],["e740",""],["e7a1",""],["e840",""],["e8a1",""],["e940",""],["e9a1",""],["ea40",""],["eaa1",""],["eb40",""],["eba1",""],["ec40",""],["eca1",""],["ed40",""],["eda1",""],["ee40",""],["eea1",""],["ef40",""],["efa1",""],["f040",""],["f0a1",""],["f140",""],["f1a1",""],["f240",""],["f2a1",""],["f340",""],["f3a1",""],["f440",""],["f4a1",""],["f540",""],["f5a1",""],["f640",""],["f6a1",""],["f740",""],["f7a1",""],["f840",""],["f8a1",""],["f940",""],["f9a1",""]]');
              }
            ),
            /***/
            5633: (
              /***/
              function(module2) {
                "use strict";
                module2.exports = JSON.parse('[["0","\\u0000",127],["8ea1","",62],["a1a1","",9,""],["a2a1",""],["a2ba",""],["a2ca",""],["a2dc",""],["a2f2",""],["a2fe",""],["a3b0","",9],["a3c1","",25],["a3e1","",25],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a7a1","",5,"",25],["a7d1","",5,"",25],["a8a1",""],["ada1","",19,"",9],["adc0",""],["addf","",4,""],["b0a1",""],["b1a1",""],["b2a1",""],["b3a1",""],["b4a1",""],["b5a1",""],["b6a1",""],["b7a1",""],["b8a1",""],["b9a1",""],["baa1",""],["bba1",""],["bca1",""],["bda1",""],["bea1",""],["bfa1",""],["c0a1",""],["c1a1",""],["c2a1",""],["c3a1",""],["c4a1",""],["c5a1",""],["c6a1",""],["c7a1",""],["c8a1",""],["c9a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1",""],["d2a1",""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fcf1","",9,""],["8fa2af",""],["8fa2c2",""],["8fa2eb",""],["8fa6e1",""],["8fa6e7",""],["8fa6e9",""],["8fa6ec",""],["8fa6f1",""],["8fa7c2","",10,""],["8fa7f2","",10,""],["8fa9a1",""],["8fa9a4",""],["8fa9a6",""],["8fa9a8",""],["8fa9ab",""],["8fa9af",""],["8fa9c1",""],["8faaa1",""],["8faaba",""],["8faba1",""],["8fabbd",""],["8fabc5",""],["8fb0a1",""],["8fb1a1",""],["8fb2a1","",4,""],["8fb3a1",""],["8fb4a1",""],["8fb5a1",""],["8fb6a1","",5,"",4,""],["8fb7a1","",4,""],["8fb8a1",""],["8fb9a1",""],["8fbaa1","",4,""],["8fbba1",""],["8fbca1","",4,""],["8fbda1","",4,""],["8fbea1","",4,""],["8fbfa1",""],["8fc0a1",""],["8fc1a1",""],["8fc2a1",""],["8fc3a1","",4,""],["8fc4a1",""],["8fc5a1",""],["8fc6a1",""],["8fc7a1",""],["8fc8a1",""],["8fc9a1","",4,"",4,""],["8fcaa1",""],["8fcba1",""],["8fcca1","",9,""],["8fcda1","",5,""],["8fcea1","",6,""],["8fcfa1",""],["8fd0a1",""],["8fd1a1",""],["8fd2a1","",5],["8fd3a1",""],["8fd4a1","",4,""],["8fd5a1",""],["8fd6a1",""],["8fd7a1",""],["8fd8a1",""],["8fd9a1","",4,"",6,""],["8fdaa1","",4,""],["8fdba1","",6,""],["8fdca1","",4,""],["8fdda1","",4,""],["8fdea1","",4,""],["8fdfa1",""],["8fe0a1",""],["8fe1a1","",4,""],["8fe2a1",""],["8fe3a1","",5,"",4,""],["8fe4a1","",4,""],["8fe5a1","",4,""],["8fe6a1",""],["8fe7a1",""],["8fe8a1","",4,""],["8fe9a1","",4],["8feaa1","",4,""],["8feba1","",4,""],["8feca1",""],["8feda1","",4,"",4,""]]');
              }
            ),
            /***/
            6258: (
              /***/
              function(module2) {
                "use strict";
                module2.exports = JSON.parse('{"uChars":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],"gbChars":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}');
              }
            ),
            /***/
            4346: (
              /***/
              function(module2) {
                "use strict";
                module2.exports = JSON.parse('[["a140","",62],["a180","",32],["a240","",62],["a280","",32],["a2ab","",5],["a2e3",""],["a2ef",""],["a2fd",""],["a340","",62],["a380","",31,""],["a440","",62],["a480","",32],["a4f4","",10],["a540","",62],["a580","",32],["a5f7","",7],["a640","",62],["a680","",32],["a6b9","",7],["a6d9","",6],["a6ec",""],["a6f3",""],["a6f6","",8],["a740","",62],["a780","",32],["a7c2","",14],["a7f2","",12],["a896","",10],["a8bc",""],["a8bf",""],["a8c1",""],["a8ea","",20],["a958",""],["a95b",""],["a95d",""],["a989","",11],["a997","",12],["a9f0","",14],["aaa1","",93],["aba1","",93],["aca1","",93],["ada1","",93],["aea1","",93],["afa1","",93],["d7fa","",4],["f8a1","",93],["f9a1","",93],["faa1","",93],["fba1","",93],["fca1","",93],["fda1","",93],["fe50",""],["fe80","",6,"",93],["8135f437",""]]');
              }
            ),
            /***/
            7014: (
              /***/
              function(module2) {
                "use strict";
                module2.exports = JSON.parse('[["0","\\u0000",128],["a1","",62],["8140","",9,""],["8180",""],["81b8",""],["81c8",""],["81da",""],["81f0",""],["81fc",""],["824f","",9],["8260","",25],["8281","",25],["829f","",82],["8340","",62],["8380","",22],["839f","",16,"",6],["83bf","",16,"",6],["8440","",5,"",25],["8470","",5,"",7],["8480","",17],["849f",""],["8740","",19,"",9],["875f",""],["877e",""],["8780","",4,""],["889f",""],["8940",""],["8980",""],["8a40",""],["8a80",""],["8b40",""],["8b80",""],["8c40",""],["8c80",""],["8d40",""],["8d80",""],["8e40",""],["8e80",""],["8f40",""],["8f80",""],["9040",""],["9080",""],["9140",""],["9180",""],["9240",""],["9280",""],["9340",""],["9380",""],["9440",""],["9480",""],["9540",""],["9580",""],["9640",""],["9680",""],["9740",""],["9780",""],["9840",""],["989f",""],["9940",""],["9980",""],["9a40",""],["9a80",""],["9b40",""],["9b80",""],["9c40",""],["9c80",""],["9d40",""],["9d80",""],["9e40",""],["9e80",""],["9f40",""],["9f80",""],["e040",""],["e080",""],["e140",""],["e180",""],["e240",""],["e280",""],["e340",""],["e380",""],["e440",""],["e480",""],["e540",""],["e580",""],["e640",""],["e680",""],["e740",""],["e780",""],["e840",""],["e880",""],["e940",""],["e980",""],["ea40",""],["ea80",""],["ed40",""],["ed80",""],["ee40",""],["ee80",""],["eeef","",9,""],["f040","",62],["f080","",124],["f140","",62],["f180","",124],["f240","",62],["f280","",124],["f340","",62],["f380","",124],["f440","",62],["f480","",124],["f540","",62],["f580","",124],["f640","",62],["f680","",124],["f740","",62],["f780","",124],["f840","",62],["f880","",124],["f940",""],["fa40","",9,"",9,""],["fa80",""],["fb40",""],["fb80",""],["fc40",""]]');
              }
            )
            /******/
          };
          var __webpack_module_cache__ = {};
          function __webpack_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              id: moduleId,
              /******/
              loaded: false,
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.loaded = true;
            return module2.exports;
          }
          !function() {
            __webpack_require__.g = function() {
              if (typeof globalThis === "object")
                return globalThis;
              try {
                return this || new Function("return this")();
              } catch (e) {
                if (typeof window === "object")
                  return window;
              }
            }();
          }();
          !function() {
            __webpack_require__.nmd = function(module2) {
              module2.paths = [];
              if (!module2.children)
                module2.children = [];
              return module2;
            };
          }();
          var __webpack_exports__ = __webpack_require__(2536);
          return __webpack_exports__;
        }()
      );
    });
  }
});
export default require_pdfmake();
/*! Bundled license information:

pdfmake/build/pdfmake.js:
  (*! pdfmake v0.2.7, @license MIT, @link http://pdfmake.org *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (** @preserve
   * Counter block mode compatible with  Dr Brian Gladman fileenc.c
   * derived from CryptoJS.mode.CTR
   * Jan Hruby jhruby.web@gmail.com
   *)
  (** @preserve
  (c) 2012 by Cdric Mesnil. All rights reserved.
  	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
  	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
      - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *)
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)
*/
//# sourceMappingURL=pdfmake_build_pdfmake.js.map
